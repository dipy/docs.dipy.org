
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_built/multiprocessing/reconst_csa_parallel.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_built_multiprocessing_reconst_csa_parallel.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_built_multiprocessing_reconst_csa_parallel.py:


====================================
Parallel reconstruction using Q-Ball
====================================

We show an example of parallel reconstruction using a Q-Ball Constant Solid
Angle model (see Aganj et al. (MRM 2010)) and `peaks_from_model`.

Import modules, fetch and read data, and compute the mask.

.. GENERATED FROM PYTHON SOURCE LINES 11-33

.. code-block:: Python


    import time

    from dipy.core.gradients import gradient_table
    from dipy.data import get_fnames, get_sphere
    from dipy.direction import peaks_from_model
    from dipy.io.gradients import read_bvals_bvecs
    from dipy.io.image import load_nifti
    from dipy.reconst.shm import CsaOdfModel
    from dipy.segment.mask import median_otsu

    hardi_fname, hardi_bval_fname, hardi_bvec_fname = get_fnames(name="stanford_hardi")

    data, affine = load_nifti(hardi_fname)

    bvals, bvecs = read_bvals_bvecs(hardi_bval_fname, hardi_bvec_fname)
    gtab = gradient_table(bvals, bvecs=bvecs)

    maskdata, mask = median_otsu(
        data, vol_idx=range(10, 50), median_radius=3, numpass=1, autocrop=True, dilate=2
    )








.. GENERATED FROM PYTHON SOURCE LINES 34-35

We instantiate our CSA model with spherical harmonic order ($l$) of 4

.. GENERATED FROM PYTHON SOURCE LINES 35-38

.. code-block:: Python


    csamodel = CsaOdfModel(gtab, 4)








.. GENERATED FROM PYTHON SOURCE LINES 39-45

`Peaks_from_model` is used to calculate properties of the ODFs (Orientation
Distribution Function) and return for
example the peaks and their indices, or GFA which is similar to FA but for
ODF based models. This function mainly needs a reconstruction model, the
data and a sphere as input. The sphere is an object that represents the
spherical discrete grid where the ODF values will be evaluated.

.. GENERATED FROM PYTHON SOURCE LINES 45-50

.. code-block:: Python


    sphere = get_sphere(name="repulsion724")

    start_time = time.time()








.. GENERATED FROM PYTHON SOURCE LINES 51-57

We will first run `peaks_from_model` using parallelism with 2 processes. If
`num_processes` is None (default option) then this function will find the
total number of processors from the operating system and use this number as
`num_processes`. Sometimes it makes sense to use only a few of the processes
in order to allow resources for other applications. However, most of the
times using the default option will be sufficient.

.. GENERATED FROM PYTHON SOURCE LINES 57-75

.. code-block:: Python


    csapeaks_parallel = peaks_from_model(
        model=csamodel,
        data=maskdata,
        sphere=sphere,
        relative_peak_threshold=0.5,
        min_separation_angle=25,
        mask=mask,
        return_odf=False,
        normalize_peaks=True,
        npeaks=5,
        parallel=True,
        num_processes=2,
    )

    time_parallel = time.time() - start_time
    print(f"peaks_from_model using 2 processes ran in : {time_parallel} seconds")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    peaks_from_model using 2 processes ran in : 21.68185305595398 seconds




.. GENERATED FROM PYTHON SOURCE LINES 76-77

If we don't use parallelism then we need to set `parallel=False`:

.. GENERATED FROM PYTHON SOURCE LINES 77-98

.. code-block:: Python


    start_time = time.time()
    csapeaks = peaks_from_model(
        model=csamodel,
        data=maskdata,
        sphere=sphere,
        relative_peak_threshold=0.5,
        min_separation_angle=25,
        mask=mask,
        return_odf=False,
        normalize_peaks=True,
        npeaks=5,
        parallel=False,
        num_processes=None,
    )

    time_single = time.time() - start_time
    print(f"peaks_from_model ran in : {time_single} seconds")

    print(f"Speedup factor : {time_single / time_parallel}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    peaks_from_model ran in : 40.8574640750885 seconds
    Speedup factor : 1.884408310011527




.. GENERATED FROM PYTHON SOURCE LINES 99-106

In Windows if you get a runtime error about frozen executable please start
your script by adding your code above in a ``main`` function and use::

   if __name__ == '__main__':
       import multiprocessing
       multiprocessing.freeze_support()
       main()

.. GENERATED FROM PYTHON SOURCE LINES 108-110

.. include:: ../../links_names.inc



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 5.059 seconds)


.. _sphx_glr_download_examples_built_multiprocessing_reconst_csa_parallel.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: reconst_csa_parallel.ipynb <reconst_csa_parallel.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: reconst_csa_parallel.py <reconst_csa_parallel.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: reconst_csa_parallel.zip <reconst_csa_parallel.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
