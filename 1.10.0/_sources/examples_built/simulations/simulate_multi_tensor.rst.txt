
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_built/simulations/simulate_multi_tensor.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_built_simulations_simulate_multi_tensor.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_built_simulations_simulate_multi_tensor.py:


======================
MultiTensor Simulation
======================

In this example we show how someone can simulate the signal and the ODF of a
single voxel using a MultiTensor.

.. GENERATED FROM PYTHON SOURCE LINES 9-19

.. code-block:: Python


    import matplotlib.pyplot as plt
    import numpy as np

    from dipy.core.gradients import gradient_table
    from dipy.core.sphere import HemiSphere, disperse_charges
    from dipy.data import get_sphere
    from dipy.sims.voxel import multi_tensor, multi_tensor_odf
    from dipy.viz import actor, window








.. GENERATED FROM PYTHON SOURCE LINES 20-23

For the simulation we will need a GradientTable with the b-values and
b-vectors. To create one, we can first create some random points on a
``HemiSphere`` using spherical polar coordinates.

.. GENERATED FROM PYTHON SOURCE LINES 23-31

.. code-block:: Python


    rng = np.random.default_rng()

    n_pts = 64
    theta = np.pi * rng.random(size=n_pts)
    phi = 2 * np.pi * rng.random(size=n_pts)
    hsph_initial = HemiSphere(theta=theta, phi=phi)








.. GENERATED FROM PYTHON SOURCE LINES 32-34

Next, we call ``disperse_charges`` which will iteratively move the points so
that the electrostatic potential energy is minimized.

.. GENERATED FROM PYTHON SOURCE LINES 34-37

.. code-block:: Python


    hsph_updated, potential = disperse_charges(hsph_initial, 5000)








.. GENERATED FROM PYTHON SOURCE LINES 38-41

We need two stacks of ``vertices``, one for every shell, and we need two sets
of b-values, one at 1000 $s/mm^2$, and one at 2500 $s/mm^2$, as we discussed
previously.

.. GENERATED FROM PYTHON SOURCE LINES 41-48

.. code-block:: Python


    vertices = hsph_updated.vertices
    values = np.ones(vertices.shape[0])

    bvecs = np.vstack((vertices, vertices))
    bvals = np.hstack((1000 * values, 2500 * values))








.. GENERATED FROM PYTHON SOURCE LINES 49-50

We can also add some b0s. Let's add one at the beginning and one at the end.

.. GENERATED FROM PYTHON SOURCE LINES 50-54

.. code-block:: Python


    bvecs = np.insert(bvecs, (0, bvecs.shape[0]), np.array([0, 0, 0]), axis=0)
    bvals = np.insert(bvals, (0, bvals.shape[0]), 0)








.. GENERATED FROM PYTHON SOURCE LINES 55-56

Let's now create the ``GradientTable``.

.. GENERATED FROM PYTHON SOURCE LINES 56-59

.. code-block:: Python


    gtab = gradient_table(bvals, bvecs=bvecs)








.. GENERATED FROM PYTHON SOURCE LINES 60-61

In ``mevals`` we save the eigenvalues of each tensor.

.. GENERATED FROM PYTHON SOURCE LINES 61-64

.. code-block:: Python


    mevals = np.array([[0.0015, 0.0003, 0.0003], [0.0015, 0.0003, 0.0003]])








.. GENERATED FROM PYTHON SOURCE LINES 65-67

In ``angles`` we save in polar coordinates (:math:`\theta, \phi`) the
principal axis of each tensor.

.. GENERATED FROM PYTHON SOURCE LINES 67-70

.. code-block:: Python


    angles = [(0, 0), (60, 0)]








.. GENERATED FROM PYTHON SOURCE LINES 71-72

In ``fractions`` we save the percentage of the contribution of each tensor.

.. GENERATED FROM PYTHON SOURCE LINES 72-75

.. code-block:: Python


    fractions = [50, 50]








.. GENERATED FROM PYTHON SOURCE LINES 76-78

The function ``multi_tensor`` will return the simulated signal and an array
with the principal axes of the tensors in cartesian coordinates.

.. GENERATED FROM PYTHON SOURCE LINES 78-83

.. code-block:: Python


    signal, sticks = multi_tensor(
        gtab, mevals, S0=100, angles=angles, fractions=fractions, snr=None
    )








.. GENERATED FROM PYTHON SOURCE LINES 84-85

We can also add Rician noise with a specific SNR.

.. GENERATED FROM PYTHON SOURCE LINES 85-97

.. code-block:: Python


    signal_noisy, sticks = multi_tensor(
        gtab, mevals, S0=100, angles=angles, fractions=fractions, snr=20
    )

    plt.plot(signal, label="noiseless")

    plt.plot(signal_noisy, label="with noise")
    plt.legend()
    # plt.show()
    plt.savefig("simulated_signal.png", bbox_inches="tight")




.. image-sg:: /examples_built/simulations/images/sphx_glr_simulate_multi_tensor_001.png
   :alt: simulate multi tensor
   :srcset: /examples_built/simulations/images/sphx_glr_simulate_multi_tensor_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 98-108

.. rst-class:: centered small fst-italic fw-semibold

Simulated MultiTensor signal



For the ODF simulation we will need a sphere. Because we are interested in a
simulation of only a single voxel, we can use a sphere with very high
resolution. We generate that by subdividing the triangles of one of DIPY_'s
cached spheres, which we can read in the following way.

.. GENERATED FROM PYTHON SOURCE LINES 108-130

.. code-block:: Python


    sphere = get_sphere(name="repulsion724")
    sphere = sphere.subdivide(n=2)

    odf = multi_tensor_odf(sphere.vertices, mevals, angles, fractions)

    # Enables/disables interactive visualization
    interactive = False

    scene = window.Scene()

    odf_actor = actor.odf_slicer(odf[None, None, None, :], sphere=sphere, colormap="plasma")
    odf_actor.RotateX(90)

    scene.add(odf_actor)

    print("Saving illustration as multi_tensor_simulation")
    window.record(scene=scene, out_path="multi_tensor_simulation.png", size=(300, 300))
    if interactive:
        window.show(scene)





.. image-sg:: /examples_built/simulations/images/sphx_glr_simulate_multi_tensor_002.png
   :alt: simulate multi tensor
   :srcset: /examples_built/simulations/images/sphx_glr_simulate_multi_tensor_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Saving illustration as multi_tensor_simulation




.. GENERATED FROM PYTHON SOURCE LINES 131-134

.. rst-class:: centered small fst-italic fw-semibold

Simulating a MultiTensor ODF.

.. GENERATED FROM PYTHON SOURCE LINES 136-138

.. include:: ../../links_names.inc



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.547 seconds)


.. _sphx_glr_download_examples_built_simulations_simulate_multi_tensor.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: simulate_multi_tensor.ipynb <simulate_multi_tensor.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: simulate_multi_tensor.py <simulate_multi_tensor.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: simulate_multi_tensor.zip <simulate_multi_tensor.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
