
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_built/simulations/simulate_dki.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_built_simulations_simulate_dki.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_built_simulations_simulate_dki.py:


==========================
DKI MultiTensor Simulation
==========================

In this example we show how to simulate the Diffusion Kurtosis Imaging (DKI)
data of a single voxel. DKI captures information about the non-Gaussian
properties of water diffusion which is a consequence of the existence of tissue
barriers and compartments. In these simulations compartmental heterogeneity is
taken into account by modeling different compartments for the intra- and
extra-cellular media of two populations of fibers. These simulations are
performed according to :footcite:p:`NetoHenriques2015`.

We first import all relevant modules.

.. GENERATED FROM PYTHON SOURCE LINES 16-26

.. code-block:: Python


    import matplotlib.pyplot as plt
    import numpy as np

    from dipy.core.gradients import gradient_table
    from dipy.data import get_fnames
    from dipy.io.gradients import read_bvals_bvecs
    from dipy.reconst.dti import decompose_tensor, from_lower_triangular
    from dipy.sims.voxel import multi_tensor_dki, single_tensor








.. GENERATED FROM PYTHON SOURCE LINES 27-30

For the simulation we will need a GradientTable with the b-values and
b-vectors. Here we use the GradientTable of the sample DIPY_ dataset
``small_64D``.

.. GENERATED FROM PYTHON SOURCE LINES 30-34

.. code-block:: Python


    fimg, fbvals, fbvecs = get_fnames(name="small_64D")
    bvals, bvecs = read_bvals_bvecs(fbvals, fbvecs)








.. GENERATED FROM PYTHON SOURCE LINES 35-38

DKI requires data from more than one non-zero b-value. Since the dataset
``small_64D`` was acquired with one non-zero b-value we artificially produce
a second non-zero b-value.

.. GENERATED FROM PYTHON SOURCE LINES 38-42

.. code-block:: Python


    bvals = np.concatenate((bvals, bvals * 2), axis=0)
    bvecs = np.concatenate((bvecs, bvecs), axis=0)








.. GENERATED FROM PYTHON SOURCE LINES 43-45

The b-values and gradient directions are then converted to DIPY's
``GradientTable`` format.

.. GENERATED FROM PYTHON SOURCE LINES 45-48

.. code-block:: Python


    gtab = gradient_table(bvals, bvecs=bvecs)








.. GENERATED FROM PYTHON SOURCE LINES 49-55

In ``mevals`` we save the eigenvalues of each tensor. To simulate crossing
fibers with two different media (representing intra and extra-cellular
media), a total of four components have to be taken in to account (i.e. the
first two compartments correspond to the intra and extra cellular media for
the first fiber population while the others correspond to the media of the
second fiber population)

.. GENERATED FROM PYTHON SOURCE LINES 55-65

.. code-block:: Python


    mevals = np.array(
        [
            [0.00099, 0, 0],
            [0.00226, 0.00087, 0.00087],
            [0.00099, 0, 0],
            [0.00226, 0.00087, 0.00087],
        ]
    )








.. GENERATED FROM PYTHON SOURCE LINES 66-71

In ``angles`` we save in polar coordinates (:math:`\theta, \phi`) the
principal axis of each compartment tensor. To simulate crossing fibers at
70$^{\circ}$ the compartments of the first fiber are aligned to the X-axis
while the compartments of the second fiber are aligned to the X-Z plane with
an angular deviation of 70$^{\\circ}$ from the first one.

.. GENERATED FROM PYTHON SOURCE LINES 71-74

.. code-block:: Python


    angles = [(90, 0), (90, 0), (20, 0), (20, 0)]








.. GENERATED FROM PYTHON SOURCE LINES 75-78

In ``fractions`` we save the percentage of the contribution of each
compartment, which is computed by multiplying the percentage of contribution
of each fiber population and the water fraction of each different medium

.. GENERATED FROM PYTHON SOURCE LINES 78-82

.. code-block:: Python


    fie = 0.49  # intra-axonal water fraction
    fractions = [fie * 50, (1 - fie) * 50, fie * 50, (1 - fie) * 50]








.. GENERATED FROM PYTHON SOURCE LINES 83-87

Having defined the parameters for all tissue compartments, the elements of
the diffusion tensor (DT), the elements of the kurtosis tensor (KT) and the
DW signals simulated from the DKI model can be obtain using the function
``multi_tensor_dki``.

.. GENERATED FROM PYTHON SOURCE LINES 87-92

.. code-block:: Python


    signal_dki, dt, kt = multi_tensor_dki(
        gtab, mevals, S0=200, angles=angles, fractions=fractions, snr=None
    )








.. GENERATED FROM PYTHON SOURCE LINES 93-94

We can also add Rician noise with a specific SNR.

.. GENERATED FROM PYTHON SOURCE LINES 94-99

.. code-block:: Python


    signal_noisy, dt, kt = multi_tensor_dki(
        gtab, mevals, S0=200, angles=angles, fractions=fractions, snr=10
    )








.. GENERATED FROM PYTHON SOURCE LINES 100-104

For comparison purposes, we also compute the DW signal if only the diffusion
tensor components are taken into account. For this we use DIPY's function
``single_tensor`` which requires that dt is decomposed into its eigenvalues
and eigenvectors.

.. GENERATED FROM PYTHON SOURCE LINES 104-108

.. code-block:: Python


    dt_evals, dt_evecs = decompose_tensor(from_lower_triangular(dt))
    signal_dti = single_tensor(gtab, S0=200, evals=dt_evals, evecs=dt_evecs, snr=None)








.. GENERATED FROM PYTHON SOURCE LINES 109-111

Finally, we can visualize the values of the different version of simulated
signals for all assumed gradient directions and bvalues.

.. GENERATED FROM PYTHON SOURCE LINES 111-119

.. code-block:: Python


    plt.plot(signal_dti, label="noiseless dti")
    plt.plot(signal_dki, label="noiseless dki")
    plt.plot(signal_noisy, label="with noise")
    plt.legend()
    plt.savefig("simulated_dki_signal.png", bbox_inches="tight")





.. image-sg:: /examples_built/simulations/images/sphx_glr_simulate_dki_001.png
   :alt: simulate dki
   :srcset: /examples_built/simulations/images/sphx_glr_simulate_dki_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 120-137

.. rst-class:: centered small fst-italic fw-semibold

Simulated signals obtain from the DTI and DKI models.


Non-Gaussian diffusion properties in tissues are responsible to smaller
signal attenuation for larger bvalues when compared to signal attenuation
from free Gaussian water diffusion. This feature can be shown from the
figure above, since signals simulated from the DKI models reveals larger DW
signal intensities than the signals obtained only from the diffusion tensor
components.

References
----------

.. footbibliography::


.. GENERATED FROM PYTHON SOURCE LINES 139-141

.. include:: ../../links_names.inc



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.065 seconds)


.. _sphx_glr_download_examples_built_simulations_simulate_dki.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: simulate_dki.ipynb <simulate_dki.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: simulate_dki.py <simulate_dki.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: simulate_dki.zip <simulate_dki.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
