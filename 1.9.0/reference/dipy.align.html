
<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>DIPY &#8212; dipy 1.9.0 documentation</title>
  
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/css/dipy.css?v=cedb193d" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

  
<link rel="stylesheet" href="../_static/styles/grg-sphinx-theme.css"/>

    <script src="../_static/documentation_options.js?v=baecdfc0"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-D610GKJZRC"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-D610GKJZRC');
            </script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-D610GKJZRC');
            </script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'reference/dipy.align';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://docs.dipy.org/dev/_static/version_switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '1.9.0';
        </script>
    <link rel="icon" href="../_static/dipy-favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="core" href="dipy.core.html" />
    <link rel="prev" title="dipy" href="dipy.html" />
  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
<nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
   

<a class="navbar-brand logo" href="https://dipy.org">
  
  
  
  
    
    
      
    
    
    <img src="../_static/dipy-logo.png" class="logo__image only-light" alt="DIPY"/>
    <script>document.write(`<img src="../_static/dipy-logo.png" class="logo__image only-dark" alt="DIPY"/>`);</script>
  
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  
  <ul class="bd-navbar-elements navbar-nav">
    
          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Docs
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
      <li class="nav-item">
        <a class="nav-link" href="../index.html">
          Overview
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../examples_built/index.html">
          Tutorials
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../recipes.html">
          Recipes
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../interfaces/index.html">
          CLI / Workflows
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="index.html">
          API
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../reference_cmd/index.html">
          CLI API
        </a>
      </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Workshops
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Latest
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2024" target="_blank">
            DIPY Workshop 2024 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Past
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2023" target="_blank">
            DIPY Workshop 2023 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2022" target="_blank">
            DIPY Workshop 2022 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2021" target="_blank">
            DIPY Workshop 2021 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2020" target="_blank">
            DIPY Workshop 2020 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2019" target="_blank">
            DIPY Workshop 2019 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Community
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        News
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/calendar">
            Calendar
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://mail.python.org/mailman3/lists/dipy.python.org/" target="_blank">
            Newsletters <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/blog">
            Blog
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://www.youtube.com/c/diffusionimaginginpython" target="_blank">
            Youtube <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Help
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://app.gitter.im/#/room/%23dipy_dipy:gitter.im" target="_blank">
            Live Chat (Gitter) <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://github.com/dipy/dipy/discussions" target="_blank">
            Github Discussions <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    About
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/team">
            Team
          </a>
        </li>

      <li class="nav-item">
        <a class="nav-link" href="../faq.html">
          FAQ
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../user_guide/mission.html">
          Mission Statement
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../stateoftheart.html">
          Releases
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../cite.html">
          Cite
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../glossary.html">
          Glossary
        </a>
      </li>
                </ul>
            </li>
          
  </ul>
  
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
      
        <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button type="button" class="version-switcher__button btn btn-sm navbar-btn dropdown-toggle" data-bs-toggle="dropdown">
      1.9.0  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div class="version-switcher__menu dropdown-menu list-group-flush py-0">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dipy" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/dipymri" title="Twitter/X" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter/X</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/c/diffusionimaginginpython" title="YouTube" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-youtube"></i></span>
            <label class="sr-only">YouTube</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/dipy/" title="LinkedIn" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-linkedin"></i></span>
            <label class="sr-only">LinkedIn</label></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

</nav>
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  
  <ul class="bd-navbar-elements navbar-nav">
    
          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Docs
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
      <li class="nav-item">
        <a class="nav-link" href="../index.html">
          Overview
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../examples_built/index.html">
          Tutorials
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../recipes.html">
          Recipes
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../interfaces/index.html">
          CLI / Workflows
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="index.html">
          API
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../reference_cmd/index.html">
          CLI API
        </a>
      </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Workshops
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Latest
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2024" target="_blank">
            DIPY Workshop 2024 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Past
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2023" target="_blank">
            DIPY Workshop 2023 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2022" target="_blank">
            DIPY Workshop 2022 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2021" target="_blank">
            DIPY Workshop 2021 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2020" target="_blank">
            DIPY Workshop 2020 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2019" target="_blank">
            DIPY Workshop 2019 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Community
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        News
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/calendar">
            Calendar
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://mail.python.org/mailman3/lists/dipy.python.org/" target="_blank">
            Newsletters <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/blog">
            Blog
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://www.youtube.com/c/diffusionimaginginpython" target="_blank">
            Youtube <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Help
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://app.gitter.im/#/room/%23dipy_dipy:gitter.im" target="_blank">
            Live Chat (Gitter) <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://github.com/dipy/dipy/discussions" target="_blank">
            Github Discussions <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    About
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/team">
            Team
          </a>
        </li>

      <li class="nav-item">
        <a class="nav-link" href="../faq.html">
          FAQ
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../user_guide/mission.html">
          Mission Statement
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../stateoftheart.html">
          Releases
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../cite.html">
          Cite
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../glossary.html">
          Glossary
        </a>
      </li>
                </ul>
            </li>
          
  </ul>
  
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
        
          <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button type="button" class="version-switcher__button btn btn-sm navbar-btn dropdown-toggle" data-bs-toggle="dropdown">
      1.9.0  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div class="version-switcher__menu dropdown-menu list-group-flush py-0">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dipy" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/dipymri" title="Twitter/X" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter/X</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/c/diffusionimaginginpython" title="YouTube" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-youtube"></i></span>
            <label class="sr-only">YouTube</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/dipy/" title="LinkedIn" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-linkedin"></i></span>
            <label class="sr-only">LinkedIn</label></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item"><nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="dipy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dipy</span></code></a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">align</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.core.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">core</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.data.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.denoise.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">denoise</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.direction.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">direction</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.io.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.nn.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nn</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.reconst.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.segment.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">segment</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.sims.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sims</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.stats.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stats</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.tracking.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracking</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.viz.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">viz</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.workflows.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">workflows</span></code></a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">API Reference</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">DIPY</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="module-dipy.align">
<span id="align"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">align</span></code><a class="headerlink" href="#module-dipy.align" title="Link to this heading">#</a></h1>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.Bunch" title="dipy.align.Bunch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Bunch</span></code></a>(**kwds)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.VerbosityLevels" title="dipy.align.VerbosityLevels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VerbosityLevels</span></code></a></p></td>
<td><p>VerbosityLevels This enum defines the four levels of verbosity we use in the align module.</p></td>
</tr>
</tbody>
</table>
<section id="module-dipy.align._public">
<span id="module-align-public"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align._public</span></code><a class="headerlink" href="#module-dipy.align._public" title="Link to this heading">#</a></h2>
<p>Registration API: simplified API for registration of MRI data and of
streamlines.</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align._public.syn_registration" title="dipy.align._public.syn_registration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">syn_registration</span></code></a>(moving, static[, ...])</p></td>
<td><p>Register a 2D/3D source image (moving) to a 2D/3D target image (static).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align._public.register_dwi_to_template" title="dipy.align._public.register_dwi_to_template"><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_dwi_to_template</span></code></a>(dwi, gtab[, ...])</p></td>
<td><p>Register DWI data to a template through the B0 volumes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align._public.write_mapping" title="dipy.align._public.write_mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_mapping</span></code></a>(mapping, fname)</p></td>
<td><p>Write out a syn registration mapping to a nifti file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align._public.read_mapping" title="dipy.align._public.read_mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_mapping</span></code></a>(disp, domain_img, codomain_img)</p></td>
<td><p>Read a syn registration mapping from a nifti file.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align._public.resample" title="dipy.align._public.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(moving, static[, moving_affine, ...])</p></td>
<td><p>Resample an image (moving) from one space to another (static).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align._public.affine_registration" title="dipy.align._public.affine_registration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">affine_registration</span></code></a>(moving, static[, ...])</p></td>
<td><p>Find the affine transformation between two 3D images.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align._public.center_of_mass" title="dipy.align._public.center_of_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_of_mass</span></code></a>(moving, static[, ...])</p></td>
<td><p>Implements a center of mass transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align._public.translation" title="dipy.align._public.translation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translation</span></code></a>(moving, static[, moving_affine, ...])</p></td>
<td><p>Implements a translation transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align._public.rigid" title="dipy.align._public.rigid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rigid</span></code></a>(moving, static[, moving_affine, ...])</p></td>
<td><p>Implements a rigid transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align._public.rigid_isoscaling" title="dipy.align._public.rigid_isoscaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rigid_isoscaling</span></code></a>(moving, static[, ...])</p></td>
<td><p>Implements a rigid isoscaling transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align._public.rigid_scaling" title="dipy.align._public.rigid_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rigid_scaling</span></code></a>(moving, static[, ...])</p></td>
<td><p>Implements a rigid scaling transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align._public.affine" title="dipy.align._public.affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">affine</span></code></a>(moving, static[, moving_affine, ...])</p></td>
<td><p>Implements an affine transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align._public._METHOD_DICT" title="dipy.align._public._METHOD_DICT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_METHOD_DICT</span></code></a></p></td>
<td><p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(<a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list. For example:  dict(one=1, two=2).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align._public.register_series" title="dipy.align._public.register_series"><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_series</span></code></a>(series, ref[, pipeline, ...])</p></td>
<td><p>Register a series to a reference image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align._public.register_dwi_series" title="dipy.align._public.register_dwi_series"><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_dwi_series</span></code></a>(data, gtab[, affine, ...])</p></td>
<td><p>Register a DWI series to the mean of the B0 images in that series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align._public.motion_correction" title="dipy.align._public.motion_correction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">motion_correction</span></code></a>(data, gtab[, affine, ...])</p></td>
<td><p>Apply a motion correction to a DWI dataset (Between-Volumes Motion correction)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align._public.streamline_registration" title="dipy.align._public.streamline_registration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">streamline_registration</span></code></a>(moving, static[, ...])</p></td>
<td><p>Register two collections of streamlines ('bundles') to each other.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.bundlemin">
<span id="module-align-bundlemin"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.bundlemin</span></code><a class="headerlink" href="#module-dipy.align.bundlemin" title="Link to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.bundlemin.determine_num_threads" title="dipy.align.bundlemin.determine_num_threads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">determine_num_threads</span></code></a>(num_threads)</p></td>
<td><p>Determine the effective number of threads to be used for OpenMP calls</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.bundlemin.distance_matrix_mdf" title="dipy.align.bundlemin.distance_matrix_mdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance_matrix_mdf</span></code></a>(streamlines_a, streamlines_b)</p></td>
<td><p>Minimum direct flipped distance matrix between two streamline sets</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.cpd">
<span id="module-align-cpd"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.cpd</span></code><a class="headerlink" href="#module-dipy.align.cpd" title="Link to this heading">#</a></h2>
<section id="note">
<h3>Note<a class="headerlink" href="#note" title="Link to this heading">#</a></h3>
<p>This file is copied (possibly with major modifications) from the
sources of the pycpd project - <a class="github reference external" href="https://github.com/siavashk/pycpd">siavashk/pycpd</a>.
It remains licensed as the rest of PyCPD (MIT license as of October 2010).</p>
<p># ## ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
#
#   See COPYING file distributed along with the PyCPD package for the
#   copyright and license terms.
#
# ## ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##</p>
</section>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.cpd.DeformableRegistration" title="dipy.align.cpd.DeformableRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DeformableRegistration</span></code></a>(X, Y[, sigma2, ...])</p></td>
<td><p>Deformable point cloud registration.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.cpd.gaussian_kernel" title="dipy.align.cpd.gaussian_kernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gaussian_kernel</span></code></a>(X, beta[, Y])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.cpd.low_rank_eigen" title="dipy.align.cpd.low_rank_eigen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">low_rank_eigen</span></code></a>(G, num_eig)</p></td>
<td><p>Calculate num_eig eigenvectors and eigenvalues of gaussian matrix G.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.cpd.initialize_sigma2" title="dipy.align.cpd.initialize_sigma2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_sigma2</span></code></a>(X, Y)</p></td>
<td><p>Initialize the variance (sigma2).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.cpd.lowrankQS" title="dipy.align.cpd.lowrankQS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lowrankQS</span></code></a>(G, beta, num_eig[, eig_fgt])</p></td>
<td><p>Calculate eigenvectors and eigenvalues of gaussian matrix G.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.crosscorr">
<span id="module-align-crosscorr"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.crosscorr</span></code><a class="headerlink" href="#module-dipy.align.crosscorr" title="Link to this heading">#</a></h2>
<p>Utility functions used by the Cross Correlation (CC) metric</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.crosscorr.compute_cc_backward_step_2d" title="dipy.align.crosscorr.compute_cc_backward_step_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cc_backward_step_2d</span></code></a>(grad_moving, ...)</p></td>
<td><p>Gradient of the CC Metric w.r.t.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.crosscorr.compute_cc_backward_step_3d" title="dipy.align.crosscorr.compute_cc_backward_step_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cc_backward_step_3d</span></code></a>(grad_moving, ...)</p></td>
<td><p>Gradient of the CC Metric w.r.t.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.crosscorr.compute_cc_forward_step_2d" title="dipy.align.crosscorr.compute_cc_forward_step_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cc_forward_step_2d</span></code></a>(grad_static, ...)</p></td>
<td><p>Gradient of the CC Metric w.r.t.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.crosscorr.compute_cc_forward_step_3d" title="dipy.align.crosscorr.compute_cc_forward_step_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cc_forward_step_3d</span></code></a>(grad_static, ...)</p></td>
<td><p>Gradient of the CC Metric w.r.t.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.crosscorr.precompute_cc_factors_2d" title="dipy.align.crosscorr.precompute_cc_factors_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precompute_cc_factors_2d</span></code></a>(static, moving, radius)</p></td>
<td><p>Precomputations to quickly compute the gradient of the CC Metric</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.crosscorr.precompute_cc_factors_2d_test" title="dipy.align.crosscorr.precompute_cc_factors_2d_test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precompute_cc_factors_2d_test</span></code></a>(static, ...)</p></td>
<td><p>Precomputations to quickly compute the gradient of the CC Metric</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.crosscorr.precompute_cc_factors_3d" title="dipy.align.crosscorr.precompute_cc_factors_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precompute_cc_factors_3d</span></code></a>(static, moving, radius)</p></td>
<td><p>Precomputations to quickly compute the gradient of the CC Metric</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.crosscorr.precompute_cc_factors_3d_test" title="dipy.align.crosscorr.precompute_cc_factors_3d_test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precompute_cc_factors_3d_test</span></code></a>(static, ...)</p></td>
<td><p>Precomputations to quickly compute the gradient of the CC Metric</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.expectmax">
<span id="module-align-expectmax"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.expectmax</span></code><a class="headerlink" href="#module-dipy.align.expectmax" title="Link to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.expectmax.compute_em_demons_step_2d" title="dipy.align.expectmax.compute_em_demons_step_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_em_demons_step_2d</span></code></a>(delta_field, ...)</p></td>
<td><p>Demons step for EM metric in 2D

Computes the demons step [Vercauteren09] for SSD-driven registration
( eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.expectmax.compute_em_demons_step_3d" title="dipy.align.expectmax.compute_em_demons_step_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_em_demons_step_3d</span></code></a>(delta_field, ...)</p></td>
<td><p>Demons step for EM metric in 3D

Computes the demons step [Vercauteren09] for SSD-driven registration
( eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.expectmax.compute_masked_class_stats_2d" title="dipy.align.expectmax.compute_masked_class_stats_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_masked_class_stats_2d</span></code></a>(mask, v, ...)</p></td>
<td><p>Computes the mean and std.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.expectmax.compute_masked_class_stats_3d" title="dipy.align.expectmax.compute_masked_class_stats_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_masked_class_stats_3d</span></code></a>(mask, v, ...)</p></td>
<td><p>Computes the mean and std.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.expectmax.quantize_positive_2d" title="dipy.align.expectmax.quantize_positive_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantize_positive_2d</span></code></a>(v, num_levels)</p></td>
<td><p>Quantizes a 2D image to num_levels quantization levels</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.expectmax.quantize_positive_3d" title="dipy.align.expectmax.quantize_positive_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantize_positive_3d</span></code></a>(v, num_levels)</p></td>
<td><p>Quantizes a 3D volume to num_levels quantization levels</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.imaffine">
<span id="module-align-imaffine"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.imaffine</span></code><a class="headerlink" href="#module-dipy.align.imaffine" title="Link to this heading">#</a></h2>
<p>Affine image registration module consisting of the following classes:</p>
<dl class="simple">
<dt>AffineMap: encapsulates the necessary information to perform affine</dt><dd><p>transforms between two domains, defined by a <cite>static</cite> and a <cite>moving</cite>
image. The <cite>domain</cite> of the transform is the set of points in the
<cite>static</cite> image’s grid, and the <cite>codomain</cite> is the set of points in
the <cite>moving</cite> image. When we call the <cite>transform</cite> method, <cite>AffineMap</cite>
maps each point <cite>x</cite> of the domain (<cite>static</cite> grid) to the codomain
(<cite>moving</cite> grid) and interpolates the <cite>moving</cite> image at that point
to obtain the intensity value to be placed at <cite>x</cite> in the resulting
grid. The <cite>transform_inverse</cite> method performs the opposite operation
mapping points in the codomain to points in the domain.</p>
</dd>
<dt>ParzenJointHistogram: computes the marginal and joint distributions of</dt><dd><p>intensities of a pair of images, using Parzen windows [Parzen62]
with a cubic spline kernel, as proposed by Mattes et al. [Mattes03].
It also computes the gradient of the joint histogram w.r.t. the
parameters of a given transform.</p>
</dd>
<dt>MutualInformationMetric: computes the value and gradient of the mutual</dt><dd><p>information metric the way <cite>Optimizer</cite> needs them. That is, given
a set of transform parameters, it will use <cite>ParzenJointHistogram</cite>
to compute the value and gradient of the joint intensity histogram
evaluated at the given parameters, and evaluate the value and
gradient of the histogram’s mutual information.</p>
</dd>
<dt>AffineRegistration: it runs the multi-resolution registration, putting</dt><dd><p>all the pieces together. It needs to create the scale space of the
images and run the multi-resolution registration by using the Metric
and the Optimizer at each level of the Gaussian pyramid. At each
level, it will setup the metric to compute value and gradient of the
metric with the input images with different levels of smoothing.</p>
</dd>
</dl>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading">#</a></h3>
<dl class="simple">
<dt>[Parzen62] E. Parzen. On the estimation of a probability density</dt><dd><p>function and the mode. Annals of Mathematical Statistics,
33(3), 1065-1076, 1962.</p>
</dd>
<dt>[Mattes03] Mattes, D., Haynor, D. R., Vesselle, H., Lewellen, T. K.,</dt><dd><p>&amp; Eubank, W. PET-CT image registration in the chest using
free-form deformations. IEEE Transactions on Medical
Imaging, 22(1), 120-8, 2003.</p>
</dd>
</dl>
</section>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineInversionError" title="dipy.align.imaffine.AffineInversionError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineInversionError</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineInvalidValuesError" title="dipy.align.imaffine.AffineInvalidValuesError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineInvalidValuesError</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineMap" title="dipy.align.imaffine.AffineMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineMap</span></code></a>(affine[, domain_grid_shape, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.MutualInformationMetric" title="dipy.align.imaffine.MutualInformationMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MutualInformationMetric</span></code></a>([nbins, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineRegistration" title="dipy.align.imaffine.AffineRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineRegistration</span></code></a>([metric, level_iters, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine._transform_method" title="dipy.align.imaffine._transform_method"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_transform_method</span></code></a></p></td>
<td><p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(<a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list. For example:  dict(one=1, two=2).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.transform_centers_of_mass" title="dipy.align.imaffine.transform_centers_of_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_centers_of_mass</span></code></a>(static, ...)</p></td>
<td><p>Transformation to align the center of mass of the input images.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.transform_geometric_centers" title="dipy.align.imaffine.transform_geometric_centers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_geometric_centers</span></code></a>(static, ...)</p></td>
<td><p>Transformation to align the geometric center of the input images.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.transform_origins" title="dipy.align.imaffine.transform_origins"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_origins</span></code></a>(static, static_grid2world, ...)</p></td>
<td><p>Transformation to align the origins of the input images.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.imwarp">
<span id="module-align-imwarp"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.imwarp</span></code><a class="headerlink" href="#module-dipy.align.imwarp" title="Link to this heading">#</a></h2>
<p>Classes and functions for Symmetric Diffeomorphic Registration</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap" title="dipy.align.imwarp.DiffeomorphicMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffeomorphicMap</span></code></a>(dim, disp_shape[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicRegistration" title="dipy.align.imwarp.DiffeomorphicRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffeomorphicRegistration</span></code></a>([metric])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration" title="dipy.align.imwarp.SymmetricDiffeomorphicRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration</span></code></a>(metric[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.RegistrationStages" title="dipy.align.imwarp.RegistrationStages"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RegistrationStages</span></code></a></p></td>
<td><p>Registration Stages</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.logger" title="dipy.align.imwarp.logger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logger</span></code></a></p></td>
<td><p>Instances of the Logger class represent a single logging channel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.mult_aff" title="dipy.align.imwarp.mult_aff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mult_aff</span></code></a>(A, B)</p></td>
<td><p>Returns the matrix product A.dot(B) considering None as the identity</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.get_direction_and_spacings" title="dipy.align.imwarp.get_direction_and_spacings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_direction_and_spacings</span></code></a>(affine, dim)</p></td>
<td><p>Extracts the rotational and spacing components from a matrix</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.metrics">
<span id="module-align-metrics"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.metrics</span></code><a class="headerlink" href="#module-dipy.align.metrics" title="Link to this heading">#</a></h2>
<p>Metrics for Symmetric Diffeomorphic Registration</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a>(dim)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.CCMetric" title="dipy.align.metrics.CCMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CCMetric</span></code></a>(dim[, sigma_diff, radius])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric" title="dipy.align.metrics.EMMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EMMetric</span></code></a>(dim[, smooth, inner_iter, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SSDMetric" title="dipy.align.metrics.SSDMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SSDMetric</span></code></a>(dim[, smooth, inner_iter, step_type])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.v_cycle_2d" title="dipy.align.metrics.v_cycle_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">v_cycle_2d</span></code></a>(n, k, delta_field, ...[, depth])</p></td>
<td><p>Multi-resolution Gauss-Seidel solver using V-type cycles</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.v_cycle_3d" title="dipy.align.metrics.v_cycle_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">v_cycle_3d</span></code></a>(n, k, delta_field, ...[, depth])</p></td>
<td><p>Multi-resolution Gauss-Seidel solver using V-type cycles</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.parzenhist">
<span id="module-align-parzenhist"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.parzenhist</span></code><a class="headerlink" href="#module-dipy.align.parzenhist" title="Link to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.parzenhist.ParzenJointHistogram" title="dipy.align.parzenhist.ParzenJointHistogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ParzenJointHistogram</span></code></a>(nbins)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.parzenhist.compute_parzen_mi" title="dipy.align.parzenhist.compute_parzen_mi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_parzen_mi</span></code></a>(joint, joint_gradient, ...)</p></td>
<td><p>Computes the mutual information and its gradient (if requested)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.parzenhist.cubic_spline" title="dipy.align.parzenhist.cubic_spline"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cubic_spline</span></code></a>(x)</p></td>
<td><p>Evaluates the cubic spline at a set of values</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.parzenhist.cubic_spline_derivative" title="dipy.align.parzenhist.cubic_spline_derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cubic_spline_derivative</span></code></a>(x)</p></td>
<td><p>Evaluates the cubic spline derivative at a set of values</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.parzenhist.sample_domain_regular" title="dipy.align.parzenhist.sample_domain_regular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_domain_regular</span></code></a>(k, shape, grid2world)</p></td>
<td><p>Take floor(total_voxels/k) samples from a (2D or 3D) grid</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.reslice">
<span id="module-align-reslice"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.reslice</span></code><a class="headerlink" href="#module-dipy.align.reslice" title="Link to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.reslice.reslice" title="dipy.align.reslice.reslice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reslice</span></code></a>(data, affine, zooms, new_zooms[, ...])</p></td>
<td><p>Reslice data with new voxel resolution defined by <code class="docutils literal notranslate"><span class="pre">new_zooms</span></code>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.scalespace">
<span id="module-align-scalespace"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.scalespace</span></code><a class="headerlink" href="#module-dipy.align.scalespace" title="Link to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace" title="dipy.align.scalespace.ScaleSpace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a>(image, num_levels[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.scalespace.IsotropicScaleSpace" title="dipy.align.scalespace.IsotropicScaleSpace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a>(image, factors, sigmas)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.scalespace.logger" title="dipy.align.scalespace.logger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logger</span></code></a></p></td>
<td><p>Instances of the Logger class represent a single logging channel.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.streamlinear">
<span id="module-align-streamlinear"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.streamlinear</span></code><a class="headerlink" href="#module-dipy.align.streamlinear" title="Link to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a>([num_threads])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMetric" title="dipy.align.streamlinear.BundleMinDistanceMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a>([num_threads])</p></td>
<td><p>Bundle-based Minimum Distance aka BMD</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric" title="dipy.align.streamlinear.BundleMinDistanceMatrixMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric</span></code></a>([num_threads])</p></td>
<td><p>Bundle-based Minimum Distance aka BMD</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric" title="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a>([num_threads])</p></td>
<td><p>Asymmetric Bundle-based Minimum distance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric" title="dipy.align.streamlinear.BundleSumDistanceMatrixMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a>([num_threads])</p></td>
<td><p>Bundle-based Sum Distance aka BMD</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric" title="dipy.align.streamlinear.JointBundleMinDistanceMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">JointBundleMinDistanceMetric</span></code></a>([num_threads])</p></td>
<td><p>Bundle-based Minimum Distance for joint optimization.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.StreamlineLinearRegistration" title="dipy.align.streamlinear.StreamlineLinearRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a>([metric, x0, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.StreamlineRegistrationMap" title="dipy.align.streamlinear.StreamlineRegistrationMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StreamlineRegistrationMap</span></code></a>(matopt, xopt, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.JointStreamlineRegistrationMap" title="dipy.align.streamlinear.JointStreamlineRegistrationMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">JointStreamlineRegistrationMap</span></code></a>(xopt, fopt, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.logger" title="dipy.align.streamlinear.logger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logger</span></code></a></p></td>
<td><p>Instances of the Logger class represent a single logging channel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.bundle_sum_distance" title="dipy.align.streamlinear.bundle_sum_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_sum_distance</span></code></a>(t, static, moving[, ...])</p></td>
<td><p>MDF distance optimization function (SUM).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.bundle_min_distance" title="dipy.align.streamlinear.bundle_min_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_min_distance</span></code></a>(t, static, moving)</p></td>
<td><p>MDF-based pairwise distance optimization function (MIN).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.bundle_min_distance_fast" title="dipy.align.streamlinear.bundle_min_distance_fast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_min_distance_fast</span></code></a>(t, static, moving, ...)</p></td>
<td><p>MDF-based pairwise distance optimization function (MIN).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.bundle_min_distance_asymmetric_fast" title="dipy.align.streamlinear.bundle_min_distance_asymmetric_fast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_min_distance_asymmetric_fast</span></code></a>(t, ...)</p></td>
<td><p>MDF-based pairwise distance optimization function (MIN).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.remove_clusters_by_size" title="dipy.align.streamlinear.remove_clusters_by_size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_clusters_by_size</span></code></a>(clusters[, min_size])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.progressive_slr" title="dipy.align.streamlinear.progressive_slr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">progressive_slr</span></code></a>(static, moving, metric, x0, ...)</p></td>
<td><p>Progressive SLR.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.slr_with_qbx" title="dipy.align.streamlinear.slr_with_qbx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slr_with_qbx</span></code></a>(static, moving[, x0, ...])</p></td>
<td><p>Utility function for registering large tractograms.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.groupwise_slr" title="dipy.align.streamlinear.groupwise_slr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groupwise_slr</span></code></a>(bundles[, x0, tol, max_iter, ...])</p></td>
<td><p>Function to perform unbiased groupwise bundle registration.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.get_unique_pairs" title="dipy.align.streamlinear.get_unique_pairs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_unique_pairs</span></code></a>(n_bundle[, pairs])</p></td>
<td><p>Make unique pairs from n_bundle bundles.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.compose_matrix44" title="dipy.align.streamlinear.compose_matrix44"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose_matrix44</span></code></a>(t[, dtype])</p></td>
<td><p>Compose a 4x4 transformation matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.decompose_matrix44" title="dipy.align.streamlinear.decompose_matrix44"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_matrix44</span></code></a>(mat[, size])</p></td>
<td><p>Given a 4x4 homogeneous matrix return the parameter vector.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.streamwarp">
<span id="module-align-streamwarp"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.streamwarp</span></code><a class="headerlink" href="#module-dipy.align.streamwarp" title="Link to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamwarp.average_bundle_length" title="dipy.align.streamwarp.average_bundle_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_bundle_length</span></code></a>(bundle)</p></td>
<td><p>Find average Euclidean length of the bundle in mm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamwarp.find_missing" title="dipy.align.streamwarp.find_missing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_missing</span></code></a>(lst, cb)</p></td>
<td><p>Find unmatched streamline indices in moving bundle.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamwarp.bundlewarp" title="dipy.align.streamwarp.bundlewarp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundlewarp</span></code></a>(static, moving[, dist, alpha, ...])</p></td>
<td><p>Register two bundles using nonlinear method.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamwarp.bundlewarp_vector_filed" title="dipy.align.streamwarp.bundlewarp_vector_filed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundlewarp_vector_filed</span></code></a>(moving_aligned, ...)</p></td>
<td><p>Calculate vector fields.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamwarp.bundlewarp_shape_analysis" title="dipy.align.streamwarp.bundlewarp_shape_analysis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundlewarp_shape_analysis</span></code></a>(moving_aligned, ...)</p></td>
<td><p>Calculate bundle shape difference profile.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.sumsqdiff">
<span id="module-align-sumsqdiff"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.sumsqdiff</span></code><a class="headerlink" href="#module-dipy.align.sumsqdiff" title="Link to this heading">#</a></h2>
<p>Utility functions used by the Sum of Squared Differences (SSD) metric</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.compute_energy_ssd_2d" title="dipy.align.sumsqdiff.compute_energy_ssd_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_energy_ssd_2d</span></code></a>(delta_field)</p></td>
<td><p>Sum of squared differences between two 2D images</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.compute_energy_ssd_3d" title="dipy.align.sumsqdiff.compute_energy_ssd_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_energy_ssd_3d</span></code></a>(delta_field)</p></td>
<td><p>Sum of squared differences between two 3D volumes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_2d" title="dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_residual_displacement_field_ssd_2d</span></code></a>(...)</p></td>
<td><p>The residual displacement field to be fit on the next iteration</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_3d" title="dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_residual_displacement_field_ssd_3d</span></code></a>(...)</p></td>
<td><p>The residual displacement field to be fit on the next iteration</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.compute_ssd_demons_step_2d" title="dipy.align.sumsqdiff.compute_ssd_demons_step_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_ssd_demons_step_2d</span></code></a>(delta_field, ...)</p></td>
<td><p>Demons step for 2D SSD-driven registration

Computes the demons step for SSD-driven registration
( eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.compute_ssd_demons_step_3d" title="dipy.align.sumsqdiff.compute_ssd_demons_step_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_ssd_demons_step_3d</span></code></a>(delta_field, ...)</p></td>
<td><p>Demons step for 3D SSD-driven registration

Computes the demons step for SSD-driven registration
( eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_2d" title="dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iterate_residual_displacement_field_ssd_2d</span></code></a>(...)</p></td>
<td><p>One iteration of a large linear system solver for 2D SSD registration</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_3d" title="dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iterate_residual_displacement_field_ssd_3d</span></code></a>(...)</p></td>
<td><p>One iteration of a large linear system solver for 3D SSD registration</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.solve_2d_symmetric_positive_definite" title="dipy.align.sumsqdiff.solve_2d_symmetric_positive_definite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_2d_symmetric_positive_definite</span></code></a>(A, y, det)</p></td>
<td><p>Solves a 2-variable symmetric positive-definite linear system

Solves the symmetric positive-definite linear system <span class="math notranslate nohighlight">\(Mx = y\)</span> given by::

    M = [[A[0], A[1]],
         [A[1], A[2]]]

Parameters
----------
A : array, shape (3,)
    the array containing the entries of the symmetric 2x2 matrix
y : array, shape (2,)
    right-hand side of the system to be solved

Returns
-------
out : array, shape (2,)
    the array the output will be stored in</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.sumsqdiff.solve_3d_symmetric_positive_definite" title="dipy.align.sumsqdiff.solve_3d_symmetric_positive_definite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_3d_symmetric_positive_definite</span></code></a>(g, y, tau)</p></td>
<td><p>Solves a 3-variable symmetric positive-definite linear system

Solves the symmetric semi-positive-definite linear system <span class="math notranslate nohighlight">\(Mx = y\)</span> given by
<span class="math notranslate nohighlight">\(M = (g g^{T} + \tau I)\)</span>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.transforms">
<span id="module-align-transforms"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.transforms</span></code><a class="headerlink" href="#module-dipy.align.transforms" title="Link to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.transforms.AffineTransform2D" title="dipy.align.transforms.AffineTransform2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineTransform2D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.transforms.AffineTransform3D" title="dipy.align.transforms.AffineTransform3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineTransform3D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.transforms.RigidIsoScalingTransform2D" title="dipy.align.transforms.RigidIsoScalingTransform2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RigidIsoScalingTransform2D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.transforms.RigidIsoScalingTransform3D" title="dipy.align.transforms.RigidIsoScalingTransform3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RigidIsoScalingTransform3D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.transforms.RigidScalingTransform2D" title="dipy.align.transforms.RigidScalingTransform2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RigidScalingTransform2D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.transforms.RigidScalingTransform3D" title="dipy.align.transforms.RigidScalingTransform3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RigidScalingTransform3D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.transforms.RigidTransform2D" title="dipy.align.transforms.RigidTransform2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RigidTransform2D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.transforms.RigidTransform3D" title="dipy.align.transforms.RigidTransform3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RigidTransform3D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.transforms.RotationTransform2D" title="dipy.align.transforms.RotationTransform2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RotationTransform2D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.transforms.RotationTransform3D" title="dipy.align.transforms.RotationTransform3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RotationTransform3D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.transforms.ScalingTransform2D" title="dipy.align.transforms.ScalingTransform2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScalingTransform2D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.transforms.ScalingTransform3D" title="dipy.align.transforms.ScalingTransform3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScalingTransform3D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Transform</span></code></a></p></td>
<td><p>Base class (contract) for all transforms for affine image registration Each transform must define the following (fast, nogil) methods:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.transforms.TranslationTransform2D" title="dipy.align.transforms.TranslationTransform2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TranslationTransform2D</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.transforms.TranslationTransform3D" title="dipy.align.transforms.TranslationTransform3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TranslationTransform3D</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.align.vector_fields">
<span id="module-align-vector-fields"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.vector_fields</span></code><a class="headerlink" href="#module-dipy.align.vector_fields" title="Link to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.compose_vector_fields_2d" title="dipy.align.vector_fields.compose_vector_fields_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose_vector_fields_2d</span></code></a>(d1, d2, ...)</p></td>
<td><p>Computes the composition of two 2D displacement fields</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.compose_vector_fields_3d" title="dipy.align.vector_fields.compose_vector_fields_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose_vector_fields_3d</span></code></a>(d1, d2, ...)</p></td>
<td><p>Computes the composition of two 3D displacement fields</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.create_circle" title="dipy.align.vector_fields.create_circle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_circle</span></code></a>(nrows, ncols, radius)</p></td>
<td><p>Create a binary 2D image where pixel values are 1 iff their distance to the center of the image is less than or equal to radius.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.create_harmonic_fields_2d" title="dipy.align.vector_fields.create_harmonic_fields_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_harmonic_fields_2d</span></code></a>(nrows, ncols, b, m)</p></td>
<td><p>Creates an invertible 2D displacement field</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.create_harmonic_fields_3d" title="dipy.align.vector_fields.create_harmonic_fields_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_harmonic_fields_3d</span></code></a>(nslices, nrows, ...)</p></td>
<td><p>Creates an invertible 3D displacement field</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.create_random_displacement_2d" title="dipy.align.vector_fields.create_random_displacement_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_random_displacement_2d</span></code></a>(from_shape, ...)</p></td>
<td><p>Creates a random 2D displacement 'exactly' mapping points of two grids</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.create_random_displacement_3d" title="dipy.align.vector_fields.create_random_displacement_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_random_displacement_3d</span></code></a>(from_shape, ...)</p></td>
<td><p>Creates a random 3D displacement 'exactly' mapping points of two grids</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.create_sphere" title="dipy.align.vector_fields.create_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_sphere</span></code></a>(nslices, nrows, ncols, radius)</p></td>
<td><p>Create a binary 3D image where voxel values are 1 iff their distance to the center of the image is less than or equal to radius.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.downsample_displacement_field_2d" title="dipy.align.vector_fields.downsample_displacement_field_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">downsample_displacement_field_2d</span></code></a>(field)</p></td>
<td><p>Down-samples the 2D input vector field by a factor of 2 Down-samples the input vector field by a factor of 2.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.downsample_displacement_field_3d" title="dipy.align.vector_fields.downsample_displacement_field_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">downsample_displacement_field_3d</span></code></a>(field)</p></td>
<td><p>Down-samples the input 3D vector field by a factor of 2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.downsample_scalar_field_2d" title="dipy.align.vector_fields.downsample_scalar_field_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">downsample_scalar_field_2d</span></code></a>(field)</p></td>
<td><p>Down-samples the input 2D image by a factor of 2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.downsample_scalar_field_3d" title="dipy.align.vector_fields.downsample_scalar_field_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">downsample_scalar_field_3d</span></code></a>(field)</p></td>
<td><p>Down-samples the input volume by a factor of 2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.gradient" title="dipy.align.vector_fields.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a>(img, img_world2grid, img_spacing, ...)</p></td>
<td><p>Gradient of an image in physical space</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.invert_vector_field_fixed_point_2d" title="dipy.align.vector_fields.invert_vector_field_fixed_point_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert_vector_field_fixed_point_2d</span></code></a>(d, ...[, ...])</p></td>
<td><p>Computes the inverse of a 2D displacement fields</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.invert_vector_field_fixed_point_3d" title="dipy.align.vector_fields.invert_vector_field_fixed_point_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert_vector_field_fixed_point_3d</span></code></a>(d, ...[, ...])</p></td>
<td><p>Computes the inverse of a 3D displacement fields</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.is_valid_affine" title="dipy.align.vector_fields.is_valid_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_valid_affine</span></code></a>(M, dim)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.reorient_vector_field_2d" title="dipy.align.vector_fields.reorient_vector_field_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorient_vector_field_2d</span></code></a>(d, affine)</p></td>
<td><p>Linearly transforms all vectors of a 2D displacement field</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.reorient_vector_field_3d" title="dipy.align.vector_fields.reorient_vector_field_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorient_vector_field_3d</span></code></a>(d, affine)</p></td>
<td><p>Linearly transforms all vectors of a 3D displacement field</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.resample_displacement_field_2d" title="dipy.align.vector_fields.resample_displacement_field_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample_displacement_field_2d</span></code></a>(field, ...)</p></td>
<td><p>Resamples a 2D vector field to a custom target shape</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.resample_displacement_field_3d" title="dipy.align.vector_fields.resample_displacement_field_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample_displacement_field_3d</span></code></a>(field, ...)</p></td>
<td><p>Resamples a 3D vector field to a custom target shape</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.simplify_warp_function_2d" title="dipy.align.vector_fields.simplify_warp_function_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">simplify_warp_function_2d</span></code></a>(d, affine_idx_in, ...)</p></td>
<td><p>Simplifies a nonlinear warping function combined with an affine transform</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.simplify_warp_function_3d" title="dipy.align.vector_fields.simplify_warp_function_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">simplify_warp_function_3d</span></code></a>(d, affine_idx_in, ...)</p></td>
<td><p>Simplifies a nonlinear warping function combined with an affine transform</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.sparse_gradient" title="dipy.align.vector_fields.sparse_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_gradient</span></code></a>(img, img_world2grid, ...)</p></td>
<td><p>Gradient of an image in physical space</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.transform_2d_affine" title="dipy.align.vector_fields.transform_2d_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_2d_affine</span></code></a>(image, ref_shape[, affine])</p></td>
<td><p>Transforms a 2D image by an affine transform with bilinear interp.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.transform_2d_affine_nn" title="dipy.align.vector_fields.transform_2d_affine_nn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_2d_affine_nn</span></code></a>(image, ref_shape[, ...])</p></td>
<td><p>Transforms a 2D image by an affine transform with NN interpolation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.transform_3d_affine" title="dipy.align.vector_fields.transform_3d_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_3d_affine</span></code></a>(volume, ref_shape, affine)</p></td>
<td><p>Transforms a 3D volume by an affine transform with trilinear interp.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.transform_3d_affine_nn" title="dipy.align.vector_fields.transform_3d_affine_nn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_3d_affine_nn</span></code></a>(volume, ref_shape[, ...])</p></td>
<td><p>Transforms a 3D volume by an affine transform with NN interpolation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.warp_2d" title="dipy.align.vector_fields.warp_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_2d</span></code></a>(image, d1[, affine_idx_in, ...])</p></td>
<td><p>Warps a 2D image using bilinear interpolation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.warp_2d_nn" title="dipy.align.vector_fields.warp_2d_nn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_2d_nn</span></code></a>(image, d1[, affine_idx_in, ...])</p></td>
<td><p>Warps a 2D image using nearest neighbor interpolation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.warp_3d" title="dipy.align.vector_fields.warp_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_3d</span></code></a>(volume, d1[, affine_idx_in, ...])</p></td>
<td><p>Warps a 3D volume using trilinear interpolation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.warp_3d_nn" title="dipy.align.vector_fields.warp_3d_nn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_3d_nn</span></code></a>(volume, d1[, affine_idx_in, ...])</p></td>
<td><p>Warps a 3D volume using using nearest-neighbor interpolation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.vector_fields.warp_coordinates_2d" title="dipy.align.vector_fields.warp_coordinates_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_coordinates_2d</span></code></a>(points, d1, in2world, ...)</p></td>
<td><p>Parameters

points : array, shape (n, 2)
d1 : array, shape (S, R, C, 2)
in2world : array, shape (3, 3)
world2out : array, shape (3, 3)
field_world2grid : array, shape (3, 3)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.vector_fields.warp_coordinates_3d" title="dipy.align.vector_fields.warp_coordinates_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_coordinates_3d</span></code></a>(points, d1, in2world, ...)</p></td>
<td><p>Parameters

points : array, shape (n, 3)
d1 : array, shape (S, R, C, 3)
in2world : array, shape (4, 4)
world2out : array, shape (4, 4)
field_world2grid : array, shape (4, 4)</p></td>
</tr>
</tbody>
</table>
<section id="bunch">
<h3><a class="reference internal" href="#dipy.align.Bunch" title="dipy.align.Bunch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bunch</span></code></a><a class="headerlink" href="#bunch" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.Bunch">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.</span></span><span class="sig-name descname"><span class="pre">Bunch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.Bunch" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.Bunch.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.Bunch.__init__" title="Link to this definition">#</a></dt>
<dd><p>A ‘bunch’ of values (a replacement of Enum)</p>
<p>This is a temporary replacement of Enum, which is not available
on all versions of Python 2</p>
</dd></dl>

</dd></dl>

</section>
<section id="verbositylevels">
<h3>VerbosityLevels<a class="headerlink" href="#verbositylevels" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.VerbosityLevels">
<span class="sig-prename descclassname"><span class="pre">dipy.align.</span></span><span class="sig-name descname"><span class="pre">VerbosityLevels</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.VerbosityLevels" title="Link to this definition">#</a></dt>
<dd><p>VerbosityLevels
This enum defines the four levels of verbosity we use in the align
module.
NONE : do not print anything
STATUS : print information about the current status of the algorithm
DIAGNOSE : print high level information of the components involved in the
registration that can be used to detect a failing component.
DEBUG : print as much information as possible to isolate the cause of a bug.</p>
</dd></dl>

</section>
<section id="syn-registration">
<h3>syn_registration<a class="headerlink" href="#syn-registration" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.syn_registration">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">syn_registration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CC'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prealign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">metric_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.syn_registration" title="Link to this definition">#</a></dt>
<dd><p>Register a 2D/3D source image (moving) to a 2D/3D target image (static).</p>
<section id="parameters">
<h4>Parameters<a class="headerlink" href="#parameters" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>moving, static<span class="classifier">array or nib.Nifti1Image or str.</span></dt><dd><p>Either as a 2D/3D array or as a nifti image object, or as
a string containing the full path to a nifti file.</p>
</dd>
<dt>moving_affine, static_affine<span class="classifier">4x4 array, optional.</span></dt><dd><p>Must be provided for <cite>data</cite> provided as an array. If provided together
with Nifti1Image or str <cite>data</cite>, this input will over-ride the affine
that is stored in the <cite>data</cite> input. Default: use the affine stored
in <cite>data</cite>.</p>
</dd>
<dt>metric<span class="classifier">string, optional</span></dt><dd><p>The metric to be optimized. One of <cite>CC</cite>, <cite>EM</cite>, <cite>SSD</cite>,
Default: ‘CC’ =&gt; CCMetric.</p>
</dd>
<dt>dim: int (either 2 or 3), optional</dt><dd><p>The dimensions of the image domain. Default: 3</p>
</dd>
<dt>level_iters<span class="classifier">list of int, optional</span></dt><dd><p>the number of iterations at each level of the Gaussian Pyramid (the
length of the list defines the number of pyramid levels to be
used). Default: [10, 10, 5].</p>
</dd>
<dt>metric_kwargs<span class="classifier">dict, optional</span></dt><dd><p>Parameters for initialization of the metric object. If not provided,
uses the default settings of each metric.</p>
</dd>
</dl>
</section>
<section id="returns">
<h4>Returns<a class="headerlink" href="#returns" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>warped_moving<span class="classifier">ndarray</span></dt><dd><p>The data in <cite>moving</cite>, warped towards the <cite>static</cite> data.</p>
</dd>
<dt>forward<span class="classifier">ndarray (…, 3)</span></dt><dd><p>The vector field describing the forward warping from the source to the
target.</p>
</dd>
<dt>backward<span class="classifier">ndarray (…, 3)</span></dt><dd><p>The vector field describing the backward warping from the target to the
source.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="register-dwi-to-template">
<h3>register_dwi_to_template<a class="headerlink" href="#register-dwi-to-template" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.register_dwi_to_template">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">register_dwi_to_template</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dwi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dwi_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'syn'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">reg_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.register_dwi_to_template" title="Link to this definition">#</a></dt>
<dd><p>Register DWI data to a template through the B0 volumes.</p>
<section id="id5">
<h4>Parameters<a class="headerlink" href="#id5" title="Link to this heading">#</a></h4>
<dl>
<dt>dwi<span class="classifier">4D array, nifti image or str</span></dt><dd><p>Containing the DWI data, or full path to a nifti file with DWI.</p>
</dd>
<dt>gtab<span class="classifier">GradientTable or sequence of strings</span></dt><dd><p>The gradients associated with the DWI data, or a sequence with
(fbval, fbvec), full paths to bvals and bvecs files.</p>
</dd>
<dt>dwi_affine<span class="classifier">4x4 array, optional</span></dt><dd><p>An affine transformation associated with the DWI. Required if data
is provided as an array. If provided together with nifti/path,
will over-ride the affine that is in the nifti.</p>
</dd>
<dt>template<span class="classifier">3D array, nifti image or str</span></dt><dd><p>Containing the data for the template, or full path to a nifti file
with the template data.</p>
</dd>
<dt>template_affine<span class="classifier">4x4 array, optional</span></dt><dd><p>An affine transformation associated with the template. Required if data
is provided as an array. If provided together with nifti/path,
will over-ride the affine that is in the nifti.</p>
</dd>
<dt>reg_method<span class="classifier">str,</span></dt><dd><p>One of “syn” or “aff”, which designates which registration method is
used. Either syn, which uses the <a class="reference internal" href="#dipy.align._public.syn_registration" title="dipy.align._public.syn_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">syn_registration()</span></code></a> function
or <a class="reference internal" href="#dipy.align._public.affine_registration" title="dipy.align._public.affine_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">affine_registration()</span></code></a> function. Default: “syn”.</p>
</dd>
<dt>reg_kwargs<span class="classifier">key-word arguments for <a class="reference internal" href="#dipy.align._public.syn_registration" title="dipy.align._public.syn_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">syn_registration()</span></code></a> or</span></dt><dd><p><a class="reference internal" href="#dipy.align._public.affine_registration" title="dipy.align._public.affine_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">affine_registration()</span></code></a></p>
</dd>
</dl>
</section>
<section id="id6">
<h4>Returns<a class="headerlink" href="#id6" title="Link to this heading">#</a></h4>
<p>warped_b0, mapping: The fist is an array with the b0 volume warped to the
template. If reg_method is “syn”, the second is a DiffeomorphicMap class
instance that can be used to transform between the two spaces. Otherwise,
if reg_method is “aff”, this is a 4x4 matrix encoding the affine transform.</p>
</section>
<section id="notes">
<h4>Notes<a class="headerlink" href="#notes" title="Link to this heading">#</a></h4>
<p>This function assumes that the DWI data is already internally registered.
See <a class="reference internal" href="#dipy.align._public.register_dwi_series" title="dipy.align._public.register_dwi_series"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_dwi_series()</span></code></a>.</p>
</section>
</dd></dl>

</section>
<section id="write-mapping">
<h3>write_mapping<a class="headerlink" href="#write-mapping" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.write_mapping">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">write_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.write_mapping" title="Link to this definition">#</a></dt>
<dd><p>Write out a syn registration mapping to a nifti file.</p>
<section id="id7">
<h4>Parameters<a class="headerlink" href="#id7" title="Link to this heading">#</a></h4>
<p>mapping : a DiffeomorphicMap object derived from <a class="reference internal" href="#dipy.align._public.syn_registration" title="dipy.align._public.syn_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">syn_registration()</span></code></a>
fname : str</p>
<blockquote>
<div><p>Full path to the nifti file storing the mapping</p>
</div></blockquote>
</section>
<section id="id8">
<h4>Notes<a class="headerlink" href="#id8" title="Link to this heading">#</a></h4>
<p>The data in the file is organized with shape (X, Y, Z, 3, 2), such
that the forward mapping in each voxel is in <cite>data[i, j, k, :, 0]</cite> and
the backward mapping in each voxel is in <cite>data[i, j, k, :, 1]</cite>.</p>
</section>
</dd></dl>

</section>
<section id="read-mapping">
<h3>read_mapping<a class="headerlink" href="#read-mapping" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.read_mapping">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">read_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain_img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prealign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.read_mapping" title="Link to this definition">#</a></dt>
<dd><p>Read a syn registration mapping from a nifti file.</p>
<section id="id9">
<h4>Parameters<a class="headerlink" href="#id9" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>disp<span class="classifier">str or Nifti1Image</span></dt><dd><p>A file of image containing the mapping displacement field in each voxel
Shape (x, y, z, 3, 2)</p>
</dd>
</dl>
<p>domain_img : str or Nifti1Image</p>
<p>codomain_img : str or Nifti1Image</p>
</section>
<section id="id10">
<h4>Returns<a class="headerlink" href="#id10" title="Link to this heading">#</a></h4>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicMap</span></code> object.</p>
</section>
<section id="id11">
<h4>Notes<a class="headerlink" href="#id11" title="Link to this heading">#</a></h4>
<p>See <a class="reference internal" href="#dipy.align._public.write_mapping" title="dipy.align._public.write_mapping"><code class="xref py py-func docutils literal notranslate"><span class="pre">write_mapping()</span></code></a> for the data format expected.</p>
</section>
</dd></dl>

</section>
<section id="resample">
<h3>resample<a class="headerlink" href="#resample" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.resample">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">between_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.resample" title="Link to this definition">#</a></dt>
<dd><p>Resample an image (moving) from one space to another (static).</p>
<section id="id12">
<h4>Parameters<a class="headerlink" href="#id12" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>moving<span class="classifier">array, nifti image or str</span></dt><dd><p>Containing the data for the moving object, or full path to a nifti file
with the moving data.</p>
</dd>
<dt>moving_affine<span class="classifier">4x4 array, optional</span></dt><dd><p>An affine transformation associated with the moving object. Required if
data is provided as an array. If provided together with nifti/path,
will over-ride the affine that is in the nifti.</p>
</dd>
<dt>static<span class="classifier">array, nifti image or str</span></dt><dd><p>Containing the data for the static object, or full path to a nifti file
with the moving data.</p>
</dd>
<dt>static_affine<span class="classifier">4x4 array, optional</span></dt><dd><p>An affine transformation associated with the static object. Required if
data is provided as an array. If provided together with nifti/path,
will over-ride the affine that is in the nifti.</p>
</dd>
<dt>between_affine: 4x4 array, optional</dt><dd><p>If an additional affine is needed between the two spaces.
Default: identity (no additional registration).</p>
</dd>
</dl>
</section>
<section id="id13">
<h4>Returns<a class="headerlink" href="#id13" title="Link to this heading">#</a></h4>
<p>A Nifti1Image class instance with the data from the moving object
resampled into the space of the static object.</p>
</section>
</dd></dl>

</section>
<section id="affine-registration">
<h3>affine_registration<a class="headerlink" href="#affine-registration" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.affine_registration">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">affine_registration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">metric_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.affine_registration" title="Link to this definition">#</a></dt>
<dd><p>Find the affine transformation between two 3D images. Alternatively, find
the combination of several linear transformations.</p>
<section id="id14">
<h4>Parameters<a class="headerlink" href="#id14" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>moving<span class="classifier">array, nifti image or str</span></dt><dd><p>Containing the data for the moving object, or full path to a nifti file
with the moving data.</p>
</dd>
<dt>static<span class="classifier">array, nifti image or str</span></dt><dd><p>Containing the data for the static object, or full path to a nifti file
with the moving data.</p>
</dd>
<dt>moving_affine<span class="classifier">4x4 array, optional</span></dt><dd><p>An affine transformation associated with the moving object. Required if
data is provided as an array. If provided together with nifti/path,
will over-ride the affine that is in the nifti.</p>
</dd>
<dt>static_affine<span class="classifier">4x4 array, optional</span></dt><dd><p>An affine transformation associated with the static object. Required if
data is provided as an array. If provided together with nifti/path,
will over-ride the affine that is in the nifti.</p>
</dd>
<dt>pipeline<span class="classifier">list of str, optional</span></dt><dd><p>Sequence of transforms to use in the gradual fitting. Default: gradual
fit of the full affine (executed from left to right):
<code class="docutils literal notranslate"><span class="pre">[&quot;center_of_mass&quot;,</span> <span class="pre">&quot;translation&quot;,</span> <span class="pre">&quot;rigid&quot;,</span> <span class="pre">&quot;affine&quot;]</span></code>
Alternatively, any other combination of the following registration
methods might be used: center_of_mass, translation, rigid,
rigid_isoscaling, rigid_scaling and affine.</p>
</dd>
<dt>starting_affine: 4x4 array, optional</dt><dd><p>Initial guess for the transformation between the spaces.
Default: identity.</p>
</dd>
<dt>metric<span class="classifier">str, optional.</span></dt><dd><p>Currently only supports ‘MI’ for MutualInformationMetric.</p>
</dd>
<dt>level_iters<span class="classifier">sequence, optional</span></dt><dd><p>AffineRegistration key-word argument: the number of iterations at each
scale of the scale space. <cite>level_iters[0]</cite> corresponds to the coarsest
scale, <cite>level_iters[-1]</cite> the finest, where n is the length of the
sequence. By default, a 3-level scale space with iterations
sequence equal to [10000, 1000, 100] will be used.</p>
</dd>
<dt>sigmas<span class="classifier">sequence of floats, optional</span></dt><dd><p>AffineRegistration key-word argument: custom smoothing parameter to
build the scale space (one parameter for each scale). By default,
the sequence of sigmas will be [3, 1, 0].</p>
</dd>
<dt>factors<span class="classifier">sequence of floats, optional</span></dt><dd><p>AffineRegistration key-word argument: custom scale factors to build the
scale space (one factor for each scale). By default, the sequence of
factors will be [4, 2, 1].</p>
</dd>
<dt>ret_metric<span class="classifier">boolean, optional</span></dt><dd><p>Set it to True to return the value of the optimized coefficients and
the optimization quality metric.</p>
</dd>
<dt>moving_mask<span class="classifier">array, shape (S’, R’, C’) or (R’, C’), optional</span></dt><dd><p>moving image mask that defines which pixels in the moving image
are used to calculate the mutual information.</p>
</dd>
<dt>static_mask<span class="classifier">array, shape (S, R, C) or (R, C), optional</span></dt><dd><p>static image mask that defines which pixels in the static image
are used to calculate the mutual information.</p>
</dd>
<dt>nbins<span class="classifier">int, optional</span></dt><dd><p>MutualInformationMetric key-word argument: the number of bins to be
used for computing the intensity histograms. The default is 32.</p>
</dd>
<dt>sampling_proportion<span class="classifier">None or float in interval (0, 1], optional</span></dt><dd><p>MutualInformationMetric key-word argument: There are two types of
sampling: dense and sparse. Dense sampling uses all voxels for
estimating the (joint and marginal) intensity histograms, while
sparse sampling uses a subset of them. If <cite>sampling_proportion</cite> is
None, then dense sampling is used. If <cite>sampling_proportion</cite> is a
floating point value in (0,1] then sparse sampling is used,
where <cite>sampling_proportion</cite> specifies the proportion of voxels to
be used. The default is None (dense sampling).</p>
</dd>
</dl>
</section>
<section id="id15">
<h4>Returns<a class="headerlink" href="#id15" title="Link to this heading">#</a></h4>
<p>transformed : array with moving data resampled to the static space
after computing the affine transformation
affine : the affine 4x4 associated with the transformation.
xopt : the value of the optimized coefficients.
fopt : the value of the optimization quality metric.</p>
</section>
<section id="id16">
<h4>Notes<a class="headerlink" href="#id16" title="Link to this heading">#</a></h4>
<p>Performs a gradual registration between the two inputs, using a pipeline
that gradually approximates the final registration. If the final default
step (<cite>affine</cite>) is omitted, the resulting affine may not have all 12
degrees of freedom adjusted.</p>
</section>
</dd></dl>

</section>
<section id="center-of-mass">
<h3>center_of_mass<a class="headerlink" href="#center-of-mass" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.center_of_mass">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">center_of_mass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['center_of_mass']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">metric_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.center_of_mass" title="Link to this definition">#</a></dt>
<dd><p>Implements a center of mass transform. Based on <cite>affine_registration()</cite>.</p>
</dd></dl>

</section>
<section id="translation">
<h3>translation<a class="headerlink" href="#translation" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.translation">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['translation']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">metric_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.translation" title="Link to this definition">#</a></dt>
<dd><p>Implements a translation transform. Based on <cite>affine_registration()</cite>.</p>
</dd></dl>

</section>
<section id="rigid">
<h3>rigid<a class="headerlink" href="#rigid" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.rigid">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">rigid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['rigid']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">metric_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.rigid" title="Link to this definition">#</a></dt>
<dd><p>Implements a rigid transform. Based on <cite>affine_registration()</cite>.</p>
</dd></dl>

</section>
<section id="rigid-isoscaling">
<h3>rigid_isoscaling<a class="headerlink" href="#rigid-isoscaling" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.rigid_isoscaling">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">rigid_isoscaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['rigid_isoscaling']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">metric_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.rigid_isoscaling" title="Link to this definition">#</a></dt>
<dd><p>Implements a rigid isoscaling transform. Based on <cite>affine_registration()</cite>.</p>
</dd></dl>

</section>
<section id="rigid-scaling">
<h3>rigid_scaling<a class="headerlink" href="#rigid-scaling" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.rigid_scaling">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">rigid_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['rigid_scaling']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">metric_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.rigid_scaling" title="Link to this definition">#</a></dt>
<dd><p>Implements a rigid scaling transform. Based on <cite>affine_registration()</cite>.</p>
</dd></dl>

</section>
<section id="affine">
<h3>affine<a class="headerlink" href="#affine" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.affine">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['affine']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">metric_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.affine" title="Link to this definition">#</a></dt>
<dd><p>Implements an affine transform. Based on <cite>affine_registration()</cite>.</p>
</dd></dl>

</section>
<section id="method-dict">
<h3>_METHOD_DICT<a class="headerlink" href="#method-dict" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public._METHOD_DICT">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">_METHOD_DICT</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public._METHOD_DICT" title="Link to this definition">#</a></dt>
<dd><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object’s</p>
<blockquote>
<div><p>(key, value) pairs</p>
</div></blockquote>
<dl>
<dt>dict(iterable) -&gt; new dictionary initialized as if via:</dt><dd><p>d = {}
for k, v in iterable:</p>
<blockquote>
<div><p>d[k] = v</p>
</div></blockquote>
</dd>
<dt>dict(<a href="#id17"><span class="problematic" id="id18">**</span></a>kwargs) -&gt; new dictionary initialized with the name=value pairs</dt><dd><p>in the keyword argument list.  For example:  dict(one=1, two=2)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="register-series">
<h3>register_series<a class="headerlink" href="#register-series" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.register_series">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">register_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">series_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.register_series" title="Link to this definition">#</a></dt>
<dd><p>Register a series to a reference image.</p>
<section id="id19">
<h4>Parameters<a class="headerlink" href="#id19" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>series<span class="classifier">4D array or nib.Nifti1Image class instance or str</span></dt><dd><p>The data is 4D with the last dimension separating different 3D volumes</p>
</dd>
<dt>ref<span class="classifier">int or 3D array or nib.Nifti1Image class instance or str</span></dt><dd><p>If this is an int, this is the index of the reference image within the
series. Otherwise it is an array of data to register with (associated
with a <cite>ref_affine</cite> required) or a nifti img or full path to a file
containing one.</p>
</dd>
<dt>pipeline<span class="classifier">sequence, optional</span></dt><dd><p>Sequence of transforms to do for each volume in the series.
Default: (executed from left to right):
<cite>[center_of_mass, translation, rigid, affine]</cite></p>
</dd>
<dt>series_affine, ref_affine<span class="classifier">4x4 arrays, optional.</span></dt><dd><p>The affine. If provided, this input will over-ride the affine provided
together with the nifti img or file.</p>
</dd>
<dt>static_mask<span class="classifier">array, shape (S, R, C) or (R, C), optional</span></dt><dd><p>static image mask that defines which pixels in the static image
are used to calculate the mutual information.</p>
</dd>
</dl>
</section>
<section id="id20">
<h4>Returns<a class="headerlink" href="#id20" title="Link to this heading">#</a></h4>
<p>xformed, affines : 4D array with transformed data and a (4,4,n) array
with 4x4 matrices associated with each of the volumes of the input moving
data that was used to transform it into register with the static data.</p>
</section>
</dd></dl>

</section>
<section id="register-dwi-series">
<h3>register_dwi_series<a class="headerlink" href="#register-dwi-series" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.register_dwi_series">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">register_dwi_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b0_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.register_dwi_series" title="Link to this definition">#</a></dt>
<dd><p>Register a DWI series to the mean of the B0 images in that series.</p>
<p>all first registered to the first B0 volume</p>
<section id="id21">
<h4>Parameters<a class="headerlink" href="#id21" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">4D array or nibabel Nifti1Image class instance or str</span></dt><dd><p>Diffusion data. Either as a 4D array or as a nifti image object, or as
a string containing the full path to a nifti file.</p>
</dd>
<dt>gtab<span class="classifier">a GradientTable class instance or tuple of strings</span></dt><dd><p>If provided as a tuple of strings, these are assumed to be full paths
to the bvals and bvecs files (in that order).</p>
</dd>
<dt>affine<span class="classifier">4x4 array, optional.</span></dt><dd><p>Must be provided for <cite>data</cite> provided as an array. If provided together
with Nifti1Image or str <cite>data</cite>, this input will over-ride the affine
that is stored in the <cite>data</cite> input. Default: use the affine stored
in <cite>data</cite>.</p>
</dd>
<dt>b0_ref<span class="classifier">int, optional.</span></dt><dd><p>Which b0 volume to use as reference. Default: 0</p>
</dd>
<dt>pipeline<span class="classifier">list of callables, optional.</span></dt><dd><p>The transformations to perform in sequence (from left to right):
Default: <code class="docutils literal notranslate"><span class="pre">[center_of_mass,</span> <span class="pre">translation,</span> <span class="pre">rigid,</span> <span class="pre">affine]</span></code></p>
</dd>
<dt>static_mask<span class="classifier">array, shape (S, R, C) or (R, C), optional</span></dt><dd><p>static image mask that defines which pixels in the static image
are used to calculate the mutual information.</p>
</dd>
</dl>
</section>
<section id="id22">
<h4>Returns<a class="headerlink" href="#id22" title="Link to this heading">#</a></h4>
<p>xform_img, affine_array: a Nifti1Image containing the registered data and
using the affine of the original data and a list containing the affine
transforms associated with each of the</p>
</section>
</dd></dl>

</section>
<section id="motion-correction">
<h3>motion_correction<a class="headerlink" href="#motion-correction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.motion_correction">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">motion_correction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b0_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['center_of_mass',</span> <span class="pre">'translation',</span> <span class="pre">'rigid',</span> <span class="pre">'affine']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.motion_correction" title="Link to this definition">#</a></dt>
<dd><p>Apply a motion correction to a DWI dataset (Between-Volumes Motion correction)</p>
<section id="id23">
<h4>Parameters<a class="headerlink" href="#id23" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">4D array or nibabel Nifti1Image class instance or str</span></dt><dd><p>Diffusion data. Either as a 4D array or as a nifti image object, or as
a string containing the full path to a nifti file.</p>
</dd>
<dt>gtab<span class="classifier">a GradientTable class instance or tuple of strings</span></dt><dd><p>If provided as a tuple of strings, these are assumed to be full paths
to the bvals and bvecs files (in that order).</p>
</dd>
<dt>affine<span class="classifier">4x4 array, optional.</span></dt><dd><p>Must be provided for <cite>data</cite> provided as an array. If provided together
with Nifti1Image or str <cite>data</cite>, this input will over-ride the affine
that is stored in the <cite>data</cite> input. Default: use the affine stored
in <cite>data</cite>.</p>
</dd>
<dt>b0_ref<span class="classifier">int, optional.</span></dt><dd><p>Which b0 volume to use as reference. Default: 0</p>
</dd>
<dt>pipeline<span class="classifier">list of callables, optional.</span></dt><dd><p>The transformations to perform in sequence (from left to right):
Default: <code class="docutils literal notranslate"><span class="pre">[center_of_mass,</span> <span class="pre">translation,</span> <span class="pre">rigid,</span> <span class="pre">affine]</span></code></p>
</dd>
<dt>static_mask<span class="classifier">array, shape (S, R, C) or (R, C), optional</span></dt><dd><p>static image mask that defines which pixels in the static image
are used to calculate the mutual information.</p>
</dd>
</dl>
</section>
<section id="id24">
<h4>Returns<a class="headerlink" href="#id24" title="Link to this heading">#</a></h4>
<p>xform_img, affine_array: a Nifti1Image containing the registered data and
using the affine of the original data and a list containing the affine
transforms associated with each of the</p>
</section>
</dd></dl>

</section>
<section id="streamline-registration">
<h3>streamline_registration<a class="headerlink" href="#streamline-registration" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align._public.streamline_registration">
<span class="sig-prename descclassname"><span class="pre">dipy.align._public.</span></span><span class="sig-name descname"><span class="pre">streamline_registration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">native_resampled</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align._public.streamline_registration" title="Link to this definition">#</a></dt>
<dd><p>Register two collections of streamlines (‘bundles’) to each other.</p>
<section id="id25">
<h4>Parameters<a class="headerlink" href="#id25" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>moving, static<span class="classifier">lists of 3 by n, or str</span></dt><dd><p>The two bundles to be registered. Given either as lists of arrays with
3D coordinates, or strings containing full paths to these files.</p>
</dd>
<dt>n_points<span class="classifier">int, optional</span></dt><dd><p>How many points to resample to. Default: 100.</p>
</dd>
<dt>native_resampled<span class="classifier">bool, optional</span></dt><dd><p>Whether to return the moving bundle in the original space, but
resampled in the static space to n_points.</p>
</dd>
</dl>
</section>
<section id="id26">
<h4>Returns<a class="headerlink" href="#id26" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>aligned<span class="classifier">list</span></dt><dd><p>Streamlines from the moving group, moved to be closely matched to
the static group.</p>
</dd>
<dt>matrix<span class="classifier">array (4, 4)</span></dt><dd><p>The affine transformation that takes us from ‘moving’ to ‘static’</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="determine-num-threads">
<h3>determine_num_threads<a class="headerlink" href="#determine-num-threads" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.bundlemin.determine_num_threads">
<span class="sig-prename descclassname"><span class="pre">dipy.align.bundlemin.</span></span><span class="sig-name descname"><span class="pre">determine_num_threads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.bundlemin.determine_num_threads" title="Link to this definition">#</a></dt>
<dd><p>Determine the effective number of threads to be used for OpenMP calls</p>
<ul class="simple">
<li><p>For <code class="docutils literal notranslate"><span class="pre">num_threads</span> <span class="pre">=</span> <span class="pre">None</span></code>,
- if the <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> environment variable is set, return that
value
- otherwise, return the maximum number of cores retrieved by
<code class="docutils literal notranslate"><span class="pre">openmp.opm_get_num_procs()</span></code>.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">num_threads</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, return this value.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">num_threads</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, return the maximal number of threads minus
<code class="docutils literal notranslate"><span class="pre">|num_threads</span> <span class="pre">+</span> <span class="pre">1|</span></code>. In particular <code class="docutils literal notranslate"><span class="pre">num_threads</span> <span class="pre">=</span> <span class="pre">-1</span></code> will use as
many threads as there are available cores on the machine.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">num_threads</span> <span class="pre">=</span> <span class="pre">0</span></code> a ValueError is raised.</p></li>
</ul>
<section id="id27">
<h4>Parameters<a class="headerlink" href="#id27" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>num_threads<span class="classifier">int or None</span></dt><dd><p>Desired number of threads to be used.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="distance-matrix-mdf">
<h3>distance_matrix_mdf<a class="headerlink" href="#distance-matrix-mdf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.bundlemin.distance_matrix_mdf">
<span class="sig-prename descclassname"><span class="pre">dipy.align.bundlemin.</span></span><span class="sig-name descname"><span class="pre">distance_matrix_mdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">streamlines_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streamlines_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.bundlemin.distance_matrix_mdf" title="Link to this definition">#</a></dt>
<dd><p>Minimum direct flipped distance matrix between two streamline sets</p>
<p>All streamlines need to have the same number of points</p>
<section id="id28">
<h4>Parameters<a class="headerlink" href="#id28" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>streamlines_a<span class="classifier">sequence</span></dt><dd><p>of streamlines as arrays, [(N, 3) .. (N, 3)]</p>
</dd>
<dt>streamlines_b<span class="classifier">sequence</span></dt><dd><p>of streamlines as arrays, [(N, 3) .. (N, 3)]</p>
</dd>
</dl>
</section>
<section id="id29">
<h4>Returns<a class="headerlink" href="#id29" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>DM<span class="classifier">array, shape (len(streamlines_a), len(streamlines_b))</span></dt><dd><p>distance matrix</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="deformableregistration">
<h3><a class="reference internal" href="#dipy.align.cpd.DeformableRegistration" title="dipy.align.cpd.DeformableRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeformableRegistration</span></code></a><a class="headerlink" href="#deformableregistration" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.cpd.</span></span><span class="sig-name descname"><span class="pre">DeformableRegistration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_eig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Deformable point cloud registration.</p>
<section id="attributes">
<h4>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>X: numpy array</dt><dd><p>NxD array of target points.</p>
</dd>
<dt>Y: numpy array</dt><dd><p>MxD array of source points.</p>
</dd>
<dt>TY: numpy array</dt><dd><p>MxD array of transformed source points.</p>
</dd>
<dt>sigma2: float (positive)</dt><dd><p>Initial variance of the Gaussian mixture model.</p>
</dd>
<dt>N: int</dt><dd><p>Number of target points.</p>
</dd>
<dt>M: int</dt><dd><p>Number of source points.</p>
</dd>
<dt>D: int</dt><dd><p>Dimensionality of source and target points</p>
</dd>
<dt>iteration: int</dt><dd><p>The current iteration throughout registration.</p>
</dd>
<dt>max_iterations: int</dt><dd><p>Registration will terminate once the algorithm has taken this
many iterations.</p>
</dd>
<dt>tolerance: float (positive)</dt><dd><p>Registration will terminate once the difference between
consecutive objective function values falls within this tolerance.</p>
</dd>
<dt>w: float (between 0 and 1)</dt><dd><p>Contribution of the uniform distribution to account for outliers.
Valid values span 0 (inclusive) and 1 (exclusive).</p>
</dd>
<dt>q: float</dt><dd><p>The objective function value that represents the misalignment between
source and target point clouds.</p>
</dd>
<dt>diff: float (positive)</dt><dd><p>The absolute difference between the current and previous objective
function values.</p>
</dd>
<dt>P: numpy array</dt><dd><p>MxN array of probabilities.
P[m, n] represents the probability that the m-th source point
corresponds to the n-th target point.</p>
</dd>
<dt>Pt1: numpy array</dt><dd><p>Nx1 column array. Multiplication result between the transpose of P
and a column vector of all 1s.</p>
</dd>
<dt>P1: numpy array</dt><dd><p>Mx1 column array.
Multiplication result between P and a column vector of all 1s.</p>
</dd>
<dt>Np: float (positive)</dt><dd><p>The sum of all elements in P.</p>
</dd>
<dt>alpha: float (positive)</dt><dd><p>Represents the trade-off between the goodness of maximum likelihoo
fit and regularization.</p>
</dd>
<dt>beta: float(positive)</dt><dd><p>Width of the Gaussian kernel.</p>
</dd>
<dt>low_rank: bool</dt><dd><p>Whether to use low rank approximation.</p>
</dd>
<dt>num_eig: int</dt><dd><p>Number of eigenvectors to use in lowrank calculation.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_eig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration.expectation">
<span class="sig-name descname"><span class="pre">expectation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration.expectation" title="Link to this definition">#</a></dt>
<dd><p>Compute the expectation step of the EM algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration.get_registration_parameters">
<span class="sig-name descname"><span class="pre">get_registration_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration.get_registration_parameters" title="Link to this definition">#</a></dt>
<dd><p>Return the current estimate of the deformable transformation
parameters.</p>
<section id="id30">
<h5>Returns<a class="headerlink" href="#id30" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>self.G: numpy array</dt><dd><p>Gaussian kernel matrix.</p>
</dd>
<dt>self.W: numpy array</dt><dd><p>Deformable transformation matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration.iterate">
<span class="sig-name descname"><span class="pre">iterate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration.iterate" title="Link to this definition">#</a></dt>
<dd><p>Perform one iteration of the EM algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration.maximization">
<span class="sig-name descname"><span class="pre">maximization</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration.maximization" title="Link to this definition">#</a></dt>
<dd><p>Compute the maximization step of the EM algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration.register">
<span class="sig-name descname"><span class="pre">register</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback=&lt;function</span> <span class="pre">DeformableRegistration.&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration.register" title="Link to this definition">#</a></dt>
<dd><p>Perform the EM registration.</p>
<section id="id31">
<h5>Parameters<a class="headerlink" href="#id31" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>callback: function</dt><dd><p>A function that will be called after each iteration.
Can be used to visualize the registration process.</p>
</dd>
</dl>
</section>
<section id="id32">
<h5>Returns<a class="headerlink" href="#id32" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>self.TY: numpy array</dt><dd><p>MxD array of transformed source points.</p>
</dd>
<dt>registration_parameters:</dt><dd><p>Returned params dependent on registration method used.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration.transform_point_cloud">
<span class="sig-name descname"><span class="pre">transform_point_cloud</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration.transform_point_cloud" title="Link to this definition">#</a></dt>
<dd><p>Update a point cloud using the new estimate of the deformable
transformation.</p>
<section id="id33">
<h5>Parameters<a class="headerlink" href="#id33" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>Y: numpy array, optional</dt><dd><p>Array of points to transform - use to predict on new set of points.
Best for predicting on new points not used to run initial
registration. If None, self.Y used.</p>
</dd>
</dl>
</section>
<section id="id34">
<h5>Returns<a class="headerlink" href="#id34" title="Link to this heading">#</a></h5>
<p>If Y is None, returns None.
Otherwise, returns the transformed Y.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration.update_transform">
<span class="sig-name descname"><span class="pre">update_transform</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration.update_transform" title="Link to this definition">#</a></dt>
<dd><p>Calculate a new estimate of the deformable transformation.
See Eq. 22 of <a class="reference external" href="https://arxiv.org/pdf/0905.2635.pdf">https://arxiv.org/pdf/0905.2635.pdf</a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.cpd.DeformableRegistration.update_variance">
<span class="sig-name descname"><span class="pre">update_variance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.DeformableRegistration.update_variance" title="Link to this definition">#</a></dt>
<dd><p>Update the variance of the mixture model.</p>
<p>This is using the new estimate of the deformable transformation.
See the update rule for sigma2 in
Eq. 23 of of <a class="reference external" href="https://arxiv.org/pdf/0905.2635.pdf">https://arxiv.org/pdf/0905.2635.pdf</a>.</p>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="gaussian-kernel">
<h3>gaussian_kernel<a class="headerlink" href="#gaussian-kernel" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.cpd.gaussian_kernel">
<span class="sig-prename descclassname"><span class="pre">dipy.align.cpd.</span></span><span class="sig-name descname"><span class="pre">gaussian_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.gaussian_kernel" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="low-rank-eigen">
<h3>low_rank_eigen<a class="headerlink" href="#low-rank-eigen" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.cpd.low_rank_eigen">
<span class="sig-prename descclassname"><span class="pre">dipy.align.cpd.</span></span><span class="sig-name descname"><span class="pre">low_rank_eigen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_eig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.low_rank_eigen" title="Link to this definition">#</a></dt>
<dd><p>Calculate num_eig eigenvectors and eigenvalues of gaussian matrix G.</p>
<p>Enables lower dimensional solving.</p>
</dd></dl>

</section>
<section id="initialize-sigma2">
<h3>initialize_sigma2<a class="headerlink" href="#initialize-sigma2" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.cpd.initialize_sigma2">
<span class="sig-prename descclassname"><span class="pre">dipy.align.cpd.</span></span><span class="sig-name descname"><span class="pre">initialize_sigma2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.initialize_sigma2" title="Link to this definition">#</a></dt>
<dd><p>Initialize the variance (sigma2).</p>
<section id="id35">
<h4>Parameters<a class="headerlink" href="#id35" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>X: numpy array</dt><dd><p>NxD array of points for target.</p>
</dd>
<dt>Y: numpy array</dt><dd><p>MxD array of points for source.</p>
</dd>
</dl>
</section>
<section id="id36">
<h4>Returns<a class="headerlink" href="#id36" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>sigma2: float</dt><dd><p>Initial variance.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="lowrankqs">
<h3>lowrankQS<a class="headerlink" href="#lowrankqs" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.cpd.lowrankQS">
<span class="sig-prename descclassname"><span class="pre">dipy.align.cpd.</span></span><span class="sig-name descname"><span class="pre">lowrankQS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_eig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eig_fgt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.cpd.lowrankQS" title="Link to this definition">#</a></dt>
<dd><p>Calculate eigenvectors and eigenvalues of gaussian matrix G.</p>
<p>!!!
This function is a placeholder for implementing the fast
gauss transform. It is not yet implemented.
!!!</p>
<section id="id37">
<h4>Parameters<a class="headerlink" href="#id37" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>G: numpy array</dt><dd><p>Gaussian kernel matrix.</p>
</dd>
<dt>beta: float</dt><dd><p>Width of the Gaussian kernel.</p>
</dd>
<dt>num_eig: int</dt><dd><p>Number of eigenvectors to use in lowrank calculation of G</p>
</dd>
<dt>eig_fgt: bool</dt><dd><p>If True, use fast gauss transform method to speed up.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="compute-cc-backward-step-2d">
<h3>compute_cc_backward_step_2d<a class="headerlink" href="#compute-cc-backward-step-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.crosscorr.compute_cc_backward_step_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.crosscorr.</span></span><span class="sig-name descname"><span class="pre">compute_cc_backward_step_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad_moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.crosscorr.compute_cc_backward_step_2d" title="Link to this definition">#</a></dt>
<dd><p>Gradient of the CC Metric w.r.t. the backward transformation</p>
<p>Computes the gradient of the Cross Correlation metric for symmetric
registration (SyN) <span id="id38">[Avants2008]</span> w.r.t. the displacement associated to
the static image (‘forward’ step) as in <a class="reference internal" href="../examples_built/segmentation/tissue_classification.html#avants2011" id="id39"><span>[Avants2011]</span></a></p>
<section id="id40">
<h4>Parameters<a class="headerlink" href="#id40" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>grad_moving<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt>factors<span class="classifier">array, shape (R, C, 5)</span></dt><dd><p>the precomputed cross correlation terms obtained via
precompute_cc_factors_2d</p>
</dd>
</dl>
</section>
<section id="id41">
<h4>Returns<a class="headerlink" href="#id41" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the gradient of the cross correlation metric with respect to the
displacement associated to the static image</p>
</dd>
</dl>
<p>energy : the cross correlation energy (data term) at this iteration</p>
</section>
<section id="id42">
<h4>References<a class="headerlink" href="#id42" title="Link to this heading">#</a></h4>
</section>
</dd></dl>

</section>
<section id="compute-cc-backward-step-3d">
<h3>compute_cc_backward_step_3d<a class="headerlink" href="#compute-cc-backward-step-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.crosscorr.compute_cc_backward_step_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.crosscorr.</span></span><span class="sig-name descname"><span class="pre">compute_cc_backward_step_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad_moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.crosscorr.compute_cc_backward_step_3d" title="Link to this definition">#</a></dt>
<dd><p>Gradient of the CC Metric w.r.t. the backward transformation</p>
<p>Computes the gradient of the Cross Correlation metric for symmetric
registration (SyN) <span id="id43">[Avants08]</span> w.r.t. the displacement associated to
the static volume (‘backward’ step) as in <a class="reference internal" href="../interfaces/registration_flow.html#avants11" id="id44"><span>[Avants11]</span></a></p>
<section id="id45">
<h4>Parameters<a class="headerlink" href="#id45" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>grad_moving<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the moving volume</p>
</dd>
<dt>factors<span class="classifier">array, shape (S, R, C, 5)</span></dt><dd><p>the precomputed cross correlation terms obtained via
precompute_cc_factors_3d</p>
</dd>
<dt>radius<span class="classifier">int</span></dt><dd><p>the radius of the neighborhood used for the CC metric when
computing the factors. The returned vector field will be
zero along a boundary of width radius voxels.</p>
</dd>
</dl>
</section>
<section id="id46">
<h4>Returns<a class="headerlink" href="#id46" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the cross correlation metric with respect to the
displacement associated to the static volume</p>
</dd>
</dl>
<p>energy : the cross correlation energy (data term) at this iteration</p>
</section>
<section id="id47">
<h4>References<a class="headerlink" href="#id47" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt><span id="id48">[Avants08]</span> Avants, B. B., Epstein, C. L., Grossman, M., &amp; Gee, J. C. (2008)</dt><dd><p>Symmetric Diffeomorphic Image Registration with
Cross-Correlation: Evaluating Automated Labeling of Elderly and
Neurodegenerative Brain, Med Image Anal. 12(1), 26-41.</p>
</dd>
<dt><a class="reference internal" href="../interfaces/registration_flow.html#avants11" id="id49"><span>[Avants11]</span></a> Avants, B. B., Tustison, N., &amp; Song, G. (2011).</dt><dd><p>Advanced Normalization Tools (ANTS), 1-35.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="compute-cc-forward-step-2d">
<h3>compute_cc_forward_step_2d<a class="headerlink" href="#compute-cc-forward-step-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.crosscorr.compute_cc_forward_step_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.crosscorr.</span></span><span class="sig-name descname"><span class="pre">compute_cc_forward_step_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad_static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.crosscorr.compute_cc_forward_step_2d" title="Link to this definition">#</a></dt>
<dd><p>Gradient of the CC Metric w.r.t. the forward transformation</p>
<p>Computes the gradient of the Cross Correlation metric for symmetric
registration (SyN) <span id="id50">[Avants2008]</span> w.r.t. the displacement associated to
the moving image (‘backward’ step) as in <a class="reference internal" href="../examples_built/segmentation/tissue_classification.html#avants2011" id="id51"><span>[Avants2011]</span></a></p>
<section id="id52">
<h4>Parameters<a class="headerlink" href="#id52" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>grad_static<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the gradient of the static image</p>
</dd>
<dt>factors<span class="classifier">array, shape (R, C, 5)</span></dt><dd><p>the precomputed cross correlation terms obtained via
precompute_cc_factors_2d</p>
</dd>
</dl>
</section>
<section id="id53">
<h4>Returns<a class="headerlink" href="#id53" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the gradient of the cross correlation metric with respect to the
displacement associated to the moving image</p>
</dd>
</dl>
<p>energy : the cross correlation energy (data term) at this iteration</p>
</section>
<section id="id54">
<h4>Notes<a class="headerlink" href="#id54" title="Link to this heading">#</a></h4>
<p>Currently, the gradient of the static image is not being used, but some
authors suggest that symmetrizing the gradient by including both, the
moving and static gradients may improve the registration quality. We are
leaving this parameter as a placeholder for future investigation</p>
</section>
<section id="id55">
<h4>References<a class="headerlink" href="#id55" title="Link to this heading">#</a></h4>
</section>
</dd></dl>

</section>
<section id="compute-cc-forward-step-3d">
<h3>compute_cc_forward_step_3d<a class="headerlink" href="#compute-cc-forward-step-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.crosscorr.compute_cc_forward_step_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.crosscorr.</span></span><span class="sig-name descname"><span class="pre">compute_cc_forward_step_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad_static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.crosscorr.compute_cc_forward_step_3d" title="Link to this definition">#</a></dt>
<dd><p>Gradient of the CC Metric w.r.t. the forward transformation</p>
<p>Computes the gradient of the Cross Correlation metric for symmetric
registration (SyN) <span id="id56">[Avants2008]</span> w.r.t. the displacement associated to
the moving volume (‘forward’ step) as in <a class="reference internal" href="../examples_built/segmentation/tissue_classification.html#avants2011" id="id57"><span>[Avants2011]</span></a></p>
<section id="id58">
<h4>Parameters<a class="headerlink" href="#id58" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>grad_static<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the static volume</p>
</dd>
<dt>factors<span class="classifier">array, shape (S, R, C, 5)</span></dt><dd><p>the precomputed cross correlation terms obtained via
precompute_cc_factors_3d</p>
</dd>
<dt>radius<span class="classifier">int</span></dt><dd><p>the radius of the neighborhood used for the CC metric when
computing the factors. The returned vector field will be
zero along a boundary of width radius voxels.</p>
</dd>
</dl>
</section>
<section id="id59">
<h4>Returns<a class="headerlink" href="#id59" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the cross correlation metric with respect to the
displacement associated to the moving volume</p>
</dd>
</dl>
<p>energy : the cross correlation energy (data term) at this iteration</p>
</section>
<section id="id60">
<h4>References<a class="headerlink" href="#id60" title="Link to this heading">#</a></h4>
</section>
</dd></dl>

</section>
<section id="precompute-cc-factors-2d">
<h3>precompute_cc_factors_2d<a class="headerlink" href="#precompute-cc-factors-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.crosscorr.precompute_cc_factors_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.crosscorr.</span></span><span class="sig-name descname"><span class="pre">precompute_cc_factors_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.crosscorr.precompute_cc_factors_2d" title="Link to this definition">#</a></dt>
<dd><p>Precomputations to quickly compute the gradient of the CC Metric</p>
<p>Pre-computes the separate terms of the cross correlation metric
<span id="id61">[Avants2008]</span> and image norms at each voxel considering a neighborhood of
the given radius to efficiently <a class="reference internal" href="../examples_built/segmentation/tissue_classification.html#avants2011" id="id62"><span>[Avants2011]</span></a> compute the gradient of the
metric with respect to the deformation field.</p>
<section id="id63">
<h4>Parameters<a class="headerlink" href="#id63" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">array, shape (R, C)</span></dt><dd><p>the static volume, which also defines the reference registration domain</p>
</dd>
<dt>moving<span class="classifier">array, shape (R, C)</span></dt><dd><p>the moving volume (notice that both images must already be in a common
reference domain, i.e. the same R, C)</p>
</dd>
</dl>
<p>radius : the radius of the neighborhood(square of (2*radius + 1)^2 voxels)</p>
</section>
<section id="id64">
<h4>Returns<a class="headerlink" href="#id64" title="Link to this heading">#</a></h4>
<dl>
<dt>factors<span class="classifier">array, shape (R, C, 5)</span></dt><dd><p>the precomputed cross correlation terms:
factors[:,:,0] : static minus its mean value along the neighborhood
factors[:,:,1] : moving minus its mean value along the neighborhood
factors[:,:,2] : sum of the pointwise products of static and moving</p>
<blockquote>
<div><p>along the neighborhood</p>
</div></blockquote>
<p>factors[:,:,3] : sum of sq. values of static along the neighborhood
factors[:,:,4] : sum of sq. values of moving along the neighborhood</p>
</dd>
</dl>
</section>
<section id="id65">
<h4>References<a class="headerlink" href="#id65" title="Link to this heading">#</a></h4>
</section>
</dd></dl>

</section>
<section id="precompute-cc-factors-2d-test">
<h3>precompute_cc_factors_2d_test<a class="headerlink" href="#precompute-cc-factors-2d-test" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.crosscorr.precompute_cc_factors_2d_test">
<span class="sig-prename descclassname"><span class="pre">dipy.align.crosscorr.</span></span><span class="sig-name descname"><span class="pre">precompute_cc_factors_2d_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.crosscorr.precompute_cc_factors_2d_test" title="Link to this definition">#</a></dt>
<dd><p>Precomputations to quickly compute the gradient of the CC Metric</p>
<p>This version of precompute_cc_factors_2d is for testing purposes, it
directly computes the local cross-correlation without any optimization.</p>
</dd></dl>

</section>
<section id="precompute-cc-factors-3d">
<h3>precompute_cc_factors_3d<a class="headerlink" href="#precompute-cc-factors-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.crosscorr.precompute_cc_factors_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.crosscorr.</span></span><span class="sig-name descname"><span class="pre">precompute_cc_factors_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.crosscorr.precompute_cc_factors_3d" title="Link to this definition">#</a></dt>
<dd><p>Precomputations to quickly compute the gradient of the CC Metric</p>
<p>Pre-computes the separate terms of the cross correlation metric and image
norms at each voxel considering a neighborhood of the given radius to
efficiently compute the gradient of the metric with respect to the
deformation field <span id="id66">[Ocegueda2016]</span> <span id="id67">[Avants2008]</span> <a class="reference internal" href="../examples_built/segmentation/tissue_classification.html#avants2011" id="id68"><span>[Avants2011]</span></a>.</p>
<section id="id69">
<h4>Parameters<a class="headerlink" href="#id69" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the static volume, which also defines the reference registration domain</p>
</dd>
<dt>moving<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the moving volume (notice that both images must already be in a common
reference domain, i.e. the same S, R, C)</p>
</dd>
</dl>
<p>radius : the radius of the neighborhood (cube of (2 * radius + 1)^3 voxels)</p>
</section>
<section id="id70">
<h4>Returns<a class="headerlink" href="#id70" title="Link to this heading">#</a></h4>
<dl>
<dt>factors<span class="classifier">array, shape (S, R, C, 5)</span></dt><dd><p>the precomputed cross correlation terms:
factors[:,:,:,0] : static minus its mean value along the neighborhood
factors[:,:,:,1] : moving minus its mean value along the neighborhood
factors[:,:,:,2] : sum of the pointwise products of static and moving</p>
<blockquote>
<div><p>along the neighborhood</p>
</div></blockquote>
<p>factors[:,:,:,3] : sum of sq. values of static along the neighborhood
factors[:,:,:,4] : sum of sq. values of moving along the neighborhood</p>
</dd>
</dl>
</section>
<section id="id71">
<h4>References<a class="headerlink" href="#id71" title="Link to this heading">#</a></h4>
</section>
</dd></dl>

</section>
<section id="precompute-cc-factors-3d-test">
<h3>precompute_cc_factors_3d_test<a class="headerlink" href="#precompute-cc-factors-3d-test" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.crosscorr.precompute_cc_factors_3d_test">
<span class="sig-prename descclassname"><span class="pre">dipy.align.crosscorr.</span></span><span class="sig-name descname"><span class="pre">precompute_cc_factors_3d_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.crosscorr.precompute_cc_factors_3d_test" title="Link to this definition">#</a></dt>
<dd><p>Precomputations to quickly compute the gradient of the CC Metric</p>
<p>This version of precompute_cc_factors_3d is for testing purposes, it
directly computes the local cross-correlation factors without any
optimization, so it is less error-prone than the accelerated version.</p>
</dd></dl>

</section>
<section id="compute-em-demons-step-2d">
<h3>compute_em_demons_step_2d<a class="headerlink" href="#compute-em-demons-step-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.expectmax.compute_em_demons_step_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.expectmax.</span></span><span class="sig-name descname"><span class="pre">compute_em_demons_step_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.expectmax.compute_em_demons_step_2d" title="Link to this definition">#</a></dt>
<dd><p>Demons step for EM metric in 2D

Computes the demons step [Vercauteren09] for SSD-driven registration
( eq. 4 in [Vercauteren09] ) using the EM algorithm [Arce14] to handle
multi-modality images.

In this case, <span class="math notranslate nohighlight">\(\sigma_i\)</span> in eq. 4 of [Vercauteren] is estimated using the EM
algorithm, while in the original version of diffeomorphic demons it is
estimated by the difference between the image values at each pixel.

Parameters
———-
delta_field : array, shape (R, C)
    contains, at each pixel, the difference between the moving image (warped
    under the current deformation s(. , .) ) J and the static image I:
    delta_field[i,j] = J(s(i,j)) - I(i,j). The order is important, changing
    to delta_field[i,j] = I(i,j) - J(s(i,j)) yields the backward demons step
    warping the static image towards the moving, which may not be the
    intended behavior unless the ‘gradient_moving’ passed corresponds to
    the gradient of the static image
sigma_sq_field : array, shape (R, C)
    contains, at each pixel (i, j), the estimated variance (not std) of the
    hidden variable associated to the intensity at static[i,j] (which must
    have been previously quantized)
gradient_moving : array, shape (R, C, 2)
    the gradient of the moving image
sigma_sq_x : float
    parameter controlling the amount of regularization. It corresponds to
    <span class="math notranslate nohighlight">\(\sigma_x^2\)</span> in algorithm 1 of Vercauteren et al.[2]
out : array, shape (R, C, 2)
    the resulting demons step will be written to this array

Returns
——-
demons_step : array, shape (R, C, 2)
    the demons step to be applied for updating the current displacement
    field
energy : float
    the current em energy (before applying the returned demons_step)

References
———-
[Arce14] Arce-santana, E., Campos-delgado, D. U., &amp; Vigueras-g, F. (2014).
         Non-rigid Multimodal Image Registration Based on the
         Expectation-Maximization Algorithm, (168140), 36-47.

[Vercauteren09] Vercauteren, T., Pennec, X., Perchant, A., &amp; Ayache, N.
                (2009). Diffeomorphic demons: efficient non-parametric
                image registration. NeuroImage, 45(1 Suppl), S61-72.
                doi:10.1016/j.neuroimage.2008.10.040</p>
</dd></dl>

</section>
<section id="compute-em-demons-step-3d">
<h3>compute_em_demons_step_3d<a class="headerlink" href="#compute-em-demons-step-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.expectmax.compute_em_demons_step_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.expectmax.</span></span><span class="sig-name descname"><span class="pre">compute_em_demons_step_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.expectmax.compute_em_demons_step_3d" title="Link to this definition">#</a></dt>
<dd><p>Demons step for EM metric in 3D

Computes the demons step [Vercauteren09] for SSD-driven registration
( eq. 4 in [Vercauteren09] ) using the EM algorithm [Arce14] to handle
multi-modality images.

In this case, <span class="math notranslate nohighlight">\(\sigma_i\)</span> in eq. 4 of [Vercauteren09] is estimated using
the EM algorithm, while in the original version of diffeomorphic demons
it is estimated by the difference between the image values at each pixel.

Parameters
———-
delta_field : array, shape (S, R, C)
    contains, at each pixel, the difference between the moving image (warped
    under the current deformation s ) J and the static image I:
    delta_field[k,i,j] = J(s(k,i,j)) - I(k,i,j). The order is important,
    changing to delta_field[k,i,j] = I(k,i,j) - J(s(k,i,j)) yields the
    backward demons step warping the static image towards the moving, which
    may not be the intended behavior unless the ‘gradient_moving’ passed
    corresponds to the gradient of the static image
sigma_sq_field : array, shape (S, R, C)
    contains, at each pixel (k, i, j), the estimated variance (not std) of
    the hidden variable associated to the intensity at static[k,i,j] (which
    must have been previously quantized)
gradient_moving : array, shape (S, R, C, 2)
    the gradient of the moving image
sigma_sq_x : float
    parameter controlling the amount of regularization. It corresponds to
    <span class="math notranslate nohighlight">\(\sigma_x^2\)</span> in algorithm 1 of Vercauteren et al.[2].
out : array, shape (S, R, C, 2)
    the resulting demons step will be written to this array

Returns
——-
demons_step : array, shape (S, R, C, 3)
    the demons step to be applied for updating the current displacement
    field
energy : float
    the current em energy (before applying the returned demons_step)

References
———-
[Arce14] Arce-santana, E., Campos-delgado, D. U., &amp; Vigueras-g, F. (2014).
         Non-rigid Multimodal Image Registration Based on the
         Expectation-Maximization Algorithm, (168140), 36-47.

[Vercauteren09] Vercauteren, T., Pennec, X., Perchant, A., &amp; Ayache, N.
                (2009). Diffeomorphic demons: efficient non-parametric
                image registration. NeuroImage, 45(1 Suppl), S61-72.
                doi:10.1016/j.neuroimage.2008.10.040</p>
</dd></dl>

</section>
<section id="compute-masked-class-stats-2d">
<h3>compute_masked_class_stats_2d<a class="headerlink" href="#compute-masked-class-stats-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.expectmax.compute_masked_class_stats_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.expectmax.</span></span><span class="sig-name descname"><span class="pre">compute_masked_class_stats_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.expectmax.compute_masked_class_stats_2d" title="Link to this definition">#</a></dt>
<dd><p>Computes the mean and std. for each quantization level.</p>
<p>Computes the mean and standard deviation of the intensities in ‘v’ for
each corresponding label in ‘labels’. In other words, for each label
L, it computes the mean and standard deviation of the intensities in ‘v’
at pixels whose label in ‘labels’ is L. This is used by the EM metric
to compute statistics for each hidden variable represented by the labels.</p>
<section id="id72">
<h4>Parameters<a class="headerlink" href="#id72" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>mask<span class="classifier">array, shape (R, C)</span></dt><dd><p>the mask of pixels that will be taken into account for computing the
statistics. All zero pixels in mask will be ignored</p>
</dd>
<dt>v<span class="classifier">array, shape (R, C)</span></dt><dd><p>the image which the statistics will be computed from</p>
</dd>
<dt>num_labels<span class="classifier">int</span></dt><dd><p>the number of different labels in ‘labels’ (equal to the
number of hidden variables in the EM metric)</p>
</dd>
<dt>labels<span class="classifier">array, shape (R, C)</span></dt><dd><p>the label assigned to each pixel</p>
</dd>
</dl>
</section>
<section id="id73">
<h4>Returns<a class="headerlink" href="#id73" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>means<span class="classifier">array, shape (num_labels,)</span></dt><dd><p>means[i], 0&lt;=i&lt;num_labels will be the mean intensity in v of all
voxels labeled i, or 0 if no voxels are labeled i</p>
</dd>
<dt>variances<span class="classifier">array, shape (num_labels,)</span></dt><dd><p>variances[i], 0&lt;=i&lt;num_labels will be the standard deviation of the
intensities in v of all voxels labeled i, or infinite if less than 2
voxels are labeled i.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="compute-masked-class-stats-3d">
<h3>compute_masked_class_stats_3d<a class="headerlink" href="#compute-masked-class-stats-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.expectmax.compute_masked_class_stats_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.expectmax.</span></span><span class="sig-name descname"><span class="pre">compute_masked_class_stats_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.expectmax.compute_masked_class_stats_3d" title="Link to this definition">#</a></dt>
<dd><p>Computes the mean and std. for each quantization level.</p>
<p>Computes the mean and standard deviation of the intensities in ‘v’ for
each corresponding label in ‘labels’. In other words, for each label
L, it computes the mean and standard deviation of the intensities in ‘v’
at voxels whose label in ‘labels’ is L. This is used by the EM metric
to compute statistics for each hidden variable represented by the labels.</p>
<section id="id74">
<h4>Parameters<a class="headerlink" href="#id74" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>mask<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the mask of voxels that will be taken into account for computing the
statistics. All zero voxels in mask will be ignored</p>
</dd>
<dt>v<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the volume which the statistics will be computed from</p>
</dd>
<dt>num_labels<span class="classifier">int</span></dt><dd><p>the number of different labels in ‘labels’ (equal to the
number of hidden variables in the EM metric)</p>
</dd>
<dt>labels<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the label assigned to each pixel</p>
</dd>
</dl>
</section>
<section id="id75">
<h4>Returns<a class="headerlink" href="#id75" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>means<span class="classifier">array, shape (num_labels,)</span></dt><dd><p>means[i], 0&lt;=i&lt;num_labels will be the mean intensity in v of all
voxels labeled i, or 0 if no voxels are labeled i</p>
</dd>
<dt>variances<span class="classifier">array, shape (num_labels,)</span></dt><dd><p>variances[i], 0&lt;=i&lt;num_labels will be the standard deviation of the
intensities in v of all voxels labeled i, or infinite if less than 2
voxels are labeled i.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="quantize-positive-2d">
<h3>quantize_positive_2d<a class="headerlink" href="#quantize-positive-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.expectmax.quantize_positive_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.expectmax.</span></span><span class="sig-name descname"><span class="pre">quantize_positive_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.expectmax.quantize_positive_2d" title="Link to this definition">#</a></dt>
<dd><p>Quantizes a 2D image to num_levels quantization levels</p>
<p>Quantizes the input image at num_levels intensity levels considering &lt;=0
as a special value. Those input pixels &lt;=0, and only those, will be
assigned a quantization level of 0. The positive values are divided into
the remaining num_levels-1 uniform quantization levels.</p>
<p>The following are undefined, and raise a ValueError:
* Quantizing at zero levels because at least one level must be assigned
* Quantizing at one level because positive values should be assigned a</p>
<blockquote>
<div><p>level different from the secial level 0 (at least 2 levels are needed)</p>
</div></blockquote>
<section id="id76">
<h4>Parameters<a class="headerlink" href="#id76" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>v<span class="classifier">array, shape (R, C)</span></dt><dd><p>the image to be quantized</p>
</dd>
<dt>num_levels<span class="classifier">int</span></dt><dd><p>the number of levels</p>
</dd>
</dl>
</section>
<section id="id77">
<h4>Returns<a class="headerlink" href="#id77" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (R, C), same shape as v</span></dt><dd><p>the quantized image</p>
</dd>
<dt>levels: array, shape (num_levels,)</dt><dd><p>the quantization values: levels[0]=0, and levels[i] is the mid-point
of the interval of intensities that are assigned to quantization
level i, i=1, …, num_levels-1.</p>
</dd>
<dt>hist: array, shape (num_levels,)</dt><dd><p>histogram: the number of pixels that were assigned to each quantization
level</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="quantize-positive-3d">
<h3>quantize_positive_3d<a class="headerlink" href="#quantize-positive-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.expectmax.quantize_positive_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.expectmax.</span></span><span class="sig-name descname"><span class="pre">quantize_positive_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.expectmax.quantize_positive_3d" title="Link to this definition">#</a></dt>
<dd><p>Quantizes a 3D volume to num_levels quantization levels</p>
<p>Quantizes the input volume at num_levels intensity levels considering &lt;=0
as a special value. Those input voxels &lt;=0, and only those, will be
assigned a quantization level of 0. The positive values are divided into
the remaining num_levels-1 uniform quantization levels.</p>
<p>The following are undefined, and raise a ValueError:
* Quantizing at zero levels because at least one level must be assigned
* Quantizing at one level because positive values should be assigned a</p>
<blockquote>
<div><p>level different from the secial level 0 (at least 2 levels are needed)</p>
</div></blockquote>
<section id="id78">
<h4>Parameters<a class="headerlink" href="#id78" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>v<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the volume to be quantized</p>
</dd>
<dt>num_levels<span class="classifier">int</span></dt><dd><p>the number of levels</p>
</dd>
</dl>
</section>
<section id="id79">
<h4>Returns<a class="headerlink" href="#id79" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (S, R, C), same shape as v</span></dt><dd><p>the quantized volume</p>
</dd>
<dt>levels: array, shape (num_levels,)</dt><dd><p>the quantization values: levels[0]=0, and levels[i] is the mid-point
of the interval of intensities that are assigned to quantization
level i, i=1, …, num_levels-1.</p>
</dd>
<dt>hist: array, shape (num_levels,)</dt><dd><p>histogram: the number of voxels that were assigned to each quantization
level</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="affineinversionerror">
<h3><a class="reference internal" href="#dipy.align.imaffine.AffineInversionError" title="dipy.align.imaffine.AffineInversionError"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineInversionError</span></code></a><a class="headerlink" href="#affineinversionerror" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineInversionError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.imaffine.</span></span><span class="sig-name descname"><span class="pre">AffineInversionError</span></span><a class="headerlink" href="#dipy.align.imaffine.AffineInversionError" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineInversionError.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineInversionError.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="affineinvalidvalueserror">
<h3><a class="reference internal" href="#dipy.align.imaffine.AffineInvalidValuesError" title="dipy.align.imaffine.AffineInvalidValuesError"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineInvalidValuesError</span></code></a><a class="headerlink" href="#affineinvalidvalueserror" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineInvalidValuesError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.imaffine.</span></span><span class="sig-name descname"><span class="pre">AffineInvalidValuesError</span></span><a class="headerlink" href="#dipy.align.imaffine.AffineInvalidValuesError" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineInvalidValuesError.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineInvalidValuesError.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="affinemap">
<h3><a class="reference internal" href="#dipy.align.imaffine.AffineMap" title="dipy.align.imaffine.AffineMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineMap</span></code></a><a class="headerlink" href="#affinemap" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.imaffine.</span></span><span class="sig-name descname"><span class="pre">AffineMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">affine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_grid_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain_grid_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineMap.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">affine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_grid_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain_grid_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.__init__" title="Link to this definition">#</a></dt>
<dd><p>AffineMap.</p>
<p>Implements an affine transformation whose domain is given by
<cite>domain_grid</cite> and <cite>domain_grid2world</cite>, and whose co-domain is
given by <cite>codomain_grid</cite> and <cite>codomain_grid2world</cite>.</p>
<p>The actual transform is represented by the <cite>affine</cite> matrix, which
operate in world coordinates. Therefore, to transform a moving image
towards a static image, we first map each voxel (i,j,k) of the static
image to world coordinates (x,y,z) by applying <cite>domain_grid2world</cite>.
Then we apply the <cite>affine</cite> transform to (x,y,z) obtaining (x’, y’, z’)
in moving image’s world coordinates. Finally, (x’, y’, z’) is mapped
to voxel coordinates (i’, j’, k’) in the moving image by multiplying
(x’, y’, z’) by the inverse of <cite>codomain_grid2world</cite>. The
<cite>codomain_grid_shape</cite> is used analogously to transform the static
image towards the moving image when calling <cite>transform_inverse</cite>.</p>
<p>If the domain/co-domain information is not provided (None) then the
sampling information needs to be specified each time the <cite>transform</cite>
or <cite>transform_inverse</cite> is called to transform images. Note that such
sampling information is not necessary to transform points defined in
physical space, such as stream lines.</p>
<section id="id80">
<h4>Parameters<a class="headerlink" href="#id80" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>affine<span class="classifier">array, shape (dim + 1, dim + 1)</span></dt><dd><p>the matrix defining the affine transform, where <cite>dim</cite> is the
dimension of the space this map operates in (2 for 2D images,
3 for 3D images). If None, then <cite>self</cite> represents the identity
transformation.</p>
</dd>
<dt>domain_grid_shape<span class="classifier">sequence, shape (dim,), optional</span></dt><dd><p>the shape of the default domain sampling grid. When <cite>transform</cite>
is called to transform an image, the resulting image will have
this shape, unless a different sampling information is provided.
If None, then the sampling grid shape must be specified each time
the <cite>transform</cite> method is called.</p>
</dd>
<dt>domain_grid2world<span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with the domain grid.
If None (the default), then the grid-to-world transform is assumed
to be the identity.</p>
</dd>
<dt>codomain_grid_shape<span class="classifier">sequence of integers, shape (dim,)</span></dt><dd><p>the shape of the default co-domain sampling grid. When
<cite>transform_inverse</cite> is called to transform an image, the resulting
image will have this shape, unless a different sampling
information is provided. If None (the default), then the sampling
grid shape must be specified each time the <cite>transform_inverse</cite>
method is called.</p>
</dd>
<dt>codomain_grid2world<span class="classifier">array, shape (dim + 1, dim + 1)</span></dt><dd><p>the grid-to-world transform associated with the co-domain grid.
If None (the default), then the grid-to-world transform is assumed
to be the identity.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineMap.get_affine">
<span class="sig-name descname"><span class="pre">get_affine</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.get_affine" title="Link to this definition">#</a></dt>
<dd><p>Return the value of the transformation, not a reference.</p>
<section id="id81">
<h4>Returns<a class="headerlink" href="#id81" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>affine<span class="classifier">ndarray</span></dt><dd><p>Copy of the transform, not a reference.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineMap.set_affine">
<span class="sig-name descname"><span class="pre">set_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">affine</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.set_affine" title="Link to this definition">#</a></dt>
<dd><p>Set the affine transform (operating in physical space).</p>
<p>Also sets <cite>self.affine_inv</cite> - the inverse of <cite>affine</cite>, or None if
there is no inverse.</p>
<section id="id82">
<h4>Parameters<a class="headerlink" href="#id82" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>affine<span class="classifier">array, shape (dim + 1, dim + 1)</span></dt><dd><p>the matrix representing the affine transform operating in
physical space. The domain and co-domain information
remains unchanged. If None, then <cite>self</cite> represents the identity
transformation.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineMap.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_grid_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.transform" title="Link to this definition">#</a></dt>
<dd><p>Transform the input image from co-domain to domain space.</p>
<p>By default, the transformed image is sampled at a grid defined by
<cite>self.domain_shape</cite> and <cite>self.domain_grid2world</cite>. If such
information was not provided then <cite>sampling_grid_shape</cite> is mandatory.</p>
<section id="id83">
<h4>Parameters<a class="headerlink" href="#id83" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>image<span class="classifier">2D or 3D array</span></dt><dd><p>the image to be transformed</p>
</dd>
<dt>interpolation<span class="classifier">string, either ‘linear’ or ‘nearest’</span></dt><dd><p>the type of interpolation to be used, either ‘linear’
(for k-linear interpolation) or ‘nearest’ for nearest neighbor</p>
</dd>
<dt>image_grid2world<span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with <cite>image</cite>.
If None (the default), then the grid-to-world transform is assumed
to be the identity.</p>
</dd>
<dt>sampling_grid_shape<span class="classifier">sequence, shape (dim,), optional</span></dt><dd><p>the shape of the grid where the transformed image must be sampled.
If None (the default), then <cite>self.codomain_shape</cite> is used instead
(which must have been set at initialization, otherwise an exception
will be raised).</p>
</dd>
<dt>sampling_grid2world<span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with the sampling grid
(specified by <cite>sampling_grid_shape</cite>, or by default
<cite>self.codomain_shape</cite>). If None (the default), then the
grid-to-world transform is assumed to be the identity.</p>
</dd>
<dt>resample_only<span class="classifier">Boolean, optional</span></dt><dd><p>If False (the default) the affine transform is applied normally.
If True, then the affine transform is not applied, and the input
image is just re-sampled on the domain grid of this transform.</p>
</dd>
</dl>
</section>
<section id="id84">
<h4>Returns<a class="headerlink" href="#id84" title="Link to this heading">#</a></h4>
<dl>
<dt>transformed<span class="classifier">array, shape <cite>sampling_grid_shape</cite> or</span></dt><dd><blockquote>
<div><p><cite>self.codomain_shape</cite></p>
</div></blockquote>
<p>the transformed image, sampled at the requested grid</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineMap.transform_inverse">
<span class="sig-name descname"><span class="pre">transform_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_grid_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.transform_inverse" title="Link to this definition">#</a></dt>
<dd><p>Transform the input image from domain to co-domain space.</p>
<p>By default, the transformed image is sampled at a grid defined by
<cite>self.codomain_shape</cite> and <cite>self.codomain_grid2world</cite>. If such
information was not provided then <cite>sampling_grid_shape</cite> is mandatory.</p>
<section id="id85">
<h4>Parameters<a class="headerlink" href="#id85" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>image<span class="classifier">2D or 3D array</span></dt><dd><p>the image to be transformed</p>
</dd>
<dt>interpolation<span class="classifier">string, either ‘linear’ or ‘nearest’</span></dt><dd><p>the type of interpolation to be used, either ‘linear’
(for k-linear interpolation) or ‘nearest’ for nearest neighbor</p>
</dd>
<dt>image_grid2world<span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with <cite>image</cite>.
If None (the default), then the grid-to-world transform is assumed
to be the identity.</p>
</dd>
<dt>sampling_grid_shape<span class="classifier">sequence, shape (dim,), optional</span></dt><dd><p>the shape of the grid where the transformed image must be sampled.
If None (the default), then <cite>self.codomain_shape</cite> is used instead
(which must have been set at initialization, otherwise an exception
will be raised).</p>
</dd>
<dt>sampling_grid2world<span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with the sampling grid
(specified by <cite>sampling_grid_shape</cite>, or by default
<cite>self.codomain_shape</cite>). If None (the default), then the
grid-to-world transform is assumed to be the identity.</p>
</dd>
<dt>resample_only<span class="classifier">Boolean, optional</span></dt><dd><p>If False (the default) the affine transform is applied normally.
If True, then the affine transform is not applied, and the input
image is just re-sampled on the domain grid of this transform.</p>
</dd>
</dl>
</section>
<section id="id86">
<h4>Returns<a class="headerlink" href="#id86" title="Link to this heading">#</a></h4>
<dl>
<dt>transformed<span class="classifier">array, shape <cite>sampling_grid_shape</cite> or</span></dt><dd><blockquote>
<div><p><cite>self.codomain_shape</cite></p>
</div></blockquote>
<p>the transformed image, sampled at the requested grid</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="mutualinformationmetric">
<h3><a class="reference internal" href="#dipy.align.imaffine.MutualInformationMetric" title="dipy.align.imaffine.MutualInformationMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutualInformationMetric</span></code></a><a class="headerlink" href="#mutualinformationmetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.imaffine.MutualInformationMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.imaffine.</span></span><span class="sig-name descname"><span class="pre">MutualInformationMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_proportion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.MutualInformationMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_proportion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>Initialize an instance of the Mutual Information metric.</p>
<p>This class implements the methods required by Optimizer to drive the
registration process.</p>
<section id="id87">
<h4>Parameters<a class="headerlink" href="#id87" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>nbins<span class="classifier">int, optional</span></dt><dd><p>the number of bins to be used for computing the intensity
histograms. The default is 32.</p>
</dd>
<dt>sampling_proportion<span class="classifier">None or float in interval (0, 1], optional</span></dt><dd><p>There are two types of sampling: dense and sparse. Dense sampling
uses all voxels for estimating the (joint and marginal) intensity
histograms, while sparse sampling uses a subset of them. If
<cite>sampling_proportion</cite> is None, then dense sampling is
used. If <cite>sampling_proportion</cite> is a floating point value in (0,1]
then sparse sampling is used, where <cite>sampling_proportion</cite>
specifies the proportion of voxels to be used. The default is
None.</p>
</dd>
</dl>
</section>
<section id="id88">
<h4>Notes<a class="headerlink" href="#id88" title="Link to this heading">#</a></h4>
<p>Since we use linear interpolation, images are not, in general,
differentiable at exact voxel coordinates, but they are differentiable
between voxel coordinates. When using sparse sampling, selected voxels
are slightly moved by adding a small random displacement within one
voxel to prevent sampling points from being located exactly at voxel
coordinates. When using dense sampling, this random displacement is
not applied.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.MutualInformationMetric.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.distance" title="Link to this definition">#</a></dt>
<dd><p>Numeric value of the negative Mutual Information.</p>
<p>We need to change the sign so we can use standard minimization
algorithms.</p>
<section id="id89">
<h4>Parameters<a class="headerlink" href="#id89" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">array, shape (n,)</span></dt><dd><p>the parameter vector of the transform currently used by the metric
(the transform name is provided when self.setup is called), n is
the number of parameters of the transform</p>
</dd>
</dl>
</section>
<section id="id90">
<h4>Returns<a class="headerlink" href="#id90" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>neg_mi<span class="classifier">float</span></dt><dd><p>the negative mutual information of the input images after
transforming the moving image by the currently set transform
with <cite>params</cite> parameters</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.MutualInformationMetric.distance_and_gradient">
<span class="sig-name descname"><span class="pre">distance_and_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.distance_and_gradient" title="Link to this definition">#</a></dt>
<dd><p>Numeric value of the metric and its gradient at given parameters.</p>
<section id="id91">
<h4>Parameters<a class="headerlink" href="#id91" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">array, shape (n,)</span></dt><dd><p>the parameter vector of the transform currently used by the metric
(the transform name is provided when self.setup is called), n is
the number of parameters of the transform</p>
</dd>
</dl>
</section>
<section id="id92">
<h4>Returns<a class="headerlink" href="#id92" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>neg_mi<span class="classifier">float</span></dt><dd><p>the negative mutual information of the input images after
transforming the moving image by the currently set transform
with <cite>params</cite> parameters</p>
</dd>
<dt>neg_mi_grad<span class="classifier">array, shape (n,)</span></dt><dd><p>the gradient of the negative Mutual Information</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.MutualInformationMetric.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.gradient" title="Link to this definition">#</a></dt>
<dd><p>Numeric value of the metric’s gradient at the given parameters.</p>
<section id="id93">
<h4>Parameters<a class="headerlink" href="#id93" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">array, shape (n,)</span></dt><dd><p>the parameter vector of the transform currently used by the metric
(the transform name is provided when self.setup is called), n is
the number of parameters of the transform</p>
</dd>
</dl>
</section>
<section id="id94">
<h4>Returns<a class="headerlink" href="#id94" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>grad<span class="classifier">array, shape (n,)</span></dt><dd><p>the gradient of the negative Mutual Information</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.MutualInformationMetric.setup">
<span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.setup" title="Link to this definition">#</a></dt>
<dd><p>Prepare the metric to compute intensity densities and gradients.</p>
<p>The histograms will be setup to compute probability densities of
intensities within the minimum and maximum values of <cite>static</cite> and
<cite>moving</cite></p>
<section id="id95">
<h4>Parameters<a class="headerlink" href="#id95" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>transform: instance of Transform</dt><dd><p>the transformation with respect to whose parameters the gradient
must be computed</p>
</dd>
<dt>static<span class="classifier">array, shape (S, R, C) or (R, C)</span></dt><dd><p>static image</p>
</dd>
<dt>moving<span class="classifier">array, shape (S’, R’, C’) or (R’, C’)</span></dt><dd><p>moving image. The dimensions of the static (S, R, C) and moving
(S’, R’, C’) images do not need to be the same.</p>
</dd>
<dt>static_grid2world<span class="classifier">array (dim+1, dim+1), optional</span></dt><dd><p>the grid-to-space transform of the static image. The default is
None, implying the transform is the identity.</p>
</dd>
<dt>moving_grid2world<span class="classifier">array (dim+1, dim+1)</span></dt><dd><p>the grid-to-space transform of the moving image. The default is
None, implying the spacing along all axes is 1.</p>
</dd>
<dt>starting_affine<span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>the pre-aligning matrix (an affine transform) that roughly aligns
the moving image towards the static image. If None, no
pre-alignment is performed. If a pre-alignment matrix is available,
it is recommended to provide this matrix as <cite>starting_affine</cite>
instead of manually transforming the moving image to reduce
interpolation artifacts. The default is None, implying no
pre-alignment is performed.</p>
</dd>
<dt>static_mask<span class="classifier">array, shape (S, R, C) or (R, C), optional</span></dt><dd><p>static image mask that defines which pixels in the static image
are used to calculate the mutual information.</p>
</dd>
<dt>moving_mask<span class="classifier">array, shape (S’, R’, C’) or (R’, C’), optional</span></dt><dd><p>moving image mask that defines which pixels in the moving image
are used to calculate the mutual information.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="affineregistration">
<h3><a class="reference internal" href="#dipy.align.imaffine.AffineRegistration" title="dipy.align.imaffine.AffineRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineRegistration</span></code></a><a class="headerlink" href="#affineregistration" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineRegistration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.imaffine.</span></span><span class="sig-name descname"><span class="pre">AffineRegistration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss_sigma_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineRegistration" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineRegistration.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss_sigma_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineRegistration.__init__" title="Link to this definition">#</a></dt>
<dd><p>Initialize an instance of the AffineRegistration class.

Parameters
———-
metric : None or object, optional
    an instance of a metric. The default is None, implying
    the Mutual Information metric with default settings.
level_iters : sequence, optional
    the number of iterations at each scale of the scale space.
    <cite>level_iters[0]</cite> corresponds to the coarsest scale,
    <cite>level_iters[-1]</cite> the finest, where n is the length of the
    sequence. By default, a 3-level scale space with iterations
    sequence equal to [10000, 1000, 100] will be used.
sigmas : sequence of floats, optional
    custom smoothing parameter to build the scale space (one parameter
    for each scale). By default, the sequence of sigmas will be
    [3, 1, 0].
factors : sequence of floats, optional
    custom scale factors to build the scale space (one factor for each
    scale). By default, the sequence of factors will be [4, 2, 1].
method : string, optional
    optimization method to be used. If Scipy version &lt; 0.12, then
    only L-BFGS-B is available. Otherwise, <cite>method</cite> can be any
    gradient-based method available in <cite>dipy.core.Optimize</cite>: CG, BFGS,
    Newton-CG, dogleg or trust-ncg.
    The default is ‘L-BFGS-B’.
ss_sigma_factor : float, optional
    If None, this parameter is not used and an isotropic scale
    space with the given <cite>factors</cite> and <cite>sigmas</cite> will be built.
    If not None, an anisotropic scale space will be used by
    automatically selecting the smoothing sigmas along each axis
    according to the voxel dimensions of the given image.
    The <cite>ss_sigma_factor</cite> is used to scale the automatically computed
    sigmas. For example, in the isotropic case, the sigma of the
    kernel will be <span class="math notranslate nohighlight">\(factor * (2 ^ i)\)</span> where
    <span class="math notranslate nohighlight">\(i = 1, 2, ..., n_scales - 1\)</span> is the scale (the finest resolution
    image <span class="math notranslate nohighlight">\(i=0\)</span> is never smoothed). The default is None.
options : dict, optional
    extra optimization options. The default is None, implying
    no extra options are passed to the optimizer.

verbosity: int (one of {0, 1, 2, 3}), optional
    Set the verbosity level of the algorithm:
    0 : do not print anything
    1 : print information about the current status of the algorithm
    2 : print high level information of the components involved in
        the registration that can be used to detect a failing
        component.
    3 : print as much information as possible to isolate the cause
        of a bug.
    Default: 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineRegistration.docstring_addendum">
<span class="sig-name descname"><span class="pre">docstring_addendum</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'verbosity:</span> <span class="pre">int</span> <span class="pre">(one</span> <span class="pre">of</span> <span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3}),</span> <span class="pre">optional\n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Set</span> <span class="pre">the</span> <span class="pre">verbosity</span> <span class="pre">level</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">algorithm:\n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">0</span> <span class="pre">:</span> <span class="pre">do</span> <span class="pre">not</span> <span class="pre">print</span> <span class="pre">anything\n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">1</span> <span class="pre">:</span> <span class="pre">print</span> <span class="pre">information</span> <span class="pre">about</span> <span class="pre">the</span> <span class="pre">current</span> <span class="pre">status</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">algorithm\n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">2</span> <span class="pre">:</span> <span class="pre">print</span> <span class="pre">high</span> <span class="pre">level</span> <span class="pre">information</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">components</span> <span class="pre">involved</span> <span class="pre">in\n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">the</span> <span class="pre">registration</span> <span class="pre">that</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">used</span> <span class="pre">to</span> <span class="pre">detect</span> <span class="pre">a</span> <span class="pre">failing\n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">component.\n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">3</span> <span class="pre">:</span> <span class="pre">print</span> <span class="pre">as</span> <span class="pre">much</span> <span class="pre">information</span> <span class="pre">as</span> <span class="pre">possible</span> <span class="pre">to</span> <span class="pre">isolate</span> <span class="pre">the</span> <span class="pre">cause\n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">of</span> <span class="pre">a</span> <span class="pre">bug.\n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Default:</span> <span class="pre">1\n</span>&#160;&#160;&#160; <span class="pre">'</span></em><a class="headerlink" href="#dipy.align.imaffine.AffineRegistration.docstring_addendum" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imaffine.AffineRegistration.optimize">
<span class="sig-name descname"><span class="pre">optimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineRegistration.optimize" title="Link to this definition">#</a></dt>
<dd><p>Start the optimization process.</p>
<section id="id96">
<h4>Parameters<a class="headerlink" href="#id96" title="Link to this heading">#</a></h4>
<dl>
<dt>static<span class="classifier">2D or 3D array</span></dt><dd><p>the image to be used as reference during optimization.</p>
</dd>
<dt>moving<span class="classifier">2D or 3D array</span></dt><dd><p>the image to be used as “moving” during optimization. It is
necessary to pre-align the moving image to ensure its domain
lies inside the domain of the deformation fields. This is assumed
to be accomplished by “pre-aligning” the moving image towards the
static using an affine transformation given by the
‘starting_affine’ matrix</p>
</dd>
<dt>transform<span class="classifier">instance of Transform</span></dt><dd><p>the transformation with respect to whose parameters the gradient
must be computed</p>
</dd>
<dt>params0<span class="classifier">array, shape (n,)</span></dt><dd><p>parameters from which to start the optimization. If None, the
optimization will start at the identity transform. n is the
number of parameters of the specified transformation.</p>
</dd>
<dt>static_grid2world<span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>the voxel-to-space transformation associated with the static
image. The default is None, implying the transform is the
identity.</p>
</dd>
<dt>moving_grid2world<span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>the voxel-to-space transformation associated with the moving
image. The default is None, implying the transform is the
identity.</p>
</dd>
<dt>starting_affine<span class="classifier">string, or matrix, or None, optional</span></dt><dd><dl class="simple">
<dt>If string:</dt><dd><p>‘mass’: align centers of gravity
‘voxel-origin’: align physical coordinates of voxel (0,0,0)
‘centers’: align physical coordinates of central voxels</p>
</dd>
<dt>If matrix:</dt><dd><p>array, shape (dim+1, dim+1).</p>
</dd>
<dt>If None:</dt><dd><p>Start from identity.</p>
</dd>
</dl>
<p>The default is None.</p>
</dd>
<dt>ret_metric<span class="classifier">boolean, optional</span></dt><dd><p>if True, it returns the parameters for measuring the
similarity between the images (default ‘False’).
The metric containing optimal parameters and
the distance between the images.</p>
</dd>
<dt>static_mask<span class="classifier">array, shape (S, R, C) or (R, C), optional</span></dt><dd><p>static image mask that defines which pixels in the static image
are used to calculate the mutual information.</p>
</dd>
<dt>moving_mask<span class="classifier">array, shape (S’, R’, C’) or (R’, C’), optional</span></dt><dd><p>moving image mask that defines which pixels in the moving image
are used to calculate the mutual information.</p>
</dd>
</dl>
</section>
<section id="id97">
<h4>Returns<a class="headerlink" href="#id97" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>affine_map<span class="classifier">instance of AffineMap</span></dt><dd><p>the affine resulting affine transformation</p>
</dd>
<dt>xopt<span class="classifier">optimal parameters</span></dt><dd><p>the optimal parameters (translation, rotation shear etc.)</p>
</dd>
<dt>fopt<span class="classifier">Similarity metric</span></dt><dd><p>the value of the function at the optimal parameters.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="transform-method">
<h3>_transform_method<a class="headerlink" href="#transform-method" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.imaffine._transform_method">
<span class="sig-prename descclassname"><span class="pre">dipy.align.imaffine.</span></span><span class="sig-name descname"><span class="pre">_transform_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine._transform_method" title="Link to this definition">#</a></dt>
<dd><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object’s</p>
<blockquote>
<div><p>(key, value) pairs</p>
</div></blockquote>
<dl>
<dt>dict(iterable) -&gt; new dictionary initialized as if via:</dt><dd><p>d = {}
for k, v in iterable:</p>
<blockquote>
<div><p>d[k] = v</p>
</div></blockquote>
</dd>
<dt>dict(<a href="#id98"><span class="problematic" id="id99">**</span></a>kwargs) -&gt; new dictionary initialized with the name=value pairs</dt><dd><p>in the keyword argument list.  For example:  dict(one=1, two=2)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="transform-centers-of-mass">
<h3>transform_centers_of_mass<a class="headerlink" href="#transform-centers-of-mass" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.imaffine.transform_centers_of_mass">
<span class="sig-prename descclassname"><span class="pre">dipy.align.imaffine.</span></span><span class="sig-name descname"><span class="pre">transform_centers_of_mass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_grid2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_grid2world</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.transform_centers_of_mass" title="Link to this definition">#</a></dt>
<dd><p>Transformation to align the center of mass of the input images.</p>
<section id="id100">
<h4>Parameters<a class="headerlink" href="#id100" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt>static_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the static image</p>
</dd>
<dt>moving<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt>moving_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the moving image</p>
</dd>
</dl>
</section>
<section id="id101">
<h4>Returns<a class="headerlink" href="#id101" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>affine_map<span class="classifier">instance of AffineMap</span></dt><dd><p>the affine transformation (translation only, in this case) aligning
the center of mass of the moving image towards the one of the static
image</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="transform-geometric-centers">
<h3>transform_geometric_centers<a class="headerlink" href="#transform-geometric-centers" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.imaffine.transform_geometric_centers">
<span class="sig-prename descclassname"><span class="pre">dipy.align.imaffine.</span></span><span class="sig-name descname"><span class="pre">transform_geometric_centers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_grid2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_grid2world</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.transform_geometric_centers" title="Link to this definition">#</a></dt>
<dd><p>Transformation to align the geometric center of the input images.</p>
<p>With “geometric center” of a volume we mean the physical coordinates of
its central voxel</p>
<section id="id102">
<h4>Parameters<a class="headerlink" href="#id102" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt>static_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the static image</p>
</dd>
<dt>moving<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt>moving_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the moving image</p>
</dd>
</dl>
</section>
<section id="id103">
<h4>Returns<a class="headerlink" href="#id103" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>affine_map<span class="classifier">instance of AffineMap</span></dt><dd><p>the affine transformation (translation only, in this case) aligning
the geometric center of the moving image towards the one of the static
image</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="transform-origins">
<h3>transform_origins<a class="headerlink" href="#transform-origins" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.imaffine.transform_origins">
<span class="sig-prename descclassname"><span class="pre">dipy.align.imaffine.</span></span><span class="sig-name descname"><span class="pre">transform_origins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_grid2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_grid2world</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.transform_origins" title="Link to this definition">#</a></dt>
<dd><p>Transformation to align the origins of the input images.</p>
<p>With “origin” of a volume we mean the physical coordinates of
voxel (0,0,0)</p>
<section id="id104">
<h4>Parameters<a class="headerlink" href="#id104" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt>static_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the static image</p>
</dd>
<dt>moving<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt>moving_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the moving image</p>
</dd>
</dl>
</section>
<section id="id105">
<h4>Returns<a class="headerlink" href="#id105" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>affine_map<span class="classifier">instance of AffineMap</span></dt><dd><p>the affine transformation (translation only, in this case) aligning
the origin of the moving image towards the one of the static
image</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="diffeomorphicmap">
<h3><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap" title="dipy.align.imwarp.DiffeomorphicMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicMap</span></code></a><a class="headerlink" href="#diffeomorphicmap" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.imwarp.</span></span><span class="sig-name descname"><span class="pre">DiffeomorphicMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prealign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prealign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.__init__" title="Link to this definition">#</a></dt>
<dd><p>DiffeomorphicMap</p>
<p>Implements a diffeomorphic transformation on the physical space. The
deformation fields encoding the direct and inverse transformations
share the same domain discretization (both the discretization grid
shape and voxel-to-space matrix). The input coordinates (physical
coordinates) are first aligned using prealign, and then displaced
using the corresponding vector field interpolated at the aligned
coordinates.</p>
<section id="id106">
<h4>Parameters<a class="headerlink" href="#id106" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>dim<span class="classifier">int, 2 or 3</span></dt><dd><p>the transformation’s dimension</p>
</dd>
<dt>disp_shape<span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices (if 3D), rows and columns of the deformation
field’s discretization</p>
</dd>
<dt>disp_grid2world<span class="classifier">the voxel-to-space transform between the def. fields</span></dt><dd><p>grid and space</p>
</dd>
<dt>domain_shape<span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices (if 3D), rows and columns of the default
discretization of this map’s domain</p>
</dd>
<dt>domain_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the default voxel-to-space transformation between this map’s
discretization and physical space</p>
</dd>
<dt>codomain_shape<span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices (if 3D), rows and columns of the images that
are ‘normally’ warped using this transformation in the forward
direction (this will provide default transformation parameters to
warp images under this transformation). By default, we assume that
the inverse transformation is ‘normally’ used to warp images with
the same discretization and voxel-to-space transformation as the
deformation field grid.</p>
</dd>
<dt>codomain_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of images that are ‘normally’
warped using this transformation (in the forward direction).</p>
</dd>
<dt>prealign<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the linear transformation to be applied to align input images to
the reference space before warping under the deformation field.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.allocate">
<span class="sig-name descname"><span class="pre">allocate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.allocate" title="Link to this definition">#</a></dt>
<dd><p>Creates a zero displacement field</p>
<p>Creates a zero displacement field (the identity transformation).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.compute_inversion_error">
<span class="sig-name descname"><span class="pre">compute_inversion_error</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.compute_inversion_error" title="Link to this definition">#</a></dt>
<dd><p>Inversion error of the displacement fields</p>
<p>Estimates the inversion error of the displacement fields by computing
statistics of the residual vectors obtained after composing the forward
and backward displacement fields.</p>
<section id="id107">
<h4>Returns<a class="headerlink" href="#id107" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>residual<span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the displacement field resulting from composing the forward and
backward displacement fields of this transformation (the residual
should be zero for a perfect diffeomorphism)</p>
</dd>
<dt>stats<span class="classifier">array, shape (3,)</span></dt><dd><p>statistics from the norms of the vectors of the residual
displacement field: maximum, mean and standard deviation</p>
</dd>
</dl>
</section>
<section id="id108">
<h4>Notes<a class="headerlink" href="#id108" title="Link to this heading">#</a></h4>
<p>Since the forward and backward displacement fields have the same
discretization, the final composition is given by</p>
<p>comp[i] = forward[ i + Dinv * backward[i]]</p>
<p>where Dinv is the space-to-grid transformation of the displacement
fields</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.expand_fields">
<span class="sig-name descname"><span class="pre">expand_fields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expand_factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.expand_fields" title="Link to this definition">#</a></dt>
<dd><p>Expands the displacement fields from current shape to new_shape</p>
<p>Up-samples the discretization of the displacement fields to be of
new_shape shape.</p>
<section id="id109">
<h4>Parameters<a class="headerlink" href="#id109" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>expand_factors<span class="classifier">array, shape (dim,)</span></dt><dd><p>the factors scaling current spacings (voxel sizes) to spacings in
the expanded discretization.</p>
</dd>
<dt>new_shape<span class="classifier">array, shape (dim,)</span></dt><dd><p>the shape of the arrays holding the up-sampled discretization</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.get_backward_field">
<span class="sig-name descname"><span class="pre">get_backward_field</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.get_backward_field" title="Link to this definition">#</a></dt>
<dd><p>Deformation field to transform an image in the backward direction</p>
<p>Returns the deformation field that must be used to warp an image under
this transformation in the backward direction (note the ‘is_inverse’
flag).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.get_forward_field">
<span class="sig-name descname"><span class="pre">get_forward_field</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.get_forward_field" title="Link to this definition">#</a></dt>
<dd><p>Deformation field to transform an image in the forward direction</p>
<p>Returns the deformation field that must be used to warp an image under
this transformation in the forward direction (note the ‘is_inverse’
flag).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.get_simplified_transform">
<span class="sig-name descname"><span class="pre">get_simplified_transform</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.get_simplified_transform" title="Link to this definition">#</a></dt>
<dd><p>Constructs a simplified version of this Diffeomorhic Map</p>
<p>The simplified version incorporates the pre-align transform, as well as
the domain and codomain affine transforms into the displacement field.
The resulting transformation may be regarded as operating on the
image spaces given by the domain and codomain discretization. As a
result, self.prealign, self.disp_grid2world, self.domain_grid2world and
self.codomain affine will be None (denoting Identity) in the resulting
diffeomorphic map.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.interpret_matrix">
<span class="sig-name descname"><span class="pre">interpret_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.interpret_matrix" title="Link to this definition">#</a></dt>
<dd><p>Try to interpret <cite>obj</cite> as a matrix</p>
<p>Some operations are performed faster if we know in advance if a matrix
is the identity (so we can skip the actual matrix-vector
multiplication). This function returns None if the given object
is None or the ‘identity’ string. It returns the same object if it is
a numpy array. It raises an exception otherwise.</p>
<section id="id110">
<h4>Parameters<a class="headerlink" href="#id110" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>obj<span class="classifier">object</span></dt><dd><p>any object</p>
</dd>
</dl>
</section>
<section id="id111">
<h4>Returns<a class="headerlink" href="#id111" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>obj<span class="classifier">object</span></dt><dd><p>the same object given as argument if <cite>obj</cite> is None or a numpy
array. None if <cite>obj</cite> is the ‘identity’ string.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.inverse" title="Link to this definition">#</a></dt>
<dd><p>Inverse of this DiffeomorphicMap instance</p>
<p>Returns a diffeomorphic map object representing the inverse of this
transformation. The internal arrays are not copied but just referenced.</p>
<section id="id112">
<h4>Returns<a class="headerlink" href="#id112" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>inv<span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the inverse of this diffeomorphic map.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.shallow_copy">
<span class="sig-name descname"><span class="pre">shallow_copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.shallow_copy" title="Link to this definition">#</a></dt>
<dd><p>Shallow copy of this DiffeomorphicMap instance</p>
<p>Creates a shallow copy of this diffeomorphic map (the arrays are not
copied but just referenced)</p>
<section id="id113">
<h4>Returns<a class="headerlink" href="#id113" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>new_map<span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the shallow copy of this diffeomorphic map</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_world2grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.transform" title="Link to this definition">#</a></dt>
<dd><p>Warps an image in the forward direction</p>
<p>Transforms the input image under this transformation in the forward
direction. It uses the “is_inverse” flag to switch between “forward”
and “backward” (if is_inverse is False, then transform(…) warps the
image forwards, else it warps the image backwards).</p>
<section id="id114">
<h4>Parameters<a class="headerlink" href="#id114" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>image<span class="classifier">array, shape (s, r, c) if dim = 3 or (r, c) if dim = 2</span></dt><dd><p>the image to be warped under this transformation in the forward
direction</p>
</dd>
<dt>interpolation<span class="classifier">string, either ‘linear’ or ‘nearest’</span></dt><dd><p>the type of interpolation to be used for warping, either ‘linear’
(for k-linear interpolation) or ‘nearest’ for nearest neighbor</p>
</dd>
<dt>image_world2grid<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the transformation bringing world (space) coordinates to voxel
coordinates of the image given as input</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices, rows and columns of the desired warped image</p>
</dd>
<dt>out_grid2world<span class="classifier">the transformation bringing voxel coordinates of the</span></dt><dd><p>warped image to physical space</p>
</dd>
</dl>
</section>
<section id="id115">
<h4>Returns<a class="headerlink" href="#id115" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>warped<span class="classifier">array, shape = out_shape or self.codomain_shape if None</span></dt><dd><p>the warped image under this transformation in the forward direction</p>
</dd>
</dl>
</section>
<section id="id116">
<h4>Notes<a class="headerlink" href="#id116" title="Link to this heading">#</a></h4>
<p>See _warp_forward and _warp_backward documentation for further
information.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.transform_inverse">
<span class="sig-name descname"><span class="pre">transform_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_world2grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.transform_inverse" title="Link to this definition">#</a></dt>
<dd><p>Warps an image in the backward direction</p>
<p>Transforms the input image under this transformation in the backward
direction. It uses the “is_inverse” flag to switch between “forward”
and “backward” (if is_inverse is False, then transform_inverse(…)
warps the image backwards, else it warps the image forwards)</p>
<section id="id117">
<h4>Parameters<a class="headerlink" href="#id117" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>image<span class="classifier">array, shape (s, r, c) if dim = 3 or (r, c) if dim = 2</span></dt><dd><p>the image to be warped under this transformation in the forward
direction</p>
</dd>
<dt>interpolation<span class="classifier">string, either ‘linear’ or ‘nearest’</span></dt><dd><p>the type of interpolation to be used for warping, either ‘linear’
(for k-linear interpolation) or ‘nearest’ for nearest neighbor</p>
</dd>
<dt>image_world2grid<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the transformation bringing world (space) coordinates to voxel
coordinates of the image given as input</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices, rows, and columns of the desired warped image</p>
</dd>
<dt>out_grid2world<span class="classifier">the transformation bringing voxel coordinates of the</span></dt><dd><p>warped image to physical space</p>
</dd>
</dl>
</section>
<section id="id118">
<h4>Returns<a class="headerlink" href="#id118" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>warped<span class="classifier">array, shape = out_shape or self.codomain_shape if None</span></dt><dd><p>warped image under this transformation in the backward direction</p>
</dd>
</dl>
</section>
<section id="id119">
<h4>Notes<a class="headerlink" href="#id119" title="Link to this heading">#</a></h4>
<p>See _warp_forward and _warp_backward documentation for further
information.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.transform_points">
<span class="sig-name descname"><span class="pre">transform_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">world2coord</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.transform_points" title="Link to this definition">#</a></dt>
<dd><p>Warp the list of points in the forward direction.</p>
<p>Applies this diffeomorphic map to the list of points (or streamlines)
given by <cite>points</cite>. We assume that the points’ coordinates are mapped
to world coordinates by applying the <cite>coord2world</cite> affine transform.
The warped coordinates are given in world coordinates unless
<cite>world2coord</cite> affine transform is specified, in which case the warped
points will be transformed to the corresponding coordinate system.</p>
<section id="id120">
<h4>Parameters<a class="headerlink" href="#id120" title="Link to this heading">#</a></h4>
<p>points : array, shape (N, dim) or Streamlines object</p>
<dl class="simple">
<dt>coord2world<span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>affine matrix mapping points to world coordinates</p>
</dd>
<dt>world2coord<span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>affine matrix mapping world coordinates to points</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.transform_points_inverse">
<span class="sig-name descname"><span class="pre">transform_points_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">world2coord</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.transform_points_inverse" title="Link to this definition">#</a></dt>
<dd><p>Warp the list of points in the backward direction.</p>
<p>Applies this diffeomorphic map to the list of points (or streamlines)
given by <cite>points</cite>. We assume that the points’ coordinates are mapped
to world coordinates by applying the <cite>coord2world</cite> affine transform.
The warped coordinates are given in world coordinates unless
<cite>world2coord</cite> affine transform is specified, in which case the warped
points will be transformed to the corresponding coordinate system.</p>
<section id="id121">
<h4>Parameters<a class="headerlink" href="#id121" title="Link to this heading">#</a></h4>
<p>points : array, shape (N, dim) or Streamlines object</p>
<dl class="simple">
<dt>coord2world<span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>affine matrix mapping points to world coordinates</p>
</dd>
<dt>world2coord<span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>affine matrix mapping world coordinates to points</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicMap.warp_endomorphism">
<span class="sig-name descname"><span class="pre">warp_endomorphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.warp_endomorphism" title="Link to this definition">#</a></dt>
<dd><p>Composition of this DiffeomorphicMap with a given endomorphism</p>
<p>Creates a new DiffeomorphicMap C with the same properties as self and
composes its displacement fields with phi’s corresponding fields.
The resulting diffeomorphism is of the form C(x) = phi(self(x)) with
inverse C^{-1}(y) = self^{-1}(phi^{-1}(y)). We assume that phi is an
endomorphism with the same discretization and domain affine as self
to ensure that the composition inherits self’s properties (we also
assume that the pre-aligning matrix of phi is None or identity).</p>
<section id="id122">
<h4>Parameters<a class="headerlink" href="#id122" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>phi<span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the endomorphism to be warped by this diffeomorphic map</p>
</dd>
</dl>
</section>
<section id="id123">
<h4>Returns<a class="headerlink" href="#id123" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>composition<span class="classifier">the composition of this diffeomorphic map with the</span></dt><dd><p>endomorphism given as input</p>
</dd>
</dl>
</section>
<section id="id124">
<h4>Notes<a class="headerlink" href="#id124" title="Link to this heading">#</a></h4>
<p>The problem with our current representation of a DiffeomorphicMap is
that the set of Diffeomorphism that can be represented this way (a
pre-aligning matrix followed by a non-linear endomorphism given as a
displacement field) is not closed under the composition operation.</p>
<p>Supporting a general DiffeomorphicMap class, closed under composition,
may be extremely costly computationally, and the kind of
transformations we actually need for Avants’ mid-point algorithm (SyN)
are much simpler.</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="diffeomorphicregistration">
<h3><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicRegistration" title="dipy.align.imwarp.DiffeomorphicRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicRegistration</span></code></a><a class="headerlink" href="#diffeomorphicregistration" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicRegistration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.imwarp.</span></span><span class="sig-name descname"><span class="pre">DiffeomorphicRegistration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicRegistration.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration.__init__" title="Link to this definition">#</a></dt>
<dd><p>Diffeomorphic Registration</p>
<p>This abstract class defines the interface to be implemented by any
optimization algorithm for diffeomorphic registration.</p>
<section id="id125">
<h4>Parameters<a class="headerlink" href="#id125" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>metric<span class="classifier">SimilarityMetric object</span></dt><dd><p>the object measuring the similarity of the two images. The
registration algorithm will minimize (or maximize) the provided
similarity.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicRegistration.get_map">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration.get_map" title="Link to this definition">#</a></dt>
<dd><p>Returns the resulting diffeomorphic map after optimization</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicRegistration.optimize">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">optimize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration.optimize" title="Link to this definition">#</a></dt>
<dd><p>Starts the metric optimization</p>
<p>This is the main function each specialized class derived from this must
implement. Upon completion, the deformation field must be available
from the forward transformation model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.DiffeomorphicRegistration.set_level_iters">
<span class="sig-name descname"><span class="pre">set_level_iters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level_iters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration.set_level_iters" title="Link to this definition">#</a></dt>
<dd><p>Sets the number of iterations at each pyramid level</p>
<p>Establishes the maximum number of iterations to be performed at each
level of the Gaussian pyramid, similar to ANTS.</p>
<section id="id126">
<h4>Parameters<a class="headerlink" href="#id126" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>level_iters<span class="classifier">list</span></dt><dd><p>the number of iterations at each level of the Gaussian pyramid.
level_iters[0] corresponds to the finest level, level_iters[n-1]
the coarsest, where n is the length of the list</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="symmetricdiffeomorphicregistration">
<h3><a class="reference internal" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration" title="dipy.align.imwarp.SymmetricDiffeomorphicRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration</span></code></a><a class="headerlink" href="#symmetricdiffeomorphicregistration" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.imwarp.</span></span><span class="sig-name descname"><span class="pre">SymmetricDiffeomorphicRegistration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss_sigma_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicRegistration" title="dipy.align.imwarp.DiffeomorphicRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicRegistration</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss_sigma_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.__init__" title="Link to this definition">#</a></dt>
<dd><p>Symmetric Diffeomorphic Registration (SyN) Algorithm</p>
<p>Performs the multi-resolution optimization algorithm for non-linear
registration using a given similarity metric.</p>
<section id="id127">
<h4>Parameters<a class="headerlink" href="#id127" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>metric<span class="classifier">SimilarityMetric object</span></dt><dd><p>the metric to be optimized</p>
</dd>
<dt>level_iters<span class="classifier">list of int</span></dt><dd><p>the number of iterations at each level of the Gaussian Pyramid (the
length of the list defines the number of pyramid levels to be
used)</p>
</dd>
<dt>opt_tol<span class="classifier">float</span></dt><dd><p>the optimization will stop when the estimated derivative of the
energy profile w.r.t. time falls below this threshold</p>
</dd>
<dt>inv_iter<span class="classifier">int</span></dt><dd><p>the number of iterations to be performed by the displacement field
inversion algorithm</p>
</dd>
<dt>step_length<span class="classifier">float</span></dt><dd><p>the length of the maximum displacement vector of the update
displacement field at each iteration</p>
</dd>
<dt>ss_sigma_factor<span class="classifier">float</span></dt><dd><p>parameter of the scale-space smoothing kernel. For example, the
std. dev. of the kernel will be factor*(2^i) in the isotropic case
where i = 0, 1, …, n_scales is the scale</p>
</dd>
<dt>inv_tol<span class="classifier">float</span></dt><dd><p>the displacement field inversion algorithm will stop iterating
when the inversion error falls below this threshold</p>
</dd>
<dt>callback<span class="classifier">function(SymmetricDiffeomorphicRegistration)</span></dt><dd><p>a function receiving a SymmetricDiffeomorphicRegistration object
to be called after each iteration (this optimizer will call this
function passing self as parameter)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.get_map">
<span class="sig-name descname"><span class="pre">get_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.get_map" title="Link to this definition">#</a></dt>
<dd><p>Return the resulting diffeomorphic map.</p>
<p>Returns the DiffeomorphicMap registering the moving image towards
the static image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.optimize">
<span class="sig-name descname"><span class="pre">optimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prealign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.optimize" title="Link to this definition">#</a></dt>
<dd><p>Starts the optimization</p>
<section id="id128">
<h4>Parameters<a class="headerlink" href="#id128" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">array, shape (S, R, C) or (R, C)</span></dt><dd><p>the image to be used as reference during optimization. The
displacement fields will have the same discretization as the static
image.</p>
</dd>
<dt>moving<span class="classifier">array, shape (S, R, C) or (R, C)</span></dt><dd><p>the image to be used as “moving” during optimization. Since the
deformation fields’ discretization is the same as the static image,
it is necessary to pre-align the moving image to ensure its domain
lies inside the domain of the deformation fields. This is assumed
to be accomplished by “pre-aligning” the moving image towards the
static using an affine transformation given by the ‘prealign’
matrix</p>
</dd>
<dt>static_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation associated to the static image</p>
</dd>
<dt>moving_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation associated to the moving image</p>
</dd>
<dt>prealign<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the affine transformation (operating on the physical space)
pre-aligning the moving image towards the static</p>
</dd>
</dl>
</section>
<section id="id129">
<h4>Returns<a class="headerlink" href="#id129" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static_to_ref<span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the diffeomorphic map that brings the moving image towards the
static one in the forward direction (i.e. by calling
static_to_ref.transform) and the static image towards the
moving one in the backward direction (i.e. by calling
static_to_ref.transform_inverse).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_displacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_displacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp_world2grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.update" title="Link to this definition">#</a></dt>
<dd><p>Composition of the current displacement field with the given field</p>
<p>Interpolates new displacement at the locations defined by
current_displacement. Equivalently, computes the composition C of the
given displacement fields as C(x) = B(A(x)), where A is
current_displacement and B is new_displacement. This function is
intended to be used with deformation fields of the same sampling
(e.g. to be called by a registration algorithm).</p>
<section id="id130">
<h4>Parameters<a class="headerlink" href="#id130" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>current_displacement<span class="classifier">array, shape (R’, C’, 2) or (S’, R’, C’, 3)</span></dt><dd><p>the displacement field defining where to interpolate
new_displacement</p>
</dd>
<dt>new_displacement<span class="classifier">array, shape (R, C, 2) or (S, R, C, 3)</span></dt><dd><p>the displacement field to be warped by current_displacement</p>
</dd>
<dt>disp_world2grid<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the space-to-grid transform associated with the displacements’
grid (we assume that both displacements are discretized over the
same grid)</p>
</dd>
<dt>time_scaling<span class="classifier">float</span></dt><dd><p>scaling factor applied to d2. The effect may be interpreted as
moving d1 displacements along a factor (<cite>time_scaling</cite>) of d2.</p>
</dd>
</dl>
</section>
<section id="id131">
<h4>Returns<a class="headerlink" href="#id131" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>updated<span class="classifier">array, shape (the same as new_displacement)</span></dt><dd><p>the warped displacement field</p>
</dd>
</dl>
<p>mean_norm : the mean norm of all vectors in current_displacement</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="registrationstages">
<h3>RegistrationStages<a class="headerlink" href="#registrationstages" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.imwarp.RegistrationStages">
<span class="sig-prename descclassname"><span class="pre">dipy.align.imwarp.</span></span><span class="sig-name descname"><span class="pre">RegistrationStages</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.RegistrationStages" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="logger">
<h3>logger<a class="headerlink" href="#logger" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.imwarp.logger">
<span class="sig-prename descclassname"><span class="pre">dipy.align.imwarp.</span></span><span class="sig-name descname"><span class="pre">logger</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.logger" title="Link to this definition">#</a></dt>
<dd><p>Instances of the Logger class represent a single logging channel. A
“logging channel” indicates an area of an application. Exactly how an
“area” is defined is up to the application developer. Since an
application can have any number of areas, logging channels are identified
by a unique string. Application areas can be nested (e.g. an area
of “input processing” might include sub-areas “read CSV files”, “read
XLS files” and “read Gnumeric files”). To cater for this natural nesting,
channel names are organized into a namespace hierarchy where levels are
separated by periods, much like the Java or Python package namespace. So
in the instance given above, channel names might be “input” for the upper
level, and “input.csv”, “input.xls” and “input.gnu” for the sub-levels.
There is no arbitrary limit to the depth of nesting.</p>
</dd></dl>

</section>
<section id="mult-aff">
<h3>mult_aff<a class="headerlink" href="#mult-aff" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.imwarp.mult_aff">
<span class="sig-prename descclassname"><span class="pre">dipy.align.imwarp.</span></span><span class="sig-name descname"><span class="pre">mult_aff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.mult_aff" title="Link to this definition">#</a></dt>
<dd><p>Returns the matrix product A.dot(B) considering None as the identity</p>
<section id="id132">
<h4>Parameters<a class="headerlink" href="#id132" title="Link to this heading">#</a></h4>
<p>A : array, shape (n,k)
B : array, shape (k,m)</p>
</section>
<section id="id133">
<h4>Returns<a class="headerlink" href="#id133" title="Link to this heading">#</a></h4>
<p>The matrix product A.dot(B). If any of the input matrices is None, it is
treated as the identity matrix. If both matrices are None, None is returned</p>
</section>
</dd></dl>

</section>
<section id="get-direction-and-spacings">
<h3>get_direction_and_spacings<a class="headerlink" href="#get-direction-and-spacings" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.imwarp.get_direction_and_spacings">
<span class="sig-prename descclassname"><span class="pre">dipy.align.imwarp.</span></span><span class="sig-name descname"><span class="pre">get_direction_and_spacings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">affine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.get_direction_and_spacings" title="Link to this definition">#</a></dt>
<dd><p>Extracts the rotational and spacing components from a matrix</p>
<p>Extracts the rotational and spacing (voxel dimensions) components from a
matrix. An image gradient represents the local variation of the image’s
gray values per voxel. Since we are iterating on the physical space, we
need to compute the gradients as variation per millimeter, so we need to
divide each gradient’s component by the voxel size along the corresponding
axis, that’s what the spacings are used for. Since the image’s gradients
are oriented along the grid axes, we also need to re-orient the gradients
to be given in physical space coordinates.</p>
<section id="id134">
<h4>Parameters<a class="headerlink" href="#id134" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>affine<span class="classifier">array, shape (k, k), k = 3, 4</span></dt><dd><p>the matrix transforming grid coordinates to physical space.</p>
</dd>
</dl>
</section>
<section id="id135">
<h4>Returns<a class="headerlink" href="#id135" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>direction<span class="classifier">array, shape (k-1, k-1)</span></dt><dd><p>the rotational component of the input matrix</p>
</dd>
<dt>spacings<span class="classifier">array, shape (k-1,)</span></dt><dd><p>the scaling component (voxel size) of the matrix</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="similaritymetric">
<h3><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a><a class="headerlink" href="#similaritymetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.metrics.</span></span><span class="sig-name descname"><span class="pre">SimilarityMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>Similarity Metric abstract class</p>
<p>A similarity metric is in charge of keeping track of the numerical
value of the similarity (or distance) between the two given images. It
also computes the update field for the forward and inverse displacement
fields to be used in a gradient-based optimization algorithm. Note that
this metric does not depend on any transformation (affine or
non-linear) so it assumes the static and moving images are already
warped</p>
<section id="id136">
<h4>Parameters<a class="headerlink" href="#id136" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>dim<span class="classifier">int (either 2 or 3)</span></dt><dd><p>the dimension of the image domain</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.compute_backward">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compute_backward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.compute_backward" title="Link to this definition">#</a></dt>
<dd><p>Computes one step bringing the static image towards the moving.</p>
<p>Computes the backward update field to register the static image towards
the moving image in a gradient-based optimization algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.compute_forward">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compute_forward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.compute_forward" title="Link to this definition">#</a></dt>
<dd><p>Computes one step bringing the reference image towards the static.</p>
<p>Computes the forward update field to register the moving image towards
the static image in a gradient-based optimization algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.free_iteration">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">free_iteration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.free_iteration" title="Link to this definition">#</a></dt>
<dd><p>Releases the resources no longer needed by the metric</p>
<p>This method is called by the RegistrationOptimizer after the required
iterations have been computed (forward and / or backward) so that the
SimilarityMetric can safely delete any data it computed as part of the
initialization</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.get_energy">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_energy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.get_energy" title="Link to this definition">#</a></dt>
<dd><p>Numerical value assigned by this metric to the current image pair</p>
<p>Must return the numeric value of the similarity between the given
static and moving images</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.initialize_iteration">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">initialize_iteration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.initialize_iteration" title="Link to this definition">#</a></dt>
<dd><p>Prepares the metric to compute one displacement field iteration.</p>
<p>This method will be called before any compute_forward or
compute_backward call, this allows the Metric to pre-compute any useful
information for speeding up the update computations. This
initialization was needed in ANTS because the updates are called once
per voxel. In Python this is unpractical, though.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.set_levels_above">
<span class="sig-name descname"><span class="pre">set_levels_above</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">levels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.set_levels_above" title="Link to this definition">#</a></dt>
<dd><p>Informs the metric how many pyramid levels are above the current one</p>
<p>Informs this metric the number of pyramid levels above the current one.
The metric may change its behavior (e.g. number of inner iterations)
accordingly</p>
<section id="id137">
<h4>Parameters<a class="headerlink" href="#id137" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>levels<span class="classifier">int</span></dt><dd><p>the number of levels above the current Gaussian Pyramid level</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.set_levels_below">
<span class="sig-name descname"><span class="pre">set_levels_below</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">levels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.set_levels_below" title="Link to this definition">#</a></dt>
<dd><p>Informs the metric how many pyramid levels are below the current one</p>
<p>Informs this metric the number of pyramid levels below the current one.
The metric may change its behavior (e.g. number of inner iterations)
accordingly</p>
<section id="id138">
<h4>Parameters<a class="headerlink" href="#id138" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>levels<span class="classifier">int</span></dt><dd><p>the number of levels below the current Gaussian Pyramid level</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.set_moving_image">
<span class="sig-name descname"><span class="pre">set_moving_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_affine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_direction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.set_moving_image" title="Link to this definition">#</a></dt>
<dd><p>Sets the moving image being compared against the static one.</p>
<p>Sets the moving image. The default behavior (of this abstract class) is
simply to assign the reference to an attribute, but
generalizations of the metric may need to perform other operations</p>
<section id="id139">
<h4>Parameters<a class="headerlink" href="#id139" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>moving_image<span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the moving image</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.set_static_image">
<span class="sig-name descname"><span class="pre">set_static_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_affine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_direction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.set_static_image" title="Link to this definition">#</a></dt>
<dd><p>Sets the static image being compared against the moving one.</p>
<p>Sets the static image. The default behavior (of this abstract class) is
simply to assign the reference to an attribute, but
generalizations of the metric may need to perform other operations</p>
<section id="id140">
<h4>Parameters<a class="headerlink" href="#id140" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static_image<span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the static image</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.use_moving_image_dynamics">
<span class="sig-name descname"><span class="pre">use_moving_image_dynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_moving_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.use_moving_image_dynamics" title="Link to this definition">#</a></dt>
<dd><p>This is called by the optimizer just after setting the moving image</p>
<p>This method allows the metric to compute any useful
information from knowing how the current static image was generated
(as the transformation of an original static image). This method is
called by the optimizer just after it sets the static image.
Transformation will be an instance of DiffeomorficMap or None if
the original_moving_image equals self.moving_image.</p>
<section id="id141">
<h4>Parameters<a class="headerlink" href="#id141" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>original_moving_image<span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>original image from which the current moving image was generated</p>
</dd>
<dt>transformation<span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the transformation that was applied to the original image to generate
the current moving image</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SimilarityMetric.use_static_image_dynamics">
<span class="sig-name descname"><span class="pre">use_static_image_dynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_static_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.use_static_image_dynamics" title="Link to this definition">#</a></dt>
<dd><p>This is called by the optimizer just after setting the static image.</p>
<p>This method allows the metric to compute any useful
information from knowing how the current static image was generated
(as the transformation of an original static image). This method is
called by the optimizer just after it sets the static image.
Transformation will be an instance of DiffeomorficMap or None
if the original_static_image equals self.moving_image.</p>
<section id="id142">
<h4>Parameters<a class="headerlink" href="#id142" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>original_static_image<span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>original image from which the current static image was generated</p>
</dd>
<dt>transformation<span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the transformation that was applied to original image to generate
the current static image</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="ccmetric">
<h3><a class="reference internal" href="#dipy.align.metrics.CCMetric" title="dipy.align.metrics.CCMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCMetric</span></code></a><a class="headerlink" href="#ccmetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.metrics.CCMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.metrics.</span></span><span class="sig-name descname"><span class="pre">CCMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.CCMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>Normalized Cross-Correlation Similarity metric.</p>
<section id="id143">
<h4>Parameters<a class="headerlink" href="#id143" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>dim<span class="classifier">int (either 2 or 3)</span></dt><dd><p>the dimension of the image domain</p>
</dd>
<dt>sigma_diff<span class="classifier">the standard deviation of the Gaussian smoothing kernel to</span></dt><dd><p>be applied to the update field at each iteration</p>
</dd>
<dt>radius<span class="classifier">int</span></dt><dd><p>the radius of the squared (cubic) neighborhood at each voxel to be
considered to compute the cross correlation</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.CCMetric.compute_backward">
<span class="sig-name descname"><span class="pre">compute_backward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.compute_backward" title="Link to this definition">#</a></dt>
<dd><p>Computes one step bringing the static image towards the moving.</p>
<p>Computes the update displacement field to be used for registration of
the static image towards the moving image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.CCMetric.compute_forward">
<span class="sig-name descname"><span class="pre">compute_forward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.compute_forward" title="Link to this definition">#</a></dt>
<dd><p>Computes one step bringing the moving image towards the static.</p>
<p>Computes the update displacement field to be used for registration of
the moving image towards the static image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.CCMetric.free_iteration">
<span class="sig-name descname"><span class="pre">free_iteration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.free_iteration" title="Link to this definition">#</a></dt>
<dd><p>Frees the resources allocated during initialization</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.CCMetric.get_energy">
<span class="sig-name descname"><span class="pre">get_energy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.get_energy" title="Link to this definition">#</a></dt>
<dd><p>Numerical value assigned by this metric to the current image pair</p>
<p>Returns the Cross Correlation (data term) energy computed at the
largest iteration</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.CCMetric.initialize_iteration">
<span class="sig-name descname"><span class="pre">initialize_iteration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.initialize_iteration" title="Link to this definition">#</a></dt>
<dd><p>Prepares the metric to compute one displacement field iteration.</p>
<p>Pre-computes the cross-correlation factors for efficient computation
of the gradient of the Cross Correlation w.r.t. the displacement field.
It also pre-computes the image gradients in the physical space by
re-orienting the gradients in the voxel space using the corresponding
affine transformations.</p>
</dd></dl>

</dd></dl>

</section>
<section id="emmetric">
<h3><a class="reference internal" href="#dipy.align.metrics.EMMetric" title="dipy.align.metrics.EMMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">EMMetric</span></code></a><a class="headerlink" href="#emmetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.metrics.</span></span><span class="sig-name descname"><span class="pre">EMMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double_gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss_newton'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double_gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss_newton'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>Expectation-Maximization Metric</p>
<p>Similarity metric based on the Expectation-Maximization algorithm to
handle multi-modal images. The transfer function is modeled as a set of
hidden random variables that are estimated at each iteration of the
algorithm.</p>
<section id="id144">
<h4>Parameters<a class="headerlink" href="#id144" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>dim<span class="classifier">int (either 2 or 3)</span></dt><dd><p>the dimension of the image domain</p>
</dd>
<dt>smooth<span class="classifier">float</span></dt><dd><p>smoothness parameter, the larger the value the smoother the
deformation field</p>
</dd>
<dt>inner_iter<span class="classifier">int</span></dt><dd><p>number of iterations to be performed at each level of the multi-
resolution Gauss-Seidel optimization algorithm (this is not the
number of steps per Gaussian Pyramid level, that parameter must
be set for the optimizer, not the metric)</p>
</dd>
<dt>q_levels<span class="classifier">number of quantization levels (equal to the number of hidden</span></dt><dd><p>variables in the EM algorithm)</p>
</dd>
<dt>double_gradient<span class="classifier">boolean</span></dt><dd><p>if True, the gradient of the expected static image under the moving
modality will be added to the gradient of the moving image,
similarly, the gradient of the expected moving image under the
static modality will be added to the gradient of the static image.</p>
</dd>
<dt>step_type<span class="classifier">string (‘gauss_newton’, ‘demons’)</span></dt><dd><p>the optimization schedule to be used in the multi-resolution
Gauss-Seidel optimization algorithm (not used if Demons Step is
selected)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.compute_backward">
<span class="sig-name descname"><span class="pre">compute_backward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.compute_backward" title="Link to this definition">#</a></dt>
<dd><p>Computes one step bringing the static image towards the moving.</p>
<p>Computes the update displacement field to be used for registration of
the static image towards the moving image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.compute_demons_step">
<span class="sig-name descname"><span class="pre">compute_demons_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forward_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.compute_demons_step" title="Link to this definition">#</a></dt>
<dd><p>Demons step for EM metric</p>
<section id="id145">
<h4>Parameters<a class="headerlink" href="#id145" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>forward_step<span class="classifier">boolean</span></dt><dd><p>if True, computes the Demons step in the forward direction
(warping the moving towards the static image). If False,
computes the backward step (warping the static image to the
moving image)</p>
</dd>
</dl>
</section>
<section id="id146">
<h4>Returns<a class="headerlink" href="#id146" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>displacement<span class="classifier">array, shape (R, C, 2) or (S, R, C, 3)</span></dt><dd><p>the Demons step</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.compute_forward">
<span class="sig-name descname"><span class="pre">compute_forward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.compute_forward" title="Link to this definition">#</a></dt>
<dd><p>Computes one step bringing the reference image towards the static.</p>
<p>Computes the forward update field to register the moving image towards
the static image in a gradient-based optimization algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.compute_gauss_newton_step">
<span class="sig-name descname"><span class="pre">compute_gauss_newton_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forward_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.compute_gauss_newton_step" title="Link to this definition">#</a></dt>
<dd><p>Computes the Gauss-Newton energy minimization step</p>
<p>Computes the Newton step to minimize this energy, i.e., minimizes the
linearized energy function with respect to the
regularized displacement field (this step does not require
post-smoothing, as opposed to the demons step, which does not include
regularization). To accelerate convergence we use the multi-grid
Gauss-Seidel algorithm proposed by Bruhn and Weickert et al [Bruhn05]</p>
<section id="id147">
<h4>Parameters<a class="headerlink" href="#id147" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>forward_step<span class="classifier">boolean</span></dt><dd><p>if True, computes the Newton step in the forward direction
(warping the moving towards the static image). If False,
computes the backward step (warping the static image to the
moving image)</p>
</dd>
</dl>
</section>
<section id="id148">
<h4>Returns<a class="headerlink" href="#id148" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>displacement<span class="classifier">array, shape (R, C, 2) or (S, R, C, 3)</span></dt><dd><p>the Newton step</p>
</dd>
</dl>
</section>
<section id="id149">
<h4>References<a class="headerlink" href="#id149" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion</dt><dd><p>estimation: combining highest accuracy with real-time
performance”, 10th IEEE International Conference on Computer
Vision, 2005. ICCV 2005.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.free_iteration">
<span class="sig-name descname"><span class="pre">free_iteration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.free_iteration" title="Link to this definition">#</a></dt>
<dd><p>Frees the resources allocated during initialization</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.get_energy">
<span class="sig-name descname"><span class="pre">get_energy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.get_energy" title="Link to this definition">#</a></dt>
<dd><p>The numerical value assigned by this metric to the current image pair</p>
<p>Returns the EM (data term) energy computed at the largest
iteration</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.initialize_iteration">
<span class="sig-name descname"><span class="pre">initialize_iteration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.initialize_iteration" title="Link to this definition">#</a></dt>
<dd><p>Prepares the metric to compute one displacement field iteration.</p>
<p>Pre-computes the transfer functions (hidden random variables) and
variances of the estimators. Also pre-computes the gradient of both
input images. Note that once the images are transformed to the opposite
modality, the gradient of the transformed images can be used with the
gradient of the corresponding modality in the same fashion as
diff-demons does for mono-modality images. If the flag
self.use_double_gradient is True these gradients are averaged.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.use_moving_image_dynamics">
<span class="sig-name descname"><span class="pre">use_moving_image_dynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_moving_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.use_moving_image_dynamics" title="Link to this definition">#</a></dt>
<dd><p>This is called by the optimizer just after setting the moving image.</p>
<p>EMMetric takes advantage of the image dynamics by computing the
current moving image mask from the original_moving_image mask (warped
by nearest neighbor interpolation)</p>
<section id="id150">
<h4>Parameters<a class="headerlink" href="#id150" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>original_moving_image<span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the original moving image from which the current moving image was
generated, the current moving image is the one that was provided
via ‘set_moving_image(…)’, which may not be the same as the
original moving image but a warped version of it.</p>
</dd>
<dt>transformation<span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the transformation that was applied to the original_moving_image
to generate the current moving image</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.EMMetric.use_static_image_dynamics">
<span class="sig-name descname"><span class="pre">use_static_image_dynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_static_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.use_static_image_dynamics" title="Link to this definition">#</a></dt>
<dd><p>This is called by the optimizer just after setting the static image.</p>
<p>EMMetric takes advantage of the image dynamics by computing the
current static image mask from the originalstaticImage mask (warped
by nearest neighbor interpolation)</p>
<section id="id151">
<h4>Parameters<a class="headerlink" href="#id151" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>original_static_image<span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the original static image from which the current static image was
generated, the current static image is the one that was provided
via ‘set_static_image(…)’, which may not be the same as the
original static image but a warped version of it (even the static
image changes during Symmetric Normalization, not only the moving
one).</p>
</dd>
<dt>transformation<span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the transformation that was applied to the original_static_image
to generate the current static image</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="ssdmetric">
<h3><a class="reference internal" href="#dipy.align.metrics.SSDMetric" title="dipy.align.metrics.SSDMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSDMetric</span></code></a><a class="headerlink" href="#ssdmetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.metrics.SSDMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.metrics.</span></span><span class="sig-name descname"><span class="pre">SSDMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'demons'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SSDMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'demons'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>Sum of Squared Differences (SSD) Metric</p>
<p>Similarity metric for (mono-modal) nonlinear image registration defined
by the sum of squared differences (SSD)</p>
<section id="id152">
<h4>Parameters<a class="headerlink" href="#id152" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>dim<span class="classifier">int (either 2 or 3)</span></dt><dd><p>the dimension of the image domain</p>
</dd>
<dt>smooth<span class="classifier">float</span></dt><dd><p>smoothness parameter, the larger the value the smoother the
deformation field</p>
</dd>
<dt>inner_iter<span class="classifier">int</span></dt><dd><p>number of iterations to be performed at each level of the multi-
resolution Gauss-Seidel optimization algorithm (this is not the
number of steps per Gaussian Pyramid level, that parameter must
be set for the optimizer, not the metric)</p>
</dd>
<dt>step_type<span class="classifier">string</span></dt><dd><p>the displacement field step to be computed when ‘compute_forward’
and ‘compute_backward’ are called. Either ‘demons’ or
‘gauss_newton’</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SSDMetric.compute_backward">
<span class="sig-name descname"><span class="pre">compute_backward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.compute_backward" title="Link to this definition">#</a></dt>
<dd><p>Computes one step bringing the static image towards the moving.</p>
<p>Computes the updated displacement field to be used for registration of
the static image towards the moving image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SSDMetric.compute_demons_step">
<span class="sig-name descname"><span class="pre">compute_demons_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forward_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.compute_demons_step" title="Link to this definition">#</a></dt>
<dd><p>Demons step for SSD metric</p>
<p>Computes the demons step proposed by Vercauteren et al.[Vercauteren09]
for the SSD metric.</p>
<section id="id153">
<h4>Parameters<a class="headerlink" href="#id153" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>forward_step<span class="classifier">boolean</span></dt><dd><p>if True, computes the Demons step in the forward direction
(warping the moving towards the static image). If False,
computes the backward step (warping the static image to the
moving image)</p>
</dd>
</dl>
</section>
<section id="id154">
<h4>Returns<a class="headerlink" href="#id154" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>displacement<span class="classifier">array, shape (R, C, 2) or (S, R, C, 3)</span></dt><dd><p>the Demons step</p>
</dd>
</dl>
</section>
<section id="id155">
<h4>References<a class="headerlink" href="#id155" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>[Vercauteren09] Tom Vercauteren, Xavier Pennec, Aymeric Perchant,</dt><dd><p>Nicholas Ayache, “Diffeomorphic Demons: Efficient
Non-parametric Image Registration”, Neuroimage 2009</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SSDMetric.compute_forward">
<span class="sig-name descname"><span class="pre">compute_forward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.compute_forward" title="Link to this definition">#</a></dt>
<dd><p>Computes one step bringing the reference image towards the static.</p>
<p>Computes the update displacement field to be used for registration of
the moving image towards the static image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SSDMetric.compute_gauss_newton_step">
<span class="sig-name descname"><span class="pre">compute_gauss_newton_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forward_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.compute_gauss_newton_step" title="Link to this definition">#</a></dt>
<dd><p>Computes the Gauss-Newton energy minimization step</p>
<p>Minimizes the linearized energy function (Newton step) defined by the
sum of squared differences of corresponding pixels of the input images
with respect to the displacement field.</p>
<section id="id156">
<h4>Parameters<a class="headerlink" href="#id156" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>forward_step<span class="classifier">boolean</span></dt><dd><p>if True, computes the Newton step in the forward direction
(warping the moving towards the static image). If False,
computes the backward step (warping the static image to the
moving image)</p>
</dd>
</dl>
</section>
<section id="id157">
<h4>Returns<a class="headerlink" href="#id157" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>displacement<span class="classifier">array, shape = static_image.shape + (3,)</span></dt><dd><p>if forward_step==True, the forward SSD Gauss-Newton step,
else, the backward step</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SSDMetric.free_iteration">
<span class="sig-name descname"><span class="pre">free_iteration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.free_iteration" title="Link to this definition">#</a></dt>
<dd><p>Nothing to free for the SSD metric</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SSDMetric.get_energy">
<span class="sig-name descname"><span class="pre">get_energy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.get_energy" title="Link to this definition">#</a></dt>
<dd><p>The numerical value assigned by this metric to the current image pair</p>
<p>Returns the Sum of Squared Differences (data term) energy computed at
the largest iteration</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.metrics.SSDMetric.initialize_iteration">
<span class="sig-name descname"><span class="pre">initialize_iteration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.initialize_iteration" title="Link to this definition">#</a></dt>
<dd><p>Prepares the metric to compute one displacement field iteration.</p>
<p>Pre-computes the gradient of the input images to be used in the
computation of the forward and backward steps.</p>
</dd></dl>

</dd></dl>

</section>
<section id="v-cycle-2d">
<h3>v_cycle_2d<a class="headerlink" href="#v-cycle-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.metrics.v_cycle_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.metrics.</span></span><span class="sig-name descname"><span class="pre">v_cycle_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">displacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.v_cycle_2d" title="Link to this definition">#</a></dt>
<dd><p>Multi-resolution Gauss-Seidel solver using V-type cycles</p>
<p>Multi-resolution Gauss-Seidel solver: solves the Gauss-Newton linear system
by first filtering (GS-iterate) the current level, then solves for the
residual at a coarser resolution and finally refines the solution at the
current resolution. This scheme corresponds to the V-cycle proposed by
Bruhn and Weickert[Bruhn05].</p>
<section id="id158">
<h4>Parameters<a class="headerlink" href="#id158" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>number of levels of the multi-resolution algorithm (it will be called
recursively until level n == 0)</p>
</dd>
<dt>k<span class="classifier">int</span></dt><dd><p>the number of iterations at each multi-resolution level</p>
</dd>
<dt>delta_field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
<dt>sigma_sq_field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the variance of the gray level value at each voxel, according to the
EM model (for SSD, it is 1 for all voxels). Inf and 0 values
are processed specially to support infinite and zero variance.</p>
</dd>
<dt>gradient_field<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt>target<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>right-hand side of the linear system to be solved in the Weickert’s
multi-resolution algorithm</p>
</dd>
<dt>lambda_param<span class="classifier">float</span></dt><dd><p>smoothness parameter, the larger its value the smoother the
displacement field</p>
</dd>
<dt>displacement<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the displacement field to start the optimization from</p>
</dd>
</dl>
</section>
<section id="id159">
<h4>Returns<a class="headerlink" href="#id159" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>energy<span class="classifier">the energy of the EM (or SSD if sigmafield[…]==1) metric at this</span></dt><dd><p>iteration</p>
</dd>
</dl>
</section>
<section id="id160">
<h4>References<a class="headerlink" href="#id160" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion</dt><dd><p>estimation: combining the highest accuracy with real-time
performance”, 10th IEEE International Conference on Computer
Vision, 2005. ICCV 2005.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="v-cycle-3d">
<h3>v_cycle_3d<a class="headerlink" href="#v-cycle-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.metrics.v_cycle_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.metrics.</span></span><span class="sig-name descname"><span class="pre">v_cycle_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">displacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.v_cycle_3d" title="Link to this definition">#</a></dt>
<dd><p>Multi-resolution Gauss-Seidel solver using V-type cycles</p>
<p>Multi-resolution Gauss-Seidel solver: solves the linear system by first
filtering (GS-iterate) the current level, then solves for the residual
at a coarser resolution and finally refines the solution at the current
resolution. This scheme corresponds to the V-cycle proposed by Bruhn and
Weickert[1].
[1] Andres Bruhn and Joachim Weickert, “Towards ultimate motion estimation:</p>
<blockquote>
<div><p>combining highest accuracy with real-time performance”,
10th IEEE International Conference on Computer Vision, 2005.
ICCV 2005.</p>
</div></blockquote>
<section id="id161">
<h4>Parameters<a class="headerlink" href="#id161" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>number of levels of the multi-resolution algorithm (it will be called
recursively until level n == 0)</p>
</dd>
<dt>k<span class="classifier">int</span></dt><dd><p>the number of iterations at each multi-resolution level</p>
</dd>
<dt>delta_field<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
<dt>sigma_sq_field<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the variance of the gray level value at each voxel, according to the
EM model (for SSD, it is 1 for all voxels). Inf and 0 values
are processed specially to support infinite and zero variance.</p>
</dd>
<dt>gradient_field<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt>target<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>right-hand side of the linear system to be solved in the Weickert’s
multi-resolution algorithm</p>
</dd>
<dt>lambda_param<span class="classifier">float</span></dt><dd><p>smoothness parameter, the larger its value the smoother the
displacement field</p>
</dd>
<dt>displacement<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the displacement field to start the optimization from</p>
</dd>
</dl>
</section>
<section id="id162">
<h4>Returns<a class="headerlink" href="#id162" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>energy<span class="classifier">the energy of the EM (or SSD if sigmafield[…]==1) metric at this</span></dt><dd><p>iteration</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="parzenjointhistogram">
<h3><a class="reference internal" href="#dipy.align.parzenhist.ParzenJointHistogram" title="dipy.align.parzenhist.ParzenJointHistogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParzenJointHistogram</span></code></a><a class="headerlink" href="#parzenjointhistogram" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.parzenhist.</span></span><span class="sig-name descname"><span class="pre">ParzenJointHistogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbins</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbins</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram.__init__" title="Link to this definition">#</a></dt>
<dd><p>Computes joint histogram and derivatives with Parzen windows</p>
<p>Base class to compute joint and marginal probability density
functions and their derivatives with respect to a transform’s
parameters. The smooth histograms are computed by using Parzen
windows [Parzen62] with a cubic spline kernel, as proposed by
Mattes et al. [Mattes03]. This implementation is not tied to any
optimization (registration) method, the idea is that
information-theoretic matching functionals (such as Mutual
Information) can inherit from this class to perform the low-level
computations of the joint intensity distributions and its gradient
w.r.t. the transform parameters. The derived class can then compute
the similarity/dissimilarity measure and gradient, and finally
communicate the results to the appropriate optimizer.</p>
<section id="id163">
<h4>Parameters<a class="headerlink" href="#id163" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>nbins<span class="classifier">int</span></dt><dd><p>the number of bins of the joint and marginal probability density
functions (the actual number of bins of the joint PDF is nbins**2)</p>
</dd>
</dl>
</section>
<section id="id164">
<h4>References<a class="headerlink" href="#id164" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>[Parzen62] E. Parzen. On the estimation of a probability density</dt><dd><p>function and the mode. Annals of Mathematical Statistics,
33(3), 1065-1076, 1962.</p>
</dd>
<dt>[Mattes03] Mattes, D., Haynor, D. R., Vesselle, H., Lewellen, T. K.,</dt><dd><p>&amp; Eubank, W. PET-CT image registration in the chest using
free-form deformations. IEEE Transactions on Medical
Imaging, 22(1), 120-8, 2003.</p>
</dd>
</dl>
</section>
<section id="id165">
<h4>Notes<a class="headerlink" href="#id165" title="Link to this heading">#</a></h4>
<p>We need this class in cython to allow _joint_pdf_gradient_dense_2d and
_joint_pdf_gradient_dense_3d to use a nogil Jacobian function (obtained
from an instance of the Transform class), which allows us to evaluate
Jacobians at all the sampling points (maybe the full grid) inside a
nogil loop.</p>
<p>The reason we need a class is to encapsulate all the parameters related
to the joint and marginal distributions.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram.bin_index">
<span class="sig-name descname"><span class="pre">bin_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xnorm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram.bin_index" title="Link to this definition">#</a></dt>
<dd><p>Bin index associated with the given normalized intensity</p>
<p>The return value is an integer in [padding, nbins - 1 - padding]</p>
<section id="id166">
<h4>Parameters<a class="headerlink" href="#id166" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>xnorm<span class="classifier">float</span></dt><dd><p>intensity value normalized to the range covered by the histogram</p>
</dd>
</dl>
</section>
<section id="id167">
<h4>Returns<a class="headerlink" href="#id167" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>bin<span class="classifier">int</span></dt><dd><p>the bin index associated with the given normalized intensity</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram.bin_normalize_moving">
<span class="sig-name descname"><span class="pre">bin_normalize_moving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram.bin_normalize_moving" title="Link to this definition">#</a></dt>
<dd><p>Maps intensity x to the range covered by the moving histogram</p>
<p>If the input intensity is in [self.mmin, self.mmax] then the normalized
intensity will be in [self.padding, self.nbins - self.padding]</p>
<section id="id168">
<h4>Parameters<a class="headerlink" href="#id168" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>x<span class="classifier">float</span></dt><dd><p>the intensity to be normalized</p>
</dd>
</dl>
</section>
<section id="id169">
<h4>Returns<a class="headerlink" href="#id169" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>xnorm<span class="classifier">float</span></dt><dd><p>normalized intensity to the range covered by the moving histogram</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram.bin_normalize_static">
<span class="sig-name descname"><span class="pre">bin_normalize_static</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram.bin_normalize_static" title="Link to this definition">#</a></dt>
<dd><p>Maps intensity x to the range covered by the static histogram</p>
<p>If the input intensity is in [self.smin, self.smax] then the normalized
intensity will be in [self.padding, self.nbins - self.padding]</p>
<section id="id170">
<h4>Parameters<a class="headerlink" href="#id170" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>x<span class="classifier">float</span></dt><dd><p>the intensity to be normalized</p>
</dd>
</dl>
</section>
<section id="id171">
<h4>Returns<a class="headerlink" href="#id171" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>xnorm<span class="classifier">float</span></dt><dd><p>normalized intensity to the range covered by the static histogram</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram.setup">
<span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram.setup" title="Link to this definition">#</a></dt>
<dd><p>Compute histogram settings to store the PDF of input images</p>
<section id="id172">
<h4>Parameters<a class="headerlink" href="#id172" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">array</span></dt><dd><p>static image</p>
</dd>
<dt>moving<span class="classifier">array</span></dt><dd><p>moving image</p>
</dd>
<dt>smask<span class="classifier">array</span></dt><dd><p>mask of static object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
If None, the behaviour is equivalent to smask=ones_like(static)</p>
</dd>
<dt>mmask<span class="classifier">array</span></dt><dd><p>mask of moving object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
If None, the behaviour is equivalent to mmask=ones_like(static)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram.update_gradient_dense">
<span class="sig-name descname"><span class="pre">update_gradient_dense</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mgradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram.update_gradient_dense" title="Link to this definition">#</a></dt>
<dd><p>Computes the Gradient of the joint PDF w.r.t. transform parameters</p>
<p>Computes the vector of partial derivatives of the joint histogram
w.r.t. each transformation parameter.</p>
<p>The gradient is stored in self.joint_grad.</p>
<section id="id173">
<h4>Parameters<a class="headerlink" href="#id173" title="Link to this heading">#</a></h4>
<dl>
<dt>theta<span class="classifier">array, shape (n,)</span></dt><dd><p>parameters of the transformation to compute the gradient from</p>
</dd>
<dt>transform<span class="classifier">instance of Transform</span></dt><dd><p>the transformation with respect to whose parameters the gradient
must be computed</p>
</dd>
<dt>static<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt>moving<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt>grid2world<span class="classifier">array, shape (4, 4)</span></dt><dd><p>we assume that both images have already been sampled at a common
grid. This transform must map voxel coordinates of this common grid
to physical coordinates of its corresponding voxel in the moving
image. For example, if the moving image was sampled on the static
image’s grid (this is the typical setting) using an aligning
matrix A, then</p>
<ol class="arabic simple">
<li><p>grid2world = A.dot(static_affine)</p></li>
</ol>
<p>where static_affine is the transformation mapping static image’s
grid coordinates to physical space.</p>
</dd>
<dt>mgradient<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt>smask<span class="classifier">array, shape (S, R, C), optional</span></dt><dd><p>mask of static object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
The default is None, indicating all voxels are considered.</p>
</dd>
<dt>mmask<span class="classifier">array, shape (S, R, C), optional</span></dt><dd><p>mask of moving object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
The default is None, indicating all voxels are considered.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram.update_gradient_sparse">
<span class="sig-name descname"><span class="pre">update_gradient_sparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mgradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram.update_gradient_sparse" title="Link to this definition">#</a></dt>
<dd><p>Computes the Gradient of the joint PDF w.r.t. transform parameters</p>
<p>Computes the vector of partial derivatives of the joint histogram
w.r.t. each transformation parameter.</p>
<p>The list of intensities <cite>sval</cite> and <cite>mval</cite> are assumed to be sampled
from the static and moving images, respectively, at the same
physical points. Of course, the images may not be perfectly aligned
at the moment the sampling was performed. The resulting  gradient
corresponds to the paired intensities according to the alignment at the
moment the images were sampled.</p>
<p>The gradient is stored in self.joint_grad.</p>
<section id="id174">
<h4>Parameters<a class="headerlink" href="#id174" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>theta<span class="classifier">array, shape (n,)</span></dt><dd><p>parameters to compute the gradient at</p>
</dd>
<dt>transform<span class="classifier">instance of Transform</span></dt><dd><p>the transformation with respect to whose parameters the gradient
must be computed</p>
</dd>
<dt>sval<span class="classifier">array, shape (m,)</span></dt><dd><p>sampled intensities from the static image at sampled_points</p>
</dd>
<dt>mval<span class="classifier">array, shape (m,)</span></dt><dd><p>sampled intensities from the moving image at sampled_points</p>
</dd>
<dt>sample_points<span class="classifier">array, shape (m, 3)</span></dt><dd><p>coordinates (in physical space) of the points the images were
sampled at</p>
</dd>
<dt>mgradient<span class="classifier">array, shape (m, 3)</span></dt><dd><p>the gradient of the moving image at the sample points</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram.update_pdfs_dense">
<span class="sig-name descname"><span class="pre">update_pdfs_dense</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram.update_pdfs_dense" title="Link to this definition">#</a></dt>
<dd><p>Computes the Probability Density Functions of two images</p>
<p>The joint PDF is stored in self.joint. The marginal distributions
corresponding to the static and moving images are computed and
stored in self.smarginal and self.mmarginal, respectively.</p>
<section id="id175">
<h4>Parameters<a class="headerlink" href="#id175" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt>moving<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt>smask<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>mask of static object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
If None, ones_like(static) is used as mask.</p>
</dd>
<dt>mmask<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>mask of moving object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
If None, ones_like(moving) is used as mask.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.parzenhist.ParzenJointHistogram.update_pdfs_sparse">
<span class="sig-name descname"><span class="pre">update_pdfs_sparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.ParzenJointHistogram.update_pdfs_sparse" title="Link to this definition">#</a></dt>
<dd><p>Computes the Probability Density Functions from a set of samples</p>
<p>The list of intensities <cite>sval</cite> and <cite>mval</cite> are assumed to be sampled
from the static and moving images, respectively, at the same
physical points. Of course, the images may not be perfectly aligned
at the moment the sampling was performed. The resulting  distributions
corresponds to the paired intensities according to the alignment at the
moment the images were sampled.</p>
<p>The joint PDF is stored in self.joint. The marginal distributions
corresponding to the static and moving images are computed and
stored in self.smarginal and self.mmarginal, respectively.</p>
<section id="id176">
<h4>Parameters<a class="headerlink" href="#id176" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>sval<span class="classifier">array, shape (n,)</span></dt><dd><p>sampled intensities from the static image at sampled_points</p>
</dd>
<dt>mval<span class="classifier">array, shape (n,)</span></dt><dd><p>sampled intensities from the moving image at sampled_points</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="compute-parzen-mi">
<h3>compute_parzen_mi<a class="headerlink" href="#compute-parzen-mi" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.parzenhist.compute_parzen_mi">
<span class="sig-prename descclassname"><span class="pre">dipy.align.parzenhist.</span></span><span class="sig-name descname"><span class="pre">compute_parzen_mi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">joint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smarginal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmarginal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mi_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.compute_parzen_mi" title="Link to this definition">#</a></dt>
<dd><p>Computes the mutual information and its gradient (if requested)</p>
<section id="id177">
<h4>Parameters<a class="headerlink" href="#id177" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>joint<span class="classifier">array, shape (nbins, nbins)</span></dt><dd><p>the joint intensity distribution</p>
</dd>
<dt>joint_gradient<span class="classifier">array, shape (nbins, nbins, n)</span></dt><dd><p>the gradient of the joint distribution w.r.t. the transformation
parameters</p>
</dd>
<dt>smarginal<span class="classifier">array, shape (nbins,)</span></dt><dd><p>the marginal intensity distribution of the static image</p>
</dd>
<dt>mmarginal<span class="classifier">array, shape (nbins,)</span></dt><dd><p>the marginal intensity distribution of the moving image</p>
</dd>
<dt>mi_gradient<span class="classifier">array, shape (n,)</span></dt><dd><p>the buffer in which to write the gradient of the mutual information.
If None, the gradient is not computed</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="cubic-spline">
<h3>cubic_spline<a class="headerlink" href="#cubic-spline" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.parzenhist.cubic_spline">
<span class="sig-prename descclassname"><span class="pre">dipy.align.parzenhist.</span></span><span class="sig-name descname"><span class="pre">cubic_spline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.cubic_spline" title="Link to this definition">#</a></dt>
<dd><p>Evaluates the cubic spline at a set of values</p>
<section id="id178">
<h4>Parameters<a class="headerlink" href="#id178" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>x<span class="classifier">array, shape (n)</span></dt><dd><p>input values</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="cubic-spline-derivative">
<h3>cubic_spline_derivative<a class="headerlink" href="#cubic-spline-derivative" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.parzenhist.cubic_spline_derivative">
<span class="sig-prename descclassname"><span class="pre">dipy.align.parzenhist.</span></span><span class="sig-name descname"><span class="pre">cubic_spline_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.cubic_spline_derivative" title="Link to this definition">#</a></dt>
<dd><p>Evaluates the cubic spline derivative at a set of values</p>
<section id="id179">
<h4>Parameters<a class="headerlink" href="#id179" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>x<span class="classifier">array, shape (n)</span></dt><dd><p>input values</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="sample-domain-regular">
<h3>sample_domain_regular<a class="headerlink" href="#sample-domain-regular" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.parzenhist.sample_domain_regular">
<span class="sig-prename descclassname"><span class="pre">dipy.align.parzenhist.</span></span><span class="sig-name descname"><span class="pre">sample_domain_regular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.parzenhist.sample_domain_regular" title="Link to this definition">#</a></dt>
<dd><p>Take floor(total_voxels/k) samples from a (2D or 3D) grid</p>
<p>The sampling is made by taking all pixels whose index (in lexicographical
order) is a multiple of k. Each selected point is slightly perturbed by
adding a realization of a normally distributed random variable and then
mapped to physical space by the given grid-to-space transform.</p>
<p>The lexicographical order of a pixels in a grid of shape (a, b, c) is
defined by assigning to each voxel position (i, j, k) the integer index</p>
<p>F((i, j, k)) = i * (b * c) + j * (c) + k</p>
<p>and sorting increasingly by this index.</p>
<section id="id180">
<h4>Parameters<a class="headerlink" href="#id180" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>k<span class="classifier">int</span></dt><dd><p>the sampling rate, as described before</p>
</dd>
<dt>shape<span class="classifier">array, shape (dim,)</span></dt><dd><p>the shape of the grid to be sampled</p>
</dd>
<dt>grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the grid-to-space transform</p>
</dd>
<dt>sigma<span class="classifier">float</span></dt><dd><p>the standard deviation of the Normal random distortion to be applied
to the sampled points</p>
</dd>
</dl>
</section>
<section id="id181">
<h4>Returns<a class="headerlink" href="#id181" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>samples<span class="classifier">array, shape (total_pixels//k, dim)</span></dt><dd><p>the matrix whose rows are the sampled points</p>
</dd>
</dl>
</section>
<section id="examples">
<h4>Examples<a class="headerlink" href="#examples" title="Link to this heading">#</a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.align.parzenhist</span> <span class="kn">import</span> <span class="n">sample_domain_regular</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dipy.align.vector_fields</span> <span class="k">as</span> <span class="nn">vf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid2world</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sample_domain_regular</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">grid2world</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="n">k</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">isamples</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">isamples</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">indices</span><span class="o">%</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="reslice">
<h3>reslice<a class="headerlink" href="#reslice" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.reslice.reslice">
<span class="sig-prename descclassname"><span class="pre">dipy.align.reslice.</span></span><span class="sig-name descname"><span class="pre">reslice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zooms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_zooms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.reslice.reslice" title="Link to this definition">#</a></dt>
<dd><p>Reslice data with new voxel resolution defined by <code class="docutils literal notranslate"><span class="pre">new_zooms</span></code>.</p>
<section id="id182">
<h4>Parameters<a class="headerlink" href="#id182" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">array, shape (I,J,K) or (I,J,K,N)</span></dt><dd><p>3d volume or 4d volume with datasets</p>
</dd>
<dt>affine<span class="classifier">array, shape (4,4)</span></dt><dd><p>mapping from voxel coordinates to world coordinates</p>
</dd>
<dt>zooms<span class="classifier">tuple, shape (3,)</span></dt><dd><p>voxel size for (i,j,k) dimensions</p>
</dd>
<dt>new_zooms<span class="classifier">tuple, shape (3,)</span></dt><dd><p>new voxel size for (i,j,k) after resampling</p>
</dd>
<dt>order<span class="classifier">int, from 0 to 5</span></dt><dd><p>order of interpolation for resampling/reslicing,
0 nearest interpolation, 1 trilinear etc..
if you don’t want any smoothing 0 is the option you need.</p>
</dd>
<dt>mode<span class="classifier">string (‘constant’, ‘nearest’, ‘reflect’ or ‘wrap’)</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.</p>
</dd>
<dt>cval<span class="classifier">float</span></dt><dd><p>Value used for points outside the boundaries of the input if
mode=’constant’.</p>
</dd>
<dt>num_processes<span class="classifier">int, optional</span></dt><dd><p>Split the calculation to a pool of children processes. This only
applies to 4D <cite>data</cite> arrays. Default is 1. If &lt; 0 the maximal number
of cores minus <code class="docutils literal notranslate"><span class="pre">num_processes</span> <span class="pre">+</span> <span class="pre">1</span></code> is used (enter -1 to use as many
cores as possible). 0 raises an error.</p>
</dd>
</dl>
</section>
<section id="id183">
<h4>Returns<a class="headerlink" href="#id183" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>data2<span class="classifier">array, shape (I,J,K) or (I,J,K,N)</span></dt><dd><p>datasets resampled into isotropic voxel size</p>
</dd>
<dt>affine2<span class="classifier">array, shape (4,4)</span></dt><dd><p>new affine for the resampled image</p>
</dd>
</dl>
</section>
<section id="id184">
<h4>Examples<a class="headerlink" href="#id184" title="Link to this heading">#</a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.io.image</span> <span class="kn">import</span> <span class="n">load_nifti</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.align.reslice</span> <span class="kn">import</span> <span class="n">reslice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="kn">import</span> <span class="n">get_fnames</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_name</span> <span class="o">=</span> <span class="n">get_fnames</span><span class="p">(</span><span class="s1">&#39;aniso_vox&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">zooms</span> <span class="o">=</span> <span class="n">load_nifti</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">return_voxsize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zooms</span>
<span class="go">(4.0, 4.0, 5.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_zooms</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">3.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_zooms</span>
<span class="go">(3.0, 3.0, 3.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data2</span><span class="p">,</span> <span class="n">affine2</span> <span class="o">=</span> <span class="n">reslice</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">zooms</span><span class="p">,</span> <span class="n">new_zooms</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data2</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="scalespace">
<h3><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace" title="dipy.align.scalespace.ScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a><a class="headerlink" href="#scalespace" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.scalespace.</span></span><span class="sig-name descname"><span class="pre">ScaleSpace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.__init__" title="Link to this definition">#</a></dt>
<dd><p>ScaleSpace.

Computes the Scale Space representation of an image. The scale space is
simply a list of images produced by smoothing the input image with a
Gaussian kernel with increasing smoothing parameter. If the image’s
voxels are isotropic, the smoothing will be the same along all
directions: at level L = 0, 1, …, the sigma is given by
<span class="math notranslate nohighlight">\(s * ( 2^L - 1 )\)</span>.
If the voxel dimensions are not isotropic, then the smoothing is
weaker along low resolution directions.

Parameters
———-
image : array, shape (r,c) or (s, r, c) where s is the number of
    slices, r is the number of rows and c is the number of columns of
    the input image.
num_levels : int
    the desired number of levels (resolutions) of the scale space
image_grid2world : array, shape (dim + 1, dim + 1), optional
    the grid-to-space transform of the image grid. The default is
    the identity matrix
input_spacing : array, shape (dim,), optional
    the spacing (voxel size) between voxels in physical space. The
    default is 1.0 along all axes
sigma_factor : float, optional
    the smoothing factor to be used in the construction of the scale
    space. The default is 0.2
mask0 : Boolean, optional
    if True, all smoothed images will be zero at all voxels that are
    zero in the input image. The default is False.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.get_affine">
<span class="sig-name descname"><span class="pre">get_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_affine" title="Link to this definition">#</a></dt>
<dd><p>Voxel-to-space transformation at a given level.</p>
<p>Returns the voxel-to-space transformation associated with the
sub-sampled image at a particular resolution of the scale space (note
that this object does not explicitly subsample the smoothed images, but
only provides the properties the sub-sampled images must have).</p>
<section id="id185">
<h4>Parameters<a class="headerlink" href="#id185" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>level<span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get affine transform from</p>
</dd>
</dl>
</section>
<section id="id186">
<h4>Returns<a class="headerlink" href="#id186" title="Link to this heading">#</a></h4>
<blockquote>
<div><p>the affine (voxel-to-space) transform at the requested resolution
or None if an invalid level was requested</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.get_affine_inv">
<span class="sig-name descname"><span class="pre">get_affine_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_affine_inv" title="Link to this definition">#</a></dt>
<dd><p>Space-to-voxel transformation at a given level.</p>
<p>Returns the space-to-voxel transformation associated with the
sub-sampled image at a particular resolution of the scale space (note
that this object does not explicitly subsample the smoothed images, but
only provides the properties the sub-sampled images must have).</p>
<section id="id187">
<h4>Parameters<a class="headerlink" href="#id187" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>level<span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the inverse transform from</p>
</dd>
</dl>
</section>
<section id="id188">
<h4>Returns<a class="headerlink" href="#id188" title="Link to this heading">#</a></h4>
<p>the inverse (space-to-voxel) transform at the requested resolution or
None if an invalid level was requested</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.get_domain_shape">
<span class="sig-name descname"><span class="pre">get_domain_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_domain_shape" title="Link to this definition">#</a></dt>
<dd><p>Shape the sub-sampled image must have at a particular level.</p>
<p>Returns the shape the sub-sampled image must have at a particular
resolution of the scale space (note that this object does not
explicitly subsample the smoothed images, but only provides the
properties the sub-sampled images must have).</p>
<section id="id189">
<h4>Parameters<a class="headerlink" href="#id189" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>level<span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the sub-sampled shape from</p>
</dd>
</dl>
</section>
<section id="id190">
<h4>Returns<a class="headerlink" href="#id190" title="Link to this heading">#</a></h4>
<blockquote>
<div><p>the sub-sampled shape at the requested resolution or None if an
invalid level was requested</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.get_expand_factors">
<span class="sig-name descname"><span class="pre">get_expand_factors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_expand_factors" title="Link to this definition">#</a></dt>
<dd><p>Ratio of voxel size from pyramid level from_level to to_level.</p>
<p>Given two scale space resolutions a = from_level, b = to_level,
returns the ratio of voxels size at level b to voxel size at level a
(the factor that must be used to multiply voxels at level a to
‘expand’ them to level b).</p>
<section id="id191">
<h4>Parameters<a class="headerlink" href="#id191" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>from_level<span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the resolution to expand voxels from</p>
</dd>
<dt>to_level<span class="classifier">int, 0 &lt;= to_level &lt; from_level</span></dt><dd><p>the resolution to expand voxels to</p>
</dd>
</dl>
</section>
<section id="id192">
<h4>Returns<a class="headerlink" href="#id192" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>factors<span class="classifier">array, shape (k,), k = 2, 3</span></dt><dd><p>the expand factors (a scalar for each voxel dimension)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.get_image">
<span class="sig-name descname"><span class="pre">get_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_image" title="Link to this definition">#</a></dt>
<dd><p>Smoothed image at a given level.</p>
<p>Returns the smoothed image at the requested level in the Scale Space.</p>
<section id="id193">
<h4>Parameters<a class="headerlink" href="#id193" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>level<span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the smooth image from</p>
</dd>
</dl>
</section>
<section id="id194">
<h4>Returns<a class="headerlink" href="#id194" title="Link to this heading">#</a></h4>
<blockquote>
<div><p>the smooth image at the requested resolution or None if an invalid
level was requested</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.get_scaling">
<span class="sig-name descname"><span class="pre">get_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_scaling" title="Link to this definition">#</a></dt>
<dd><p>Adjustment factor for input-spacing to reflect voxel sizes at level.</p>
<p>Returns the scaling factor that needs to be applied to the input
spacing (the voxel sizes of the image at level 0 of the scale space) to
transform them to voxel sizes at the requested level.</p>
<section id="id195">
<h4>Parameters<a class="headerlink" href="#id195" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>level<span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the scalings from</p>
</dd>
</dl>
</section>
<section id="id196">
<h4>Returns<a class="headerlink" href="#id196" title="Link to this heading">#</a></h4>
<p>the scaling factors from the original spacing to the spacings at the
requested level</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.get_sigmas">
<span class="sig-name descname"><span class="pre">get_sigmas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_sigmas" title="Link to this definition">#</a></dt>
<dd><p>Smoothing parameters used at a given level.</p>
<p>Returns the smoothing parameters (a scalar for each axis) used at the
requested level of the scale space</p>
<section id="id197">
<h4>Parameters<a class="headerlink" href="#id197" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>level<span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the smoothing parameters from</p>
</dd>
</dl>
</section>
<section id="id198">
<h4>Returns<a class="headerlink" href="#id198" title="Link to this heading">#</a></h4>
<p>the smoothing parameters at the requested level</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.get_spacing">
<span class="sig-name descname"><span class="pre">get_spacing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_spacing" title="Link to this definition">#</a></dt>
<dd><p>Spacings the sub-sampled image must have at a particular level.</p>
<p>Returns the spacings (voxel sizes) the sub-sampled image must have at a
particular resolution of the scale space (note that this object does
not explicitly subsample the smoothed images, but only provides the
properties the sub-sampled images must have).</p>
<section id="id199">
<h4>Parameters<a class="headerlink" href="#id199" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>level<span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the sub-sampled shape from</p>
</dd>
</dl>
</section>
<section id="id200">
<h4>Returns<a class="headerlink" href="#id200" title="Link to this heading">#</a></h4>
<p>the spacings (voxel sizes) at the requested resolution or None if an
invalid level was requested</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.ScaleSpace.print_level">
<span class="sig-name descname"><span class="pre">print_level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.print_level" title="Link to this definition">#</a></dt>
<dd><p>Prints properties of a pyramid level.</p>
<p>Prints the properties of a level of this scale space to standard output</p>
<section id="id201">
<h4>Parameters<a class="headerlink" href="#id201" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>level<span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to be printed</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="isotropicscalespace">
<h3><a class="reference internal" href="#dipy.align.scalespace.IsotropicScaleSpace" title="dipy.align.scalespace.IsotropicScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a><a class="headerlink" href="#isotropicscalespace" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.scalespace.IsotropicScaleSpace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.scalespace.</span></span><span class="sig-name descname"><span class="pre">IsotropicScaleSpace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.IsotropicScaleSpace" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.scalespace.ScaleSpace" title="dipy.align.scalespace.ScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.scalespace.IsotropicScaleSpace.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_grid2world</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.IsotropicScaleSpace.__init__" title="Link to this definition">#</a></dt>
<dd><p>IsotropicScaleSpace.</p>
<p>Computes the Scale Space representation of an image using isotropic
smoothing kernels for all scales. The scale space is simply a list
of images produced by smoothing the input image with a Gaussian
kernel with different smoothing parameters.</p>
<p>This specialization of ScaleSpace allows the user to provide custom
scale and smoothing factors for all scales.</p>
<section id="id202">
<h4>Parameters<a class="headerlink" href="#id202" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>image<span class="classifier">array, shape (r,c) or (s, r, c) where s is the number of</span></dt><dd><p>slices, r is the number of rows and c is the number of columns of
the input image.</p>
</dd>
<dt>factors<span class="classifier">list of floats</span></dt><dd><p>custom scale factors to build the scale space (one factor for each
scale).</p>
</dd>
<dt>sigmas<span class="classifier">list of floats</span></dt><dd><p>custom smoothing parameter to build the scale space (one parameter
for each scale).</p>
</dd>
<dt>image_grid2world<span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-space transform of the image grid. The default is
the identity matrix.</p>
</dd>
<dt>input_spacing<span class="classifier">array, shape (dim,), optional</span></dt><dd><p>the spacing (voxel size) between voxels in physical space. The
default if 1.0 along all axes.</p>
</dd>
<dt>mask0<span class="classifier">Boolean, optional</span></dt><dd><p>if True, all smoothed images will be zero at all voxels that are
zero in the input image. The default is False.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="id203">
<h3>logger<a class="headerlink" href="#id203" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.scalespace.logger">
<span class="sig-prename descclassname"><span class="pre">dipy.align.scalespace.</span></span><span class="sig-name descname"><span class="pre">logger</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.logger" title="Link to this definition">#</a></dt>
<dd><p>Instances of the Logger class represent a single logging channel. A
“logging channel” indicates an area of an application. Exactly how an
“area” is defined is up to the application developer. Since an
application can have any number of areas, logging channels are identified
by a unique string. Application areas can be nested (e.g. an area
of “input processing” might include sub-areas “read CSV files”, “read
XLS files” and “read Gnumeric files”). To cater for this natural nesting,
channel names are organized into a namespace hierarchy where levels are
separated by periods, much like the Java or Python package namespace. So
in the instance given above, channel names might be “input” for the upper
level, and “input.csv”, “input.xls” and “input.gnu” for the sub-levels.
There is no arbitrary limit to the depth of nesting.</p>
</dd></dl>

</section>
<section id="streamlinedistancemetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a><a class="headerlink" href="#streamlinedistancemetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineDistanceMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">StreamlineDistanceMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineDistanceMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineDistanceMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>An abstract class for the metric used for streamline registration.</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<section id="id204">
<h4>Parameters<a class="headerlink" href="#id204" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id377"><span class="problematic" id="id378">|num_threads + 1|</span></a> is used (enter -1
to use as many threads as possible). 0 raises an error. Only
metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineDistanceMetric.distance">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineDistanceMetric.distance" title="Link to this definition">#</a></dt>
<dd><p>calculate distance for current set of parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineDistanceMetric.setup">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineDistanceMetric.setup" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="bundlemindistancemetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMetric" title="dipy.align.streamlinear.BundleMinDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a><a class="headerlink" href="#bundlemindistancemetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">BundleMinDistanceMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a></p>
<p>Bundle-based Minimum Distance aka BMD</p>
<p>This is the cost function used by the StreamlineLinearRegistration.</p>
<section id="methods">
<h4>Methods<a class="headerlink" href="#methods" title="Link to this heading">#</a></h4>
<p>setup(static, moving)
distance(xopt)</p>
</section>
<section id="id205">
<h4>References<a class="headerlink" href="#id205" title="Link to this heading">#</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="garyfallidis14" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Garyfallidis14<span class="fn-bracket">]</span></span>
<p>Garyfallidis et al., “Direct native-space fiber
bundle alignment for group comparisons”, ISMRM,
2014.</p>
</div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>An abstract class for the metric used for streamline registration.</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<section id="id206">
<h5>Parameters<a class="headerlink" href="#id206" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id379"><span class="problematic" id="id380">|num_threads + 1|</span></a> is used (enter -1
to use as many threads as possible). 0 raises an error. Only
metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceMetric.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMetric.distance" title="Link to this definition">#</a></dt>
<dd><p>Distance calculated from this Metric.</p>
<section id="id207">
<h5>Parameters<a class="headerlink" href="#id207" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>xopt<span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector,</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceMetric.setup">
<span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMetric.setup" title="Link to this definition">#</a></dt>
<dd><p>Setup static and moving sets of streamlines.</p>
<section id="id208">
<h5>Parameters<a class="headerlink" href="#id208" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>static<span class="classifier">streamlines</span></dt><dd><p>Fixed or reference set of streamlines.</p>
</dd>
<dt>moving<span class="classifier">streamlines</span></dt><dd><p>Moving streamlines.</p>
</dd>
</dl>
</section>
<section id="id209">
<h5>Notes<a class="headerlink" href="#id209" title="Link to this heading">#</a></h5>
<p>Call this after the object is initiated and before distance.</p>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="bundlemindistancematrixmetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric" title="dipy.align.streamlinear.BundleMinDistanceMatrixMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric</span></code></a><a class="headerlink" href="#bundlemindistancematrixmetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceMatrixMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">BundleMinDistanceMatrixMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a></p>
<p>Bundle-based Minimum Distance aka BMD</p>
<p>This is the cost function used by the StreamlineLinearRegistration</p>
<section id="id210">
<h4>Methods<a class="headerlink" href="#id210" title="Link to this heading">#</a></h4>
<p>setup(static, moving)
distance(xopt)</p>
</section>
<section id="id211">
<h4>Notes<a class="headerlink" href="#id211" title="Link to this heading">#</a></h4>
<p>The difference with BundleMinDistanceMetric is that this creates
the entire distance matrix and therefore requires more memory.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceMatrixMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>An abstract class for the metric used for streamline registration.</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<section id="id212">
<h5>Parameters<a class="headerlink" href="#id212" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id381"><span class="problematic" id="id382">|num_threads + 1|</span></a> is used (enter -1
to use as many threads as possible). 0 raises an error. Only
metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceMatrixMetric.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric.distance" title="Link to this definition">#</a></dt>
<dd><p>Distance calculated from this Metric.</p>
<section id="id213">
<h5>Parameters<a class="headerlink" href="#id213" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>xopt<span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceMatrixMetric.setup">
<span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric.setup" title="Link to this definition">#</a></dt>
<dd><p>Setup static and moving sets of streamlines.</p>
<section id="id214">
<h5>Parameters<a class="headerlink" href="#id214" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>static<span class="classifier">streamlines</span></dt><dd><p>Fixed or reference set of streamlines.</p>
</dd>
<dt>moving<span class="classifier">streamlines</span></dt><dd><p>Moving streamlines.</p>
</dd>
</dl>
</section>
<section id="id215">
<h5>Notes<a class="headerlink" href="#id215" title="Link to this heading">#</a></h5>
<p>Call this after the object is initiated and before distance.</p>
<p>Num_threads is not used in this class. Use <code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code>
for a faster, threaded and less memory hungry metric</p>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="bundlemindistanceasymmetricmetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric" title="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a><a class="headerlink" href="#bundlemindistanceasymmetricmetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">BundleMinDistanceAsymmetricMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMetric" title="dipy.align.streamlinear.BundleMinDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a></p>
<p>Asymmetric Bundle-based Minimum distance.</p>
<p>This is a cost function that can be used by the
StreamlineLinearRegistration class.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>An abstract class for the metric used for streamline registration.</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<section id="id216">
<h4>Parameters<a class="headerlink" href="#id216" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id383"><span class="problematic" id="id384">|num_threads + 1|</span></a> is used (enter -1
to use as many threads as possible). 0 raises an error. Only
metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.distance" title="Link to this definition">#</a></dt>
<dd><p>Distance calculated from this Metric.</p>
<section id="id217">
<h4>Parameters<a class="headerlink" href="#id217" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>xopt<span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="bundlesumdistancematrixmetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric" title="dipy.align.streamlinear.BundleSumDistanceMatrixMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a><a class="headerlink" href="#bundlesumdistancematrixmetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleSumDistanceMatrixMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">BundleSumDistanceMatrixMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric" title="dipy.align.streamlinear.BundleMinDistanceMatrixMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric</span></code></a></p>
<p>Bundle-based Sum Distance aka BMD</p>
<p>This is a cost function that can be used by the
StreamlineLinearRegistration class.</p>
<section id="id218">
<h4>Methods<a class="headerlink" href="#id218" title="Link to this heading">#</a></h4>
<p>setup(static, moving)
distance(xopt)</p>
</section>
<section id="id219">
<h4>Notes<a class="headerlink" href="#id219" title="Link to this heading">#</a></h4>
<p>The difference with BundleMinDistanceMatrixMetric is that it uses
uses the sum of the distance matrix and not the sum of mins.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleSumDistanceMatrixMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>An abstract class for the metric used for streamline registration.</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<section id="id220">
<h5>Parameters<a class="headerlink" href="#id220" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id385"><span class="problematic" id="id386">|num_threads + 1|</span></a> is used (enter -1
to use as many threads as possible). 0 raises an error. Only
metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.BundleSumDistanceMatrixMetric.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric.distance" title="Link to this definition">#</a></dt>
<dd><p>Distance calculated from this Metric</p>
<section id="id221">
<h5>Parameters<a class="headerlink" href="#id221" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>xopt<span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="jointbundlemindistancemetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric" title="dipy.align.streamlinear.JointBundleMinDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">JointBundleMinDistanceMetric</span></code></a><a class="headerlink" href="#jointbundlemindistancemetric" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.streamlinear.JointBundleMinDistanceMetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">JointBundleMinDistanceMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a></p>
<p>Bundle-based Minimum Distance for joint optimization.</p>
<p>This cost function is used by the StreamlineLinearRegistration class when
running halfway streamline linear registration for unbiased groupwise
bundle registration and atlasing.</p>
<p>It computes the BMD distance after moving both static and moving bundles to
a halfway space in between both.</p>
<section id="id222">
<h4>Methods<a class="headerlink" href="#id222" title="Link to this heading">#</a></h4>
<p>setup(static, moving)
distance(xopt)</p>
</section>
<section id="id223">
<h4>Notes<a class="headerlink" href="#id223" title="Link to this heading">#</a></h4>
<p>In this metric both static and moving bundles are treated equally (i.e.,
there is no static reference bundle as both are intended to move). The
naming convention is kept for consistency.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.JointBundleMinDistanceMetric.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric.__init__" title="Link to this definition">#</a></dt>
<dd><p>An abstract class for the metric used for streamline registration.</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<section id="id224">
<h5>Parameters<a class="headerlink" href="#id224" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id387"><span class="problematic" id="id388">|num_threads + 1|</span></a> is used (enter -1
to use as many threads as possible). 0 raises an error. Only
metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.JointBundleMinDistanceMetric.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric.distance" title="Link to this definition">#</a></dt>
<dd><p>Distance calculated from this Metric.</p>
<section id="id225">
<h5>Parameters<a class="headerlink" href="#id225" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>xopt<span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector. These affine parameters
are used to derive the corresponding halfway transformation
parameters for each bundle.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.JointBundleMinDistanceMetric.setup">
<span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric.setup" title="Link to this definition">#</a></dt>
<dd><p>Setup static and moving sets of streamlines.</p>
<section id="id226">
<h5>Parameters<a class="headerlink" href="#id226" title="Link to this heading">#</a></h5>
<dl class="simple">
<dt>static<span class="classifier">streamlines</span></dt><dd><p>Set of streamlines</p>
</dd>
<dt>moving<span class="classifier">streamlines</span></dt><dd><p>Set of streamlines</p>
</dd>
</dl>
</section>
<section id="id227">
<h5>Notes<a class="headerlink" href="#id227" title="Link to this heading">#</a></h5>
<p>Call this after the object is initiated and before distance.
Num_threads is not used in this class.</p>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="streamlinelinearregistration">
<h3><a class="reference internal" href="#dipy.align.streamlinear.StreamlineLinearRegistration" title="dipy.align.streamlinear.StreamlineLinearRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a><a class="headerlink" href="#streamlinelinearregistration" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineLinearRegistration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">StreamlineLinearRegistration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rigid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineLinearRegistration" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineLinearRegistration.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rigid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineLinearRegistration.__init__" title="Link to this definition">#</a></dt>
<dd><p>Linear registration of 2 sets of streamlines <a class="reference internal" href="../reference_cmd/dipy_slr.html#garyfallidis15" id="id228"><span>[Garyfallidis15]</span></a>.</p>
<section id="id229">
<h4>Parameters<a class="headerlink" href="#id229" title="Link to this heading">#</a></h4>
<dl>
<dt>metric<span class="classifier">StreamlineDistanceMetric,</span></dt><dd><p>If None and fast is False then the BMD distance is used. If fast
is True then a faster implementation of BMD is used. Otherwise,
use the given distance metric.</p>
</dd>
<dt>x0<span class="classifier">array or int or str</span></dt><dd><p>Initial parametrization for the optimization.</p>
<dl>
<dt>If 1D array with:</dt><dd><p>a) 6 elements then only rigid registration is performed with
the 3 first elements for translation and 3 for rotation.
b) 7 elements also isotropic scaling is performed (similarity).
c) 12 elements then translation, rotation (in degrees),
scaling and shearing is performed (affine).</p>
<p>Here is an example of x0 with 12 elements:
<code class="docutils literal notranslate"><span class="pre">x0=np.array([0,</span> <span class="pre">10,</span> <span class="pre">0,</span> <span class="pre">40,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2.,</span> <span class="pre">1.5,</span> <span class="pre">1,</span> <span class="pre">0.1,</span> <span class="pre">-0.5,</span> <span class="pre">0])</span></code></p>
<p>This has translation (0, 10, 0), rotation (40, 0, 0) in
degrees, scaling (2., 1.5, 1) and shearing (0.1, -0.5, 0).</p>
</dd>
<dt>If int:</dt><dd><ol class="loweralpha simple">
<li><dl class="simple">
<dt>6</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>7</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>12</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
</ol>
</dd>
<dt>If str:</dt><dd><ol class="loweralpha simple">
<li><dl class="simple">
<dt>“rigid”</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“similarity”</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“affine”</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</dd>
<dt>method<span class="classifier">str,</span></dt><dd><p>‘L_BFGS_B’ or ‘Powell’ optimizers can be used. Default is
‘L_BFGS_B’.</p>
</dd>
<dt>bounds<span class="classifier">list of tuples or None,</span></dt><dd><p>If method == ‘L_BFGS_B’ then we can use bounded optimization.
For example for the six parameters of rigid rotation we can set
the bounds = [(-30, 30), (-30, 30), (-30, 30),</p>
<blockquote>
<div><p>(-45, 45), (-45, 45), (-45, 45)]</p>
</div></blockquote>
<p>That means that we have set the bounds for the three translations
and three rotation axes (in degrees).</p>
</dd>
<dt>verbose<span class="classifier">bool, optional.</span></dt><dd><p>If True, if True then information about the optimization is shown.
Default: False.</p>
</dd>
<dt>options<span class="classifier">None or dict,</span></dt><dd><p>Extra options to be used with the selected method.</p>
</dd>
<dt>evolution<span class="classifier">boolean</span></dt><dd><p>If True save the transformation for each iteration of the
optimizer. Default is False. Supported only with Scipy &gt;= 0.11.</p>
</dd>
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id389"><span class="problematic" id="id390">|num_threads + 1|</span></a> is used (enter -1
to use as many threads as possible). 0 raises an error. Only
metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</section>
<section id="id230">
<h4>References<a class="headerlink" href="#id230" title="Link to this heading">#</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="garyfallidis15" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Garyfallidis15<span class="fn-bracket">]</span></span>
<p>Garyfallidis et al. “Robust and efficient linear
registration of white-matter fascicles in the space of streamlines”,
NeuroImage, 117, 124–140, 2015</p>
</div>
<div class="citation" id="id231" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Garyfallidis14<span class="fn-bracket">]</span></span>
<p>Garyfallidis et al., “Direct native-space fiber
bundle alignment for group comparisons”, ISMRM, 2014.</p>
</div>
<div class="citation" id="garyfallidis17" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Garyfallidis17<span class="fn-bracket">]</span></span>
<p>Garyfallidis et al. Recognition of white matter
bundles using local and global streamline-based
registration and clustering, Neuroimage, 2017.</p>
</div>
</div>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineLinearRegistration.optimize">
<span class="sig-name descname"><span class="pre">optimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineLinearRegistration.optimize" title="Link to this definition">#</a></dt>
<dd><p>Find the minimum of the provided metric.</p>
<section id="id232">
<h4>Parameters<a class="headerlink" href="#id232" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">streamlines</span></dt><dd><p>Reference or fixed set of streamlines.</p>
</dd>
<dt>moving<span class="classifier">streamlines</span></dt><dd><p>Moving set of streamlines.</p>
</dd>
<dt>mat<span class="classifier">array</span></dt><dd><p>Transformation (4, 4) matrix to start the registration. <code class="docutils literal notranslate"><span class="pre">mat</span></code>
is applied to moving. Default value None which means that initial
transformation will be generated by shifting the centers of moving
and static sets of streamlines to the origin.</p>
</dd>
</dl>
</section>
<section id="id233">
<h4>Returns<a class="headerlink" href="#id233" title="Link to this heading">#</a></h4>
<p>map : StreamlineRegistrationMap</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="streamlineregistrationmap">
<h3><a class="reference internal" href="#dipy.align.streamlinear.StreamlineRegistrationMap" title="dipy.align.streamlinear.StreamlineRegistrationMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineRegistrationMap</span></code></a><a class="headerlink" href="#streamlineregistrationmap" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineRegistrationMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">StreamlineRegistrationMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matopt_history</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineRegistrationMap" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineRegistrationMap.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matopt_history</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineRegistrationMap.__init__" title="Link to this definition">#</a></dt>
<dd><p>A map holding the optimum affine matrix and some other parameters
of the optimization</p>
<section id="id234">
<h4>Parameters<a class="headerlink" href="#id234" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>matrix<span class="classifier">array,</span></dt><dd><p>4x4 affine matrix which transforms the moving to the static
streamlines</p>
</dd>
<dt>xopt<span class="classifier">array,</span></dt><dd><p>1d array with the parameters of the transformation after centering</p>
</dd>
<dt>fopt<span class="classifier">float,</span></dt><dd><p>final value of the metric</p>
</dd>
<dt>matrix_history<span class="classifier">array</span></dt><dd><p>All transformation matrices created during the optimization</p>
</dd>
<dt>funcs<span class="classifier">int,</span></dt><dd><p>Number of function evaluations of the optimizer</p>
</dd>
<dt>iterations<span class="classifier">int</span></dt><dd><p>Number of iterations of the optimizer</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.StreamlineRegistrationMap.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineRegistrationMap.transform" title="Link to this definition">#</a></dt>
<dd><p>Transform moving streamlines to the static.</p>
<section id="id235">
<h4>Parameters<a class="headerlink" href="#id235" title="Link to this heading">#</a></h4>
<p>moving : streamlines</p>
</section>
<section id="id236">
<h4>Returns<a class="headerlink" href="#id236" title="Link to this heading">#</a></h4>
<p>moved : streamlines</p>
</section>
<section id="id237">
<h4>Notes<a class="headerlink" href="#id237" title="Link to this heading">#</a></h4>
<p>All this does is apply <code class="docutils literal notranslate"><span class="pre">self.matrix</span></code> to the input streamlines.</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="jointstreamlineregistrationmap">
<h3><a class="reference internal" href="#dipy.align.streamlinear.JointStreamlineRegistrationMap" title="dipy.align.streamlinear.JointStreamlineRegistrationMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">JointStreamlineRegistrationMap</span></code></a><a class="headerlink" href="#jointstreamlineregistrationmap" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.streamlinear.JointStreamlineRegistrationMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">JointStreamlineRegistrationMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matopt_history</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.JointStreamlineRegistrationMap" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.JointStreamlineRegistrationMap.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matopt_history</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.JointStreamlineRegistrationMap.__init__" title="Link to this definition">#</a></dt>
<dd><p>A map holding the optimum affine matrices for halfway streamline
linear registration and some other parameters of the optimization.</p>
<p>xopt is optimized by StreamlineLinearRegistration using the
JointBundleMinDistanceMetric. In that case the mat argument of the
optimize method needs to be np.eye(4) to avoid streamline centering.</p>
<p>This constructor derives and stores the transformations to move both
static and moving bundles to the halfway space.</p>
<section id="id238">
<h4>Parameters<a class="headerlink" href="#id238" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>xopt<span class="classifier">array</span></dt><dd><p>1d array with the parameters of the transformation.</p>
</dd>
<dt>fopt<span class="classifier">float</span></dt><dd><p>Final value of the metric.</p>
</dd>
<dt>matopt_history<span class="classifier">array</span></dt><dd><p>All transformation matrices created during the optimization.</p>
</dd>
<dt>funcs<span class="classifier">int</span></dt><dd><p>Number of function evaluations of the optimizer.</p>
</dd>
<dt>iterations<span class="classifier">int</span></dt><dd><p>Number of iterations of the optimizer.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.streamlinear.JointStreamlineRegistrationMap.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.JointStreamlineRegistrationMap.transform" title="Link to this definition">#</a></dt>
<dd><p>Transform both static and moving bundles to the halfway space.</p>
<p>All this does is apply <code class="docutils literal notranslate"><span class="pre">self.matrix1</span></code> and <cite>self.matrix2`</cite> to the
static and moving bundles, respectively.</p>
<section id="id239">
<h4>Parameters<a class="headerlink" href="#id239" title="Link to this heading">#</a></h4>
<p>static : streamlines</p>
<p>moving : streamlines</p>
</section>
<section id="id240">
<h4>Returns<a class="headerlink" href="#id240" title="Link to this heading">#</a></h4>
<p>static : streamlines</p>
<p>moving : streamlines</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="id241">
<h3>logger<a class="headerlink" href="#id241" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.logger">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">logger</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.logger" title="Link to this definition">#</a></dt>
<dd><p>Instances of the Logger class represent a single logging channel. A
“logging channel” indicates an area of an application. Exactly how an
“area” is defined is up to the application developer. Since an
application can have any number of areas, logging channels are identified
by a unique string. Application areas can be nested (e.g. an area
of “input processing” might include sub-areas “read CSV files”, “read
XLS files” and “read Gnumeric files”). To cater for this natural nesting,
channel names are organized into a namespace hierarchy where levels are
separated by periods, much like the Java or Python package namespace. So
in the instance given above, channel names might be “input” for the upper
level, and “input.csv”, “input.xls” and “input.gnu” for the sub-levels.
There is no arbitrary limit to the depth of nesting.</p>
</dd></dl>

</section>
<section id="bundle-sum-distance">
<h3>bundle_sum_distance<a class="headerlink" href="#bundle-sum-distance" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.bundle_sum_distance">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">bundle_sum_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.bundle_sum_distance" title="Link to this definition">#</a></dt>
<dd><p>MDF distance optimization function (SUM).</p>
<p>We minimize the distance between moving streamlines as they align
with the static streamlines.</p>
<section id="id242">
<h4>Parameters<a class="headerlink" href="#id242" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>t<span class="classifier">ndarray</span></dt><dd><p>t is a vector of affine transformation parameters with
size at least 6.
If the size is 6, t is interpreted as translation + rotation.
If the size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
<dt>static<span class="classifier">list</span></dt><dd><p>Static streamlines</p>
</dd>
<dt>moving<span class="classifier">list</span></dt><dd><p>Moving streamlines. These will be transformed to align with
the static streamlines</p>
</dd>
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads. If -1 then all available threads will be used.</p>
</dd>
</dl>
</section>
<section id="id243">
<h4>Returns<a class="headerlink" href="#id243" title="Link to this heading">#</a></h4>
<p>cost: float</p>
</section>
</dd></dl>

</section>
<section id="bundle-min-distance">
<h3>bundle_min_distance<a class="headerlink" href="#bundle-min-distance" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.bundle_min_distance">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">bundle_min_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.bundle_min_distance" title="Link to this definition">#</a></dt>
<dd><p>MDF-based pairwise distance optimization function (MIN).</p>
<p>We minimize the distance between moving streamlines as they align
with the static streamlines.</p>
<section id="id244">
<h4>Parameters<a class="headerlink" href="#id244" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>t<span class="classifier">ndarray</span></dt><dd><p>t is a vector of affine transformation parameters with
size at least 6.
If size is 6, t is interpreted as translation + rotation.
If size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
<dt>static<span class="classifier">list</span></dt><dd><p>Static streamlines</p>
</dd>
<dt>moving<span class="classifier">list</span></dt><dd><p>Moving streamlines.</p>
</dd>
</dl>
</section>
<section id="id245">
<h4>Returns<a class="headerlink" href="#id245" title="Link to this heading">#</a></h4>
<p>cost: float</p>
</section>
</dd></dl>

</section>
<section id="bundle-min-distance-fast">
<h3>bundle_min_distance_fast<a class="headerlink" href="#bundle-min-distance-fast" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.bundle_min_distance_fast">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">bundle_min_distance_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.bundle_min_distance_fast" title="Link to this definition">#</a></dt>
<dd><p>MDF-based pairwise distance optimization function (MIN).</p>
<p>We minimize the distance between moving streamlines as they align
with the static streamlines.</p>
<section id="id246">
<h4>Parameters<a class="headerlink" href="#id246" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>t<span class="classifier">array</span></dt><dd><p>1D array. t is a vector of affine transformation parameters with
size at least 6.
If the size is 6, t is interpreted as translation + rotation.
If the size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
<dt>static<span class="classifier">array</span></dt><dd><p>N*M x 3 array. All the points of the static streamlines. With order of
streamlines intact. Where N is the number of streamlines and M
is the number of points per streamline.</p>
</dd>
<dt>moving<span class="classifier">array</span></dt><dd><p>K*M x 3 array. All the points of the moving streamlines. With order of
streamlines intact. Where K is the number of streamlines and M
is the number of points per streamline.</p>
</dd>
<dt>block_size<span class="classifier">int</span></dt><dd><p>Number of points per streamline. All streamlines in static and moving
should have the same number of points M.</p>
</dd>
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id391"><span class="problematic" id="id392">|num_threads + 1|</span></a> is used (enter -1 to
use as many threads as possible). 0 raises an error.</p>
</dd>
</dl>
</section>
<section id="id247">
<h4>Returns<a class="headerlink" href="#id247" title="Link to this heading">#</a></h4>
<p>cost: float</p>
</section>
<section id="id248">
<h4>Notes<a class="headerlink" href="#id248" title="Link to this heading">#</a></h4>
<p>This is a faster implementation of <code class="docutils literal notranslate"><span class="pre">bundle_min_distance</span></code>, which requires
that all the points of each streamline are allocated into an ndarray
(of shape N*M by 3, with N the number of points per streamline and M the
number of streamlines). This can be done by calling
<cite>dipy.tracking.streamlines.unlist_streamlines</cite>.</p>
</section>
</dd></dl>

</section>
<section id="bundle-min-distance-asymmetric-fast">
<h3>bundle_min_distance_asymmetric_fast<a class="headerlink" href="#bundle-min-distance-asymmetric-fast" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.bundle_min_distance_asymmetric_fast">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">bundle_min_distance_asymmetric_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.bundle_min_distance_asymmetric_fast" title="Link to this definition">#</a></dt>
<dd><p>MDF-based pairwise distance optimization function (MIN).</p>
<p>We minimize the distance between moving streamlines as they align
with the static streamlines.</p>
<section id="id249">
<h4>Parameters<a class="headerlink" href="#id249" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>t<span class="classifier">array</span></dt><dd><p>1D array. t is a vector of affine transformation parameters with
size at least 6.
If the size is 6, t is interpreted as translation + rotation.
If the size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
<dt>static<span class="classifier">array</span></dt><dd><p>N*M x 3 array. All the points of the static streamlines. With order of
streamlines intact. Where N is the number of streamlines and M
is the number of points per streamline.</p>
</dd>
<dt>moving<span class="classifier">array</span></dt><dd><p>K*M x 3 array. All the points of the moving streamlines. With order of
streamlines intact. Where K is the number of streamlines and M
is the number of points per streamline.</p>
</dd>
<dt>block_size<span class="classifier">int</span></dt><dd><p>Number of points per streamline. All streamlines in static and moving
should have the same number of points M.</p>
</dd>
</dl>
</section>
<section id="id250">
<h4>Returns<a class="headerlink" href="#id250" title="Link to this heading">#</a></h4>
<p>cost: float</p>
</section>
</dd></dl>

</section>
<section id="remove-clusters-by-size">
<h3>remove_clusters_by_size<a class="headerlink" href="#remove-clusters-by-size" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.remove_clusters_by_size">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">remove_clusters_by_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.remove_clusters_by_size" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="progressive-slr">
<h3>progressive_slr<a class="headerlink" href="#progressive-slr" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.progressive_slr">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">progressive_slr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.progressive_slr" title="Link to this definition">#</a></dt>
<dd><p>Progressive SLR.</p>
<p>This is an utility function that allows for example to do affine
registration using Streamline-based Linear Registration (SLR)
<a class="reference internal" href="../reference_cmd/dipy_slr.html#garyfallidis15" id="id251"><span>[Garyfallidis15]</span></a> by starting with translation first, then rigid,
then similarity, scaling and finally affine.</p>
<p>Similarly, if for example, you want to perform rigid then you start with
translation first. This progressive strategy can helps with finding the
optimal parameters of the final transformation.</p>
<section id="id252">
<h4>Parameters<a class="headerlink" href="#id252" title="Link to this heading">#</a></h4>
<p>static : Streamlines
moving : Streamlines
metric : StreamlineDistanceMetric
x0 : string</p>
<blockquote>
<div><p>Could be any of ‘translation’, ‘rigid’, ‘similarity’, ‘scaling’,
‘affine’</p>
</div></blockquote>
<dl class="simple">
<dt>bounds<span class="classifier">array</span></dt><dd><p>Boundaries of registration parameters. See variable <cite>DEFAULT_BOUNDS</cite>
for example.</p>
</dd>
<dt>method<span class="classifier">string</span></dt><dd><p>L_BFGS_B’ or ‘Powell’ optimizers can be used. Default is ‘L_BFGS_B’.</p>
</dd>
<dt>verbose<span class="classifier">bool, optional.</span></dt><dd><p>If True, log messages. Default:</p>
</dd>
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id393"><span class="problematic" id="id394">|num_threads + 1|</span></a> is used (enter -1 to
use as many threads as possible). 0 raises an error. Only metrics
using OpenMP will use this variable.</p>
</dd>
</dl>
</section>
<section id="id253">
<h4>References<a class="headerlink" href="#id253" title="Link to this heading">#</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="id254" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Garyfallidis15<span class="fn-bracket">]</span></span>
<p>Garyfallidis et al. “Robust and efficient linear
registration of white-matter fascicles in the space of streamlines”,
NeuroImage, 117, 124–140, 2015</p>
</div>
</div>
</section>
</dd></dl>

</section>
<section id="slr-with-qbx">
<h3>slr_with_qbx<a class="headerlink" href="#slr-with-qbx" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.slr_with_qbx">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">slr_with_qbx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'affine'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rm_small_clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">select_random</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">greater_than</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">less_than</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qbx_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(40,</span> <span class="pre">30,</span> <span class="pre">20,</span> <span class="pre">15)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progressive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.slr_with_qbx" title="Link to this definition">#</a></dt>
<dd><p>Utility function for registering large tractograms.</p>
<p>For efficiency, we apply the registration on cluster centroids and remove
small clusters.</p>
<section id="id255">
<h4>Parameters<a class="headerlink" href="#id255" title="Link to this heading">#</a></h4>
<p>static : Streamlines
moving : Streamlines</p>
<dl class="simple">
<dt>x0<span class="classifier">str, optional.</span></dt><dd><p>rigid, similarity or affine transformation model (default affine)</p>
</dd>
<dt>rm_small_clusters<span class="classifier">int, optional</span></dt><dd><p>Remove clusters that have less than <cite>rm_small_clusters</cite></p>
</dd>
<dt>maxiter<span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations to perform.</p>
</dd>
<dt>select_random<span class="classifier">int, optional.</span></dt><dd><p>If not, None selects a random number of streamlines to apply clustering
Default None.</p>
</dd>
<dt>verbose<span class="classifier">bool, optional</span></dt><dd><p>If True, logs information about optimization. Default: False</p>
</dd>
<dt>greater_than<span class="classifier">int, optional</span></dt><dd><p>Keep streamlines that have length greater than
this value (default 50)</p>
</dd>
<dt>less_than<span class="classifier">int, optional</span></dt><dd><p>Keep streamlines have length less than this value (default 250)</p>
</dd>
<dt>qbx_thr<span class="classifier">variable int</span></dt><dd><p>Thresholds for QuickBundlesX (default [40, 30, 20, 15])</p>
</dd>
<dt>nb_pts<span class="classifier">int, optional</span></dt><dd><p>Number of points for discretizing each streamline (default 20)</p>
</dd>
<dt>progressive<span class="classifier">boolean, optional</span></dt><dd><p>(default True)</p>
</dd>
<dt>rng<span class="classifier">np.random.Generator</span></dt><dd><p>If None creates random generator in function.</p>
</dd>
<dt>num_threads<span class="classifier">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None
(default) the value of OMP_NUM_THREADS environment variable is used
if it is set, otherwise all available threads are used. If &lt; 0 the
maximal number of threads minus <a href="#id395"><span class="problematic" id="id396">|num_threads + 1|</span></a> is used (enter -1 to
use as many threads as possible). 0 raises an error. Only metrics
using OpenMP will use this variable.</p>
</dd>
</dl>
</section>
<section id="id256">
<h4>Notes<a class="headerlink" href="#id256" title="Link to this heading">#</a></h4>
<p>The order of operations is the following. First short or long streamlines
are removed. Second, the tractogram or a random selection of the tractogram
is clustered with QuickBundles. Then SLR <a class="reference internal" href="../reference_cmd/dipy_slr.html#garyfallidis15" id="id257"><span>[Garyfallidis15]</span></a> is applied.</p>
</section>
<section id="id258">
<h4>References<a class="headerlink" href="#id258" title="Link to this heading">#</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="id259" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Garyfallidis15<span class="fn-bracket">]</span></span>
<p>Garyfallidis et al. “Robust and efficient linear</p>
</div>
</div>
<p>registration of white-matter fascicles in the space of streamlines”,
NeuroImage, 117, 124–140, 2015
.. [Garyfallidis14] Garyfallidis et al., “Direct native-space fiber</p>
<blockquote>
<div><p>bundle alignment for group comparisons”, ISMRM, 2014.</p>
</div></blockquote>
<div role="list" class="citation-list">
<div class="citation" id="id260" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Garyfallidis17<span class="fn-bracket">]</span></span>
<p>Garyfallidis et al. Recognition of white matter</p>
</div>
</div>
<p>bundles using local and global streamline-based registration and
clustering, Neuroimage, 2017.</p>
</section>
</dd></dl>

</section>
<section id="groupwise-slr">
<h3>groupwise_slr<a class="headerlink" href="#groupwise-slr" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.groupwise_slr">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">groupwise_slr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bundles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'affine'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qbx_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[4]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">select_random</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.groupwise_slr" title="Link to this definition">#</a></dt>
<dd><p>Function to perform unbiased groupwise bundle registration.</p>
<p>All bundles are moved to the same space by iteratively applying halfway
streamline linear registration in pairs. With each iteration, bundles get
closer to each other until the procedure converges and there is no more
improvement.</p>
<section id="id261">
<h4>Parameters<a class="headerlink" href="#id261" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>bundles<span class="classifier">list</span></dt><dd><p>List with streamlines of the bundles to be registered.</p>
</dd>
<dt>x0<span class="classifier">str, optional</span></dt><dd><p>rigid, similarity or affine transformation model. Default: affine.</p>
</dd>
<dt>tol<span class="classifier">float, optional</span></dt><dd><p>Tolerance value to be used to assume convergence. Default: 0.</p>
</dd>
<dt>max_iter<span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations. Depending on the number of bundles to be
registered this may need to be larger. Default: 20.</p>
</dd>
<dt>qbx_thr<span class="classifier">variable int, optional</span></dt><dd><p>Thresholds for Quickbundles used for clustering streamlines and reduce
computational time. If None, no clustering is performed. Higher values
cluster streamlines into a smaller number of centroids. Default: [4].</p>
</dd>
<dt>nb_pts<span class="classifier">int, optional</span></dt><dd><p>Number of points for discretizing each streamline. Default: 20.</p>
</dd>
<dt>select_random<span class="classifier">int, optional</span></dt><dd><p>Maximum number of streamlines for each bundle. If None, all the
streamlines are used. Default: 10000.</p>
</dd>
<dt>verbose<span class="classifier">bool, optional</span></dt><dd><p>If True, logs information. Default: False.</p>
</dd>
<dt>rng<span class="classifier">np.random.Generator</span></dt><dd><p>If None, creates random generator in function. Default: None.</p>
</dd>
</dl>
</section>
<section id="id262">
<h4>References<a class="headerlink" href="#id262" title="Link to this heading">#</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="id263" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Garyfallidis15<span class="fn-bracket">]</span></span>
<p>Garyfallidis et al. “Robust and efficient linear</p>
</div>
</div>
<p>registration of white-matter fascicles in the space of streamlines”,
NeuroImage, 117, 124–140, 2015
.. [Garyfallidis14] Garyfallidis et al., “Direct native-space fiber</p>
<blockquote>
<div><p>bundle alignment for group comparisons”, ISMRM, 2014.</p>
</div></blockquote>
<div role="list" class="citation-list">
<div class="citation" id="id264" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Garyfallidis17<span class="fn-bracket">]</span></span>
<p>Garyfallidis et al. Recognition of white matter</p>
</div>
</div>
<p>bundles using local and global streamline-based registration and
clustering, Neuroimage, 2017.</p>
</section>
</dd></dl>

</section>
<section id="get-unique-pairs">
<h3>get_unique_pairs<a class="headerlink" href="#get-unique-pairs" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.get_unique_pairs">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">get_unique_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_bundle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.get_unique_pairs" title="Link to this definition">#</a></dt>
<dd><p>Make unique pairs from n_bundle bundles.</p>
<p>The function allows to input a previous pairs assignment so that the new
pairs are different.</p>
<section id="id265">
<h4>Parameters<a class="headerlink" href="#id265" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>n_bundle<span class="classifier">int</span></dt><dd><p>Number of bundles to be matched in pairs.</p>
</dd>
<dt>pairs<span class="classifier">array, optional</span></dt><dd><p>array containing the indexes of previous pairs.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="compose-matrix44">
<h3>compose_matrix44<a class="headerlink" href="#compose-matrix44" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.compose_matrix44">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">compose_matrix44</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.compose_matrix44" title="Link to this definition">#</a></dt>
<dd><p>Compose a 4x4 transformation matrix.</p>
<section id="id266">
<h4>Parameters<a class="headerlink" href="#id266" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>t<span class="classifier">ndarray</span></dt><dd><p>This is a 1D vector of affine transformation parameters with
size at least 3.
If the size is 3, t is interpreted as translation.
If the size is 6, t is interpreted as translation + rotation.
If the size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If the size is 9, t is interpreted as translation + rotation +
anisotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
</dl>
</section>
<section id="id267">
<h4>Returns<a class="headerlink" href="#id267" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">ndarray</span></dt><dd><p>Homogeneous transformation matrix of size 4x4.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="decompose-matrix44">
<h3>decompose_matrix44<a class="headerlink" href="#decompose-matrix44" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamlinear.decompose_matrix44">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamlinear.</span></span><span class="sig-name descname"><span class="pre">decompose_matrix44</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.decompose_matrix44" title="Link to this definition">#</a></dt>
<dd><p>Given a 4x4 homogeneous matrix return the parameter vector.</p>
<section id="id268">
<h4>Parameters<a class="headerlink" href="#id268" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>mat<span class="classifier">array</span></dt><dd><p>Homogeneous 4x4 transformation matrix</p>
</dd>
<dt>size<span class="classifier">int</span></dt><dd><p>Size of the output vector. 3, for translation, 6 for rigid,
7 for similarity, 9 for scaling and 12 for affine. Default is 12.</p>
</dd>
</dl>
</section>
<section id="id269">
<h4>Returns<a class="headerlink" href="#id269" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>t<span class="classifier">ndarray</span></dt><dd><p>One dimensional ndarray of 3, 6, 7, 9 or 12 affine parameters.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="average-bundle-length">
<h3>average_bundle_length<a class="headerlink" href="#average-bundle-length" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamwarp.average_bundle_length">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamwarp.</span></span><span class="sig-name descname"><span class="pre">average_bundle_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bundle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamwarp.average_bundle_length" title="Link to this definition">#</a></dt>
<dd><p>Find average Euclidean length of the bundle in mm.</p>
<section id="id270">
<h4>Parameters<a class="headerlink" href="#id270" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>bundle<span class="classifier">Streamlines</span></dt><dd><p>Bundle who’s average length is to be calculated.</p>
</dd>
</dl>
</section>
<section id="id271">
<h4>Returns<a class="headerlink" href="#id271" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>int</dt><dd><p>Average Euclidean length of bundle in mm.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="find-missing">
<h3>find_missing<a class="headerlink" href="#find-missing" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamwarp.find_missing">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamwarp.</span></span><span class="sig-name descname"><span class="pre">find_missing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamwarp.find_missing" title="Link to this definition">#</a></dt>
<dd><p>Find unmatched streamline indices in moving bundle.</p>
<section id="id272">
<h4>Parameters<a class="headerlink" href="#id272" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>lst<span class="classifier">List</span></dt><dd><p>List of integers containing all the streamlines indices in moving
bundle.</p>
</dd>
<dt>cb<span class="classifier">List</span></dt><dd><p>List of integers containing streamline indices of the moving bundle
that were not matched to any streamline in static bundle.</p>
</dd>
</dl>
</section>
<section id="id273">
<h4>Returns<a class="headerlink" href="#id273" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>list</dt><dd><p>List containing unmatched streamlines from moving bundle</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="bundlewarp">
<h3>bundlewarp<a class="headerlink" href="#bundlewarp" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamwarp.bundlewarp">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamwarp.</span></span><span class="sig-name descname"><span class="pre">bundlewarp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">static</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamwarp.bundlewarp" title="Link to this definition">#</a></dt>
<dd><p>Register two bundles using nonlinear method.</p>
<section id="id274">
<h4>Parameters<a class="headerlink" href="#id274" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>static<span class="classifier">Streamlines</span></dt><dd><p>Reference/fixed bundle</p>
</dd>
<dt>moving<span class="classifier">Streamlines</span></dt><dd><p>Target bundle that will be moved/registered to match the static bundle</p>
</dd>
<dt>dist<span class="classifier">float, optional.</span></dt><dd><p>Precomputed distance matrix (default None)</p>
</dd>
<dt>alpha<span class="classifier">float, optional</span></dt><dd><p>Represents the trade-off between regularizing the deformation and
having points match very closely. Lower value of alpha means high
deformations (default 0.3)</p>
</dd>
<dt>beta<span class="classifier">int, optional</span></dt><dd><p>Represents the strength of the interaction between points
Gaussian kernel size (default 20)</p>
</dd>
<dt>max_iter<span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations for deformation process in ml-CPD method
(default 15)</p>
</dd>
<dt>affine<span class="classifier">boolean, optional</span></dt><dd><p>If False, use rigid registration as starting point (default True)</p>
</dd>
</dl>
</section>
<section id="id275">
<h4>Returns<a class="headerlink" href="#id275" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>deformed_bundle<span class="classifier">Streamlines</span></dt><dd><p>Nonlinearly moved bundle (warped bundle)</p>
</dd>
<dt>moving_aligned<span class="classifier">Streamlines</span></dt><dd><p>Linearly moved bundle (affinely moved)</p>
</dd>
<dt>dist<span class="classifier">np.ndarray</span></dt><dd><p>Float array containing distance between moving and static bundle</p>
</dd>
<dt>matched_pairs<span class="classifier">np.ndarray</span></dt><dd><p>Int array containing streamline correspondences between two bundles</p>
</dd>
<dt>warp<span class="classifier">np.ndarray</span></dt><dd><p>Nonlinear warp map generated by BundleWarp</p>
</dd>
</dl>
</section>
<section id="id276">
<h4>References<a class="headerlink" href="#id276" title="Link to this heading">#</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="chandio2023" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Chandio2023<span class="fn-bracket">]</span></span>
<p>Chandio et al. “BundleWarp, streamline-based nonlinear
registration of white matter tracts.” bioRxiv (2023): 2023-01.</p>
</div>
</div>
</section>
</dd></dl>

</section>
<section id="bundlewarp-vector-filed">
<h3>bundlewarp_vector_filed<a class="headerlink" href="#bundlewarp-vector-filed" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamwarp.bundlewarp_vector_filed">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamwarp.</span></span><span class="sig-name descname"><span class="pre">bundlewarp_vector_filed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving_aligned</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deformed_bundle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamwarp.bundlewarp_vector_filed" title="Link to this definition">#</a></dt>
<dd><p>Calculate vector fields.</p>
<p>Vector field computation as the difference between each streamline point
in the deformed and linearly aligned bundles</p>
<section id="id277">
<h4>Parameters<a class="headerlink" href="#id277" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>moving_aligned<span class="classifier">Streamlines</span></dt><dd><p>Linearly (affinely) moved bundle</p>
</dd>
<dt>deformed_bundle<span class="classifier">Streamlines</span></dt><dd><p>Nonlinearly (warped) bundle</p>
</dd>
</dl>
</section>
<section id="id278">
<h4>Returns<a class="headerlink" href="#id278" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>offsets<span class="classifier">List</span></dt><dd><p>Vector field modules</p>
</dd>
<dt>directions<span class="classifier">List</span></dt><dd><p>Unitary vector directions</p>
</dd>
</dl>
<p>colors : List</p>
</section>
</dd></dl>

</section>
<section id="bundlewarp-shape-analysis">
<h3>bundlewarp_shape_analysis<a class="headerlink" href="#bundlewarp-shape-analysis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.streamwarp.bundlewarp_shape_analysis">
<span class="sig-prename descclassname"><span class="pre">dipy.align.streamwarp.</span></span><span class="sig-name descname"><span class="pre">bundlewarp_shape_analysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moving_aligned</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deformed_bundle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_disks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plotting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamwarp.bundlewarp_shape_analysis" title="Link to this definition">#</a></dt>
<dd><p>Calculate bundle shape difference profile.</p>
<p>Bundle shape difference analysis using magnitude from BundleWarp
displacements and BUAN.</p>
<p>Depending on the number of points of a streamline, and the number of
segments requested, multiple points may be considered for the computation
of a given segment; a segment may contain information from a single point;
or some segments may not contain information from any points. In the latter
case, the segment will contain an <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> value. The point-to-segment
mapping is defined by the <code class="xref py py-func docutils literal notranslate"><span class="pre">assignment_map()</span></code>: for each segment index,
the point information of the matching index positions, as returned by
<code class="xref py py-func docutils literal notranslate"><span class="pre">assignment_map()</span></code>, are considered for the computation.</p>
<section id="id279">
<h4>Parameters<a class="headerlink" href="#id279" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>moving_aligned<span class="classifier">Streamlines</span></dt><dd><p>Linearly (affinely) moved bundle</p>
</dd>
<dt>deformed_bundle<span class="classifier">Streamlines</span></dt><dd><p>Nonlinearly (warped) moved bundle</p>
</dd>
<dt>no_disks<span class="classifier">int, optional</span></dt><dd><p>Number of segments to be created along the length of the bundle</p>
</dd>
<dt>plotting<span class="classifier">Boolean, optional</span></dt><dd><p>Plot bundle shape profile</p>
</dd>
</dl>
</section>
<section id="id280">
<h4>Returns<a class="headerlink" href="#id280" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>shape_profile<span class="classifier">np.ndarray</span></dt><dd><p>Float array containing bundlewarp displacement magnitudes along the
length of the bundle</p>
</dd>
<dt>stdv<span class="classifier">np.ndarray</span></dt><dd><p>Float array containing standard deviations</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="compute-energy-ssd-2d">
<h3>compute_energy_ssd_2d<a class="headerlink" href="#compute-energy-ssd-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.compute_energy_ssd_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">compute_energy_ssd_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.compute_energy_ssd_2d" title="Link to this definition">#</a></dt>
<dd><p>Sum of squared differences between two 2D images</p>
<p>Computes the Sum of Squared Differences between the static and moving image.
Those differences are given by delta_field</p>
<section id="id281">
<h4>Parameters<a class="headerlink" href="#id281" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>delta_field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
</dl>
</section>
<section id="id282">
<h4>Returns<a class="headerlink" href="#id282" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>energy<span class="classifier">float</span></dt><dd><p>the SSD energy at this iteration</p>
</dd>
</dl>
</section>
<section id="id283">
<h4>Notes<a class="headerlink" href="#id283" title="Link to this heading">#</a></h4>
<p>The numeric value of the energy is used only to detect convergence.
This function returns only the energy corresponding to the data term
(excluding the energy corresponding to the regularization term) because
the Greedy-SyN algorithm is an unconstrained gradient descent algorithm
in the space of diffeomorphisms: in each iteration it makes a step
along the negative smoothed gradient –of the data term– and then makes
sure the resulting diffeomorphisms are invertible using an explicit
inversion algorithm. Since it is not clear how to reflect the energy
corresponding to this re-projection to the space of diffeomorphisms,
a more precise energy computation including the regularization term
is useless. Instead, convergence is checked considering the data-term
energy only and detecting oscilations in the energy profile.</p>
</section>
</dd></dl>

</section>
<section id="compute-energy-ssd-3d">
<h3>compute_energy_ssd_3d<a class="headerlink" href="#compute-energy-ssd-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.compute_energy_ssd_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">compute_energy_ssd_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.compute_energy_ssd_3d" title="Link to this definition">#</a></dt>
<dd><p>Sum of squared differences between two 3D volumes</p>
<p>Computes the Sum of Squared Differences between the static and moving volume
Those differences are given by delta_field</p>
<section id="id284">
<h4>Parameters<a class="headerlink" href="#id284" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>delta_field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
</dl>
</section>
<section id="id285">
<h4>Returns<a class="headerlink" href="#id285" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>energy<span class="classifier">float</span></dt><dd><p>the SSD energy at this iteration</p>
</dd>
</dl>
</section>
<section id="id286">
<h4>Notes<a class="headerlink" href="#id286" title="Link to this heading">#</a></h4>
<p>The numeric value of the energy is used only to detect convergence.
This function returns only the energy corresponding to the data term
(excluding the energy corresponding to the regularization term) because
the Greedy-SyN algorithm is an unconstrained gradient descent algorithm
in the space of diffeomorphisms: in each iteration it makes a step
along the negative smoothed gradient –of the data term– and then makes
sure the resulting diffeomorphisms are invertible using an explicit
inversion algorithm. Since it is not clear how to reflect the energy
corresponding to this re-projection to the space of diffeomorphisms,
a more precise energy computation including the regularization term
is useless. Instead, convergence is checked considering the data-term
energy only and detecting oscilations in the energy profile.</p>
</section>
</dd></dl>

</section>
<section id="compute-residual-displacement-field-ssd-2d">
<h3>compute_residual_displacement_field_ssd_2d<a class="headerlink" href="#compute-residual-displacement-field-ssd-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">compute_residual_displacement_field_ssd_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmasq_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_2d" title="Link to this definition">#</a></dt>
<dd><p>The residual displacement field to be fit on the next iteration</p>
<p>Computes the residual displacement field corresponding to the current
displacement field in the Multi-resolution Gauss-Seidel solver proposed by
Bruhn and Weickert [Bruhn05].</p>
<section id="id287">
<h4>Parameters<a class="headerlink" href="#id287" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>delta_field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
<dt>sigmasq_field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the variance of the gray level value at each voxel, according to the
EM model (for SSD, it is 1 for all voxels). Inf and 0 values
are processed specially to support infinite and zero variance.</p>
</dd>
<dt>gradient_field<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt>target<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>right-hand side of the linear system to be solved in the Weickert’s
multi-resolution algorithm</p>
</dd>
<dt>lambda_param<span class="classifier">float</span></dt><dd><p>smoothness parameter in the objective function</p>
</dd>
<dt>d<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the current displacement field to compute the residual from</p>
</dd>
<dt>residual<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the displacement field to put the residual to</p>
</dd>
</dl>
</section>
<section id="id288">
<h4>Returns<a class="headerlink" href="#id288" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>residual<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the residual displacement field. If residual was None a input, then
a new field is returned, otherwise the same array is returned</p>
</dd>
</dl>
</section>
<section id="id289">
<h4>References<a class="headerlink" href="#id289" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion</dt><dd><p>estimation: combining highest accuracy with real-time
performance”, 10th IEEE International Conference on Computer
Vision, 2005. ICCV 2005.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="compute-residual-displacement-field-ssd-3d">
<h3>compute_residual_displacement_field_ssd_3d<a class="headerlink" href="#compute-residual-displacement-field-ssd-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">compute_residual_displacement_field_ssd_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmasq_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_3d" title="Link to this definition">#</a></dt>
<dd><p>The residual displacement field to be fit on the next iteration</p>
<p>Computes the residual displacement field corresponding to the current
displacement field (given by ‘disp’) in the Multi-resolution
Gauss-Seidel solver proposed by Bruhn and Weickert [Bruhn].</p>
<section id="id290">
<h4>Parameters<a class="headerlink" href="#id290" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>delta_field<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
<dt>sigmasq_field<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the variance of the gray level value at each voxel, according to the
EM model (for SSD, it is 1 for all voxels). Inf and 0 values
are processed specially to support infinite and zero variance.</p>
</dd>
<dt>gradient_field<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt>target<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>right-hand side of the linear system to be solved in the Weickert’s
multi-resolution algorithm</p>
</dd>
<dt>lambda_param<span class="classifier">float</span></dt><dd><p>smoothness parameter in the objective function</p>
</dd>
<dt>disp<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the current displacement field to compute the residual from</p>
</dd>
<dt>residual<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the displacement field to put the residual to</p>
</dd>
</dl>
</section>
<section id="id291">
<h4>Returns<a class="headerlink" href="#id291" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>residual<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the residual displacement field. If residual was None a input, then
a new field is returned, otherwise the same array is returned</p>
</dd>
</dl>
</section>
<section id="id292">
<h4>References<a class="headerlink" href="#id292" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion</dt><dd><p>estimation: combining highest accuracy with real-time
performance”, 10th IEEE International Conference on Computer
Vision, 2005. ICCV 2005.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="compute-ssd-demons-step-2d">
<h3>compute_ssd_demons_step_2d<a class="headerlink" href="#compute-ssd-demons-step-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.compute_ssd_demons_step_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">compute_ssd_demons_step_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.compute_ssd_demons_step_2d" title="Link to this definition">#</a></dt>
<dd><p>Demons step for 2D SSD-driven registration

Computes the demons step for SSD-driven registration
( eq. 4 in [Bruhn05] )

Parameters
———-
delta_field : array, shape (R, C)
    the difference between the static and moving image (the ‘derivative
    w.r.t. time’ in the optical flow model)
gradient_field : array, shape (R, C, 2)
    the gradient of the moving image
sigma_sq_x : float
    parameter controlling the amount of regularization. It corresponds to
    <span class="math notranslate nohighlight">\(\sigma_x^2\)</span> in algorithm 1 of Vercauteren et al.[Vercauteren09]
out : array, shape (R, C, 2)
    if None, a new array will be created to store the demons step. Otherwise
    the provided array will be used.

Returns
——-
demons_step : array, shape (R, C, 2)
    the demons step to be applied for updating the current displacement
    field
energy : float
    the current ssd energy (before applying the returned demons_step)

References
———-
[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion
          estimation: combining highest accuracy with real-time
          performance”, 10th IEEE International Conference on Computer
          Vision, 2005. ICCV 2005.
[Vercauteren09] Vercauteren, T., Pennec, X., Perchant, A., &amp; Ayache, N.
                (2009). Diffeomorphic demons: efficient non-parametric
                image registration. NeuroImage, 45(1 Suppl), S61-72.
                doi:10.1016/j.neuroimage.2008.10.040</p>
</dd></dl>

</section>
<section id="compute-ssd-demons-step-3d">
<h3>compute_ssd_demons_step_3d<a class="headerlink" href="#compute-ssd-demons-step-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.compute_ssd_demons_step_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">compute_ssd_demons_step_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_moving</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.compute_ssd_demons_step_3d" title="Link to this definition">#</a></dt>
<dd><p>Demons step for 3D SSD-driven registration

Computes the demons step for SSD-driven registration
( eq. 4 in [Bruhn05] )

Parameters
———-
delta_field : array, shape (S, R, C)
    the difference between the static and moving image (the ‘derivative
    w.r.t. time’ in the optical flow model)
gradient_field : array, shape (S, R, C, 2)
    the gradient of the moving image
sigma_sq_x : float
    parameter controlling the amount of regularization. It corresponds to
    <span class="math notranslate nohighlight">\(\sigma_x^2\)</span> in algorithm 1 of Vercauteren et al.[Vercauteren09]
out : array, shape (S, R, C, 2)
    if None, a new array will be created to store the demons step. Otherwise
    the provided array will be used.

Returns
——-
demons_step : array, shape (S, R, C, 3)
    the demons step to be applied for updating the current displacement
    field
energy : float
    the current ssd energy (before applying the returned demons_step)

References
———-
[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion
          estimation: combining highest accuracy with real-time
          performance”, 10th IEEE International Conference on Computer
          Vision, 2005. ICCV 2005.
[Vercauteren09] Vercauteren, T., Pennec, X., Perchant, A., &amp; Ayache, N.
                (2009). Diffeomorphic demons: efficient non-parametric
                image registration. NeuroImage, 45(1 Suppl), S61-72.
                doi:10.1016/j.neuroimage.2008.10.040</p>
</dd></dl>

</section>
<section id="iterate-residual-displacement-field-ssd-2d">
<h3>iterate_residual_displacement_field_ssd_2d<a class="headerlink" href="#iterate-residual-displacement-field-ssd-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">iterate_residual_displacement_field_ssd_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmasq_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">displacement_field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_2d" title="Link to this definition">#</a></dt>
<dd><p>One iteration of a large linear system solver for 2D SSD registration</p>
<p>Performs one iteration at one level of the Multi-resolution Gauss-Seidel
solver proposed by Bruhn and Weickert [Bruhn05].</p>
<section id="id293">
<h4>Parameters<a class="headerlink" href="#id293" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>delta_field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
<dt>sigmasq_field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the variance of the gray level value at each voxel, according to the
EM model (for SSD, it is 1 for all voxels). Inf and 0 values
are processed specially to support infinite and zero variance.</p>
</dd>
<dt>grad<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt>target<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>right-hand side of the linear system to be solved in the Weickert’s
multi-resolution algorithm</p>
</dd>
<dt>lambda_param<span class="classifier">float</span></dt><dd><p>smoothness parameter of the objective function</p>
</dd>
<dt>displacement_field<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>current displacement field to start the iteration from</p>
</dd>
</dl>
</section>
<section id="id294">
<h4>Returns<a class="headerlink" href="#id294" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>max_displacement<span class="classifier">float</span></dt><dd><p>the norm of the maximum change in the displacement field after the
iteration</p>
</dd>
</dl>
</section>
<section id="id295">
<h4>References<a class="headerlink" href="#id295" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion</dt><dd><p>estimation: combining highest accuracy with real-time
performance”, 10th IEEE International Conference on Computer
Vision, 2005. ICCV 2005.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="iterate-residual-displacement-field-ssd-3d">
<h3>iterate_residual_displacement_field_ssd_3d<a class="headerlink" href="#iterate-residual-displacement-field-ssd-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">iterate_residual_displacement_field_ssd_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmasq_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_3d" title="Link to this definition">#</a></dt>
<dd><p>One iteration of a large linear system solver for 3D SSD registration</p>
<p>Performs one iteration at one level of the Multi-resolution Gauss-Seidel
solver proposed by Bruhn and Weickert [Bruhn05].</p>
<section id="id296">
<h4>Parameters<a class="headerlink" href="#id296" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>delta_field<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
<dt>sigmasq_field<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the variance of the gray level value at each voxel, according to the
EM model (for SSD, it is 1 for all voxels). Inf and 0 values
are processed specially to support infinite and zero variance.</p>
</dd>
<dt>grad<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt>target<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>right-hand side of the linear system to be solved in the Weickert’s
multi-resolution algorithm</p>
</dd>
<dt>lambda_param<span class="classifier">float</span></dt><dd><p>smoothness parameter of the objective function</p>
</dd>
<dt>disp<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the displacement field to start the optimization from</p>
</dd>
</dl>
</section>
<section id="id297">
<h4>Returns<a class="headerlink" href="#id297" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>max_displacement<span class="classifier">float</span></dt><dd><p>the norm of the maximum change in the displacement field after the
iteration</p>
</dd>
</dl>
</section>
<section id="id298">
<h4>References<a class="headerlink" href="#id298" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion</dt><dd><p>estimation: combining highest accuracy with real-time
performance”, 10th IEEE International Conference on Computer
Vision, 2005. ICCV 2005.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="solve-2d-symmetric-positive-definite">
<h3>solve_2d_symmetric_positive_definite<a class="headerlink" href="#solve-2d-symmetric-positive-definite" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.solve_2d_symmetric_positive_definite">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">solve_2d_symmetric_positive_definite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.solve_2d_symmetric_positive_definite" title="Link to this definition">#</a></dt>
<dd><p>Solves a 2-variable symmetric positive-definite linear system

Solves the symmetric positive-definite linear system <span class="math notranslate nohighlight">\(Mx = y\)</span> given by::

    M = [[A[0], A[1]],
         [A[1], A[2]]]

Parameters
———-
A : array, shape (3,)
    the array containing the entries of the symmetric 2x2 matrix
y : array, shape (2,)
    right-hand side of the system to be solved

Returns
——-
out : array, shape (2,)
    the array the output will be stored in</p>
</dd></dl>

</section>
<section id="solve-3d-symmetric-positive-definite">
<h3>solve_3d_symmetric_positive_definite<a class="headerlink" href="#solve-3d-symmetric-positive-definite" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.sumsqdiff.solve_3d_symmetric_positive_definite">
<span class="sig-prename descclassname"><span class="pre">dipy.align.sumsqdiff.</span></span><span class="sig-name descname"><span class="pre">solve_3d_symmetric_positive_definite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.sumsqdiff.solve_3d_symmetric_positive_definite" title="Link to this definition">#</a></dt>
<dd><p>Solves a 3-variable symmetric positive-definite linear system

Solves the symmetric semi-positive-definite linear system <span class="math notranslate nohighlight">\(Mx = y\)</span> given by
<span class="math notranslate nohighlight">\(M = (g g^{T} + \tau I)\)</span>.

Parameters
———-
g : array, shape (3,)
    the vector in the outer product above
y : array, shape (3,)
    right-hand side of the system to be solved
tau : double
    <span class="math notranslate nohighlight">\(\tau\)</span> in <span class="math notranslate nohighlight">\(M = (g g^{T} + \tau I)\)</span>

Returns
——-
out : array, shape (3,)
    the array the output will be stored in
is_singular : int
    1 if M is singular, otherwise 0</p>
</dd></dl>

</section>
<section id="affinetransform2d">
<h3><a class="reference internal" href="#dipy.align.transforms.AffineTransform2D" title="dipy.align.transforms.AffineTransform2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform2D</span></code></a><a class="headerlink" href="#affinetransform2d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.AffineTransform2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">AffineTransform2D</span></span><a class="headerlink" href="#dipy.align.transforms.AffineTransform2D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.AffineTransform2D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.AffineTransform2D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Affine transform in 2D</p>
</dd></dl>

</dd></dl>

</section>
<section id="affinetransform3d">
<h3><a class="reference internal" href="#dipy.align.transforms.AffineTransform3D" title="dipy.align.transforms.AffineTransform3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform3D</span></code></a><a class="headerlink" href="#affinetransform3d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.AffineTransform3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">AffineTransform3D</span></span><a class="headerlink" href="#dipy.align.transforms.AffineTransform3D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.AffineTransform3D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.AffineTransform3D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Affine transform in 3D</p>
</dd></dl>

</dd></dl>

</section>
<section id="rigidisoscalingtransform2d">
<h3><a class="reference internal" href="#dipy.align.transforms.RigidIsoScalingTransform2D" title="dipy.align.transforms.RigidIsoScalingTransform2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidIsoScalingTransform2D</span></code></a><a class="headerlink" href="#rigidisoscalingtransform2d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidIsoScalingTransform2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">RigidIsoScalingTransform2D</span></span><a class="headerlink" href="#dipy.align.transforms.RigidIsoScalingTransform2D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidIsoScalingTransform2D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.RigidIsoScalingTransform2D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Rigid isoscaling transform in 2D.</p>
<p>(rotation + translation + scaling)</p>
<p>The parameter vector theta of length 4 is interpreted as follows:
theta[0] : rotation angle
theta[1] : translation along the x axis
theta[2] : translation along the y axis
theta[3] : isotropic scaling</p>
</dd></dl>

</dd></dl>

</section>
<section id="rigidisoscalingtransform3d">
<h3><a class="reference internal" href="#dipy.align.transforms.RigidIsoScalingTransform3D" title="dipy.align.transforms.RigidIsoScalingTransform3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidIsoScalingTransform3D</span></code></a><a class="headerlink" href="#rigidisoscalingtransform3d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidIsoScalingTransform3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">RigidIsoScalingTransform3D</span></span><a class="headerlink" href="#dipy.align.transforms.RigidIsoScalingTransform3D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidIsoScalingTransform3D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.RigidIsoScalingTransform3D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Rigid isoscaling transform in 3D.</p>
<p>(rotation + translation + scaling)
The parameter vector theta of length 7 is interpreted as follows:
theta[0] : rotation about the x axis
theta[1] : rotation about the y axis
theta[2] : rotation about the z axis
theta[3] : translation along the x axis
theta[4] : translation along the y axis
theta[5] : translation along the z axis
theta[6] : isotropic scaling</p>
</dd></dl>

</dd></dl>

</section>
<section id="rigidscalingtransform2d">
<h3><a class="reference internal" href="#dipy.align.transforms.RigidScalingTransform2D" title="dipy.align.transforms.RigidScalingTransform2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidScalingTransform2D</span></code></a><a class="headerlink" href="#rigidscalingtransform2d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidScalingTransform2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">RigidScalingTransform2D</span></span><a class="headerlink" href="#dipy.align.transforms.RigidScalingTransform2D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidScalingTransform2D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.RigidScalingTransform2D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Rigid scaling transform in 2D.</p>
<p>(rotation + translation + scaling)</p>
<p>The parameter vector theta of length 5 is interpreted as follows:
theta[0] : rotation angle
theta[1] : translation along the x axis
theta[2] : translation along the y axis
theta[3] : scaling along the x axis
theta[4] : scaling along the y axis</p>
</dd></dl>

</dd></dl>

</section>
<section id="rigidscalingtransform3d">
<h3><a class="reference internal" href="#dipy.align.transforms.RigidScalingTransform3D" title="dipy.align.transforms.RigidScalingTransform3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidScalingTransform3D</span></code></a><a class="headerlink" href="#rigidscalingtransform3d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidScalingTransform3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">RigidScalingTransform3D</span></span><a class="headerlink" href="#dipy.align.transforms.RigidScalingTransform3D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidScalingTransform3D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.RigidScalingTransform3D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Rigid Scaling transform in 3D (rotation + translation + scaling).</p>
<p>The parameter vector theta of length 9 is interpreted as follows:
theta[0] : rotation about the x axis
theta[1] : rotation about the y axis
theta[2] : rotation about the z axis
theta[3] : translation along the x axis
theta[4] : translation along the y axis
theta[5] : translation along the z axis
theta[6] : scaling in the x axis
theta[7] : scaling in the y axis
theta[8] : scaling in the z axis</p>
</dd></dl>

</dd></dl>

</section>
<section id="rigidtransform2d">
<h3><a class="reference internal" href="#dipy.align.transforms.RigidTransform2D" title="dipy.align.transforms.RigidTransform2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidTransform2D</span></code></a><a class="headerlink" href="#rigidtransform2d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidTransform2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">RigidTransform2D</span></span><a class="headerlink" href="#dipy.align.transforms.RigidTransform2D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidTransform2D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.RigidTransform2D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Rigid transform in 2D (rotation + translation)
The parameter vector theta of length 3 is interpreted as follows:
theta[0] : rotation angle
theta[1] : translation along the x axis
theta[2] : translation along the y axis</p>
</dd></dl>

</dd></dl>

</section>
<section id="rigidtransform3d">
<h3><a class="reference internal" href="#dipy.align.transforms.RigidTransform3D" title="dipy.align.transforms.RigidTransform3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidTransform3D</span></code></a><a class="headerlink" href="#rigidtransform3d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidTransform3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">RigidTransform3D</span></span><a class="headerlink" href="#dipy.align.transforms.RigidTransform3D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.RigidTransform3D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.RigidTransform3D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Rigid transform in 3D (rotation + translation)
The parameter vector theta of length 6 is interpreted as follows:
theta[0] : rotation about the x axis
theta[1] : rotation about the y axis
theta[2] : rotation about the z axis
theta[3] : translation along the x axis
theta[4] : translation along the y axis
theta[5] : translation along the z axis</p>
</dd></dl>

</dd></dl>

</section>
<section id="rotationtransform2d">
<h3><a class="reference internal" href="#dipy.align.transforms.RotationTransform2D" title="dipy.align.transforms.RotationTransform2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationTransform2D</span></code></a><a class="headerlink" href="#rotationtransform2d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.RotationTransform2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">RotationTransform2D</span></span><a class="headerlink" href="#dipy.align.transforms.RotationTransform2D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.RotationTransform2D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.RotationTransform2D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Rotation transform in 2D</p>
</dd></dl>

</dd></dl>

</section>
<section id="rotationtransform3d">
<h3><a class="reference internal" href="#dipy.align.transforms.RotationTransform3D" title="dipy.align.transforms.RotationTransform3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationTransform3D</span></code></a><a class="headerlink" href="#rotationtransform3d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.RotationTransform3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">RotationTransform3D</span></span><a class="headerlink" href="#dipy.align.transforms.RotationTransform3D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.RotationTransform3D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.RotationTransform3D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Rotation transform in 3D</p>
</dd></dl>

</dd></dl>

</section>
<section id="scalingtransform2d">
<h3><a class="reference internal" href="#dipy.align.transforms.ScalingTransform2D" title="dipy.align.transforms.ScalingTransform2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalingTransform2D</span></code></a><a class="headerlink" href="#scalingtransform2d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.ScalingTransform2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">ScalingTransform2D</span></span><a class="headerlink" href="#dipy.align.transforms.ScalingTransform2D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.ScalingTransform2D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.ScalingTransform2D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Scaling transform in 2D</p>
</dd></dl>

</dd></dl>

</section>
<section id="scalingtransform3d">
<h3><a class="reference internal" href="#dipy.align.transforms.ScalingTransform3D" title="dipy.align.transforms.ScalingTransform3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalingTransform3D</span></code></a><a class="headerlink" href="#scalingtransform3d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.ScalingTransform3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">ScalingTransform3D</span></span><a class="headerlink" href="#dipy.align.transforms.ScalingTransform3D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.ScalingTransform3D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.ScalingTransform3D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Scaling transform in 3D</p>
</dd></dl>

</dd></dl>

</section>
<section id="transform">
<h3><a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a><a class="headerlink" href="#transform" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.Transform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">Transform</span></span><a class="headerlink" href="#dipy.align.transforms.Transform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Base class (contract) for all transforms for affine image registration
Each transform must define the following (fast, nogil) methods:</p>
<ol class="arabic simple">
<li><p>_jacobian(theta, x, J): receives a parameter vector theta, a point in
x, and a matrix J with shape (dim, len(theta)). It must writes in J, the
Jacobian of the transform with parameters theta evaluated at x.</p></li>
<li><p>_get_identity_parameters(theta): receives a vector theta whose length is
the number of parameters of the transform and sets in theta the values
that define the identity transform.</p></li>
<li><p>_param_to_matrix(theta, T): receives a parameter vector theta, and a
matrix T of shape (dim + 1, dim + 1) and writes in T the matrix
representation of the transform with parameters theta</p></li>
</ol>
<p>This base class defines the (slow, convenient) python wrappers for each
of the above functions, which also do parameter checking and raise
a ValueError in case the provided parameters are invalid.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.Transform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.Transform.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.Transform.get_dim">
<span class="sig-name descname"><span class="pre">get_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.Transform.get_dim" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.Transform.get_identity_parameters">
<span class="sig-name descname"><span class="pre">get_identity_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.Transform.get_identity_parameters" title="Link to this definition">#</a></dt>
<dd><p>Parameter values corresponding to the identity transform</p>
<section id="id299">
<h4>Returns<a class="headerlink" href="#id299" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>theta<span class="classifier">array, shape (n,)</span></dt><dd><p>the n parameter values corresponding to the identity transform</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.Transform.get_number_of_parameters">
<span class="sig-name descname"><span class="pre">get_number_of_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.Transform.get_number_of_parameters" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.Transform.jacobian">
<span class="sig-name descname"><span class="pre">jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.Transform.jacobian" title="Link to this definition">#</a></dt>
<dd><p>Jacobian function of this transform</p>
<section id="id300">
<h4>Parameters<a class="headerlink" href="#id300" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>theta<span class="classifier">array, shape (n,)</span></dt><dd><p>vector containing the n parameters of this transform</p>
</dd>
<dt>x<span class="classifier">array, shape (dim,)</span></dt><dd><p>vector containing the point where the Jacobian must be evaluated</p>
</dd>
</dl>
</section>
<section id="id301">
<h4>Returns<a class="headerlink" href="#id301" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>J<span class="classifier">array, shape (dim, n)</span></dt><dd><p>Jacobian matrix of the transform with parameters theta at point x</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.Transform.param_to_matrix">
<span class="sig-name descname"><span class="pre">param_to_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.Transform.param_to_matrix" title="Link to this definition">#</a></dt>
<dd><p>Matrix representation of this transform with the given parameters</p>
<section id="id302">
<h4>Parameters<a class="headerlink" href="#id302" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>theta<span class="classifier">array, shape (n,)</span></dt><dd><p>the parameter values of the transform</p>
</dd>
</dl>
</section>
<section id="id303">
<h4>Returns<a class="headerlink" href="#id303" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">array, shape (dim + 1, dim + 1)</span></dt><dd><p>the matrix representation of this transform with parameters theta</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="translationtransform2d">
<h3><a class="reference internal" href="#dipy.align.transforms.TranslationTransform2D" title="dipy.align.transforms.TranslationTransform2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">TranslationTransform2D</span></code></a><a class="headerlink" href="#translationtransform2d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.TranslationTransform2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">TranslationTransform2D</span></span><a class="headerlink" href="#dipy.align.transforms.TranslationTransform2D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.TranslationTransform2D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.TranslationTransform2D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Translation transform in 2D</p>
</dd></dl>

</dd></dl>

</section>
<section id="translationtransform3d">
<h3><a class="reference internal" href="#dipy.align.transforms.TranslationTransform3D" title="dipy.align.transforms.TranslationTransform3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">TranslationTransform3D</span></code></a><a class="headerlink" href="#translationtransform3d" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.align.transforms.TranslationTransform3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.align.transforms.</span></span><span class="sig-name descname"><span class="pre">TranslationTransform3D</span></span><a class="headerlink" href="#dipy.align.transforms.TranslationTransform3D" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.transforms.Transform" title="dipy.align.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.align.transforms.TranslationTransform3D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.transforms.TranslationTransform3D.__init__" title="Link to this definition">#</a></dt>
<dd><p>Translation transform in 3D</p>
</dd></dl>

</dd></dl>

</section>
<section id="compose-vector-fields-2d">
<h3>compose_vector_fields_2d<a class="headerlink" href="#compose-vector-fields-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.compose_vector_fields_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">compose_vector_fields_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">premult_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">premult_disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.compose_vector_fields_2d" title="Link to this definition">#</a></dt>
<dd><p>Computes the composition of two 2D displacement fields</p>
<p>Computes the composition of the two 2-D displacements d1 and d2. The
evaluation of d2 at non-lattice points is computed using tri-linear
interpolation. The actual composition is computed as:</p>
<p>comp[i] = d1[i] + t * d2[ A * i + B * d1[i] ]</p>
<p>where t = time_scaling, A = premult_index and B=premult_disp and i denotes
the voxel coordinates of a voxel in d1’s grid. Using this parameters it is
possible to compose vector fields with arbitrary discretizations: let R and
S be the voxel-to-space transformation associated to d1 and d2,
respectively then the composition at a voxel with coordinates i in d1’s
grid is given by:</p>
<p>comp[i] = d1[i] + R*i + d2[Sinv*(R*i + d1[i])] - R*i</p>
<p>(the R*i terms cancel each other) where Sinv = S^{-1}
we can then define A = Sinv * R and B = Sinv to compute the composition
using this function.</p>
<section id="id304">
<h4>Parameters<a class="headerlink" href="#id304" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d1<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>first displacement field to be applied. R, C are the number of rows
and columns of the displacement field, respectively.</p>
</dd>
<dt>d2<span class="classifier">array, shape (R’, C’, 2)</span></dt><dd><p>second displacement field to be applied. R’, C’ are the number of rows
and columns of the displacement field, respectively.</p>
</dd>
<dt>premult_index<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix A in the explanation above</p>
</dd>
<dt>premult_disp<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix B in the explanation above</p>
</dd>
<dt>time_scaling<span class="classifier">float</span></dt><dd><p>this corresponds to the time scaling ‘t’ in the above explanation</p>
</dd>
<dt>comp<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the buffer to write the composition to. If None, the buffer is created
internally</p>
</dd>
</dl>
</section>
<section id="id305">
<h4>Returns<a class="headerlink" href="#id305" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>comp<span class="classifier">array, shape (R, C, 2), same dimension as d1</span></dt><dd><p>on output, this array will contain the composition of the two fields</p>
</dd>
<dt>stats<span class="classifier">array, shape (3,)</span></dt><dd><p>on output, this array will contain three statistics of the vector norms
of the composition (maximum, mean, standard_deviation)</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="compose-vector-fields-3d">
<h3>compose_vector_fields_3d<a class="headerlink" href="#compose-vector-fields-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.compose_vector_fields_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">compose_vector_fields_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">premult_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">premult_disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.compose_vector_fields_3d" title="Link to this definition">#</a></dt>
<dd><p>Computes the composition of two 3D displacement fields</p>
<p>Computes the composition of the two 3-D displacements d1 and d2. The
evaluation of d2 at non-lattice points is computed using tri-linear
interpolation. The actual composition is computed as:</p>
<p>comp[i] = d1[i] + t * d2[ A * i + B * d1[i] ]</p>
<p>where t = time_scaling, A = premult_index and B=premult_disp and i denotes
the voxel coordinates of a voxel in d1’s grid. Using this parameters it is
possible to compose vector fields with arbitrary discretization: let R and
S be the voxel-to-space transformation associated to d1 and d2,
respectively then the composition at a voxel with coordinates i in d1’s
grid is given by:</p>
<p>comp[i] = d1[i] + R*i + d2[Sinv*(R*i + d1[i])] - R*i</p>
<p>(the R*i terms cancel each other) where Sinv = S^{-1}
we can then define A = Sinv * R and B = Sinv to compute the composition
using this function.</p>
<section id="id306">
<h4>Parameters<a class="headerlink" href="#id306" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d1<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>first displacement field to be applied. S, R, C are the number of
slices, rows and columns of the displacement field, respectively.</p>
</dd>
<dt>d2<span class="classifier">array, shape (S’, R’, C’, 3)</span></dt><dd><p>second displacement field to be applied. R’, C’ are the number of rows
and columns of the displacement field, respectively.</p>
</dd>
<dt>premult_index<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix A in the explanation above</p>
</dd>
<dt>premult_disp<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix B in the explanation above</p>
</dd>
<dt>time_scaling<span class="classifier">float</span></dt><dd><p>this corresponds to the time scaling ‘t’ in the above explanation</p>
</dd>
<dt>comp<span class="classifier">array, shape (S, R, C, 3), same dimension as d1</span></dt><dd><p>the buffer to write the composition to. If None, the buffer will be
created internally</p>
</dd>
</dl>
</section>
<section id="id307">
<h4>Returns<a class="headerlink" href="#id307" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>comp<span class="classifier">array, shape (S, R, C, 3), same dimension as d1</span></dt><dd><p>on output, this array will contain the composition of the two fields</p>
</dd>
<dt>stats<span class="classifier">array, shape (3,)</span></dt><dd><p>on output, this array will contain three statistics of the vector norms
of the composition (maximum, mean, standard_deviation)</p>
</dd>
</dl>
</section>
<section id="id308">
<h4>Notes<a class="headerlink" href="#id308" title="Link to this heading">#</a></h4>
<p>If d1[s,r,c] lies outside the domain of d2, then comp[s,r,c] will contain
a zero vector.</p>
</section>
</dd></dl>

</section>
<section id="create-circle">
<h3>create_circle<a class="headerlink" href="#create-circle" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.create_circle">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">create_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nrows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.create_circle" title="Link to this definition">#</a></dt>
<dd><p>Create a binary 2D image where pixel values are 1 iff their distance
to the center of the image is less than or equal to radius.</p>
<section id="id309">
<h4>Parameters<a class="headerlink" href="#id309" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>nrows<span class="classifier">int</span></dt><dd><p>number of rows of the resulting image</p>
</dd>
<dt>ncols<span class="classifier">int</span></dt><dd><p>number of columns of the resulting image</p>
</dd>
<dt>radius<span class="classifier">int</span></dt><dd><p>the radius of the circle</p>
</dd>
</dl>
</section>
<section id="id310">
<h4>Returns<a class="headerlink" href="#id310" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>c<span class="classifier">array, shape (nrows, ncols)</span></dt><dd><p>the binary image of the circle with the requested dimensions</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="create-harmonic-fields-2d">
<h3>create_harmonic_fields_2d<a class="headerlink" href="#create-harmonic-fields-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.create_harmonic_fields_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">create_harmonic_fields_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nrows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.create_harmonic_fields_2d" title="Link to this definition">#</a></dt>
<dd><p>Creates an invertible 2D displacement field</p>
<p>Creates the invertible displacement fields used in Chen et al. eqs.
9 and 10 [1]</p>
<section id="id311">
<h4>Parameters<a class="headerlink" href="#id311" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>nrows<span class="classifier">int</span></dt><dd><p>number of rows in the resulting harmonic field</p>
</dd>
<dt>ncols<span class="classifier">int</span></dt><dd><p>number of columns in the resulting harmonic field</p>
</dd>
<dt>b, m<span class="classifier">float</span></dt><dd><p>parameters of the harmonic field (as in [1]). To understand the effect
of these parameters, please consider plotting a deformed image
(a circle or a grid) under the deformation field, or see examples
in [1]</p>
</dd>
</dl>
</section>
<section id="id312">
<h4>Returns<a class="headerlink" href="#id312" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d<span class="classifier">array, shape (nrows, ncols, 2)</span></dt><dd><p>the harmonic displacement field</p>
</dd>
<dt>inv<span class="classifier">array, shape (nrows, ncols, 2)</span></dt><dd><p>the analytical inverse of the harmonic displacement field</p>
</dd>
<dt>[1] Chen, M., Lu, W., Chen, Q., Ruchala, K. J., &amp; Olivera, G. H. (2008).</dt><dd><p>A simple fixed-point approach to invert a deformation field.
Medical Physics, 35(1), 81. doi:10.1118/1.2816107</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="create-harmonic-fields-3d">
<h3>create_harmonic_fields_3d<a class="headerlink" href="#create-harmonic-fields-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.create_harmonic_fields_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">create_harmonic_fields_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nslices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.create_harmonic_fields_3d" title="Link to this definition">#</a></dt>
<dd><p>Creates an invertible 3D displacement field</p>
<p>Creates the invertible displacement fields used in Chen et al. eqs.
9 and 10 [1] computing the angle theta along z-slides.</p>
<section id="id313">
<h4>Parameters<a class="headerlink" href="#id313" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>nslices<span class="classifier">int</span></dt><dd><p>number of slices in the resulting harmonic field</p>
</dd>
<dt>nrows<span class="classifier">int</span></dt><dd><p>number of rows in the resulting harmonic field</p>
</dd>
<dt>ncols<span class="classifier">int</span></dt><dd><p>number of columns in the resulting harmonic field</p>
</dd>
<dt>b, f<span class="classifier">float</span></dt><dd><p>parameters of the harmonic field (as in [1]). To understand the effect
of these parameters, please consider plotting a deformed image
(e.g. a circle or a grid) under the deformation field, or see examples
in [1]</p>
</dd>
</dl>
</section>
<section id="id314">
<h4>Returns<a class="headerlink" href="#id314" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d<span class="classifier">array, shape (nslices, nrows, ncols, 3)</span></dt><dd><p>the harmonic displacement field</p>
</dd>
<dt>inv<span class="classifier">array, shape (nslices, nrows, ncols, 3)</span></dt><dd><p>the analytical inverse of the harmonic displacement field</p>
</dd>
<dt>[1] Chen, M., Lu, W., Chen, Q., Ruchala, K. J., &amp; Olivera, G. H. (2008).</dt><dd><p>A simple fixed-point approach to invert a deformation field.
Medical Physics, 35(1), 81. doi:10.1118/1.2816107</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="create-random-displacement-2d">
<h3>create_random_displacement_2d<a class="headerlink" href="#create-random-displacement-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.create_random_displacement_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">create_random_displacement_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_grid2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_grid2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.create_random_displacement_2d" title="Link to this definition">#</a></dt>
<dd><p>Creates a random 2D displacement ‘exactly’ mapping points of two grids</p>
<p>Creates a random 2D displacement field mapping points of an input discrete
domain (with dimensions given by from_shape) to points of an output
discrete domain (with shape given by to_shape). The affine matrices
bringing discrete coordinates to physical space are given by
from_grid2world (for the displacement field discretization) and
to_grid2world (for the target discretization). Since this function is
intended to be used for testing, voxels in the input domain will never be
assigned to boundary voxels on the output domain.</p>
<section id="id315">
<h4>Parameters<a class="headerlink" href="#id315" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>from_shape<span class="classifier">array, shape (2,)</span></dt><dd><p>the grid shape where the displacement field will be defined on.</p>
</dd>
<dt>from_grid2world<span class="classifier">array, shape (3,3)</span></dt><dd><p>the grid-to-space transformation of the displacement field</p>
</dd>
<dt>to_shape<span class="classifier">array, shape (2,)</span></dt><dd><p>the grid shape where the deformation field will map the input grid to.</p>
</dd>
<dt>to_grid2world<span class="classifier">array, shape (3,3)</span></dt><dd><p>the grid-to-space transformation of the mapped grid</p>
</dd>
<dt>rng<span class="classifier">numpy.rnadom.Generator class, optional</span></dt><dd><p>Numpy’s random generator for setting seed values when needed.
Default is None.</p>
</dd>
</dl>
</section>
<section id="id316">
<h4>Returns<a class="headerlink" href="#id316" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>output<span class="classifier">array, shape = from_shape</span></dt><dd><p>the random displacement field in the physical domain</p>
</dd>
<dt>int_field<span class="classifier">array, shape = from_shape</span></dt><dd><p>the assignment of each point in the input grid to the target grid</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="create-random-displacement-3d">
<h3>create_random_displacement_3d<a class="headerlink" href="#create-random-displacement-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.create_random_displacement_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">create_random_displacement_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_grid2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_grid2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.create_random_displacement_3d" title="Link to this definition">#</a></dt>
<dd><p>Creates a random 3D displacement ‘exactly’ mapping points of two grids</p>
<p>Creates a random 3D displacement field mapping points of an input discrete
domain (with dimensions given by from_shape) to points of an output
discrete domain (with shape given by to_shape). The affine matrices
bringing discrete coordinates to physical space are given by
from_grid2world (for the displacement field discretization) and
to_grid2world (for the target discretization). Since this function is
intended to be used for testing, voxels in the input domain will never be
assigned to boundary voxels on the output domain.</p>
<section id="id317">
<h4>Parameters<a class="headerlink" href="#id317" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>from_shape<span class="classifier">array, shape (3,)</span></dt><dd><p>the grid shape where the displacement field will be defined on.</p>
</dd>
<dt>from_grid2world<span class="classifier">array, shape (4,4)</span></dt><dd><p>the grid-to-space transformation of the displacement field</p>
</dd>
<dt>to_shape<span class="classifier">array, shape (3,)</span></dt><dd><p>the grid shape where the deformation field will map the input grid to.</p>
</dd>
<dt>to_grid2world<span class="classifier">array, shape (4,4)</span></dt><dd><p>the grid-to-space transformation of the mapped grid</p>
</dd>
<dt>rng<span class="classifier">numpy.rnadom.Generator class, optional</span></dt><dd><p>Numpy’s random generator for setting seed values when needed.
Default is None.</p>
</dd>
</dl>
</section>
<section id="id318">
<h4>Returns<a class="headerlink" href="#id318" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>output<span class="classifier">array, shape = from_shape</span></dt><dd><p>the random displacement field in the physical domain</p>
</dd>
<dt>int_field<span class="classifier">array, shape = from_shape</span></dt><dd><p>the assignment of each point in the input grid to the target grid</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="create-sphere">
<h3>create_sphere<a class="headerlink" href="#create-sphere" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.create_sphere">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">create_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nslices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.create_sphere" title="Link to this definition">#</a></dt>
<dd><p>Create a binary 3D image where voxel values are 1 iff their distance
to the center of the image is less than or equal to radius.</p>
<section id="id319">
<h4>Parameters<a class="headerlink" href="#id319" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>nslices<span class="classifier">int</span></dt><dd><p>number if slices of the resulting image</p>
</dd>
<dt>nrows<span class="classifier">int</span></dt><dd><p>number of rows of the resulting image</p>
</dd>
<dt>ncols<span class="classifier">int</span></dt><dd><p>number of columns of the resulting image</p>
</dd>
<dt>radius<span class="classifier">int</span></dt><dd><p>the radius of the sphere</p>
</dd>
</dl>
</section>
<section id="id320">
<h4>Returns<a class="headerlink" href="#id320" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>c<span class="classifier">array, shape (nslices, nrows, ncols)</span></dt><dd><p>the binary image of the sphere with the requested dimensions</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="downsample-displacement-field-2d">
<h3>downsample_displacement_field_2d<a class="headerlink" href="#downsample-displacement-field-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.downsample_displacement_field_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">downsample_displacement_field_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.downsample_displacement_field_2d" title="Link to this definition">#</a></dt>
<dd><p>Down-samples the 2D input vector field by a factor of 2
Down-samples the input vector field by a factor of 2. The value at each
pixel of the resulting field is the average of its surrounding pixels in
the original field.</p>
<section id="id321">
<h4>Parameters<a class="headerlink" href="#id321" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the vector field to be down-sampled</p>
</dd>
</dl>
</section>
<section id="id322">
<h4>Returns<a class="headerlink" href="#id322" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>down<span class="classifier">array, shape (R’, C’)</span></dt><dd><p>the down-sampled displacement field, where R’= ceil(R/2), C’=ceil(C/2),</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="downsample-displacement-field-3d">
<h3>downsample_displacement_field_3d<a class="headerlink" href="#downsample-displacement-field-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.downsample_displacement_field_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">downsample_displacement_field_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.downsample_displacement_field_3d" title="Link to this definition">#</a></dt>
<dd><p>Down-samples the input 3D vector field by a factor of 2</p>
<p>Down-samples the input vector field by a factor of 2. This operation
is equivalent to dividing the input image into 2x2x2 cubes and averaging
the 8 vectors. The resulting field consists of these average vectors.</p>
<section id="id323">
<h4>Parameters<a class="headerlink" href="#id323" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>field<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the vector field to be down-sampled</p>
</dd>
</dl>
</section>
<section id="id324">
<h4>Returns<a class="headerlink" href="#id324" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>down<span class="classifier">array, shape (S’, R’, C’)</span></dt><dd><p>the down-sampled displacement field, where S’ = ceil(S/2),
R’= ceil(R/2), C’=ceil(C/2)</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="downsample-scalar-field-2d">
<h3>downsample_scalar_field_2d<a class="headerlink" href="#downsample-scalar-field-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.downsample_scalar_field_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">downsample_scalar_field_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.downsample_scalar_field_2d" title="Link to this definition">#</a></dt>
<dd><p>Down-samples the input 2D image by a factor of 2</p>
<p>Down-samples the input image by a factor of 2. The value at each pixel
of the resulting image is the average of its surrounding pixels in the
original image.</p>
<section id="id325">
<h4>Parameters<a class="headerlink" href="#id325" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>field<span class="classifier">array, shape (R, C)</span></dt><dd><p>the image to be down-sampled</p>
</dd>
</dl>
</section>
<section id="id326">
<h4>Returns<a class="headerlink" href="#id326" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>down<span class="classifier">array, shape (R’, C’)</span></dt><dd><p>the down-sampled displacement field, where R’= ceil(R/2), C’=ceil(C/2)</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="downsample-scalar-field-3d">
<h3>downsample_scalar_field_3d<a class="headerlink" href="#downsample-scalar-field-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.downsample_scalar_field_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">downsample_scalar_field_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.downsample_scalar_field_3d" title="Link to this definition">#</a></dt>
<dd><p>Down-samples the input volume by a factor of 2</p>
<p>Down-samples the input volume by a factor of 2. The value at each voxel
of the resulting volume is the average of its surrounding voxels in the
original volume.</p>
<section id="id327">
<h4>Parameters<a class="headerlink" href="#id327" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>field<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the volume to be down-sampled</p>
</dd>
</dl>
</section>
<section id="id328">
<h4>Returns<a class="headerlink" href="#id328" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>down<span class="classifier">array, shape (S’, R’, C’)</span></dt><dd><p>the down-sampled displacement field, where S’ = ceil(S/2),
R’= ceil(R/2), C’=ceil(C/2)</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="gradient">
<h3>gradient<a class="headerlink" href="#gradient" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.gradient">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img_world2grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img_spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_grid2world</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.gradient" title="Link to this definition">#</a></dt>
<dd><p>Gradient of an image in physical space</p>
<section id="id329">
<h4>Parameters<a class="headerlink" href="#id329" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>img<span class="classifier">2D or 3D array, shape (R, C) or (S, R, C)</span></dt><dd><p>the input image whose gradient will be computed</p>
</dd>
<dt>img_world2grid<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the space-to-grid transform matrix associated to img</p>
</dd>
<dt>img_spacing<span class="classifier">array, shape (dim,)</span></dt><dd><p>the spacing between voxels (voxel size along each axis) of the input
image</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of (slices), rows and columns of the sampling grid</p>
</dd>
<dt>out_grid2world<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the grid-to-space transform associated to the sampling grid</p>
</dd>
</dl>
</section>
<section id="id330">
<h4>Returns<a class="headerlink" href="#id330" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (R’, C’, 2) or (S’, R’, C’, 3)</span></dt><dd><p>the buffer in which to store the image gradient, where
(S’), R’, C’ are given by out_shape</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="invert-vector-field-fixed-point-2d">
<h3>invert_vector_field_fixed_point_2d<a class="headerlink" href="#invert-vector-field-fixed-point-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.invert_vector_field_fixed_point_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">invert_vector_field_fixed_point_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_world2grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.invert_vector_field_fixed_point_2d" title="Link to this definition">#</a></dt>
<dd><p>Computes the inverse of a 2D displacement fields</p>
<p>Computes the inverse of the given 2-D displacement field d using the
fixed-point algorithm [1].</p>
<dl class="simple">
<dt>[1] Chen, M., Lu, W., Chen, Q., Ruchala, K. J., &amp; Olivera, G. H. (2008).</dt><dd><p>A simple fixed-point approach to invert a deformation field.
Medical Physics, 35(1), 81. doi:10.1118/1.2816107</p>
</dd>
</dl>
<section id="id331">
<h4>Parameters<a class="headerlink" href="#id331" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the 2-D displacement field to be inverted</p>
</dd>
<dt>d_world2grid<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the space-to-grid transformation associated to the displacement field
d (transforming physical space coordinates to voxel coordinates of the
displacement field grid)</p>
</dd>
<dt>spacing :array, shape (2,)</dt><dd><p>the spacing between voxels (voxel size along each axis)</p>
</dd>
<dt>max_iter<span class="classifier">int</span></dt><dd><p>maximum number of iterations to be performed</p>
</dd>
<dt>tolerance<span class="classifier">float</span></dt><dd><p>maximum tolerated inversion error</p>
</dd>
<dt>start<span class="classifier">array, shape (R, C)</span></dt><dd><p>an approximation to the inverse displacement field (if no approximation
is available, None can be provided and the start displacement field
will be zero)</p>
</dd>
</dl>
</section>
<section id="id332">
<h4>Returns<a class="headerlink" href="#id332" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>p<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the inverse displacement field</p>
</dd>
</dl>
</section>
<section id="id333">
<h4>Notes<a class="headerlink" href="#id333" title="Link to this heading">#</a></h4>
<p>We assume that the displacement field is an endomorphism so that the shape
and voxel-to-space transformation of the inverse field’s discretization is
the same as those of the input displacement field. The ‘inversion error’ at
iteration t is defined as the mean norm of the displacement vectors of the
input displacement field composed with the inverse at iteration t.</p>
</section>
</dd></dl>

</section>
<section id="invert-vector-field-fixed-point-3d">
<h3>invert_vector_field_fixed_point_3d<a class="headerlink" href="#invert-vector-field-fixed-point-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.invert_vector_field_fixed_point_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">invert_vector_field_fixed_point_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_world2grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.invert_vector_field_fixed_point_3d" title="Link to this definition">#</a></dt>
<dd><p>Computes the inverse of a 3D displacement fields</p>
<p>Computes the inverse of the given 3-D displacement field d using the
fixed-point algorithm [1].</p>
<dl class="simple">
<dt>[1] Chen, M., Lu, W., Chen, Q., Ruchala, K. J., &amp; Olivera, G. H. (2008).</dt><dd><p>A simple fixed-point approach to invert a deformation field.
Medical Physics, 35(1), 81. doi:10.1118/1.2816107</p>
</dd>
</dl>
<section id="id334">
<h4>Parameters<a class="headerlink" href="#id334" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the 3-D displacement field to be inverted</p>
</dd>
<dt>d_world2grid<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the space-to-grid transformation associated to the displacement field
d (transforming physical space coordinates to voxel coordinates of the
displacement field grid)</p>
</dd>
<dt>spacing :array, shape (3,)</dt><dd><p>the spacing between voxels (voxel size along each axis)</p>
</dd>
<dt>max_iter<span class="classifier">int</span></dt><dd><p>maximum number of iterations to be performed</p>
</dd>
<dt>tol<span class="classifier">float</span></dt><dd><p>maximum tolerated inversion error</p>
</dd>
<dt>start<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>an approximation to the inverse displacement field (if no approximation
is available, None can be provided and the start displacement field
will be zero)</p>
</dd>
</dl>
</section>
<section id="id335">
<h4>Returns<a class="headerlink" href="#id335" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>p<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the inverse displacement field</p>
</dd>
</dl>
</section>
<section id="id336">
<h4>Notes<a class="headerlink" href="#id336" title="Link to this heading">#</a></h4>
<p>We assume that the displacement field is an endomorphism so that the shape
and voxel-to-space transformation of the inverse field’s discretization is
the same as those of the input displacement field. The ‘inversion error’ at
iteration t is defined as the mean norm of the displacement vectors of the
input displacement field composed with the inverse at iteration t.</p>
</section>
</dd></dl>

</section>
<section id="is-valid-affine">
<h3>is_valid_affine<a class="headerlink" href="#is-valid-affine" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.is_valid_affine">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">is_valid_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.is_valid_affine" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="reorient-vector-field-2d">
<h3>reorient_vector_field_2d<a class="headerlink" href="#reorient-vector-field-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.reorient_vector_field_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">reorient_vector_field_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.reorient_vector_field_2d" title="Link to this definition">#</a></dt>
<dd><p>Linearly transforms all vectors of a 2D displacement field</p>
<p>Modifies the input displacement field by multiplying each displacement
vector by the given matrix. Note that the elements of the displacement
field are vectors, not points, so their last homogeneous coordinate is
zero, not one, and therefore the translation component of the affine
transform will not have any effect on them.</p>
<section id="id337">
<h4>Parameters<a class="headerlink" href="#id337" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d<span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the displacement field to be re-oriented</p>
</dd>
<dt>affine: array, shape (3, 3)</dt><dd><p>the matrix to be applied</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="reorient-vector-field-3d">
<h3>reorient_vector_field_3d<a class="headerlink" href="#reorient-vector-field-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.reorient_vector_field_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">reorient_vector_field_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.reorient_vector_field_3d" title="Link to this definition">#</a></dt>
<dd><p>Linearly transforms all vectors of a 3D displacement field</p>
<p>Modifies the input displacement field by multiplying each displacement
vector by the given matrix. Note that the elements of the displacement
field are vectors, not points, so their last homogeneous coordinate is
zero, not one, and therefore the translation component of the affine
transform will not have any effect on them.</p>
<section id="id338">
<h4>Parameters<a class="headerlink" href="#id338" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d<span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the displacement field to be re-oriented</p>
</dd>
<dt>affine<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix to be applied</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="resample-displacement-field-2d">
<h3>resample_displacement_field_2d<a class="headerlink" href="#resample-displacement-field-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.resample_displacement_field_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">resample_displacement_field_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.resample_displacement_field_2d" title="Link to this definition">#</a></dt>
<dd><p>Resamples a 2D vector field to a custom target shape</p>
<p>Resamples the given 2D displacement field on a grid of the requested shape,
using the given scale factors. More precisely, the resulting displacement
field at each grid cell i is given by</p>
<p>D[i] = field[Diag(factors) * i]</p>
<section id="id339">
<h4>Parameters<a class="headerlink" href="#id339" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>factors<span class="classifier">array, shape (2,)</span></dt><dd><p>the scaling factors mapping (integer) grid coordinates in the resampled
grid to (floating point) grid coordinates in the original grid</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (2,)</span></dt><dd><p>the desired shape of the resulting grid</p>
</dd>
</dl>
</section>
<section id="id340">
<h4>Returns<a class="headerlink" href="#id340" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>expanded<span class="classifier">array, shape = out_shape + (2, )</span></dt><dd><p>the resampled displacement field</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="resample-displacement-field-3d">
<h3>resample_displacement_field_3d<a class="headerlink" href="#resample-displacement-field-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.resample_displacement_field_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">resample_displacement_field_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.resample_displacement_field_3d" title="Link to this definition">#</a></dt>
<dd><p>Resamples a 3D vector field to a custom target shape</p>
<p>Resamples the given 3D displacement field on a grid of the requested shape,
using the given scale factors. More precisely, the resulting displacement
field at each grid cell i is given by</p>
<p>D[i] = field[Diag(factors) * i]</p>
<section id="id341">
<h4>Parameters<a class="headerlink" href="#id341" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>factors<span class="classifier">array, shape (3,)</span></dt><dd><p>the scaling factors mapping (integer) grid coordinates in the resampled
grid to (floating point) grid coordinates in the original grid</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (3,)</span></dt><dd><p>the desired shape of the resulting grid</p>
</dd>
</dl>
</section>
<section id="id342">
<h4>Returns<a class="headerlink" href="#id342" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>expanded<span class="classifier">array, shape = out_shape + (3, )</span></dt><dd><p>the resampled displacement field</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="simplify-warp-function-2d">
<h3>simplify_warp_function_2d<a class="headerlink" href="#simplify-warp-function-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.simplify_warp_function_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">simplify_warp_function_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.simplify_warp_function_2d" title="Link to this definition">#</a></dt>
<dd><p>Simplifies a nonlinear warping function combined with an affine transform</p>
<p>Modifies the given deformation field by incorporating into it a
an affine transformation and voxel-to-space transforms associated to
the discretization of its domain and codomain.
The resulting transformation may be regarded as operating on the
image spaces given by the domain and codomain discretization.
More precisely, the resulting transform is of the form:</p>
<ol class="arabic simple">
<li><p>T[i] = W * d[U * i] + V * i</p></li>
</ol>
<p>Where U = affine_idx_in, V = affine_idx_out, W = affine_disp.</p>
<section id="id343">
<h4>Parameters<a class="headerlink" href="#id343" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d<span class="classifier">array, shape (R’, C’, 2)</span></dt><dd><p>the non-linear part of the transformation (displacement field)</p>
</dd>
<dt>affine_idx_in<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix U in eq. (1) above</p>
</dd>
<dt>affine_idx_out<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix V in eq. (1) above</p>
</dd>
<dt>affine_disp<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix W in eq. (1) above</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (2,)</span></dt><dd><p>the number of rows and columns of the sampling grid</p>
</dd>
</dl>
</section>
<section id="id344">
<h4>Returns<a class="headerlink" href="#id344" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape = out_shape</span></dt><dd><p>the deformation field <cite>out</cite> associated with <cite>T</cite> in eq. (1) such that:
T[i] = i + out[i]</p>
</dd>
</dl>
</section>
<section id="id345">
<h4>Notes<a class="headerlink" href="#id345" title="Link to this heading">#</a></h4>
<p>Both the direct and inverse transforms of a DiffeomorphicMap can be written
in this form:</p>
<dl>
<dt>Direct:  Let D be the voxel-to-space transform of the domain’s</dt><dd><p>discretization, P be the pre-align matrix, Rinv the space-to-voxel
transform of the reference grid (the grid the displacement field
is defined on) and Cinv be the space-to-voxel transform of the
codomain’s discretization. Then, for each i in the domain’s grid,
the direct transform is given by</p>
<ol class="arabic simple" start="2">
<li><p>T[i] = Cinv * d[Rinv * P * D * i] + Cinv * P * D * i</p></li>
</ol>
<p>and we identify U = Rinv * P * D, V = Cinv * P * D, W = Cinv</p>
</dd>
<dt>Inverse: Let C be the voxel-to-space transform of the codomain’s</dt><dd><p>discretization, Pinv be the inverse of the pre-align matrix, Rinv
the space-to-voxel transform of the reference grid (the grid the
displacement field is defined on) and Dinv be the space-to-voxel
transform of the domain’s discretization. Then, for each j in the
codomain’s grid, the inverse transform is given by</p>
<ol class="arabic simple" start="3">
<li><p>Tinv[j] = Dinv * Pinv * d[Rinv * C * j] + Dinv * Pinv * C * j</p></li>
</ol>
<p>and we identify U = Rinv * C, V = Dinv * Pinv * C, W = Dinv * Pinv</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="simplify-warp-function-3d">
<h3>simplify_warp_function_3d<a class="headerlink" href="#simplify-warp-function-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.simplify_warp_function_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">simplify_warp_function_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.simplify_warp_function_3d" title="Link to this definition">#</a></dt>
<dd><p>Simplifies a nonlinear warping function combined with an affine transform</p>
<p>Modifies the given deformation field by incorporating into it
an affine transformation and voxel-to-space transforms associated with
the discretization of its domain and codomain.</p>
<p>The resulting transformation may be regarded as operating on the
image spaces given by the domain and codomain discretization.
More precisely, the resulting transform is of the form:</p>
<ol class="arabic simple">
<li><p>T[i] = W * d[U * i] + V * i</p></li>
</ol>
<p>Where U = affine_idx_in, V = affine_idx_out, W = affine_disp.</p>
<section id="id346">
<h4>Parameters<a class="headerlink" href="#id346" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>d<span class="classifier">array, shape (S’, R’, C’, 3)</span></dt><dd><p>the non-linear part of the transformation (displacement field)</p>
</dd>
<dt>affine_idx_in<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix U in eq. (1) above</p>
</dd>
<dt>affine_idx_out<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix V in eq. (1) above</p>
</dd>
<dt>affine_disp<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix W in eq. (1) above</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (3,)</span></dt><dd><p>the number of slices, rows and columns of the sampling grid</p>
</dd>
</dl>
</section>
<section id="id347">
<h4>Returns<a class="headerlink" href="#id347" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape = out_shape</span></dt><dd><p>the deformation field <cite>out</cite> associated with <cite>T</cite> in eq. (1) such that:
T[i] = i + out[i]</p>
</dd>
</dl>
</section>
<section id="id348">
<h4>Notes<a class="headerlink" href="#id348" title="Link to this heading">#</a></h4>
<p>Both the direct and inverse transforms of a DiffeomorphicMap can be written
in this form:</p>
<dl>
<dt>Direct:  Let D be the voxel-to-space transform of the domain’s</dt><dd><p>discretization, P be the pre-align matrix, Rinv the space-to-voxel
transform of the reference grid (the grid the displacement field
is defined on) and Cinv be the space-to-voxel transform of the
codomain’s discretization. Then, for each i in the domain’s grid,
the direct transform is given by</p>
<ol class="arabic simple" start="2">
<li><p>T[i] = Cinv * d[Rinv * P * D * i] + Cinv * P * D * i</p></li>
</ol>
<p>and we identify U = Rinv * P * D, V = Cinv * P * D, W = Cinv</p>
</dd>
<dt>Inverse: Let C be the voxel-to-space transform of the codomain’s</dt><dd><p>discretization, Pinv be the inverse of the pre-align matrix, Rinv
the space-to-voxel transform of the reference grid (the grid the
displacement field is defined on) and Dinv be the space-to-voxel
transform of the domain’s discretization. Then, for each j in the
codomain’s grid, the inverse transform is given by</p>
<ol class="arabic simple" start="3">
<li><p>Tinv[j] = Dinv * Pinv * d[Rinv * C * j] + Dinv * Pinv * C * j</p></li>
</ol>
<p>and we identify U = Rinv * C, V = Dinv * Pinv * C, W = Dinv * Pinv</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="sparse-gradient">
<h3>sparse_gradient<a class="headerlink" href="#sparse-gradient" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.sparse_gradient">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">sparse_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img_world2grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img_spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.sparse_gradient" title="Link to this definition">#</a></dt>
<dd><p>Gradient of an image in physical space</p>
<section id="id349">
<h4>Parameters<a class="headerlink" href="#id349" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>img<span class="classifier">2D or 3D array, shape (R, C) or (S, R, C)</span></dt><dd><p>the input image whose gradient will be computed</p>
</dd>
<dt>img_world2grid<span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the space-to-grid transform matrix associated to img</p>
</dd>
<dt>img_spacing<span class="classifier">array, shape (dim,)</span></dt><dd><p>the spacing between voxels (voxel size along each axis) of the input
image</p>
</dd>
<dt>sample_points: array, shape (n, dim)</dt><dd><p>list of points where the derivative will be evaluated
(one point per row)</p>
</dd>
</dl>
</section>
<section id="id350">
<h4>Returns<a class="headerlink" href="#id350" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (n, dim)</span></dt><dd><p>the gradient at each point stored at its corresponding row</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="transform-2d-affine">
<h3>transform_2d_affine<a class="headerlink" href="#transform-2d-affine" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.transform_2d_affine">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">transform_2d_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.transform_2d_affine" title="Link to this definition">#</a></dt>
<dd><p>Transforms a 2D image by an affine transform with bilinear interp.</p>
<p>Deforms the input image under the given affine transformation using
tri-linear interpolation. The shape of the resulting image
is given by ref_shape. If the affine matrix is None, it is taken as the
identity.</p>
<section id="id351">
<h4>Parameters<a class="headerlink" href="#id351" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>image<span class="classifier">array, shape (R, C)</span></dt><dd><p>the input image to be transformed</p>
</dd>
<dt>ref_shape<span class="classifier">array, shape (2,)</span></dt><dd><p>the shape of the resulting image</p>
</dd>
<dt>affine<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the affine transform to be applied</p>
</dd>
</dl>
</section>
<section id="id352">
<h4>Returns<a class="headerlink" href="#id352" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (R’, C’)</span></dt><dd><p>the transformed image</p>
</dd>
</dl>
</section>
<section id="id353">
<h4>Notes<a class="headerlink" href="#id353" title="Link to this heading">#</a></h4>
<p>The reason it is necessary to provide the intended shape of the resulting
image is because the affine transformation is defined on all R^{2}
but we must sample a finite lattice. Also the resulting shape may not be
necessarily equal to the input shape, unless we are interested on
endomorphisms only and not general diffeomorphisms.</p>
</section>
</dd></dl>

</section>
<section id="transform-2d-affine-nn">
<h3>transform_2d_affine_nn<a class="headerlink" href="#transform-2d-affine-nn" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.transform_2d_affine_nn">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">transform_2d_affine_nn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.transform_2d_affine_nn" title="Link to this definition">#</a></dt>
<dd><p>Transforms a 2D image by an affine transform with NN interpolation</p>
<p>Deforms the input image under the given affine transformation using
nearest neighbor interpolation. The shape of the resulting image
is given by ref_shape. If the affine matrix is None, it is taken as the
identity.</p>
<section id="id354">
<h4>Parameters<a class="headerlink" href="#id354" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>image<span class="classifier">array, shape (R, C)</span></dt><dd><p>the input image to be transformed</p>
</dd>
<dt>ref_shape<span class="classifier">array, shape (2,)</span></dt><dd><p>the shape of the resulting image</p>
</dd>
<dt>affine<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the affine transform to be applied</p>
</dd>
</dl>
</section>
<section id="id355">
<h4>Returns<a class="headerlink" href="#id355" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (R’, C’)</span></dt><dd><p>the transformed image</p>
</dd>
</dl>
</section>
<section id="id356">
<h4>Notes<a class="headerlink" href="#id356" title="Link to this heading">#</a></h4>
<p>The reason it is necessary to provide the intended shape of the resulting
image is because the affine transformation is defined on all R^{2}
but we must sample a finite lattice. Also the resulting shape may not be
necessarily equal to the input shape, unless we are interested on
endomorphisms only and not general diffeomorphisms.</p>
</section>
</dd></dl>

</section>
<section id="transform-3d-affine">
<h3>transform_3d_affine<a class="headerlink" href="#transform-3d-affine" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.transform_3d_affine">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">transform_3d_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.transform_3d_affine" title="Link to this definition">#</a></dt>
<dd><p>Transforms a 3D volume by an affine transform with trilinear interp.</p>
<p>Deforms the input volume under the given affine transformation using
tri-linear interpolation. The shape of the resulting transformation
is given by ref_shape. If the affine matrix is None, it is taken as the
identity.</p>
<section id="id357">
<h4>Parameters<a class="headerlink" href="#id357" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>volume<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the input volume to be transformed</p>
</dd>
<dt>ref_shape<span class="classifier">array, shape (3,)</span></dt><dd><p>the shape of the resulting volume</p>
</dd>
<dt>affine<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the affine transform to be applied</p>
</dd>
</dl>
</section>
<section id="id358">
<h4>Returns<a class="headerlink" href="#id358" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (S’, R’, C’)</span></dt><dd><p>the transformed volume</p>
</dd>
</dl>
</section>
<section id="id359">
<h4>Notes<a class="headerlink" href="#id359" title="Link to this heading">#</a></h4>
<p>The reason it is necessary to provide the intended shape of the resulting
volume is because the affine transformation is defined on all R^{3}
but we must sample a finite lattice. Also the resulting shape may not be
necessarily equal to the input shape, unless we are interested on
endomorphisms only and not general diffeomorphisms.</p>
</section>
</dd></dl>

</section>
<section id="transform-3d-affine-nn">
<h3>transform_3d_affine_nn<a class="headerlink" href="#transform-3d-affine-nn" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.transform_3d_affine_nn">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">transform_3d_affine_nn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.transform_3d_affine_nn" title="Link to this definition">#</a></dt>
<dd><p>Transforms a 3D volume by an affine transform with NN interpolation</p>
<p>Deforms the input volume under the given affine transformation using
nearest neighbor interpolation. The shape of the resulting volume
is given by ref_shape. If the affine matrix is None, it is taken as the
identity.</p>
<section id="id360">
<h4>Parameters<a class="headerlink" href="#id360" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>volume<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the input volume to be transformed</p>
</dd>
<dt>ref_shape<span class="classifier">array, shape (3,)</span></dt><dd><p>the shape of the resulting volume</p>
</dd>
<dt>affine<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the affine transform to be applied</p>
</dd>
</dl>
</section>
<section id="id361">
<h4>Returns<a class="headerlink" href="#id361" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">array, shape (S’, R’, C’)</span></dt><dd><p>the transformed volume</p>
</dd>
</dl>
</section>
<section id="id362">
<h4>Notes<a class="headerlink" href="#id362" title="Link to this heading">#</a></h4>
<p>The reason it is necessary to provide the intended shape of the resulting
volume is because the affine transformation is defined on all R^{3}
but we must sample a finite lattice. Also the resulting shape may not be
necessarily equal to the input shape, unless we are interested on
endomorphisms only and not general diffeomorphisms.</p>
</section>
</dd></dl>

</section>
<section id="warp-2d">
<h3>warp_2d<a class="headerlink" href="#warp-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.warp_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">warp_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.warp_2d" title="Link to this definition">#</a></dt>
<dd><p>Warps a 2D image using bilinear interpolation</p>
<p>Deforms the input image under the given transformation. The warped image
is computed using bi-linear interpolation and is given by:</p>
<ol class="arabic simple">
<li><p>warped[i] = image[ C * d1[A*i] + B*i ]</p></li>
</ol>
<p>where A = affine_idx_in, B = affine_idx_out, C = affine_disp and i denotes
the discrete coordinates of a voxel in the sampling grid of
shape = out_shape.</p>
<section id="id363">
<h4>Parameters<a class="headerlink" href="#id363" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>image<span class="classifier">array, shape (R, C)</span></dt><dd><p>the input image to be transformed</p>
</dd>
<dt>d1<span class="classifier">array, shape (R’, C’, 2)</span></dt><dd><p>the displacement field driving the transformation</p>
</dd>
<dt>affine_idx_in<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix A in eq. (1) above</p>
</dd>
<dt>affine_idx_out<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix B in eq. (1) above</p>
</dd>
<dt>affine_disp<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix C in eq. (1) above</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (2,)</span></dt><dd><p>the number of rows and columns of the sampling grid</p>
</dd>
</dl>
</section>
<section id="id364">
<h4>Returns<a class="headerlink" href="#id364" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>warped<span class="classifier">array, shape = out_shape</span></dt><dd><p>the transformed image</p>
</dd>
</dl>
</section>
<section id="id365">
<h4>Notes<a class="headerlink" href="#id365" title="Link to this heading">#</a></h4>
<p>To illustrate the use of this function, consider a displacement field d1
with grid-to-space transformation R, an image with grid-to-space
transformation T and let’s say we want to sample the warped image on a
grid with grid-to-space transformation S (sampling grid). For each voxel
in the sampling grid with discrete coordinates i, the warped image is
given by:</p>
<ol class="arabic simple" start="2">
<li><p>warped[i] = image[Tinv * ( d1[Rinv * S * i] + S * i ) ]</p></li>
</ol>
<p>where Tinv = T^{-1} and Rinv = R^{-1}. By identifying A = Rinv * S,
B = Tinv * S, C = Tinv we can use this function to efficiently warp the
input image.</p>
</section>
</dd></dl>

</section>
<section id="warp-2d-nn">
<h3>warp_2d_nn<a class="headerlink" href="#warp-2d-nn" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.warp_2d_nn">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">warp_2d_nn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.warp_2d_nn" title="Link to this definition">#</a></dt>
<dd><p>Warps a 2D image using nearest neighbor interpolation</p>
<p>Deforms the input image under the given transformation. The warped image
is computed using nearest-neighbor interpolation and is given by:</p>
<ol class="arabic simple">
<li><p>warped[i] = image[ C * d1[A*i] + B*i ]</p></li>
</ol>
<p>where A = affine_idx_in, B = affine_idx_out, C = affine_disp and i denotes
the discrete coordinates of a voxel in the sampling grid of
shape = out_shape.</p>
<section id="id366">
<h4>Parameters<a class="headerlink" href="#id366" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>image<span class="classifier">array, shape (R, C)</span></dt><dd><p>the input image to be transformed</p>
</dd>
<dt>d1<span class="classifier">array, shape (R’, C’, 2)</span></dt><dd><p>the displacement field driving the transformation</p>
</dd>
<dt>affine_idx_in<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix A in eq. (1) above</p>
</dd>
<dt>affine_idx_out<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix B in eq. (1) above</p>
</dd>
<dt>affine_disp<span class="classifier">array, shape (3, 3)</span></dt><dd><p>the matrix C in eq. (1) above</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (2,)</span></dt><dd><p>the number of rows and columns of the sampling grid</p>
</dd>
</dl>
</section>
<section id="id367">
<h4>Returns<a class="headerlink" href="#id367" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>warped<span class="classifier">array, shape = out_shape</span></dt><dd><p>the transformed image</p>
</dd>
</dl>
</section>
<section id="id368">
<h4>Notes<a class="headerlink" href="#id368" title="Link to this heading">#</a></h4>
<p>To illustrate the use of this function, consider a displacement field d1
with grid-to-space transformation R, an image with grid-to-space
transformation T and let’s say we want to sample the warped image on a
grid with grid-to-space transformation S (sampling grid). For each voxel
in the sampling grid with discrete coordinates i, the warped image is
given by:</p>
<ol class="arabic simple" start="2">
<li><p>warped[i] = image[Tinv * ( d1[Rinv * S * i] + S * i ) ]</p></li>
</ol>
<p>where Tinv = T^{-1} and Rinv = R^{-1}. By identifying A = Rinv * S,
B = Tinv * S, C = Tinv we can use this function to efficiently warp the
input image.</p>
</section>
</dd></dl>

</section>
<section id="warp-3d">
<h3>warp_3d<a class="headerlink" href="#warp-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.warp_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">warp_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.warp_3d" title="Link to this definition">#</a></dt>
<dd><p>Warps a 3D volume using trilinear interpolation</p>
<p>Deforms the input volume under the given transformation. The warped volume
is computed using tri-linear interpolation and is given by:</p>
<ol class="arabic simple">
<li><p>warped[i] = volume[ C * d1[A*i] + B*i ]</p></li>
</ol>
<p>where A = affine_idx_in, B = affine_idx_out, C = affine_disp and i denotes
the discrete coordinates of a voxel in the sampling grid of
shape = out_shape.</p>
<section id="id369">
<h4>Parameters<a class="headerlink" href="#id369" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>volume<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the input volume to be transformed</p>
</dd>
<dt>d1<span class="classifier">array, shape (S’, R’, C’, 3)</span></dt><dd><p>the displacement field driving the transformation</p>
</dd>
<dt>affine_idx_in<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix A in eq. (1) above</p>
</dd>
<dt>affine_idx_out<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix B in eq. (1) above</p>
</dd>
<dt>affine_disp<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix C in eq. (1) above</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (3,)</span></dt><dd><p>the number of slices, rows and columns of the sampling grid</p>
</dd>
</dl>
</section>
<section id="id370">
<h4>Returns<a class="headerlink" href="#id370" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>warped<span class="classifier">array, shape = out_shape</span></dt><dd><p>the transformed volume</p>
</dd>
</dl>
</section>
<section id="id371">
<h4>Notes<a class="headerlink" href="#id371" title="Link to this heading">#</a></h4>
<p>To illustrate the use of this function, consider a displacement field d1
with grid-to-space transformation R, a volume with grid-to-space
transformation T and let’s say we want to sample the warped volume on a
grid with grid-to-space transformation S (sampling grid). For each voxel
in the sampling grid with discrete coordinates i, the warped volume is
given by:</p>
<ol class="arabic simple" start="2">
<li><p>warped[i] = volume[Tinv * ( d1[Rinv * S * i] + S * i ) ]</p></li>
</ol>
<p>where Tinv = T^{-1} and Rinv = R^{-1}. By identifying A = Rinv * S,
B = Tinv * S, C = Tinv we can use this function to efficiently warp the
input image.</p>
</section>
</dd></dl>

</section>
<section id="warp-3d-nn">
<h3>warp_3d_nn<a class="headerlink" href="#warp-3d-nn" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.warp_3d_nn">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">warp_3d_nn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_idx_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.warp_3d_nn" title="Link to this definition">#</a></dt>
<dd><p>Warps a 3D volume using using nearest-neighbor interpolation</p>
<p>Deforms the input volume under the given transformation. The warped volume
is computed using nearest-neighbor interpolation and is given by:</p>
<ol class="arabic simple">
<li><p>warped[i] = volume[ C * d1[A*i] + B*i ]</p></li>
</ol>
<p>where A = affine_idx_in, B = affine_idx_out, C = affine_disp and i denotes
the discrete coordinates of a voxel in the sampling grid of
shape = out_shape.</p>
<section id="id372">
<h4>Parameters<a class="headerlink" href="#id372" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>volume<span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the input volume to be transformed</p>
</dd>
<dt>d1<span class="classifier">array, shape (S’, R’, C’, 3)</span></dt><dd><p>the displacement field driving the transformation</p>
</dd>
<dt>affine_idx_in<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix A in eq. (1) above</p>
</dd>
<dt>affine_idx_out<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix B in eq. (1) above</p>
</dd>
<dt>affine_disp<span class="classifier">array, shape (4, 4)</span></dt><dd><p>the matrix C in eq. (1) above</p>
</dd>
<dt>out_shape<span class="classifier">array, shape (3,)</span></dt><dd><p>the number of slices, rows and columns of the sampling grid</p>
</dd>
</dl>
</section>
<section id="id373">
<h4>Returns<a class="headerlink" href="#id373" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>warped<span class="classifier">array, shape = out_shape</span></dt><dd><p>the transformed volume</p>
</dd>
</dl>
</section>
<section id="id374">
<h4>Notes<a class="headerlink" href="#id374" title="Link to this heading">#</a></h4>
<p>To illustrate the use of this function, consider a displacement field d1
with grid-to-space transformation R, a volume with grid-to-space
transformation T and let’s say we want to sample the warped volume on a
grid with grid-to-space transformation S (sampling grid). For each voxel
in the sampling grid with discrete coordinates i, the warped volume is
given by:</p>
<ol class="arabic simple" start="2">
<li><p>warped[i] = volume[Tinv * ( d1[Rinv * S * i] + S * i ) ]</p></li>
</ol>
<p>where Tinv = T^{-1} and Rinv = R^{-1}. By identifying A = Rinv * S,
B = Tinv * S, C = Tinv we can use this function to efficiently warp the
input image.</p>
</section>
</dd></dl>

</section>
<section id="warp-coordinates-2d">
<h3>warp_coordinates_2d<a class="headerlink" href="#warp-coordinates-2d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.warp_coordinates_2d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">warp_coordinates_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">world2out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_world2grid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.warp_coordinates_2d" title="Link to this definition">#</a></dt>
<dd><section id="id375">
<h4>Parameters<a class="headerlink" href="#id375" title="Link to this heading">#</a></h4>
<p>points : array, shape (n, 2)
d1 : array, shape (S, R, C, 2)
in2world : array, shape (3, 3)
world2out : array, shape (3, 3)
field_world2grid : array, shape (3, 3)</p>
</section>
</dd></dl>

</section>
<section id="warp-coordinates-3d">
<h3>warp_coordinates_3d<a class="headerlink" href="#warp-coordinates-3d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.align.vector_fields.warp_coordinates_3d">
<span class="sig-prename descclassname"><span class="pre">dipy.align.vector_fields.</span></span><span class="sig-name descname"><span class="pre">warp_coordinates_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2world</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">world2out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_world2grid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.vector_fields.warp_coordinates_3d" title="Link to this definition">#</a></dt>
<dd><section id="id376">
<h4>Parameters<a class="headerlink" href="#id376" title="Link to this heading">#</a></h4>
<p>points : array, shape (n, 3)
d1 : array, shape (S, R, C, 3)
in2world : array, shape (4, 4)
world2out : array, shape (4, 4)
field_world2grid : array, shape (4, 4)</p>
</section>
</dd></dl>

</section>
</section>
</section>


                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="dipy.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dipy</span></code></p>
      </div>
    </a>
    <a class="right-next"
       href="dipy.core.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><code class="xref py py-mod docutils literal notranslate"><span class="pre">core</span></code></p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align._public">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align._public</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.bundlemin">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.bundlemin</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.cpd">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.cpd</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#note">Note</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.crosscorr">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.crosscorr</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.expectmax">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.expectmax</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.imaffine">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.imaffine</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.imwarp">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.imwarp</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.metrics">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.metrics</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.parzenhist">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.parzenhist</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.reslice">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.reslice</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.scalespace">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.scalespace</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.streamlinear">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.streamlinear</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.streamwarp">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.streamwarp</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.sumsqdiff">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.sumsqdiff</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.transforms">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.transforms</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.align.vector_fields">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.vector_fields</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bunch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bunch</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.Bunch"><code class="docutils literal notranslate"><span class="pre">Bunch</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.Bunch.__init__"><code class="docutils literal notranslate"><span class="pre">Bunch.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#verbositylevels">VerbosityLevels</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.VerbosityLevels"><code class="docutils literal notranslate"><span class="pre">VerbosityLevels()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#syn-registration">syn_registration</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.syn_registration"><code class="docutils literal notranslate"><span class="pre">syn_registration()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#register-dwi-to-template">register_dwi_to_template</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.register_dwi_to_template"><code class="docutils literal notranslate"><span class="pre">register_dwi_to_template()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#write-mapping">write_mapping</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.write_mapping"><code class="docutils literal notranslate"><span class="pre">write_mapping()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#read-mapping">read_mapping</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.read_mapping"><code class="docutils literal notranslate"><span class="pre">read_mapping()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#resample">resample</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.resample"><code class="docutils literal notranslate"><span class="pre">resample()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#affine-registration">affine_registration</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.affine_registration"><code class="docutils literal notranslate"><span class="pre">affine_registration()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#center-of-mass">center_of_mass</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.center_of_mass"><code class="docutils literal notranslate"><span class="pre">center_of_mass()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#translation">translation</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.translation"><code class="docutils literal notranslate"><span class="pre">translation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigid">rigid</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.rigid"><code class="docutils literal notranslate"><span class="pre">rigid()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigid-isoscaling">rigid_isoscaling</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.rigid_isoscaling"><code class="docutils literal notranslate"><span class="pre">rigid_isoscaling()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigid-scaling">rigid_scaling</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.rigid_scaling"><code class="docutils literal notranslate"><span class="pre">rigid_scaling()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#affine">affine</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.affine"><code class="docutils literal notranslate"><span class="pre">affine()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#method-dict">_METHOD_DICT</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public._METHOD_DICT"><code class="docutils literal notranslate"><span class="pre">_METHOD_DICT()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#register-series">register_series</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.register_series"><code class="docutils literal notranslate"><span class="pre">register_series()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#register-dwi-series">register_dwi_series</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.register_dwi_series"><code class="docutils literal notranslate"><span class="pre">register_dwi_series()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#motion-correction">motion_correction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.motion_correction"><code class="docutils literal notranslate"><span class="pre">motion_correction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#streamline-registration">streamline_registration</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align._public.streamline_registration"><code class="docutils literal notranslate"><span class="pre">streamline_registration()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#determine-num-threads">determine_num_threads</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.bundlemin.determine_num_threads"><code class="docutils literal notranslate"><span class="pre">determine_num_threads()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#distance-matrix-mdf">distance_matrix_mdf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.bundlemin.distance_matrix_mdf"><code class="docutils literal notranslate"><span class="pre">distance_matrix_mdf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deformableregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeformableRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration.__init__"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration.expectation"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration.expectation()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration.get_registration_parameters"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration.get_registration_parameters()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration.iterate"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration.iterate()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration.maximization"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration.maximization()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration.register"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration.register()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration.transform_point_cloud"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration.transform_point_cloud()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration.update_transform"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration.update_transform()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.DeformableRegistration.update_variance"><code class="docutils literal notranslate"><span class="pre">DeformableRegistration.update_variance()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gaussian-kernel">gaussian_kernel</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.gaussian_kernel"><code class="docutils literal notranslate"><span class="pre">gaussian_kernel()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#low-rank-eigen">low_rank_eigen</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.low_rank_eigen"><code class="docutils literal notranslate"><span class="pre">low_rank_eigen()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#initialize-sigma2">initialize_sigma2</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.initialize_sigma2"><code class="docutils literal notranslate"><span class="pre">initialize_sigma2()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lowrankqs">lowrankQS</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.cpd.lowrankQS"><code class="docutils literal notranslate"><span class="pre">lowrankQS()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-cc-backward-step-2d">compute_cc_backward_step_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.crosscorr.compute_cc_backward_step_2d"><code class="docutils literal notranslate"><span class="pre">compute_cc_backward_step_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-cc-backward-step-3d">compute_cc_backward_step_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.crosscorr.compute_cc_backward_step_3d"><code class="docutils literal notranslate"><span class="pre">compute_cc_backward_step_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-cc-forward-step-2d">compute_cc_forward_step_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.crosscorr.compute_cc_forward_step_2d"><code class="docutils literal notranslate"><span class="pre">compute_cc_forward_step_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-cc-forward-step-3d">compute_cc_forward_step_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.crosscorr.compute_cc_forward_step_3d"><code class="docutils literal notranslate"><span class="pre">compute_cc_forward_step_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#precompute-cc-factors-2d">precompute_cc_factors_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.crosscorr.precompute_cc_factors_2d"><code class="docutils literal notranslate"><span class="pre">precompute_cc_factors_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#precompute-cc-factors-2d-test">precompute_cc_factors_2d_test</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.crosscorr.precompute_cc_factors_2d_test"><code class="docutils literal notranslate"><span class="pre">precompute_cc_factors_2d_test()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#precompute-cc-factors-3d">precompute_cc_factors_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.crosscorr.precompute_cc_factors_3d"><code class="docutils literal notranslate"><span class="pre">precompute_cc_factors_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#precompute-cc-factors-3d-test">precompute_cc_factors_3d_test</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.crosscorr.precompute_cc_factors_3d_test"><code class="docutils literal notranslate"><span class="pre">precompute_cc_factors_3d_test()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-em-demons-step-2d">compute_em_demons_step_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.expectmax.compute_em_demons_step_2d"><code class="docutils literal notranslate"><span class="pre">compute_em_demons_step_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-em-demons-step-3d">compute_em_demons_step_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.expectmax.compute_em_demons_step_3d"><code class="docutils literal notranslate"><span class="pre">compute_em_demons_step_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-masked-class-stats-2d">compute_masked_class_stats_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.expectmax.compute_masked_class_stats_2d"><code class="docutils literal notranslate"><span class="pre">compute_masked_class_stats_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-masked-class-stats-3d">compute_masked_class_stats_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.expectmax.compute_masked_class_stats_3d"><code class="docutils literal notranslate"><span class="pre">compute_masked_class_stats_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantize-positive-2d">quantize_positive_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.expectmax.quantize_positive_2d"><code class="docutils literal notranslate"><span class="pre">quantize_positive_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantize-positive-3d">quantize_positive_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.expectmax.quantize_positive_3d"><code class="docutils literal notranslate"><span class="pre">quantize_positive_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#affineinversionerror"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineInversionError</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineInversionError"><code class="docutils literal notranslate"><span class="pre">AffineInversionError</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineInversionError.__init__"><code class="docutils literal notranslate"><span class="pre">AffineInversionError.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#affineinvalidvalueserror"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineInvalidValuesError</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineInvalidValuesError"><code class="docutils literal notranslate"><span class="pre">AffineInvalidValuesError</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineInvalidValuesError.__init__"><code class="docutils literal notranslate"><span class="pre">AffineInvalidValuesError.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#affinemap"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineMap</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineMap"><code class="docutils literal notranslate"><span class="pre">AffineMap</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineMap.__init__"><code class="docutils literal notranslate"><span class="pre">AffineMap.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineMap.get_affine"><code class="docutils literal notranslate"><span class="pre">AffineMap.get_affine()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineMap.set_affine"><code class="docutils literal notranslate"><span class="pre">AffineMap.set_affine()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineMap.transform"><code class="docutils literal notranslate"><span class="pre">AffineMap.transform()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineMap.transform_inverse"><code class="docutils literal notranslate"><span class="pre">AffineMap.transform_inverse()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mutualinformationmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutualInformationMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.MutualInformationMetric"><code class="docutils literal notranslate"><span class="pre">MutualInformationMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.MutualInformationMetric.__init__"><code class="docutils literal notranslate"><span class="pre">MutualInformationMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.MutualInformationMetric.distance"><code class="docutils literal notranslate"><span class="pre">MutualInformationMetric.distance()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.MutualInformationMetric.distance_and_gradient"><code class="docutils literal notranslate"><span class="pre">MutualInformationMetric.distance_and_gradient()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.MutualInformationMetric.gradient"><code class="docutils literal notranslate"><span class="pre">MutualInformationMetric.gradient()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.MutualInformationMetric.setup"><code class="docutils literal notranslate"><span class="pre">MutualInformationMetric.setup()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#affineregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineRegistration"><code class="docutils literal notranslate"><span class="pre">AffineRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineRegistration.__init__"><code class="docutils literal notranslate"><span class="pre">AffineRegistration.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineRegistration.docstring_addendum"><code class="docutils literal notranslate"><span class="pre">AffineRegistration.docstring_addendum</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.AffineRegistration.optimize"><code class="docutils literal notranslate"><span class="pre">AffineRegistration.optimize()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transform-method">_transform_method</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine._transform_method"><code class="docutils literal notranslate"><span class="pre">_transform_method()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transform-centers-of-mass">transform_centers_of_mass</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.transform_centers_of_mass"><code class="docutils literal notranslate"><span class="pre">transform_centers_of_mass()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transform-geometric-centers">transform_geometric_centers</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.transform_geometric_centers"><code class="docutils literal notranslate"><span class="pre">transform_geometric_centers()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transform-origins">transform_origins</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imaffine.transform_origins"><code class="docutils literal notranslate"><span class="pre">transform_origins()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffeomorphicmap"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicMap</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.__init__"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.allocate"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.allocate()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.compute_inversion_error"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.compute_inversion_error()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.expand_fields"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.expand_fields()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.get_backward_field"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.get_backward_field()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.get_forward_field"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.get_forward_field()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.get_simplified_transform"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.get_simplified_transform()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.interpret_matrix"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.interpret_matrix()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.inverse"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.inverse()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.shallow_copy"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.shallow_copy()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.transform"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.transform()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.transform_inverse"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.transform_inverse()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.transform_points"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.transform_points()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.transform_points_inverse"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.transform_points_inverse()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicMap.warp_endomorphism"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicMap.warp_endomorphism()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffeomorphicregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicRegistration"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicRegistration.__init__"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicRegistration.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicRegistration.get_map"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicRegistration.get_map()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicRegistration.optimize"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicRegistration.optimize()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.DiffeomorphicRegistration.set_level_iters"><code class="docutils literal notranslate"><span class="pre">DiffeomorphicRegistration.set_level_iters()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#symmetricdiffeomorphicregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration"><code class="docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.__init__"><code class="docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.get_map"><code class="docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration.get_map()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.optimize"><code class="docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration.optimize()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.update"><code class="docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration.update()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#registrationstages">RegistrationStages</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.RegistrationStages"><code class="docutils literal notranslate"><span class="pre">RegistrationStages()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#logger">logger</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.logger"><code class="docutils literal notranslate"><span class="pre">logger()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mult-aff">mult_aff</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.mult_aff"><code class="docutils literal notranslate"><span class="pre">mult_aff()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#get-direction-and-spacings">get_direction_and_spacings</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.imwarp.get_direction_and_spacings"><code class="docutils literal notranslate"><span class="pre">get_direction_and_spacings()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#similaritymetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.__init__"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.compute_backward"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.compute_backward()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.compute_forward"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.compute_forward()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.free_iteration"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.free_iteration()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.get_energy"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.get_energy()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.initialize_iteration"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.initialize_iteration()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.set_levels_above"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.set_levels_above()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.set_levels_below"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.set_levels_below()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.set_moving_image"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.set_moving_image()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.set_static_image"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.set_static_image()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.use_moving_image_dynamics"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.use_moving_image_dynamics()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SimilarityMetric.use_static_image_dynamics"><code class="docutils literal notranslate"><span class="pre">SimilarityMetric.use_static_image_dynamics()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ccmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.CCMetric"><code class="docutils literal notranslate"><span class="pre">CCMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.CCMetric.__init__"><code class="docutils literal notranslate"><span class="pre">CCMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.CCMetric.compute_backward"><code class="docutils literal notranslate"><span class="pre">CCMetric.compute_backward()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.CCMetric.compute_forward"><code class="docutils literal notranslate"><span class="pre">CCMetric.compute_forward()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.CCMetric.free_iteration"><code class="docutils literal notranslate"><span class="pre">CCMetric.free_iteration()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.CCMetric.get_energy"><code class="docutils literal notranslate"><span class="pre">CCMetric.get_energy()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.CCMetric.initialize_iteration"><code class="docutils literal notranslate"><span class="pre">CCMetric.initialize_iteration()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#emmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">EMMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric"><code class="docutils literal notranslate"><span class="pre">EMMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.__init__"><code class="docutils literal notranslate"><span class="pre">EMMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.compute_backward"><code class="docutils literal notranslate"><span class="pre">EMMetric.compute_backward()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.compute_demons_step"><code class="docutils literal notranslate"><span class="pre">EMMetric.compute_demons_step()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.compute_forward"><code class="docutils literal notranslate"><span class="pre">EMMetric.compute_forward()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.compute_gauss_newton_step"><code class="docutils literal notranslate"><span class="pre">EMMetric.compute_gauss_newton_step()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.free_iteration"><code class="docutils literal notranslate"><span class="pre">EMMetric.free_iteration()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.get_energy"><code class="docutils literal notranslate"><span class="pre">EMMetric.get_energy()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.initialize_iteration"><code class="docutils literal notranslate"><span class="pre">EMMetric.initialize_iteration()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.use_moving_image_dynamics"><code class="docutils literal notranslate"><span class="pre">EMMetric.use_moving_image_dynamics()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.EMMetric.use_static_image_dynamics"><code class="docutils literal notranslate"><span class="pre">EMMetric.use_static_image_dynamics()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ssdmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSDMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SSDMetric"><code class="docutils literal notranslate"><span class="pre">SSDMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SSDMetric.__init__"><code class="docutils literal notranslate"><span class="pre">SSDMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SSDMetric.compute_backward"><code class="docutils literal notranslate"><span class="pre">SSDMetric.compute_backward()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SSDMetric.compute_demons_step"><code class="docutils literal notranslate"><span class="pre">SSDMetric.compute_demons_step()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SSDMetric.compute_forward"><code class="docutils literal notranslate"><span class="pre">SSDMetric.compute_forward()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SSDMetric.compute_gauss_newton_step"><code class="docutils literal notranslate"><span class="pre">SSDMetric.compute_gauss_newton_step()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SSDMetric.free_iteration"><code class="docutils literal notranslate"><span class="pre">SSDMetric.free_iteration()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SSDMetric.get_energy"><code class="docutils literal notranslate"><span class="pre">SSDMetric.get_energy()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.SSDMetric.initialize_iteration"><code class="docutils literal notranslate"><span class="pre">SSDMetric.initialize_iteration()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#v-cycle-2d">v_cycle_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.v_cycle_2d"><code class="docutils literal notranslate"><span class="pre">v_cycle_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#v-cycle-3d">v_cycle_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.metrics.v_cycle_3d"><code class="docutils literal notranslate"><span class="pre">v_cycle_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parzenjointhistogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParzenJointHistogram</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram.__init__"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram.bin_index"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram.bin_index()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram.bin_normalize_moving"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram.bin_normalize_moving()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram.bin_normalize_static"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram.bin_normalize_static()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram.setup"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram.setup()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram.update_gradient_dense"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram.update_gradient_dense()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram.update_gradient_sparse"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram.update_gradient_sparse()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram.update_pdfs_dense"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram.update_pdfs_dense()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.ParzenJointHistogram.update_pdfs_sparse"><code class="docutils literal notranslate"><span class="pre">ParzenJointHistogram.update_pdfs_sparse()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-parzen-mi">compute_parzen_mi</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.compute_parzen_mi"><code class="docutils literal notranslate"><span class="pre">compute_parzen_mi()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cubic-spline">cubic_spline</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.cubic_spline"><code class="docutils literal notranslate"><span class="pre">cubic_spline()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cubic-spline-derivative">cubic_spline_derivative</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.cubic_spline_derivative"><code class="docutils literal notranslate"><span class="pre">cubic_spline_derivative()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sample-domain-regular">sample_domain_regular</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.parzenhist.sample_domain_regular"><code class="docutils literal notranslate"><span class="pre">sample_domain_regular()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reslice">reslice</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.reslice.reslice"><code class="docutils literal notranslate"><span class="pre">reslice()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scalespace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace"><code class="docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.__init__"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.get_affine"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.get_affine()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.get_affine_inv"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.get_affine_inv()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.get_domain_shape"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.get_domain_shape()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.get_expand_factors"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.get_expand_factors()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.get_image"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.get_image()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.get_scaling"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.get_scaling()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.get_sigmas"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.get_sigmas()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.get_spacing"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.get_spacing()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.ScaleSpace.print_level"><code class="docutils literal notranslate"><span class="pre">ScaleSpace.print_level()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isotropicscalespace"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.IsotropicScaleSpace"><code class="docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.IsotropicScaleSpace.__init__"><code class="docutils literal notranslate"><span class="pre">IsotropicScaleSpace.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id203">logger</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.scalespace.logger"><code class="docutils literal notranslate"><span class="pre">logger()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#streamlinedistancemetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineDistanceMetric"><code class="docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineDistanceMetric.__init__"><code class="docutils literal notranslate"><span class="pre">StreamlineDistanceMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineDistanceMetric.distance"><code class="docutils literal notranslate"><span class="pre">StreamlineDistanceMetric.distance()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineDistanceMetric.setup"><code class="docutils literal notranslate"><span class="pre">StreamlineDistanceMetric.setup()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundlemindistancemetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceMetric"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceMetric.__init__"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceMetric.distance"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMetric.distance()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceMetric.setup"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMetric.setup()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundlemindistancematrixmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric.__init__"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric.distance"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric.distance()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric.setup"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric.setup()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundlemindistanceasymmetricmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.__init__"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.distance"><code class="docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric.distance()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundlesumdistancematrixmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric"><code class="docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric.__init__"><code class="docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric.distance"><code class="docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric.distance()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#jointbundlemindistancemetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">JointBundleMinDistanceMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric"><code class="docutils literal notranslate"><span class="pre">JointBundleMinDistanceMetric</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric.__init__"><code class="docutils literal notranslate"><span class="pre">JointBundleMinDistanceMetric.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric.distance"><code class="docutils literal notranslate"><span class="pre">JointBundleMinDistanceMetric.distance()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.JointBundleMinDistanceMetric.setup"><code class="docutils literal notranslate"><span class="pre">JointBundleMinDistanceMetric.setup()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#streamlinelinearregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineLinearRegistration"><code class="docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineLinearRegistration.__init__"><code class="docutils literal notranslate"><span class="pre">StreamlineLinearRegistration.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineLinearRegistration.optimize"><code class="docutils literal notranslate"><span class="pre">StreamlineLinearRegistration.optimize()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#streamlineregistrationmap"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineRegistrationMap</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineRegistrationMap"><code class="docutils literal notranslate"><span class="pre">StreamlineRegistrationMap</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineRegistrationMap.__init__"><code class="docutils literal notranslate"><span class="pre">StreamlineRegistrationMap.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.StreamlineRegistrationMap.transform"><code class="docutils literal notranslate"><span class="pre">StreamlineRegistrationMap.transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#jointstreamlineregistrationmap"><code class="xref py py-class docutils literal notranslate"><span class="pre">JointStreamlineRegistrationMap</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.JointStreamlineRegistrationMap"><code class="docutils literal notranslate"><span class="pre">JointStreamlineRegistrationMap</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.JointStreamlineRegistrationMap.__init__"><code class="docutils literal notranslate"><span class="pre">JointStreamlineRegistrationMap.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.JointStreamlineRegistrationMap.transform"><code class="docutils literal notranslate"><span class="pre">JointStreamlineRegistrationMap.transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id241">logger</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.logger"><code class="docutils literal notranslate"><span class="pre">logger()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundle-sum-distance">bundle_sum_distance</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.bundle_sum_distance"><code class="docutils literal notranslate"><span class="pre">bundle_sum_distance()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundle-min-distance">bundle_min_distance</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.bundle_min_distance"><code class="docutils literal notranslate"><span class="pre">bundle_min_distance()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundle-min-distance-fast">bundle_min_distance_fast</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.bundle_min_distance_fast"><code class="docutils literal notranslate"><span class="pre">bundle_min_distance_fast()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundle-min-distance-asymmetric-fast">bundle_min_distance_asymmetric_fast</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.bundle_min_distance_asymmetric_fast"><code class="docutils literal notranslate"><span class="pre">bundle_min_distance_asymmetric_fast()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#remove-clusters-by-size">remove_clusters_by_size</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.remove_clusters_by_size"><code class="docutils literal notranslate"><span class="pre">remove_clusters_by_size()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#progressive-slr">progressive_slr</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.progressive_slr"><code class="docutils literal notranslate"><span class="pre">progressive_slr()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#slr-with-qbx">slr_with_qbx</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.slr_with_qbx"><code class="docutils literal notranslate"><span class="pre">slr_with_qbx()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#groupwise-slr">groupwise_slr</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.groupwise_slr"><code class="docutils literal notranslate"><span class="pre">groupwise_slr()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#get-unique-pairs">get_unique_pairs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.get_unique_pairs"><code class="docutils literal notranslate"><span class="pre">get_unique_pairs()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compose-matrix44">compose_matrix44</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.compose_matrix44"><code class="docutils literal notranslate"><span class="pre">compose_matrix44()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#decompose-matrix44">decompose_matrix44</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamlinear.decompose_matrix44"><code class="docutils literal notranslate"><span class="pre">decompose_matrix44()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#average-bundle-length">average_bundle_length</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamwarp.average_bundle_length"><code class="docutils literal notranslate"><span class="pre">average_bundle_length()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#find-missing">find_missing</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamwarp.find_missing"><code class="docutils literal notranslate"><span class="pre">find_missing()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundlewarp">bundlewarp</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamwarp.bundlewarp"><code class="docutils literal notranslate"><span class="pre">bundlewarp()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundlewarp-vector-filed">bundlewarp_vector_filed</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamwarp.bundlewarp_vector_filed"><code class="docutils literal notranslate"><span class="pre">bundlewarp_vector_filed()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bundlewarp-shape-analysis">bundlewarp_shape_analysis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.streamwarp.bundlewarp_shape_analysis"><code class="docutils literal notranslate"><span class="pre">bundlewarp_shape_analysis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-energy-ssd-2d">compute_energy_ssd_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.compute_energy_ssd_2d"><code class="docutils literal notranslate"><span class="pre">compute_energy_ssd_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-energy-ssd-3d">compute_energy_ssd_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.compute_energy_ssd_3d"><code class="docutils literal notranslate"><span class="pre">compute_energy_ssd_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-residual-displacement-field-ssd-2d">compute_residual_displacement_field_ssd_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_2d"><code class="docutils literal notranslate"><span class="pre">compute_residual_displacement_field_ssd_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-residual-displacement-field-ssd-3d">compute_residual_displacement_field_ssd_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.compute_residual_displacement_field_ssd_3d"><code class="docutils literal notranslate"><span class="pre">compute_residual_displacement_field_ssd_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-ssd-demons-step-2d">compute_ssd_demons_step_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.compute_ssd_demons_step_2d"><code class="docutils literal notranslate"><span class="pre">compute_ssd_demons_step_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-ssd-demons-step-3d">compute_ssd_demons_step_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.compute_ssd_demons_step_3d"><code class="docutils literal notranslate"><span class="pre">compute_ssd_demons_step_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterate-residual-displacement-field-ssd-2d">iterate_residual_displacement_field_ssd_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_2d"><code class="docutils literal notranslate"><span class="pre">iterate_residual_displacement_field_ssd_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterate-residual-displacement-field-ssd-3d">iterate_residual_displacement_field_ssd_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.iterate_residual_displacement_field_ssd_3d"><code class="docutils literal notranslate"><span class="pre">iterate_residual_displacement_field_ssd_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solve-2d-symmetric-positive-definite">solve_2d_symmetric_positive_definite</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.solve_2d_symmetric_positive_definite"><code class="docutils literal notranslate"><span class="pre">solve_2d_symmetric_positive_definite()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solve-3d-symmetric-positive-definite">solve_3d_symmetric_positive_definite</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.sumsqdiff.solve_3d_symmetric_positive_definite"><code class="docutils literal notranslate"><span class="pre">solve_3d_symmetric_positive_definite()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#affinetransform2d"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.AffineTransform2D"><code class="docutils literal notranslate"><span class="pre">AffineTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.AffineTransform2D.__init__"><code class="docutils literal notranslate"><span class="pre">AffineTransform2D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#affinetransform3d"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.AffineTransform3D"><code class="docutils literal notranslate"><span class="pre">AffineTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.AffineTransform3D.__init__"><code class="docutils literal notranslate"><span class="pre">AffineTransform3D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidisoscalingtransform2d"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidIsoScalingTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidIsoScalingTransform2D"><code class="docutils literal notranslate"><span class="pre">RigidIsoScalingTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidIsoScalingTransform2D.__init__"><code class="docutils literal notranslate"><span class="pre">RigidIsoScalingTransform2D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidisoscalingtransform3d"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidIsoScalingTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidIsoScalingTransform3D"><code class="docutils literal notranslate"><span class="pre">RigidIsoScalingTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidIsoScalingTransform3D.__init__"><code class="docutils literal notranslate"><span class="pre">RigidIsoScalingTransform3D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidscalingtransform2d"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidScalingTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidScalingTransform2D"><code class="docutils literal notranslate"><span class="pre">RigidScalingTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidScalingTransform2D.__init__"><code class="docutils literal notranslate"><span class="pre">RigidScalingTransform2D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidscalingtransform3d"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidScalingTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidScalingTransform3D"><code class="docutils literal notranslate"><span class="pre">RigidScalingTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidScalingTransform3D.__init__"><code class="docutils literal notranslate"><span class="pre">RigidScalingTransform3D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidtransform2d"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidTransform2D"><code class="docutils literal notranslate"><span class="pre">RigidTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidTransform2D.__init__"><code class="docutils literal notranslate"><span class="pre">RigidTransform2D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidtransform3d"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidTransform3D"><code class="docutils literal notranslate"><span class="pre">RigidTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RigidTransform3D.__init__"><code class="docutils literal notranslate"><span class="pre">RigidTransform3D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotationtransform2d"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RotationTransform2D"><code class="docutils literal notranslate"><span class="pre">RotationTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RotationTransform2D.__init__"><code class="docutils literal notranslate"><span class="pre">RotationTransform2D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotationtransform3d"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RotationTransform3D"><code class="docutils literal notranslate"><span class="pre">RotationTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.RotationTransform3D.__init__"><code class="docutils literal notranslate"><span class="pre">RotationTransform3D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scalingtransform2d"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalingTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.ScalingTransform2D"><code class="docutils literal notranslate"><span class="pre">ScalingTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.ScalingTransform2D.__init__"><code class="docutils literal notranslate"><span class="pre">ScalingTransform2D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scalingtransform3d"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalingTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.ScalingTransform3D"><code class="docutils literal notranslate"><span class="pre">ScalingTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.ScalingTransform3D.__init__"><code class="docutils literal notranslate"><span class="pre">ScalingTransform3D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.Transform"><code class="docutils literal notranslate"><span class="pre">Transform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.Transform.__init__"><code class="docutils literal notranslate"><span class="pre">Transform.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.Transform.get_dim"><code class="docutils literal notranslate"><span class="pre">Transform.get_dim()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.Transform.get_identity_parameters"><code class="docutils literal notranslate"><span class="pre">Transform.get_identity_parameters()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.Transform.get_number_of_parameters"><code class="docutils literal notranslate"><span class="pre">Transform.get_number_of_parameters()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.Transform.jacobian"><code class="docutils literal notranslate"><span class="pre">Transform.jacobian()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.Transform.param_to_matrix"><code class="docutils literal notranslate"><span class="pre">Transform.param_to_matrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#translationtransform2d"><code class="xref py py-class docutils literal notranslate"><span class="pre">TranslationTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.TranslationTransform2D"><code class="docutils literal notranslate"><span class="pre">TranslationTransform2D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.TranslationTransform2D.__init__"><code class="docutils literal notranslate"><span class="pre">TranslationTransform2D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#translationtransform3d"><code class="xref py py-class docutils literal notranslate"><span class="pre">TranslationTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.TranslationTransform3D"><code class="docutils literal notranslate"><span class="pre">TranslationTransform3D</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.transforms.TranslationTransform3D.__init__"><code class="docutils literal notranslate"><span class="pre">TranslationTransform3D.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compose-vector-fields-2d">compose_vector_fields_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.compose_vector_fields_2d"><code class="docutils literal notranslate"><span class="pre">compose_vector_fields_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compose-vector-fields-3d">compose_vector_fields_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.compose_vector_fields_3d"><code class="docutils literal notranslate"><span class="pre">compose_vector_fields_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-circle">create_circle</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.create_circle"><code class="docutils literal notranslate"><span class="pre">create_circle()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-harmonic-fields-2d">create_harmonic_fields_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.create_harmonic_fields_2d"><code class="docutils literal notranslate"><span class="pre">create_harmonic_fields_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-harmonic-fields-3d">create_harmonic_fields_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.create_harmonic_fields_3d"><code class="docutils literal notranslate"><span class="pre">create_harmonic_fields_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-random-displacement-2d">create_random_displacement_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.create_random_displacement_2d"><code class="docutils literal notranslate"><span class="pre">create_random_displacement_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-random-displacement-3d">create_random_displacement_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.create_random_displacement_3d"><code class="docutils literal notranslate"><span class="pre">create_random_displacement_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-sphere">create_sphere</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.create_sphere"><code class="docutils literal notranslate"><span class="pre">create_sphere()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downsample-displacement-field-2d">downsample_displacement_field_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.downsample_displacement_field_2d"><code class="docutils literal notranslate"><span class="pre">downsample_displacement_field_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downsample-displacement-field-3d">downsample_displacement_field_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.downsample_displacement_field_3d"><code class="docutils literal notranslate"><span class="pre">downsample_displacement_field_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downsample-scalar-field-2d">downsample_scalar_field_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.downsample_scalar_field_2d"><code class="docutils literal notranslate"><span class="pre">downsample_scalar_field_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downsample-scalar-field-3d">downsample_scalar_field_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.downsample_scalar_field_3d"><code class="docutils literal notranslate"><span class="pre">downsample_scalar_field_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gradient">gradient</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.gradient"><code class="docutils literal notranslate"><span class="pre">gradient()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#invert-vector-field-fixed-point-2d">invert_vector_field_fixed_point_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.invert_vector_field_fixed_point_2d"><code class="docutils literal notranslate"><span class="pre">invert_vector_field_fixed_point_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#invert-vector-field-fixed-point-3d">invert_vector_field_fixed_point_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.invert_vector_field_fixed_point_3d"><code class="docutils literal notranslate"><span class="pre">invert_vector_field_fixed_point_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#is-valid-affine">is_valid_affine</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.is_valid_affine"><code class="docutils literal notranslate"><span class="pre">is_valid_affine()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reorient-vector-field-2d">reorient_vector_field_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.reorient_vector_field_2d"><code class="docutils literal notranslate"><span class="pre">reorient_vector_field_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reorient-vector-field-3d">reorient_vector_field_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.reorient_vector_field_3d"><code class="docutils literal notranslate"><span class="pre">reorient_vector_field_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#resample-displacement-field-2d">resample_displacement_field_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.resample_displacement_field_2d"><code class="docutils literal notranslate"><span class="pre">resample_displacement_field_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#resample-displacement-field-3d">resample_displacement_field_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.resample_displacement_field_3d"><code class="docutils literal notranslate"><span class="pre">resample_displacement_field_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#simplify-warp-function-2d">simplify_warp_function_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.simplify_warp_function_2d"><code class="docutils literal notranslate"><span class="pre">simplify_warp_function_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#simplify-warp-function-3d">simplify_warp_function_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.simplify_warp_function_3d"><code class="docutils literal notranslate"><span class="pre">simplify_warp_function_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sparse-gradient">sparse_gradient</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.sparse_gradient"><code class="docutils literal notranslate"><span class="pre">sparse_gradient()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transform-2d-affine">transform_2d_affine</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.transform_2d_affine"><code class="docutils literal notranslate"><span class="pre">transform_2d_affine()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transform-2d-affine-nn">transform_2d_affine_nn</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.transform_2d_affine_nn"><code class="docutils literal notranslate"><span class="pre">transform_2d_affine_nn()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transform-3d-affine">transform_3d_affine</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.transform_3d_affine"><code class="docutils literal notranslate"><span class="pre">transform_3d_affine()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transform-3d-affine-nn">transform_3d_affine_nn</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.transform_3d_affine_nn"><code class="docutils literal notranslate"><span class="pre">transform_3d_affine_nn()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#warp-2d">warp_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.warp_2d"><code class="docutils literal notranslate"><span class="pre">warp_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#warp-2d-nn">warp_2d_nn</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.warp_2d_nn"><code class="docutils literal notranslate"><span class="pre">warp_2d_nn()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#warp-3d">warp_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.warp_3d"><code class="docutils literal notranslate"><span class="pre">warp_3d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#warp-3d-nn">warp_3d_nn</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.warp_3d_nn"><code class="docutils literal notranslate"><span class="pre">warp_3d_nn()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#warp-coordinates-2d">warp_coordinates_2d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.warp_coordinates_2d"><code class="docutils literal notranslate"><span class="pre">warp_coordinates_2d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#warp-coordinates-3d">warp_coordinates_3d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.align.vector_fields.warp_coordinates_3d"><code class="docutils literal notranslate"><span class="pre">warp_coordinates_3d()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  
<script type="module" src="../_static/scripts/grg-sphinx-theme.js"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item"><div>
  <h3 class="footer-heading">
    Never miss an update from us!
  </h3>
  <p class="footer-sub-heading">
    Don't worry! we are not going to spam you.
  </p>
  <div class="input-group mb-3 mar-t-10">
    <input type="text" class="form-control" placeholder="You email" aria-label="You email" id="grg-subscribe-email">
    <div class="input-group-append pointer" onclick="(document.getElementById('grg-subscribe-email').value)">
      <span class="input-group-text subscribe">Subscribe</span>
    </div>
  </div>  
  <ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dipy" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/dipymri" title="Twitter/X" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter/X</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/c/diffusionimaginginpython" title="YouTube" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-youtube"></i></span>
            <label class="sr-only">YouTube</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/dipy/" title="LinkedIn" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-linkedin"></i></span>
            <label class="sr-only">LinkedIn</label></a>
        </li>
</ul>
</div></div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><div class="grid-3">
  
  <div>
    <h5 class="footer-heading">
      About
    </h5>
    <ul class="footer-section">
      
        
        <li class="pad-v-5">
          <a href="https://dipy.org/team">
            Developers
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://github.com/dipy/dipy/discussions" target="_blank" rel="noopener noreferrer">
            Support
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="../user_guide/installation.html">
            Download
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="../user_guide/getting_started.html">
            Get Started
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="../examples_built/index.html">
            Tutorials
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://www.youtube.com/c/diffusionimaginginpython" target="_blank" rel="noopener noreferrer">
            Videos
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
    </ul>
  </div>
  
  <div>
    <h5 class="footer-heading">
      Friends
    </h5>
    <ul class="footer-section">
      
        
        <li class="pad-v-5">
          <a href="http://nipy.org/" target="_blank" rel="noopener noreferrer">
            Nipy Projects
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="http://fury.gl/" target="_blank" rel="noopener noreferrer">
            FURY
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="http://nipy.org/nibabel" target="_blank" rel="noopener noreferrer">
            Nibabel
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://tortoise.nibib.nih.gov/" target="_blank" rel="noopener noreferrer">
            Tortoise
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
    </ul>
  </div>
  
  <div>
    <h5 class="footer-heading">
      Support
    </h5>
    <ul class="footer-section">
      
        
        <li class="pad-v-5">
          <a href="https://engineering.indiana.edu/" target="_blank" rel="noopener noreferrer">
            The department of Intelligent Systems Engineering of Indiana University
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://www.nibib.nih.gov/" target="_blank" rel="noopener noreferrer">
            The National Institute of Biomedical Imaging and Bioengineering, NIH
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://escience.washington.edu" target="_blank" rel="noopener noreferrer">
            The Gordon and Betty Moore Foundation and the Alfred P. Sloan Foundation, through the University of Washington eScience Institute Data Science Environment
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://summerofcode.withgoogle.com/" target="_blank" rel="noopener noreferrer">
            Google supported DIPY through the Google Summer of Code Program (2015-2024)
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
    </ul>
  </div>
  
</div></div>
      
    </div>
  
</div>

    <div class="copyright-text">
      <i class="fa-regular fa-copyright"></i> Copyright 2008-2024, DIPY developers. Created using Grg Sphinx Theme and PyData Sphinx Theme.
    </div>
  </footer>
  </body>
</html>