
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>DIPY &#8212; dipy 1.0.0 documentation</title>
    <link rel="stylesheet" href="../_static/dipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="sims" href="dipy.sims.html" />
    <link rel="prev" title="reconst" href="dipy.reconst.html" />
  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head><body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../index.html">
  <img src="../_static/dipy-banner.png" alt="DIPY logo"  border="0" />
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.sims.html" title="sims"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dipy.reconst.html" title="reconst"
             accesskey="P">previous</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">API Reference</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Site Navigation </h4>
  <ul>
    <li><a href="../documentation.html">Documentation</a></li>
    <li><a href="../devel/index.html">Development</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.org/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.org/">NIPY Projects</a></li>
    <li><a class="reference external"
	href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing List</a></li>
    <li><a class="reference external"
	href="http://nipy.org/nipy/license.html">License</a></li>
  </ul>


  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">segment</span></code></a><ul>
<li><a class="reference internal" href="#module-dipy.segment.benchmarks">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.benchmarks</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.segment.benchmarks.bench_quickbundles">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.benchmarks.bench_quickbundles</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.segment.bundles">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.bundles</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.segment.clustering">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.clustering</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.segment.mask">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.mask</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.segment.metric">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.metric</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.segment.threshold">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.threshold</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.segment.tissue">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.tissue</span></code></a><ul>
<li><a class="reference internal" href="#mdfpy"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDFpy</span></code></a></li>
<li><a class="reference internal" href="#metric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Metric</span></code></a></li>
<li><a class="reference internal" href="#qb-new"><code class="xref py py-class docutils literal notranslate"><span class="pre">QB_New</span></code></a></li>
<li><a class="reference internal" href="#streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Streamlines</span></code></a></li>
<li><a class="reference internal" href="#assert-array-equal">assert_array_equal</a></li>
<li><a class="reference internal" href="#assert-arrays-equal">assert_arrays_equal</a></li>
<li><a class="reference internal" href="#assert-equal">assert_equal</a></li>
<li><a class="reference internal" href="#bench-quickbundles">bench_quickbundles</a></li>
<li><a class="reference internal" href="#get-fnames">get_fnames</a></li>
<li><a class="reference internal" href="#load-tractogram">load_tractogram</a></li>
<li><a class="reference internal" href="#measure">measure</a></li>
<li><a class="reference internal" href="#set-number-of-points">set_number_of_points</a></li>
<li><a class="reference internal" href="#bundlemindistanceasymmetricmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a></li>
<li><a class="reference internal" href="#bundlemindistancemetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a></li>
<li><a class="reference internal" href="#bundlesumdistancematrixmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a></li>
<li><a class="reference internal" href="#recobundles"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecoBundles</span></code></a></li>
<li><a class="reference internal" href="#streamlinelinearregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a></li>
<li><a class="reference internal" href="#id14"><code class="xref py py-class docutils literal notranslate"><span class="pre">Streamlines</span></code></a></li>
<li><a class="reference internal" href="#chain"><code class="xref py py-class docutils literal notranslate"><span class="pre">chain</span></code></a></li>
<li><a class="reference internal" href="#apply-affine">apply_affine</a></li>
<li><a class="reference internal" href="#bundle-adjacency">bundle_adjacency</a></li>
<li><a class="reference internal" href="#bundles-distances-mam">bundles_distances_mam</a></li>
<li><a class="reference internal" href="#bundles-distances-mdf">bundles_distances_mdf</a></li>
<li><a class="reference internal" href="#check-range">check_range</a></li>
<li><a class="reference internal" href="#length">length</a></li>
<li><a class="reference internal" href="#nbytes">nbytes</a></li>
<li><a class="reference internal" href="#qbx-and-merge">qbx_and_merge</a></li>
<li><a class="reference internal" href="#select-random-set-of-streamlines">select_random_set_of_streamlines</a></li>
<li><a class="reference internal" href="#id19">set_number_of_points</a></li>
<li><a class="reference internal" href="#time">time</a></li>
<li><a class="reference internal" href="#abcmeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABCMeta</span></code></a></li>
<li><a class="reference internal" href="#averagepointwiseeuclideanmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragePointwiseEuclideanMetric</span></code></a></li>
<li><a class="reference internal" href="#cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a></li>
<li><a class="reference internal" href="#clustercentroid"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterCentroid</span></code></a></li>
<li><a class="reference internal" href="#clustermap"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterMap</span></code></a></li>
<li><a class="reference internal" href="#clustermapcentroid"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterMapCentroid</span></code></a></li>
<li><a class="reference internal" href="#clustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clustering</span></code></a></li>
<li><a class="reference internal" href="#identity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code></a></li>
<li><a class="reference internal" href="#id20"><code class="xref py py-class docutils literal notranslate"><span class="pre">Metric</span></code></a></li>
<li><a class="reference internal" href="#minimumaveragedirectflipmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimumAverageDirectFlipMetric</span></code></a></li>
<li><a class="reference internal" href="#quickbundles"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuickBundles</span></code></a></li>
<li><a class="reference internal" href="#quickbundlesx"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuickBundlesX</span></code></a></li>
<li><a class="reference internal" href="#resamplefeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResampleFeature</span></code></a></li>
<li><a class="reference internal" href="#treecluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeCluster</span></code></a></li>
<li><a class="reference internal" href="#treeclustermap"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeClusterMap</span></code></a></li>
<li><a class="reference internal" href="#abstractmethod">abstractmethod</a></li>
<li><a class="reference internal" href="#id27">nbytes</a></li>
<li><a class="reference internal" href="#id28">qbx_and_merge</a></li>
<li><a class="reference internal" href="#id31">set_number_of_points</a></li>
<li><a class="reference internal" href="#id32">time</a></li>
<li><a class="reference internal" href="#applymask">applymask</a></li>
<li><a class="reference internal" href="#binary-dilation">binary_dilation</a></li>
<li><a class="reference internal" href="#bounding-box">bounding_box</a></li>
<li><a class="reference internal" href="#clean-cc-mask">clean_cc_mask</a></li>
<li><a class="reference internal" href="#color-fa">color_fa</a></li>
<li><a class="reference internal" href="#crop">crop</a></li>
<li><a class="reference internal" href="#fractional-anisotropy">fractional_anisotropy</a></li>
<li><a class="reference internal" href="#generate-binary-structure">generate_binary_structure</a></li>
<li><a class="reference internal" href="#median-filter">median_filter</a></li>
<li><a class="reference internal" href="#median-otsu">median_otsu</a></li>
<li><a class="reference internal" href="#multi-median">multi_median</a></li>
<li><a class="reference internal" href="#otsu">otsu</a></li>
<li><a class="reference internal" href="#segment-from-cfa">segment_from_cfa</a></li>
<li><a class="reference internal" href="#warn">warn</a></li>
<li><a class="reference internal" href="#arclengthfeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArcLengthFeature</span></code></a></li>
<li><a class="reference internal" href="#id40"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragePointwiseEuclideanMetric</span></code></a></li>
<li><a class="reference internal" href="#centerofmassfeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">CenterOfMassFeature</span></code></a></li>
<li><a class="reference internal" href="#cosinemetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">CosineMetric</span></code></a></li>
<li><a class="reference internal" href="#euclideanmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanMetric</span></code></a></li>
<li><a class="reference internal" href="#feature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Feature</span></code></a></li>
<li><a class="reference internal" href="#identityfeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">IdentityFeature</span></code></a></li>
<li><a class="reference internal" href="#id41"><code class="xref py py-class docutils literal notranslate"><span class="pre">Metric</span></code></a></li>
<li><a class="reference internal" href="#midpointfeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">MidpointFeature</span></code></a></li>
<li><a class="reference internal" href="#id44"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimumAverageDirectFlipMetric</span></code></a></li>
<li><a class="reference internal" href="#id45"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResampleFeature</span></code></a></li>
<li><a class="reference internal" href="#sumpointwiseeuclideanmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SumPointwiseEuclideanMetric</span></code></a></li>
<li><a class="reference internal" href="#vectorofendpointsfeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorOfEndpointsFeature</span></code></a></li>
<li><a class="reference internal" href="#dist">dist</a></li>
<li><a class="reference internal" href="#distance-matrix">distance_matrix</a></li>
<li><a class="reference internal" href="#mdf">mdf</a></li>
<li><a class="reference internal" href="#id48">otsu</a></li>
<li><a class="reference internal" href="#upper-bound-by-percent">upper_bound_by_percent</a></li>
<li><a class="reference internal" href="#upper-bound-by-rate">upper_bound_by_rate</a></li>
<li><a class="reference internal" href="#constantobservationmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantObservationModel</span></code></a></li>
<li><a class="reference internal" href="#iteratedconditionalmodes"><code class="xref py py-class docutils literal notranslate"><span class="pre">IteratedConditionalModes</span></code></a></li>
<li><a class="reference internal" href="#tissueclassifierhmrf"><code class="xref py py-class docutils literal notranslate"><span class="pre">TissueClassifierHMRF</span></code></a></li>
<li><a class="reference internal" href="#add-noise">add_noise</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dipy.reconst.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dipy.sims.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sims</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/dipy.segment.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dipy.segment">
<span id="segment"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">segment</span></code><a class="headerlink" href="#module-dipy.segment" title="Permalink to this headline">¶</a></h1>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
</tbody>
</table>
<div class="section" id="module-dipy.segment.benchmarks">
<span id="module-segment-benchmarks"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.benchmarks</span></code><a class="headerlink" href="#module-dipy.segment.benchmarks" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.segment.benchmarks.bench_quickbundles">
<span id="module-segment-benchmarks-bench-quickbundles"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.benchmarks.bench_quickbundles</span></code><a class="headerlink" href="#module-dipy.segment.benchmarks.bench_quickbundles" title="Permalink to this headline">¶</a></h2>
<p>Benchmarks for QuickBundles</p>
<p>Run all benchmarks with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dipy.segment</span> <span class="k">as</span> <span class="nn">dipysegment</span>
<span class="n">dipysegment</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>With Pytest, Run this benchmark with:</p>
<blockquote>
<div><p>pytest -svv -c bench.ini /path/to/bench_quickbundles.py</p>
</div></blockquote>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.MDFpy" title="dipy.segment.benchmarks.bench_quickbundles.MDFpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MDFpy</span></code></a></p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.Metric" title="dipy.segment.benchmarks.bench_quickbundles.Metric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Metric</span></code></a></p></td>
<td><p>Computes a distance between two sequential data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.QB_New" title="dipy.segment.benchmarks.bench_quickbundles.QB_New"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QB_New</span></code></a></p></td>
<td><p>alias of <a class="reference internal" href="#dipy.segment.clustering.QuickBundles" title="dipy.segment.clustering.QuickBundles"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.clustering.QuickBundles</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.Streamlines" title="dipy.segment.benchmarks.bench_quickbundles.Streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Streamlines</span></code></a></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.array_sequence.ArraySequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.assert_array_equal" title="dipy.segment.benchmarks.bench_quickbundles.assert_array_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assert_array_equal</span></code></a>(x, y[, err_msg, verbose])</p></td>
<td><p>Raises an AssertionError if two array_like objects are not equal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.assert_arrays_equal" title="dipy.segment.benchmarks.bench_quickbundles.assert_arrays_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assert_arrays_equal</span></code></a>(arrays1, arrays2)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.assert_equal" title="dipy.segment.benchmarks.bench_quickbundles.assert_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assert_equal</span></code></a>(actual, desired[, err_msg, verbose])</p></td>
<td><p>Raises an AssertionError if two objects are not equal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.bench_quickbundles" title="dipy.segment.benchmarks.bench_quickbundles.bench_quickbundles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_quickbundles</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.get_fnames" title="dipy.segment.benchmarks.bench_quickbundles.get_fnames"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fnames</span></code></a>([name])</p></td>
<td><p>provides filenames of some test datasets or other useful parametrisations</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.load_tractogram" title="dipy.segment.benchmarks.bench_quickbundles.load_tractogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_tractogram</span></code></a>(filename, reference[, …])</p></td>
<td><p>Load the stateful tractogram from any format (trk, tck, fib, dpy)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.measure" title="dipy.segment.benchmarks.bench_quickbundles.measure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">measure</span></code></a>(code_str[, times, label])</p></td>
<td><p>Return elapsed time for executing code in the namespace of the caller.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.set_number_of_points" title="dipy.segment.benchmarks.bench_quickbundles.set_number_of_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_number_of_points</span></code></a></p></td>
<td><p>Change the number of points of streamlines</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.segment.bundles">
<span id="module-segment-bundles"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.bundles</span></code><a class="headerlink" href="#module-dipy.segment.bundles" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.BundleMinDistanceAsymmetricMetric" title="dipy.segment.bundles.BundleMinDistanceAsymmetricMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a>([num_threads])</p></td>
<td><p>Asymmetric Bundle-based Minimum distance</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.BundleMinDistanceMetric" title="dipy.segment.bundles.BundleMinDistanceMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a>([num_threads])</p></td>
<td><p>Bundle-based Minimum Distance aka BMD</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.BundleSumDistanceMatrixMetric" title="dipy.segment.bundles.BundleSumDistanceMatrixMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a>([num_threads])</p></td>
<td><p>Bundle-based Sum Distance aka BMD</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.RecoBundles" title="dipy.segment.bundles.RecoBundles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RecoBundles</span></code></a>(streamlines[, greater_than, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.StreamlineLinearRegistration" title="dipy.segment.bundles.StreamlineLinearRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a>([metric, x0, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.Streamlines" title="dipy.segment.bundles.Streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Streamlines</span></code></a></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.array_sequence.ArraySequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.chain" title="dipy.segment.bundles.chain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chain</span></code></a></p></td>
<td><p>chain(<a href="#id1"><span class="problematic" id="id2">*</span></a>iterables) –&gt; chain object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.apply_affine" title="dipy.segment.bundles.apply_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_affine</span></code></a>(aff, pts)</p></td>
<td><p>Apply affine matrix <cite>aff</cite> to points <cite>pts</cite></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.bundle_adjacency" title="dipy.segment.bundles.bundle_adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_adjacency</span></code></a>(dtracks0, dtracks1, threshold)</p></td>
<td><p>Find bundle adjacency between two given tracks/bundles</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.bundles_distances_mam" title="dipy.segment.bundles.bundles_distances_mam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundles_distances_mam</span></code></a></p></td>
<td><p>Calculate distances between list of tracks A and list of tracks B</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.bundles_distances_mdf" title="dipy.segment.bundles.bundles_distances_mdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundles_distances_mdf</span></code></a></p></td>
<td><p>Calculate distances between list of tracks A and list of tracks B</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.check_range" title="dipy.segment.bundles.check_range"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_range</span></code></a>(streamline, gt, lt)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.length" title="dipy.segment.bundles.length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">length</span></code></a></p></td>
<td><p>Euclidean length of streamlines</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.nbytes" title="dipy.segment.bundles.nbytes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></a>(streamlines)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.qbx_and_merge" title="dipy.segment.bundles.qbx_and_merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qbx_and_merge</span></code></a>(streamlines, thresholds[, …])</p></td>
<td><p>Run QuickBundlesX and then run again on the centroids of the last layer</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.select_random_set_of_streamlines" title="dipy.segment.bundles.select_random_set_of_streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_random_set_of_streamlines</span></code></a>(…[, rng])</p></td>
<td><p>Select a random set of streamlines</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.set_number_of_points" title="dipy.segment.bundles.set_number_of_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_number_of_points</span></code></a></p></td>
<td><p>Change the number of points of streamlines</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.time" title="dipy.segment.bundles.time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time</span></code></a>()</p></td>
<td><p>Return the current time in seconds since the Epoch.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.segment.clustering">
<span id="module-segment-clustering"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.clustering</span></code><a class="headerlink" href="#module-dipy.segment.clustering" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.ABCMeta" title="dipy.segment.clustering.ABCMeta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ABCMeta</span></code></a></p></td>
<td><p>Metaclass for defining Abstract Base Classes (ABCs).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.AveragePointwiseEuclideanMetric" title="dipy.segment.clustering.AveragePointwiseEuclideanMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AveragePointwiseEuclideanMetric</span></code></a></p></td>
<td><p>Computes the average of pointwise Euclidean distances between two sequential data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.Cluster" title="dipy.segment.clustering.Cluster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cluster</span></code></a>([id, indices, refdata])</p></td>
<td><p>Provides functionalities for interacting with a cluster.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterCentroid" title="dipy.segment.clustering.ClusterCentroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ClusterCentroid</span></code></a>(centroid[, id, indices, refdata])</p></td>
<td><p>Provides functionalities for interacting with a cluster.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterMap" title="dipy.segment.clustering.ClusterMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ClusterMap</span></code></a>([refdata])</p></td>
<td><p>Provides functionalities for interacting with clustering outputs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterMapCentroid" title="dipy.segment.clustering.ClusterMapCentroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ClusterMapCentroid</span></code></a>([refdata])</p></td>
<td><p>Provides functionalities for interacting with clustering outputs that have centroids.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.Clustering" title="dipy.segment.clustering.Clustering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Clustering</span></code></a></p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.Identity" title="dipy.segment.clustering.Identity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Identity</span></code></a></p></td>
<td><p>Provides identity indexing functionality.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.Metric" title="dipy.segment.clustering.Metric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Metric</span></code></a></p></td>
<td><p>Computes a distance between two sequential data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.MinimumAverageDirectFlipMetric" title="dipy.segment.clustering.MinimumAverageDirectFlipMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimumAverageDirectFlipMetric</span></code></a></p></td>
<td><p>Computes the MDF distance (minimum average direct-flip) between two sequential data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.QuickBundles" title="dipy.segment.clustering.QuickBundles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuickBundles</span></code></a>(threshold[, metric, …])</p></td>
<td><p>Clusters streamlines using QuickBundles <a class="reference internal" href="#r2491d57df3a8-garyfallidis12" id="id3">[Garyfallidis12]</a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.QuickBundlesX" title="dipy.segment.clustering.QuickBundlesX"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuickBundlesX</span></code></a>(thresholds[, metric])</p></td>
<td><p>Clusters streamlines using QuickBundlesX.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.ResampleFeature" title="dipy.segment.clustering.ResampleFeature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ResampleFeature</span></code></a></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.TreeCluster" title="dipy.segment.clustering.TreeCluster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TreeCluster</span></code></a>(threshold, centroid[, indices])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.TreeClusterMap" title="dipy.segment.clustering.TreeClusterMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TreeClusterMap</span></code></a>(root)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.abstractmethod" title="dipy.segment.clustering.abstractmethod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abstractmethod</span></code></a>(funcobj)</p></td>
<td><p>A decorator indicating abstract methods.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.nbytes" title="dipy.segment.clustering.nbytes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></a>(streamlines)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.qbx_and_merge" title="dipy.segment.clustering.qbx_and_merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qbx_and_merge</span></code></a>(streamlines, thresholds[, …])</p></td>
<td><p>Run QuickBundlesX and then run again on the centroids of the last layer</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.set_number_of_points" title="dipy.segment.clustering.set_number_of_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_number_of_points</span></code></a></p></td>
<td><p>Change the number of points of streamlines</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.time" title="dipy.segment.clustering.time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time</span></code></a>()</p></td>
<td><p>Return the current time in seconds since the Epoch.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.segment.mask">
<span id="module-segment-mask"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.mask</span></code><a class="headerlink" href="#module-dipy.segment.mask" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.mask.applymask" title="dipy.segment.mask.applymask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">applymask</span></code></a>(vol, mask)</p></td>
<td><p>Mask vol with mask.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.mask.binary_dilation" title="dipy.segment.mask.binary_dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_dilation</span></code></a>(input[, structure, …])</p></td>
<td><p>Multi-dimensional binary dilation with the given structuring element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.mask.bounding_box" title="dipy.segment.mask.bounding_box"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></a>(vol)</p></td>
<td><p>Compute the bounding box of nonzero intensity voxels in the volume.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.mask.clean_cc_mask" title="dipy.segment.mask.clean_cc_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clean_cc_mask</span></code></a>(mask)</p></td>
<td><p>Cleans a segmentation of the corpus callosum so no random pixels are included.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.mask.color_fa" title="dipy.segment.mask.color_fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code></a>(fa, evecs)</p></td>
<td><p>Color fractional anisotropy of diffusion tensor</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.mask.crop" title="dipy.segment.mask.crop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop</span></code></a>(vol, mins, maxs)</p></td>
<td><p>Crops the input volume.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.mask.fractional_anisotropy" title="dipy.segment.mask.fractional_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractional_anisotropy</span></code></a>(evals[, axis])</p></td>
<td><p>Fractional anisotropy (FA) of a diffusion tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.mask.generate_binary_structure" title="dipy.segment.mask.generate_binary_structure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a>(rank, connectivity)</p></td>
<td><p>Generate a binary structure for binary morphological operations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.mask.median_filter" title="dipy.segment.mask.median_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">median_filter</span></code></a>(input[, size, footprint, …])</p></td>
<td><p>Calculate a multidimensional median filter.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.mask.median_otsu" title="dipy.segment.mask.median_otsu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">median_otsu</span></code></a>(input_volume[, vol_idx, …])</p></td>
<td><p>Simple brain extraction tool method for images from DWI data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.mask.multi_median" title="dipy.segment.mask.multi_median"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_median</span></code></a>(input, median_radius, numpass)</p></td>
<td><p>Applies median filter multiple times on input data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.mask.otsu" title="dipy.segment.mask.otsu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">otsu</span></code></a>(image[, nbins])</p></td>
<td><p>Return threshold value based on Otsu’s method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.mask.segment_from_cfa" title="dipy.segment.mask.segment_from_cfa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">segment_from_cfa</span></code></a>(tensor_fit, roi, threshold)</p></td>
<td><p>Segment the cfa inside roi using the values from threshold as bounds.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.mask.warn" title="dipy.segment.mask.warn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warn</span></code></a></p></td>
<td><p>Issue a warning, or maybe ignore it or raise an exception.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.segment.metric">
<span id="module-segment-metric"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.metric</span></code><a class="headerlink" href="#module-dipy.segment.metric" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.ArcLengthFeature" title="dipy.segment.metric.ArcLengthFeature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ArcLengthFeature</span></code></a></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.AveragePointwiseEuclideanMetric" title="dipy.segment.metric.AveragePointwiseEuclideanMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AveragePointwiseEuclideanMetric</span></code></a></p></td>
<td><p>Computes the average of pointwise Euclidean distances between two sequential data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.CenterOfMassFeature" title="dipy.segment.metric.CenterOfMassFeature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CenterOfMassFeature</span></code></a></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.CosineMetric" title="dipy.segment.metric.CosineMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CosineMetric</span></code></a></p></td>
<td><p>Computes the cosine distance between two vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.EuclideanMetric" title="dipy.segment.metric.EuclideanMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EuclideanMetric</span></code></a></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.SumPointwiseEuclideanMetric</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.Feature" title="dipy.segment.metric.Feature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Feature</span></code></a></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.IdentityFeature" title="dipy.segment.metric.IdentityFeature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IdentityFeature</span></code></a></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.Metric" title="dipy.segment.metric.Metric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Metric</span></code></a></p></td>
<td><p>Computes a distance between two sequential data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.MidpointFeature" title="dipy.segment.metric.MidpointFeature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MidpointFeature</span></code></a></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.MinimumAverageDirectFlipMetric" title="dipy.segment.metric.MinimumAverageDirectFlipMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimumAverageDirectFlipMetric</span></code></a></p></td>
<td><p>Computes the MDF distance (minimum average direct-flip) between two sequential data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.ResampleFeature" title="dipy.segment.metric.ResampleFeature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ResampleFeature</span></code></a></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.SumPointwiseEuclideanMetric" title="dipy.segment.metric.SumPointwiseEuclideanMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SumPointwiseEuclideanMetric</span></code></a></p></td>
<td><p>Computes the sum of pointwise Euclidean distances between two sequential data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.VectorOfEndpointsFeature" title="dipy.segment.metric.VectorOfEndpointsFeature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VectorOfEndpointsFeature</span></code></a></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.dist" title="dipy.segment.metric.dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></a></p></td>
<td><p>Computes a distance between <cite>datum1</cite> and <cite>datum2</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.distance_matrix" title="dipy.segment.metric.distance_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance_matrix</span></code></a></p></td>
<td><p>Computes the distance matrix between two lists of sequential data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.mdf" title="dipy.segment.metric.mdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdf</span></code></a>(s1, s2)</p></td>
<td><p>Computes the MDF (Minimum average Direct-Flip) distance <a class="reference internal" href="#r9ec92ef08bd1-garyfallidis12" id="id4">[Garyfallidis12]</a> between two streamlines.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.segment.threshold">
<span id="module-segment-threshold"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.threshold</span></code><a class="headerlink" href="#module-dipy.segment.threshold" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.threshold.otsu" title="dipy.segment.threshold.otsu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">otsu</span></code></a>(image[, nbins])</p></td>
<td><p>Return threshold value based on Otsu’s method.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.threshold.upper_bound_by_percent" title="dipy.segment.threshold.upper_bound_by_percent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper_bound_by_percent</span></code></a>(data[, percent])</p></td>
<td><p>Find the upper bound for visualization of medical images</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.threshold.upper_bound_by_rate" title="dipy.segment.threshold.upper_bound_by_rate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper_bound_by_rate</span></code></a>(data[, rate])</p></td>
<td><p>Adjusts upper intensity boundary using rates</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.segment.tissue">
<span id="module-segment-tissue"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">segment.tissue</span></code><a class="headerlink" href="#module-dipy.segment.tissue" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.tissue.ConstantObservationModel" title="dipy.segment.tissue.ConstantObservationModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstantObservationModel</span></code></a></p></td>
<td><p>Observation model assuming that the intensity of each class is constant.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.tissue.IteratedConditionalModes" title="dipy.segment.tissue.IteratedConditionalModes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IteratedConditionalModes</span></code></a></p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.tissue.TissueClassifierHMRF" title="dipy.segment.tissue.TissueClassifierHMRF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TissueClassifierHMRF</span></code></a>([save_history, verbose])</p></td>
<td><p>This class contains the methods for tissue classification using the Markov Random Fields modeling approach</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.tissue.add_noise" title="dipy.segment.tissue.add_noise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_noise</span></code></a>(signal, snr, S0[, noise_type])</p></td>
<td><p>Add noise of specified distribution to the signal from a single voxel.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="mdfpy">
<h3><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.MDFpy" title="dipy.segment.benchmarks.bench_quickbundles.MDFpy"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDFpy</span></code></a><a class="headerlink" href="#mdfpy" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.benchmarks.bench_quickbundles.MDFpy">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">MDFpy</code><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.MDFpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.Metric</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.MDFpy.are_compatible" title="dipy.segment.benchmarks.bench_quickbundles.MDFpy.are_compatible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></a>(shape1, shape2)</p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.MDFpy.dist" title="dipy.segment.benchmarks.bench_quickbundles.MDFpy.dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></a>(features1, features2)</p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.benchmarks.bench_quickbundles.MDFpy.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.MDFpy.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.benchmarks.bench_quickbundles.MDFpy.are_compatible">
<code class="sig-name descname">are_compatible</code><span class="sig-paren">(</span><em class="sig-param">shape1</em>, <em class="sig-param">shape2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.MDFpy.are_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p>
<p>Basically this method exists so we don’t have to do this check
inside the <cite>metric.dist</cite> function (speedup).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape1</strong><span class="classifier">int, 1-tuple or 2-tuple</span></dt><dd><p>shape of the first data point’s features</p>
</dd>
<dt><strong>shape2</strong><span class="classifier">int, 1-tuple or 2-tuple</span></dt><dd><p>shape of the second data point’s features</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>are_compatible</strong><span class="classifier">bool</span></dt><dd><p>whether or not shapes are compatible</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.benchmarks.bench_quickbundles.MDFpy.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">features1</em>, <em class="sig-param">features2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.MDFpy.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a distance between two data points based on their features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>features1</strong><span class="classifier">2D array</span></dt><dd><p>Features of the first data point.</p>
</dd>
<dt><strong>features2</strong><span class="classifier">2D array</span></dt><dd><p>Features of the second data point.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>double</strong></dt><dd><p>Distance between two data points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="metric">
<h3><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.Metric" title="dipy.segment.benchmarks.bench_quickbundles.Metric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Metric</span></code></a><a class="headerlink" href="#metric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.benchmarks.bench_quickbundles.Metric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">Metric</code><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.Metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Computes a distance between two sequential data.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions). A <cite>feature</cite> object can be specified
in order to calculate the distance between extracted features, rather
than directly between the sequential data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>feature</strong><span class="classifier"><cite>Feature</cite> object, optional</span></dt><dd><p>It is used to extract features before computing the distance.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When subclassing <cite>Metric</cite>, one only needs to override the <cite>dist</cite> and
<cite>are_compatible</cite> methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.Metric.feature" title="dipy.segment.benchmarks.bench_quickbundles.Metric.feature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></a></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.Metric.is_order_invariant" title="dipy.segment.benchmarks.bench_quickbundles.Metric.is_order_invariant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></a></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.Metric.are_compatible" title="dipy.segment.benchmarks.bench_quickbundles.Metric.are_compatible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></a></p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.Metric.dist" title="dipy.segment.benchmarks.bench_quickbundles.Metric.dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></a></p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.benchmarks.bench_quickbundles.Metric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.Metric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.benchmarks.bench_quickbundles.Metric.are_compatible">
<code class="sig-name descname">are_compatible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.Metric.are_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p>
<p>Basically this method exists so we don’t have to do this check
inside the <cite>metric.dist</cite> function (speedup).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape1</strong><span class="classifier">int, 1-tuple or 2-tuple</span></dt><dd><p>shape of the first data point’s features</p>
</dd>
<dt><strong>shape2</strong><span class="classifier">int, 1-tuple or 2-tuple</span></dt><dd><p>shape of the second data point’s features</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>are_compatible</strong><span class="classifier">bool</span></dt><dd><p>whether or not shapes are compatible</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.benchmarks.bench_quickbundles.Metric.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.Metric.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a distance between two data points based on their features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>features1</strong><span class="classifier">2D array</span></dt><dd><p>Features of the first data point.</p>
</dd>
<dt><strong>features2</strong><span class="classifier">2D array</span></dt><dd><p>Features of the second data point.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>double</strong></dt><dd><p>Distance between two data points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.benchmarks.bench_quickbundles.Metric.feature">
<code class="sig-name descname">feature</code><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.Metric.feature" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.benchmarks.bench_quickbundles.Metric.is_order_invariant">
<code class="sig-name descname">is_order_invariant</code><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.Metric.is_order_invariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="qb-new">
<h3><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.QB_New" title="dipy.segment.benchmarks.bench_quickbundles.QB_New"><code class="xref py py-class docutils literal notranslate"><span class="pre">QB_New</span></code></a><a class="headerlink" href="#qb-new" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.segment.benchmarks.bench_quickbundles.QB_New">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">QB_New</code><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.QB_New" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#dipy.segment.clustering.QuickBundles" title="dipy.segment.clustering.QuickBundles"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.clustering.QuickBundles</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="streamlines">
<h3><a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.Streamlines" title="dipy.segment.benchmarks.bench_quickbundles.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Streamlines</span></code></a><a class="headerlink" href="#streamlines" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.segment.benchmarks.bench_quickbundles.Streamlines">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">Streamlines</code><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.Streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.array_sequence.ArraySequence</span></code></p>
</dd></dl>

</div>
<div class="section" id="assert-array-equal">
<h3>assert_array_equal<a class="headerlink" href="#assert-array-equal" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.benchmarks.bench_quickbundles.assert_array_equal">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">assert_array_equal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">err_msg=''</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.assert_array_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an AssertionError if two array_like objects are not equal.</p>
<p>Given two array_like objects, check that the shape is equal and all
elements of these objects are equal. An exception is raised at
shape mismatch or conflicting values. In contrast to the standard usage
in numpy, NaNs are compared like numbers, no assertion is raised if
both objects have NaNs in the same positions.</p>
<p>The usual caution for verifying equality with floating point numbers is
advised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The actual object to check.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>The desired, expected object.</p>
</dd>
<dt><strong>err_msg</strong><span class="classifier">str, optional</span></dt><dd><p>The error message to be printed in case of failure.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the conflicting values are appended to the error message.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>AssertionError</strong></dt><dd><p>If actual and desired objects are not equal.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">assert_allclose</span></code></dt><dd><p>Compare two array_like objects for equality with desired relative and/or absolute precision.</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">assert_array_almost_equal_nulp</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">assert_array_max_ulp</span></code>, <a class="reference internal" href="#dipy.segment.benchmarks.bench_quickbundles.assert_equal" title="dipy.segment.benchmarks.bench_quickbundles.assert_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assert_equal</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>The first assert does not raise an exception:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.33333</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                              <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="mf">2.33333</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
</pre></div>
</div>
<p>Assert fails with numerical inprecision with floats:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>:
<span class="go">Arrays are not equal</span>
<span class="go">Mismatch: 33.3%</span>
<span class="go">Max absolute difference: 4.4408921e-16</span>
<span class="go">Max relative difference: 1.41357986e-16</span>
<span class="go"> x: array([1.      , 3.141593,      nan])</span>
<span class="go"> y: array([1.      , 3.141593,      nan])</span>
</pre></div>
</div>
<p>Use <cite>assert_allclose</cite> or one of the nulp (number of floating point values)
functions for these cases instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="assert-arrays-equal">
<h3>assert_arrays_equal<a class="headerlink" href="#assert-arrays-equal" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.benchmarks.bench_quickbundles.assert_arrays_equal">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">assert_arrays_equal</code><span class="sig-paren">(</span><em class="sig-param">arrays1</em>, <em class="sig-param">arrays2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.assert_arrays_equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="assert-equal">
<h3>assert_equal<a class="headerlink" href="#assert-equal" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.benchmarks.bench_quickbundles.assert_equal">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">assert_equal</code><span class="sig-paren">(</span><em class="sig-param">actual</em>, <em class="sig-param">desired</em>, <em class="sig-param">err_msg=''</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.assert_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an AssertionError if two objects are not equal.</p>
<p>Given two objects (scalars, lists, tuples, dictionaries or numpy arrays),
check that all elements of these objects are equal. An exception is raised
at the first conflicting values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>actual</strong><span class="classifier">array_like</span></dt><dd><p>The object to check.</p>
</dd>
<dt><strong>desired</strong><span class="classifier">array_like</span></dt><dd><p>The expected object.</p>
</dd>
<dt><strong>err_msg</strong><span class="classifier">str, optional</span></dt><dd><p>The error message to be printed in case of failure.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the conflicting values are appended to the error message.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>AssertionError</strong></dt><dd><p>If actual and desired are not equal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>:
<span class="go">Items are not equal:</span>
<span class="go">item=1</span>
<span class="go"> ACTUAL: 5</span>
<span class="go"> DESIRED: 6</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="bench-quickbundles">
<h3>bench_quickbundles<a class="headerlink" href="#bench-quickbundles" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.benchmarks.bench_quickbundles.bench_quickbundles">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">bench_quickbundles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.bench_quickbundles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="get-fnames">
<h3>get_fnames<a class="headerlink" href="#get-fnames" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.benchmarks.bench_quickbundles.get_fnames">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">get_fnames</code><span class="sig-paren">(</span><em class="sig-param">name='small_64D'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.get_fnames" title="Permalink to this definition">¶</a></dt>
<dd><p>provides filenames of some test datasets or other useful parametrisations</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>the filename/s of which dataset to return, one of:
‘small_64D’ small region of interest nifti,bvecs,bvals 64 directions
‘small_101D’ small region of interest nifti,bvecs,bvals 101 directions
‘aniso_vox’ volume with anisotropic voxel size as Nifti
‘fornix’ 300 tracks in Trackvis format (from Pittsburgh</p>
<blockquote>
<div><p>Brain Competition)</p>
</div></blockquote>
<dl class="simple">
<dt>‘gqi_vectors’ the scanner wave vectors needed for a GQI acquisitions</dt><dd><p>of 101 directions tested on Siemens 3T Trio</p>
</dd>
</dl>
<p>‘small_25’ small ROI (10x8x2) DTI data (b value 2000, 25 directions)
‘test_piesno’ slice of N=8, K=14 diffusion data
‘reg_c’ small 2D image used for validating registration
‘reg_o’ small 2D image used for validation registration
‘cb_2’ two vectorized cingulum bundles</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fnames</strong><span class="classifier">tuple</span></dt><dd><p>filenames for dataset</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_fnames</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fimg</span><span class="p">,</span><span class="n">fbvals</span><span class="p">,</span><span class="n">fbvecs</span><span class="o">=</span><span class="n">get_fnames</span><span class="p">(</span><span class="s1">&#39;small_101D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">fbvals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvecs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">fbvecs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">=</span><span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fimg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">102</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">102</span><span class="p">,)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">102</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="load-tractogram">
<h3>load_tractogram<a class="headerlink" href="#load-tractogram" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.benchmarks.bench_quickbundles.load_tractogram">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">load_tractogram</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">reference</em>, <em class="sig-param">to_space=&lt;Space.RASMM: 'rasmm'&gt;</em>, <em class="sig-param">shifted_origin=False</em>, <em class="sig-param">bbox_valid_check=True</em>, <em class="sig-param">trk_header_check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.load_tractogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the stateful tractogram from any format (trk, tck, fib, dpy)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">string</span></dt><dd><p>Filename with valid extension</p>
</dd>
<dt><strong>reference</strong><span class="classifier">Nifti or Trk filename, Nifti1Image or TrkFile, Nifti1Header or</span></dt><dd><p>trk.header (dict), or ‘same’ if the input is a trk file.
Reference that provides the spatial attribute.
Typically a nifti-related object from the native diffusion used for
streamlines generation</p>
</dd>
<dt><strong>space</strong><span class="classifier">string</span></dt><dd><p>Space in which the streamlines will be transformed after loading
(vox, voxmm or rasmm)</p>
</dd>
<dt><strong>shifted_origin</strong><span class="classifier">bool</span></dt><dd><p>Information on the position of the origin,
False is Trackvis standard, default (center of the voxel)
True is NIFTI standard (corner of the voxel)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">StatefulTractogram</span></dt><dd><p>The tractogram to load (must have been saved properly)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="measure">
<h3>measure<a class="headerlink" href="#measure" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.benchmarks.bench_quickbundles.measure">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">measure</code><span class="sig-paren">(</span><em class="sig-param">code_str</em>, <em class="sig-param">times=1</em>, <em class="sig-param">label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>
<p>The supplied code string is compiled with the Python builtin <code class="docutils literal notranslate"><span class="pre">compile</span></code>.
The precision of the timing is 10 milli-seconds. If the code will execute
fast on this timescale, it can be executed many times to get reasonable
timing accuracy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>code_str</strong><span class="classifier">str</span></dt><dd><p>The code to be timed.</p>
</dd>
<dt><strong>times</strong><span class="classifier">int, optional</span></dt><dd><p>The number of times the code is executed. Default is 1. The code is
only compiled once.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>A label to identify <cite>code_str</cite> with. This is passed into <code class="docutils literal notranslate"><span class="pre">compile</span></code>
as the second argument (for run-time error messages).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>elapsed</strong><span class="classifier">float</span></dt><dd><p>Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="s1">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time for a single execution : &quot;</span><span class="p">,</span> <span class="n">etime</span> <span class="o">/</span> <span class="n">times</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">Time for a single execution :  0.005 s</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="set-number-of-points">
<h3>set_number_of_points<a class="headerlink" href="#set-number-of-points" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.benchmarks.bench_quickbundles.set_number_of_points">
<code class="sig-prename descclassname">dipy.segment.benchmarks.bench_quickbundles.</code><code class="sig-name descname">set_number_of_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.benchmarks.bench_quickbundles.set_number_of_points" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Change the number of points of streamlines</dt><dd><p>(either by downsampling or upsampling)</p>
</dd>
</dl>
<p>Change the number of points of streamlines in order to obtain
<cite>nb_points</cite>-1 segments of equal length. Points of streamlines will be
modified along the curve.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>If ndarray, must have shape (N,3) where N is the number of points
of the streamline.
If list, each item must be ndarray shape (Ni,3) where Ni is the number
of points of streamline i.
If <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a>, its <cite>common_shape</cite> must be 3.</p>
</dd>
<dt><strong>nb_points</strong><span class="classifier">int</span></dt><dd><p>integer representing number of points wanted along the curve.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>new_streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>Results of the downsampling or upsampling process.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.tracking.streamline</span> <span class="k">import</span> <span class="n">set_number_of_points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>One streamline, a semi-circle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modified_streamline</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamline</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">modified_streamline</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Multiple streamlines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="p">[</span><span class="n">streamline</span><span class="p">,</span> <span class="n">streamline</span><span class="p">[::</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_streamlines</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamlines</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">streamlines</span><span class="p">]</span>
<span class="go">[100, 50]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_streamlines</span><span class="p">]</span>
<span class="go">[10, 10]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="bundlemindistanceasymmetricmetric">
<h3><a class="reference internal" href="#dipy.segment.bundles.BundleMinDistanceAsymmetricMetric" title="dipy.segment.bundles.BundleMinDistanceAsymmetricMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a><a class="headerlink" href="#bundlemindistanceasymmetricmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.bundles.BundleMinDistanceAsymmetricMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">BundleMinDistanceAsymmetricMetric</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleMinDistanceAsymmetricMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="dipy.align.html#dipy.align.streamlinear.BundleMinDistanceMetric" title="dipy.align.streamlinear.BundleMinDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.streamlinear.BundleMinDistanceMetric</span></code></a></p>
<p>Asymmetric Bundle-based Minimum distance</p>
<p>This is a cost function that can be used by the
StreamlineLinearRegistration class.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.BundleMinDistanceAsymmetricMetric.distance" title="dipy.segment.bundles.BundleMinDistanceAsymmetricMetric.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a>(xopt)</p></td>
<td><p>Distance calculated from this Metric</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setup</span></code>(static, moving)</p></td>
<td><p>Setup static and moving sets of streamlines</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.bundles.BundleMinDistanceAsymmetricMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleMinDistanceAsymmetricMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for the metric used for streamline registration</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.bundles.BundleMinDistanceAsymmetricMetric.distance">
<code class="sig-name descname">distance</code><span class="sig-paren">(</span><em class="sig-param">xopt</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleMinDistanceAsymmetricMetric.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance calculated from this Metric</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xopt</strong><span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bundlemindistancemetric">
<h3><a class="reference internal" href="#dipy.segment.bundles.BundleMinDistanceMetric" title="dipy.segment.bundles.BundleMinDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a><a class="headerlink" href="#bundlemindistancemetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.bundles.BundleMinDistanceMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">BundleMinDistanceMetric</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleMinDistanceMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="dipy.align.html#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.streamlinear.StreamlineDistanceMetric</span></code></a></p>
<p>Bundle-based Minimum Distance aka BMD</p>
<p>This is the cost function used by the StreamlineLinearRegistration</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd1b9b2d12117-garyfallidis14"><span class="brackets"><a class="fn-backref" href="#id5">Garyfallidis14</a></span></dt>
<dd><p>Garyfallidis et al., “Direct native-space fiber
bundle alignment for group comparisons”, ISMRM,
2014.</p>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>setup(static, moving)</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>distance(xopt)</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.bundles.BundleMinDistanceMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleMinDistanceMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for the metric used for streamline registration</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.bundles.BundleMinDistanceMetric.distance">
<code class="sig-name descname">distance</code><span class="sig-paren">(</span><em class="sig-param">xopt</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleMinDistanceMetric.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance calculated from this Metric</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xopt</strong><span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector,</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.bundles.BundleMinDistanceMetric.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">moving</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleMinDistanceMetric.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup static and moving sets of streamlines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">streamlines</span></dt><dd><p>Fixed or reference set of streamlines.</p>
</dd>
<dt><strong>moving</strong><span class="classifier">streamlines</span></dt><dd><p>Moving streamlines.</p>
</dd>
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Call this after the object is initiated and before distance.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bundlesumdistancematrixmetric">
<h3><a class="reference internal" href="#dipy.segment.bundles.BundleSumDistanceMatrixMetric" title="dipy.segment.bundles.BundleSumDistanceMatrixMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a><a class="headerlink" href="#bundlesumdistancematrixmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.bundles.BundleSumDistanceMatrixMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">BundleSumDistanceMatrixMetric</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleSumDistanceMatrixMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="dipy.align.html#dipy.align.streamlinear.BundleMinDistanceMatrixMetric" title="dipy.align.streamlinear.BundleMinDistanceMatrixMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.streamlinear.BundleMinDistanceMatrixMetric</span></code></a></p>
<p>Bundle-based Sum Distance aka BMD</p>
<p>This is a cost function that can be used by the
StreamlineLinearRegistration class.</p>
<p class="rubric">Notes</p>
<p>The difference with BundleMinDistanceMatrixMetric is that it uses
uses the sum of the distance matrix and not the sum of mins.</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>setup(static, moving)</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>distance(xopt)</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.bundles.BundleSumDistanceMatrixMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleSumDistanceMatrixMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for the metric used for streamline registration</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.bundles.BundleSumDistanceMatrixMetric.distance">
<code class="sig-name descname">distance</code><span class="sig-paren">(</span><em class="sig-param">xopt</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.BundleSumDistanceMatrixMetric.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance calculated from this Metric</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xopt</strong><span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="recobundles">
<h3><a class="reference internal" href="#dipy.segment.bundles.RecoBundles" title="dipy.segment.bundles.RecoBundles"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecoBundles</span></code></a><a class="headerlink" href="#recobundles" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.bundles.RecoBundles">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">RecoBundles</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">greater_than=50</em>, <em class="sig-param">less_than=1000000</em>, <em class="sig-param">cluster_map=None</em>, <em class="sig-param">clust_thr=15</em>, <em class="sig-param">nb_pts=20</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.RecoBundles" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.RecoBundles.evaluate_results" title="dipy.segment.bundles.RecoBundles.evaluate_results"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_results</span></code></a>(model_bundle, …)</p></td>
<td><p>Compare the similiarity between two given bundles, model bundle, and extracted bundle.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.bundles.RecoBundles.recognize" title="dipy.segment.bundles.RecoBundles.recognize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recognize</span></code></a>(model_bundle, model_clust_thr[, …])</p></td>
<td><p>Recognize the model_bundle in self.streamlines</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.RecoBundles.refine" title="dipy.segment.bundles.RecoBundles.refine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">refine</span></code></a>(model_bundle, pruned_streamlines, …)</p></td>
<td><p>Refine and recognize the model_bundle in self.streamlines This method expects once pruned streamlines as input.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.bundles.RecoBundles.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">greater_than=50</em>, <em class="sig-param">less_than=1000000</em>, <em class="sig-param">cluster_map=None</em>, <em class="sig-param">clust_thr=15</em>, <em class="sig-param">nb_pts=20</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.RecoBundles.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Recognition of bundles</p>
<p>Extract bundles from a participants’ tractograms using model bundles
segmented from a different subject or an atlas of bundles.
See <a class="reference internal" href="#r5023d436ddc1-garyfallidis17" id="id6">[Garyfallidis17]</a> for the details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">Streamlines</span></dt><dd><p>The tractogram in which you want to recognize bundles.</p>
</dd>
<dt><strong>greater_than</strong><span class="classifier">int, optional</span></dt><dd><p>Keep streamlines that have length greater than
this value (default 50)</p>
</dd>
<dt><strong>less_than</strong><span class="classifier">int, optional</span></dt><dd><p>Keep streamlines have length less than this value (default 1000000)</p>
</dd>
<dt><strong>cluster_map</strong><span class="classifier">QB map</span></dt><dd><p>Provide existing clustering to start RB faster (default None).</p>
</dd>
<dt><strong>clust_thr</strong><span class="classifier">float</span></dt><dd><p>Distance threshold in mm for clustering <cite>streamlines</cite></p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState</span></dt><dd><p>If None define RandomState in initialization function.</p>
</dd>
<dt><strong>nb_pts</strong><span class="classifier">int</span></dt><dd><p>Number of points per streamline (default 20)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Make sure that before creating this class that the streamlines and
the model bundles are roughly in the same space.
Also default thresholds are assumed in RAS 1mm^3 space. You may
want to adjust those if your streamlines are not in world coordinates.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5023d436ddc1-garyfallidis17"><span class="brackets">Garyfallidis17</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id7">2</a>)</span></dt>
<dd><p>Garyfallidis et al. Recognition of white matter
bundles using local and global streamline-based registration and
clustering, Neuroimage, 2017.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.bundles.RecoBundles.evaluate_results">
<code class="sig-name descname">evaluate_results</code><span class="sig-paren">(</span><em class="sig-param">model_bundle</em>, <em class="sig-param">pruned_streamlines</em>, <em class="sig-param">slr_select</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.RecoBundles.evaluate_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the similiarity between two given bundles, model bundle,
and extracted bundle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model_bundle</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>pruned_streamlines</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>slr_select</strong><span class="classifier">tuple</span></dt><dd><p>Select the number of streamlines from model to neirborhood of
model to perform the local SLR.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ba_value</strong><span class="classifier">float</span></dt><dd><p>bundle adjacency value between model bundle and pruned bundle</p>
</dd>
<dt><strong>bmd_value</strong><span class="classifier">float</span></dt><dd><p>bundle minimum distance value between model bundle and
pruned bundle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.bundles.RecoBundles.recognize">
<code class="sig-name descname">recognize</code><span class="sig-paren">(</span><em class="sig-param">model_bundle</em>, <em class="sig-param">model_clust_thr</em>, <em class="sig-param">reduction_thr=10</em>, <em class="sig-param">reduction_distance='mdf'</em>, <em class="sig-param">slr=True</em>, <em class="sig-param">slr_num_threads=None</em>, <em class="sig-param">slr_metric=None</em>, <em class="sig-param">slr_x0=None</em>, <em class="sig-param">slr_bounds=None</em>, <em class="sig-param">slr_select=(400</em>, <em class="sig-param">600)</em>, <em class="sig-param">slr_method='L-BFGS-B'</em>, <em class="sig-param">pruning_thr=5</em>, <em class="sig-param">pruning_distance='mdf'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.RecoBundles.recognize" title="Permalink to this definition">¶</a></dt>
<dd><p>Recognize the model_bundle in self.streamlines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model_bundle</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>model_clust_thr</strong><span class="classifier">float</span></dt><dd></dd>
<dt><strong>reduction_thr</strong><span class="classifier">float</span></dt><dd></dd>
<dt><strong>reduction_distance</strong><span class="classifier">string</span></dt><dd><p>mdf or mam (default mam)</p>
</dd>
<dt><strong>slr</strong><span class="classifier">bool</span></dt><dd><p>Use Streamline-based Linear Registration (SLR) locally
(default True)</p>
</dd>
<dt><strong>slr_metric</strong><span class="classifier">BundleMinDistanceMetric</span></dt><dd></dd>
<dt><strong>slr_x0</strong><span class="classifier">array</span></dt><dd><p>(default None)</p>
</dd>
<dt><strong>slr_bounds</strong><span class="classifier">array</span></dt><dd><p>(default None)</p>
</dd>
<dt><strong>slr_select</strong><span class="classifier">tuple</span></dt><dd><p>Select the number of streamlines from model to neirborhood of
model to perform the local SLR.</p>
</dd>
<dt><strong>slr_method</strong><span class="classifier">string</span></dt><dd><p>Optimization method (default ‘L-BFGS-B’)</p>
</dd>
<dt><strong>pruning_thr</strong><span class="classifier">float</span></dt><dd></dd>
<dt><strong>pruning_distance</strong><span class="classifier">string</span></dt><dd><p>MDF (‘mdf’) and MAM (‘mam’)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>recognized_transf</strong><span class="classifier">Streamlines</span></dt><dd><p>Recognized bundle in the space of the model tractogram</p>
</dd>
<dt><strong>recognized_labels</strong><span class="classifier">array</span></dt><dd><p>Indices of recognized bundle in the original tractogram</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7eb0071af658-garyfallidis17"><span class="brackets"><a class="fn-backref" href="#id8">Garyfallidis17</a></span></dt>
<dd><p>Garyfallidis et al. Recognition of white matter
bundles using local and global streamline-based registration and
clustering, Neuroimage, 2017.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.bundles.RecoBundles.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">model_bundle</em>, <em class="sig-param">pruned_streamlines</em>, <em class="sig-param">model_clust_thr</em>, <em class="sig-param">reduction_thr=14</em>, <em class="sig-param">reduction_distance='mdf'</em>, <em class="sig-param">slr=True</em>, <em class="sig-param">slr_metric=None</em>, <em class="sig-param">slr_x0=None</em>, <em class="sig-param">slr_bounds=None</em>, <em class="sig-param">slr_select=(400</em>, <em class="sig-param">600)</em>, <em class="sig-param">slr_method='L-BFGS-B'</em>, <em class="sig-param">pruning_thr=6</em>, <em class="sig-param">pruning_distance='mdf'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.RecoBundles.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine and recognize the model_bundle in self.streamlines
This method expects once pruned streamlines as input. It refines the
first ouput of recobundle by applying second local slr (optional),
and second pruning. This method is useful when we are dealing with
noisy data or when we want to extract small tracks from tractograms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model_bundle</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>pruned_streamlines</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>model_clust_thr</strong><span class="classifier">float</span></dt><dd></dd>
<dt><strong>reduction_thr</strong><span class="classifier">float</span></dt><dd></dd>
<dt><strong>reduction_distance</strong><span class="classifier">string</span></dt><dd><p>mdf or mam (default mam)</p>
</dd>
<dt><strong>slr</strong><span class="classifier">bool</span></dt><dd><p>Use Streamline-based Linear Registration (SLR) locally
(default True)</p>
</dd>
<dt><strong>slr_metric</strong><span class="classifier">BundleMinDistanceMetric</span></dt><dd></dd>
<dt><strong>slr_x0</strong><span class="classifier">array</span></dt><dd><p>(default None)</p>
</dd>
<dt><strong>slr_bounds</strong><span class="classifier">array</span></dt><dd><p>(default None)</p>
</dd>
<dt><strong>slr_select</strong><span class="classifier">tuple</span></dt><dd><p>Select the number of streamlines from model to neirborhood of
model to perform the local SLR.</p>
</dd>
<dt><strong>slr_method</strong><span class="classifier">string</span></dt><dd><p>Optimization method (default ‘L-BFGS-B’)</p>
</dd>
<dt><strong>pruning_thr</strong><span class="classifier">float</span></dt><dd></dd>
<dt><strong>pruning_distance</strong><span class="classifier">string</span></dt><dd><p>MDF (‘mdf’) and MAM (‘mam’)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>recognized_transf</strong><span class="classifier">Streamlines</span></dt><dd><p>Recognized bundle in the space of the model tractogram</p>
</dd>
<dt><strong>recognized_labels</strong><span class="classifier">array</span></dt><dd><p>Indices of recognized bundle in the original tractogram</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r455259b8a2fd-garyfallidis17"><span class="brackets"><a class="fn-backref" href="#id9">Garyfallidis17</a></span></dt>
<dd><p>Garyfallidis et al. Recognition of white matter
bundles using local and global streamline-based registration and
clustering, Neuroimage, 2017.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="streamlinelinearregistration">
<h3><a class="reference internal" href="#dipy.segment.bundles.StreamlineLinearRegistration" title="dipy.segment.bundles.StreamlineLinearRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a><a class="headerlink" href="#streamlinelinearregistration" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.bundles.StreamlineLinearRegistration">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">StreamlineLinearRegistration</code><span class="sig-paren">(</span><em class="sig-param">metric=None</em>, <em class="sig-param">x0='rigid'</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em>, <em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.StreamlineLinearRegistration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.StreamlineLinearRegistration.optimize" title="dipy.segment.bundles.StreamlineLinearRegistration.optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize</span></code></a>(static, moving[, mat])</p></td>
<td><p>Find the minimum of the provided metric.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.bundles.StreamlineLinearRegistration.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">metric=None</em>, <em class="sig-param">x0='rigid'</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em>, <em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.StreamlineLinearRegistration.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear registration of 2 sets of streamlines <a class="reference internal" href="#r9cc75057ef44-garyfallidis15" id="id10">[Garyfallidis15]</a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>metric</strong><span class="classifier">StreamlineDistanceMetric,</span></dt><dd><p>If None and fast is False then the BMD distance is used. If fast
is True then a faster implementation of BMD is used. Otherwise,
use the given distance metric.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">array or int or str</span></dt><dd><p>Initial parametrization for the optimization.</p>
<dl>
<dt>If 1D array with:</dt><dd><p>a) 6 elements then only rigid registration is performed with
the 3 first elements for translation and 3 for rotation.
b) 7 elements also isotropic scaling is performed (similarity).
c) 12 elements then translation, rotation (in degrees),
scaling and shearing is performed (affine).</p>
<p>Here is an example of x0 with 12 elements:
<code class="docutils literal notranslate"><span class="pre">x0=np.array([0,</span> <span class="pre">10,</span> <span class="pre">0,</span> <span class="pre">40,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2.,</span> <span class="pre">1.5,</span> <span class="pre">1,</span> <span class="pre">0.1,</span> <span class="pre">-0.5,</span> <span class="pre">0])</span></code></p>
<p>This has translation (0, 10, 0), rotation (40, 0, 0) in
degrees, scaling (2., 1.5, 1) and shearing (0.1, -0.5, 0).</p>
</dd>
<dt>If int:</dt><dd><ol class="loweralpha simple">
<li><dl class="simple">
<dt>6</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>7</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>12</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
</ol>
</dd>
<dt>If str:</dt><dd><ol class="loweralpha simple">
<li><dl class="simple">
<dt>“rigid”</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“similarity”</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“affine”</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</dd>
<dt><strong>method</strong><span class="classifier">str,</span></dt><dd><p>‘L_BFGS_B’ or ‘Powell’ optimizers can be used. Default is
‘L_BFGS_B’.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">list of tuples or None,</span></dt><dd><p>If method == ‘L_BFGS_B’ then we can use bounded optimization.
For example for the six parameters of rigid rotation we can set
the bounds = [(-30, 30), (-30, 30), (-30, 30),</p>
<blockquote>
<div><p>(-45, 45), (-45, 45), (-45, 45)]</p>
</div></blockquote>
<p>That means that we have set the bounds for the three translations
and three rotation axes (in degrees).</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool,</span></dt><dd><p>If True then information about the optimization is shown.</p>
</dd>
<dt><strong>options</strong><span class="classifier">None or dict,</span></dt><dd><p>Extra options to be used with the selected method.</p>
</dd>
<dt><strong>evolution</strong><span class="classifier">boolean</span></dt><dd><p>If True save the transformation for each iteration of the
optimizer. Default is False. Supported only with Scipy &gt;= 0.11.</p>
</dd>
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9cc75057ef44-garyfallidis15"><span class="brackets">Garyfallidis15</span><span class="fn-backref">(<a href="#id10">1</a>,<a href="#id11">2</a>)</span></dt>
<dd><p>Garyfallidis et al. “Robust and efficient linear
registration of white-matter fascicles in the space of streamlines”,
NeuroImage, 117, 124–140, 2015</p>
</dd>
<dt class="label" id="r9cc75057ef44-garyfallidis14"><span class="brackets"><a class="fn-backref" href="#id12">Garyfallidis14</a></span></dt>
<dd><p>Garyfallidis et al., “Direct native-space fiber
bundle alignment for group comparisons”, ISMRM, 2014.</p>
</dd>
<dt class="label" id="r9cc75057ef44-garyfallidis17"><span class="brackets"><a class="fn-backref" href="#id13">Garyfallidis17</a></span></dt>
<dd><p>Garyfallidis et al. Recognition of white matter
bundles using local and global streamline-based
registration and clustering, Neuroimage, 2017.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.bundles.StreamlineLinearRegistration.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">moving</em>, <em class="sig-param">mat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.StreamlineLinearRegistration.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum of the provided metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">streamlines</span></dt><dd><p>Reference or fixed set of streamlines.</p>
</dd>
<dt><strong>moving</strong><span class="classifier">streamlines</span></dt><dd><p>Moving set of streamlines.</p>
</dd>
<dt><strong>mat</strong><span class="classifier">array</span></dt><dd><p>Transformation (4, 4) matrix to start the registration. <code class="docutils literal notranslate"><span class="pre">mat</span></code>
is applied to moving. Default value None which means that initial
transformation will be generated by shifting the centers of moving
and static sets of streamlines to the origin.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>map</strong><span class="classifier">StreamlineRegistrationMap</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id14">
<h3><a class="reference internal" href="#dipy.segment.bundles.Streamlines" title="dipy.segment.bundles.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Streamlines</span></code></a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.segment.bundles.Streamlines">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">Streamlines</code><a class="headerlink" href="#dipy.segment.bundles.Streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.array_sequence.ArraySequence</span></code></p>
</dd></dl>

</div>
<div class="section" id="chain">
<h3><a class="reference internal" href="#dipy.segment.bundles.chain" title="dipy.segment.bundles.chain"><code class="xref py py-class docutils literal notranslate"><span class="pre">chain</span></code></a><a class="headerlink" href="#chain" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.bundles.chain">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">chain</code><a class="headerlink" href="#dipy.segment.bundles.chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>chain(<a href="#id15"><span class="problematic" id="id16">*</span></a>iterables) –&gt; chain object</p>
<p>Return a chain object whose .__next__() method returns elements from the
first iterable until it is exhausted, then elements from the next
iterable, until all of the iterables are exhausted.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.bundles.chain.from_iterable" title="dipy.segment.bundles.chain.from_iterable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_iterable</span></code></a></p></td>
<td><p>chain.from_iterable(iterable) –&gt; chain object</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.bundles.chain.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.chain.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.bundles.chain.from_iterable">
<code class="sig-name descname">from_iterable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.chain.from_iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>chain.from_iterable(iterable) –&gt; chain object</p>
<p>Alternate chain() constructor taking a single iterable argument
that evaluates lazily.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="apply-affine">
<h3>apply_affine<a class="headerlink" href="#apply-affine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.apply_affine">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">apply_affine</code><span class="sig-paren">(</span><em class="sig-param">aff</em>, <em class="sig-param">pts</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.apply_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply affine matrix <cite>aff</cite> to points <cite>pts</cite></p>
<p>Returns result of application of <cite>aff</cite> to the <em>right</em> of <cite>pts</cite>.  The
coordinate dimension of <cite>pts</cite> should be the last.</p>
<p>For the 3D case, <cite>aff</cite> will be shape (4,4) and <cite>pts</cite> will have final axis
length 3 - maybe it will just be N by 3. The return value is the
transformed points, in this case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">],</span> <span class="n">pts</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>This routine is more general than 3D, in that <cite>aff</cite> can have any shape
(N,N), and <cite>pts</cite> can have any shape, as long as the last dimension is for
the coordinates, and is therefore length N-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>aff</strong><span class="classifier">(N, N) array-like</span></dt><dd><p>Homogenous affine, for 3D points, will be 4 by 4. Contrary to first
appearance, the affine will be applied on the left of <cite>pts</cite>.</p>
</dd>
<dt><strong>pts</strong><span class="classifier">(…, N-1) array-like</span></dt><dd><p>Points, where the last dimension contains the coordinates of each
point.  For 3D, the last dimension will be length 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>transformed_pts</strong><span class="classifier">(…, N-1) array</span></dt><dd><p>transformed points</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">11</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_affine</span><span class="p">(</span><span class="n">aff</span><span class="p">,</span> <span class="n">pts</span><span class="p">)</span> <span class="c1">#doctest: +ELLIPSIS</span>
<span class="go">array([[14, 14, 24],</span>
<span class="go">       [16, 17, 28],</span>
<span class="go">       [20, 23, 36],</span>
<span class="go">       [24, 29, 44]]...)</span>
</pre></div>
</div>
<p>Just to show that in the simple 3D case, it is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">],</span> <span class="n">pts</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="c1">#doctest: +ELLIPSIS</span>
<span class="go">array([[14, 14, 24],</span>
<span class="go">       [16, 17, 28],</span>
<span class="go">       [20, 23, 36],</span>
<span class="go">       [24, 29, 44]]...)</span>
</pre></div>
</div>
<p>But <cite>pts</cite> can be a more complicated shape:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_affine</span><span class="p">(</span><span class="n">aff</span><span class="p">,</span> <span class="n">pts</span><span class="p">)</span> <span class="c1">#doctest: +ELLIPSIS</span>
<span class="go">array([[[14, 14, 24],</span>
<span class="go">        [16, 17, 28]],</span>
<span class="go">&lt;BLANKLINE&gt;</span>
<span class="go">       [[20, 23, 36],</span>
<span class="go">        [24, 29, 44]]]...)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="bundle-adjacency">
<h3>bundle_adjacency<a class="headerlink" href="#bundle-adjacency" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.bundle_adjacency">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">bundle_adjacency</code><span class="sig-paren">(</span><em class="sig-param">dtracks0</em>, <em class="sig-param">dtracks1</em>, <em class="sig-param">threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.bundle_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bundle adjacency between two given tracks/bundles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtracks0</strong><span class="classifier">Streamlines</span></dt><dd><p>dtracks1 : Streamlines
threshold: float</p>
</dd>
<dt><strong>References</strong></dt><dd></dd>
<dt><strong>———-</strong></dt><dd></dd>
<dt><strong>.. [Garyfallidis12] Garyfallidis E. et al., QuickBundles a method for</strong></dt><dd><p>tractography simplification, Frontiers in Neuroscience,
vol 6, no 175, 2012.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="bundles-distances-mam">
<h3>bundles_distances_mam<a class="headerlink" href="#bundles-distances-mam" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.bundles_distances_mam">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">bundles_distances_mam</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.bundles_distances_mam" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate distances between list of tracks A and list of tracks B</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tracksA</strong><span class="classifier">sequence</span></dt><dd><p>of tracks as arrays, shape (N1,3) .. (Nm,3)</p>
</dd>
<dt><strong>tracksB</strong><span class="classifier">sequence</span></dt><dd><p>of tracks as arrays, shape (N1,3) .. (Nm,3)</p>
</dd>
<dt><strong>metric</strong><span class="classifier">str</span></dt><dd><p>‘avg’, ‘min’, ‘max’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DM</strong><span class="classifier">array, shape (len(tracksA), len(tracksB))</span></dt><dd><p>distances between tracksA and tracksB according to metric</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="bundles-distances-mdf">
<h3>bundles_distances_mdf<a class="headerlink" href="#bundles-distances-mdf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.bundles_distances_mdf">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">bundles_distances_mdf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.bundles_distances_mdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate distances between list of tracks A and list of tracks B</p>
<p>All tracks need to have the same number of points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tracksA</strong><span class="classifier">sequence</span></dt><dd><p>of tracks as arrays, [(N,3) .. (N,3)]</p>
</dd>
<dt><strong>tracksB</strong><span class="classifier">sequence</span></dt><dd><p>of tracks as arrays, [(N,3) .. (N,3)]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DM</strong><span class="classifier">array, shape (len(tracksA), len(tracksB))</span></dt><dd><p>distances between tracksA and tracksB according to metric</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dipy.metrics.downsample</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="check-range">
<h3>check_range<a class="headerlink" href="#check-range" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.check_range">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">check_range</code><span class="sig-paren">(</span><em class="sig-param">streamline</em>, <em class="sig-param">gt</em>, <em class="sig-param">lt</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.check_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="length">
<h3>length<a class="headerlink" href="#length" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.length">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Euclidean length of streamlines</p>
<p>Length is in mm only if streamlines are expressed in world coordinates.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>If ndarray, must have shape (N,3) where N is the number of points
of the streamline.
If list, each item must be ndarray shape (Ni,3) where Ni is the number
of points of streamline i.
If <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a>, its <cite>common_shape</cite> must be 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lengths</strong><span class="classifier">scalar or ndarray shape (N,)</span></dt><dd><p>If there is only one streamline, a scalar representing the length of the
streamline.
If there are several streamlines, ndarray containing the length of every
streamline.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.tracking.streamline</span> <span class="k">import</span> <span class="n">length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expected_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="o">**</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span><span class="p">(</span><span class="n">streamline</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected_length</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="p">[</span><span class="n">streamline</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">streamline</span><span class="p">,</span> <span class="n">streamline</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expected_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">expected_length</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">expected_length</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">length</span><span class="p">(</span><span class="n">streamlines</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">length</span><span class="p">(</span><span class="n">streamlines</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">expected_lengths</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span><span class="p">([])</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]))</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nbytes">
<h3>nbytes<a class="headerlink" href="#nbytes" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.nbytes">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">nbytes</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.nbytes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="qbx-and-merge">
<h3>qbx_and_merge<a class="headerlink" href="#qbx-and-merge" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.qbx_and_merge">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">qbx_and_merge</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">thresholds</em>, <em class="sig-param">nb_pts=20</em>, <em class="sig-param">select_randomly=None</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.qbx_and_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Run QuickBundlesX and then run again on the centroids of the last layer</p>
<p>Running again QuickBundles at a layer has the effect of merging
some of the clusters that maybe originally devided because of branching.
This function help obtain a result at a QuickBundles quality but with
QuickBundlesX speed. The merging phase has low cost because it is applied
only on the centroids rather than the entire dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>thresholds</strong><span class="classifier">sequence</span></dt><dd><p>List of distance thresholds for QuickBundlesX.</p>
</dd>
<dt><strong>nb_pts</strong><span class="classifier">int</span></dt><dd><p>Number of points for discretizing each streamline</p>
</dd>
<dt><strong>select_randomly</strong><span class="classifier">int</span></dt><dd><p>Randomly select a specific number of streamlines. If None all the
streamlines are used.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState</span></dt><dd><p>If None then RandomState is initialized internally.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True print information in stdout.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clusters</strong><span class="classifier">obj</span></dt><dd><p>Contains the clusters of the last layer of QuickBundlesX after merging.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5dc5efa199c0-garyfallidis12"><span class="brackets"><a class="fn-backref" href="#id17">Garyfallidis12</a></span></dt>
<dd><p>Garyfallidis E. et al., QuickBundles a method for
tractography simplification, Frontiers in Neuroscience,
vol 6, no 175, 2012.</p>
</dd>
<dt class="label" id="r5dc5efa199c0-garyfallidis16"><span class="brackets"><a class="fn-backref" href="#id18">Garyfallidis16</a></span></dt>
<dd><p>Garyfallidis E. et al. QuickBundlesX: Sequential
clustering of millions of streamlines in multiple
levels of detail at record execution time. Proceedings
of the, International Society of Magnetic Resonance
in Medicine (ISMRM). Singapore, 4187, 2016.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="select-random-set-of-streamlines">
<h3>select_random_set_of_streamlines<a class="headerlink" href="#select-random-set-of-streamlines" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.select_random_set_of_streamlines">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">select_random_set_of_streamlines</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">select</em>, <em class="sig-param">rng=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.select_random_set_of_streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a random set of streamlines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">Steamlines</span></dt><dd><p>Object of 2D ndarrays of shape[-1]==3</p>
</dd>
<dt><strong>select</strong><span class="classifier">int</span></dt><dd><p>Number of streamlines to select. If there are less streamlines
than <code class="docutils literal notranslate"><span class="pre">select</span></code> then <code class="docutils literal notranslate"><span class="pre">select=len(streamlines)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState</span></dt><dd><p>Default None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selected_streamlines</strong><span class="classifier">list</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The same streamline will not be selected twice.</p>
</dd></dl>

</div>
<div class="section" id="id19">
<h3>set_number_of_points<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.set_number_of_points">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">set_number_of_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.bundles.set_number_of_points" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Change the number of points of streamlines</dt><dd><p>(either by downsampling or upsampling)</p>
</dd>
</dl>
<p>Change the number of points of streamlines in order to obtain
<cite>nb_points</cite>-1 segments of equal length. Points of streamlines will be
modified along the curve.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>If ndarray, must have shape (N,3) where N is the number of points
of the streamline.
If list, each item must be ndarray shape (Ni,3) where Ni is the number
of points of streamline i.
If <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a>, its <cite>common_shape</cite> must be 3.</p>
</dd>
<dt><strong>nb_points</strong><span class="classifier">int</span></dt><dd><p>integer representing number of points wanted along the curve.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>new_streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>Results of the downsampling or upsampling process.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.tracking.streamline</span> <span class="k">import</span> <span class="n">set_number_of_points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>One streamline, a semi-circle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modified_streamline</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamline</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">modified_streamline</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Multiple streamlines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="p">[</span><span class="n">streamline</span><span class="p">,</span> <span class="n">streamline</span><span class="p">[::</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_streamlines</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamlines</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">streamlines</span><span class="p">]</span>
<span class="go">[100, 50]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_streamlines</span><span class="p">]</span>
<span class="go">[10, 10]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="time">
<h3>time<a class="headerlink" href="#time" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.bundles.time">
<code class="sig-prename descclassname">dipy.segment.bundles.</code><code class="sig-name descname">time</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; floating point number<a class="headerlink" href="#dipy.segment.bundles.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current time in seconds since the Epoch.
Fractions of a second may be present if the system clock provides them.</p>
</dd></dl>

</div>
<div class="section" id="abcmeta">
<h3><a class="reference internal" href="#dipy.segment.clustering.ABCMeta" title="dipy.segment.clustering.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABCMeta</span></code></a><a class="headerlink" href="#abcmeta" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.ABCMeta">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">ABCMeta</code><a class="headerlink" href="#dipy.segment.clustering.ABCMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a></p>
<p>Metaclass for defining Abstract Base Classes (ABCs).</p>
<p>Use this metaclass to create an ABC.  An ABC can be subclassed
directly, and then acts as a mix-in class.  You can also register
unrelated concrete classes (even built-in classes) and unrelated
ABCs as ‘virtual subclasses’ – these and their descendants will
be considered subclasses of the registering ABC by the built-in
issubclass() function, but the registering ABC won’t show up in
their MRO (Method Resolution Order) nor will method
implementations defined by the registering ABC be callable (not
even via super()).</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>($self, /, *args, **kwargs)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mro</span></code>()</p></td>
<td><p>return a type’s method resolution order</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.ABCMeta.register" title="dipy.segment.clustering.ABCMeta.register"><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code></a>(subclass)</p></td>
<td><p>Register a virtual subclass of an ABC.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.ABCMeta.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ABCMeta.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ABCMeta.register">
<code class="sig-name descname">register</code><span class="sig-paren">(</span><em class="sig-param">subclass</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ABCMeta.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a virtual subclass of an ABC.</p>
<p>Returns the subclass, to allow usage as a class decorator.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="averagepointwiseeuclideanmetric">
<h3><a class="reference internal" href="#dipy.segment.clustering.AveragePointwiseEuclideanMetric" title="dipy.segment.clustering.AveragePointwiseEuclideanMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragePointwiseEuclideanMetric</span></code></a><a class="headerlink" href="#averagepointwiseeuclideanmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.AveragePointwiseEuclideanMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">AveragePointwiseEuclideanMetric</code><a class="headerlink" href="#dipy.segment.clustering.AveragePointwiseEuclideanMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.SumPointwiseEuclideanMetric</span></code></p>
<p>Computes the average of pointwise Euclidean distances between two
sequential data.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions). A <cite>feature</cite> object can be specified
in order to calculate the distance between the features, rather than
directly between the sequential data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>feature</strong><span class="classifier"><cite>Feature</cite> object, optional</span></dt><dd><p>It is used to extract features before computing the distance.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The distance between two 2D sequential data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s1</span>       <span class="n">s2</span>

<span class="mi">0</span><span class="o">*</span>   <span class="n">a</span>    <span class="o">*</span><span class="mi">0</span>
  \       <span class="o">|</span>
   \      <span class="o">|</span>
   <span class="mi">1</span><span class="o">*</span>     <span class="o">|</span>
    <span class="o">|</span>  <span class="n">b</span>  <span class="o">*</span><span class="mi">1</span>
    <span class="o">|</span>      \
    <span class="mi">2</span><span class="o">*</span>      \
        <span class="n">c</span>    <span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p>is equal to <span class="math notranslate nohighlight">\((a+b+c)/3\)</span> where <span class="math notranslate nohighlight">\(a\)</span> is the Euclidean distance between s1[0] and
s2[0], <span class="math notranslate nohighlight">\(b\)</span> between s1[1] and s2[1] and <span class="math notranslate nohighlight">\(c\)</span> between s1[2] and s2[2].</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.AveragePointwiseEuclideanMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.AveragePointwiseEuclideanMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="cluster">
<h3><a class="reference internal" href="#dipy.segment.clustering.Cluster" title="dipy.segment.clustering.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a><a class="headerlink" href="#cluster" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.Cluster">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">Cluster</code><span class="sig-paren">(</span><em class="sig-param">id=0</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">refdata=&lt;dipy.segment.clustering.Identity object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.Cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Provides functionalities for interacting with a cluster.</p>
<p>Useful container to retrieve index of elements grouped together. If
a reference to the data is provided to <cite>cluster_map</cite>, elements will
be returned instead of their index when possible.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>cluster_map</strong><span class="classifier"><cite>ClusterMap</cite> object</span></dt><dd><p>Reference to the set of clusters this cluster is being part of.</p>
</dd>
<dt><strong>id</strong><span class="classifier">int</span></dt><dd><p>Id of this cluster in its associated <cite>cluster_map</cite> object.</p>
</dd>
<dt><strong>refdata</strong><span class="classifier">list (optional)</span></dt><dd><p>Actual elements that clustered indices refer to.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A cluster does not contain actual data but instead knows how to
retrieve them using its <cite>ClusterMap</cite> object.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.Cluster.assign" title="dipy.segment.clustering.Cluster.assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assign</span></code></a>(*indices)</p></td>
<td><p>Assigns indices to this cluster.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.Cluster.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">id=0</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">refdata=&lt;dipy.segment.clustering.Identity object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.Cluster.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.Cluster.assign">
<code class="sig-name descname">assign</code><span class="sig-paren">(</span><em class="sig-param">*indices</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.Cluster.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns indices to this cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">list of indices</span></dt><dd><p>Indices to add to this cluster.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="clustercentroid">
<h3><a class="reference internal" href="#dipy.segment.clustering.ClusterCentroid" title="dipy.segment.clustering.ClusterCentroid"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterCentroid</span></code></a><a class="headerlink" href="#clustercentroid" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.ClusterCentroid">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">ClusterCentroid</code><span class="sig-paren">(</span><em class="sig-param">centroid</em>, <em class="sig-param">id=0</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">refdata=&lt;dipy.segment.clustering.Identity object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterCentroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.segment.clustering.Cluster" title="dipy.segment.clustering.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.clustering.Cluster</span></code></a></p>
<p>Provides functionalities for interacting with a cluster.</p>
<p>Useful container to retrieve the indices of elements grouped together and
the cluster’s centroid. If a reference to the data is provided to
<cite>cluster_map</cite>, elements will be returned instead of their index when
possible.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>cluster_map</strong><span class="classifier"><cite>ClusterMapCentroid</cite> object</span></dt><dd><p>Reference to the set of clusters this cluster is being part of.</p>
</dd>
<dt><strong>id</strong><span class="classifier">int</span></dt><dd><p>Id of this cluster in its associated <cite>cluster_map</cite> object.</p>
</dd>
<dt><strong>refdata</strong><span class="classifier">list (optional)</span></dt><dd><p>Actual elements that clustered indices refer to.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A cluster does not contain actual data but instead knows how to
retrieve them using its <cite>ClusterMapCentroid</cite> object.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterCentroid.assign" title="dipy.segment.clustering.ClusterCentroid.assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assign</span></code></a>(id_datum, features)</p></td>
<td><p>Assigns a data point to this cluster.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterCentroid.update" title="dipy.segment.clustering.ClusterCentroid.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>()</p></td>
<td><p>Update centroid of this cluster.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.ClusterCentroid.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">centroid</em>, <em class="sig-param">id=0</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">refdata=&lt;dipy.segment.clustering.Identity object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterCentroid.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterCentroid.assign">
<code class="sig-name descname">assign</code><span class="sig-paren">(</span><em class="sig-param">id_datum</em>, <em class="sig-param">features</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterCentroid.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a data point to this cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id_datum</strong><span class="classifier">int</span></dt><dd><p>Index of the data point to add to this cluster.</p>
</dd>
<dt><strong>features</strong><span class="classifier">2D array</span></dt><dd><p>Data point’s features to modify this cluster’s centroid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterCentroid.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterCentroid.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update centroid of this cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>converged</strong><span class="classifier">bool</span></dt><dd><p>Tells if the centroid has moved.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="clustermap">
<h3><a class="reference internal" href="#dipy.segment.clustering.ClusterMap" title="dipy.segment.clustering.ClusterMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterMap</span></code></a><a class="headerlink" href="#clustermap" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.ClusterMap">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">ClusterMap</code><span class="sig-paren">(</span><em class="sig-param">refdata=&lt;dipy.segment.clustering.Identity object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Provides functionalities for interacting with clustering outputs.</p>
<p>Useful container to create, remove, retrieve and filter clusters.
If <cite>refdata</cite> is given, elements will be returned instead of their
index when using <cite>Cluster</cite> objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>refdata</strong><span class="classifier">list</span></dt><dd><p>Actual elements that clustered indices refer to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clusters</strong></dt><dd></dd>
<dt><strong>refdata</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterMap.add_cluster" title="dipy.segment.clustering.ClusterMap.add_cluster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_cluster</span></code></a>(*clusters)</p></td>
<td><p>Adds one or multiple clusters to this cluster map.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterMap.clear" title="dipy.segment.clustering.ClusterMap.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</p></td>
<td><p>Remove all clusters from this cluster map.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterMap.clusters_sizes" title="dipy.segment.clustering.ClusterMap.clusters_sizes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clusters_sizes</span></code></a>()</p></td>
<td><p>Gets the size of every cluster contained in this cluster map.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterMap.get_large_clusters" title="dipy.segment.clustering.ClusterMap.get_large_clusters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_large_clusters</span></code></a>(min_size)</p></td>
<td><p>Gets clusters which contains at least <cite>min_size</cite> elements.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterMap.get_small_clusters" title="dipy.segment.clustering.ClusterMap.get_small_clusters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_small_clusters</span></code></a>(max_size)</p></td>
<td><p>Gets clusters which contains at most <cite>max_size</cite> elements.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterMap.remove_cluster" title="dipy.segment.clustering.ClusterMap.remove_cluster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_cluster</span></code></a>(*clusters)</p></td>
<td><p>Remove one or multiple clusters from this cluster map.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.ClusterMap.size" title="dipy.segment.clustering.ClusterMap.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a>()</p></td>
<td><p>Gets number of clusters contained in this cluster map.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">refdata=&lt;dipy.segment.clustering.Identity object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.add_cluster">
<code class="sig-name descname">add_cluster</code><span class="sig-paren">(</span><em class="sig-param">*clusters</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.add_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds one or multiple clusters to this cluster map.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>*clusters</strong><span class="classifier"><cite>Cluster</cite> object, …</span></dt><dd><p>Cluster(s) to be added in this cluster map.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all clusters from this cluster map.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.clusters">
<em class="property">property </em><code class="sig-name descname">clusters</code><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.clusters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.clusters_sizes">
<code class="sig-name descname">clusters_sizes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.clusters_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the size of every cluster contained in this cluster map.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>list of int</strong></dt><dd><p>Sizes of every cluster in this cluster map.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.get_large_clusters">
<code class="sig-name descname">get_large_clusters</code><span class="sig-paren">(</span><em class="sig-param">min_size</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.get_large_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets clusters which contains at least <cite>min_size</cite> elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_size</strong><span class="classifier">int</span></dt><dd><p>Minimum number of elements a cluster needs to have to be selected.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>list of `Cluster` objects</strong></dt><dd><p>Clusters having at least <cite>min_size</cite> elements.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.get_small_clusters">
<code class="sig-name descname">get_small_clusters</code><span class="sig-paren">(</span><em class="sig-param">max_size</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.get_small_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets clusters which contains at most <cite>max_size</cite> elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_size</strong><span class="classifier">int</span></dt><dd><p>Maximum number of elements a cluster can have to be selected.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>list of `Cluster` objects</strong></dt><dd><p>Clusters having at most <cite>max_size</cite> elements.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.refdata">
<em class="property">property </em><code class="sig-name descname">refdata</code><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.refdata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.remove_cluster">
<code class="sig-name descname">remove_cluster</code><span class="sig-paren">(</span><em class="sig-param">*clusters</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.remove_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove one or multiple clusters from this cluster map.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>*clusters</strong><span class="classifier"><cite>Cluster</cite> object, …</span></dt><dd><p>Cluster(s) to be removed from this cluster map.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMap.size">
<code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMap.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets number of clusters contained in this cluster map.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="clustermapcentroid">
<h3><a class="reference internal" href="#dipy.segment.clustering.ClusterMapCentroid" title="dipy.segment.clustering.ClusterMapCentroid"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterMapCentroid</span></code></a><a class="headerlink" href="#clustermapcentroid" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.ClusterMapCentroid">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">ClusterMapCentroid</code><span class="sig-paren">(</span><em class="sig-param">refdata=&lt;dipy.segment.clustering.Identity object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMapCentroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.segment.clustering.ClusterMap" title="dipy.segment.clustering.ClusterMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.clustering.ClusterMap</span></code></a></p>
<p>Provides functionalities for interacting with clustering outputs
that have centroids.</p>
<p>Allows to retrieve easely the centroid of every cluster. Also, it is
a useful container to create, remove, retrieve and filter clusters.
If <cite>refdata</cite> is given, elements will be returned instead of their
index when using <cite>ClusterCentroid</cite> objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>refdata</strong><span class="classifier">list</span></dt><dd><p>Actual elements that clustered indices refer to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>centroids</strong></dt><dd></dd>
<dt><strong>clusters</strong></dt><dd></dd>
<dt><strong>refdata</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_cluster</span></code>(*clusters)</p></td>
<td><p>Adds one or multiple clusters to this cluster map.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</p></td>
<td><p>Remove all clusters from this cluster map.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clusters_sizes</span></code>()</p></td>
<td><p>Gets the size of every cluster contained in this cluster map.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_large_clusters</span></code>(min_size)</p></td>
<td><p>Gets clusters which contains at least <cite>min_size</cite> elements.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_small_clusters</span></code>(max_size)</p></td>
<td><p>Gets clusters which contains at most <cite>max_size</cite> elements.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_cluster</span></code>(*clusters)</p></td>
<td><p>Remove one or multiple clusters from this cluster map.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code>()</p></td>
<td><p>Gets number of clusters contained in this cluster map.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.ClusterMapCentroid.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">refdata=&lt;dipy.segment.clustering.Identity object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ClusterMapCentroid.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.ClusterMapCentroid.centroids">
<em class="property">property </em><code class="sig-name descname">centroids</code><a class="headerlink" href="#dipy.segment.clustering.ClusterMapCentroid.centroids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="clustering">
<h3><a class="reference internal" href="#dipy.segment.clustering.Clustering" title="dipy.segment.clustering.Clustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clustering</span></code></a><a class="headerlink" href="#clustering" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.Clustering">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">Clustering</code><a class="headerlink" href="#dipy.segment.clustering.Clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.Clustering.cluster" title="dipy.segment.clustering.Clustering.cluster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cluster</span></code></a>(data[, ordering])</p></td>
<td><p>Clusters <cite>data</cite>.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.Clustering.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.Clustering.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.Clustering.cluster">
<em class="property">abstract </em><code class="sig-name descname">cluster</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">ordering=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.Clustering.cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters <cite>data</cite>.</p>
<p>Subclasses will perform their clustering algorithm here.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">list of N-dimensional arrays</span></dt><dd><p>Each array represents a data point.</p>
</dd>
<dt><strong>ordering</strong><span class="classifier">iterable of indices, optional</span></dt><dd><p>Specifies the order in which data points will be clustered.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>`ClusterMap` object</strong></dt><dd><p>Result of the clustering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="identity">
<h3><a class="reference internal" href="#dipy.segment.clustering.Identity" title="dipy.segment.clustering.Identity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code></a><a class="headerlink" href="#identity" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.Identity">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">Identity</code><a class="headerlink" href="#dipy.segment.clustering.Identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Provides identity indexing functionality.</p>
<p>This can replace any class supporting indexing used for referencing
(e.g. list, tuple). Indexing an instance of this class will return the
index provided instead of the element. It does not support slicing.</p>
<dl class="method">
<dt id="dipy.segment.clustering.Identity.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.Identity.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id20">
<h3><a class="reference internal" href="#dipy.segment.clustering.Metric" title="dipy.segment.clustering.Metric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Metric</span></code></a><a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.Metric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">Metric</code><a class="headerlink" href="#dipy.segment.clustering.Metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Computes a distance between two sequential data.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions). A <cite>feature</cite> object can be specified
in order to calculate the distance between extracted features, rather
than directly between the sequential data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>feature</strong><span class="classifier"><cite>Feature</cite> object, optional</span></dt><dd><p>It is used to extract features before computing the distance.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When subclassing <cite>Metric</cite>, one only needs to override the <cite>dist</cite> and
<cite>are_compatible</cite> methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#dipy.segment.clustering.Metric.feature" title="dipy.segment.clustering.Metric.feature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></a></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><a class="reference internal" href="#dipy.segment.clustering.Metric.is_order_invariant" title="dipy.segment.clustering.Metric.is_order_invariant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></a></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.Metric.are_compatible" title="dipy.segment.clustering.Metric.are_compatible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></a></p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.clustering.Metric.dist" title="dipy.segment.clustering.Metric.dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></a></p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.Metric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.Metric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.Metric.are_compatible">
<code class="sig-name descname">are_compatible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.Metric.are_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p>
<p>Basically this method exists so we don’t have to do this check
inside the <cite>metric.dist</cite> function (speedup).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape1</strong><span class="classifier">int, 1-tuple or 2-tuple</span></dt><dd><p>shape of the first data point’s features</p>
</dd>
<dt><strong>shape2</strong><span class="classifier">int, 1-tuple or 2-tuple</span></dt><dd><p>shape of the second data point’s features</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>are_compatible</strong><span class="classifier">bool</span></dt><dd><p>whether or not shapes are compatible</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.Metric.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.Metric.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a distance between two data points based on their features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>features1</strong><span class="classifier">2D array</span></dt><dd><p>Features of the first data point.</p>
</dd>
<dt><strong>features2</strong><span class="classifier">2D array</span></dt><dd><p>Features of the second data point.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>double</strong></dt><dd><p>Distance between two data points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.clustering.Metric.feature">
<code class="sig-name descname">feature</code><a class="headerlink" href="#dipy.segment.clustering.Metric.feature" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.clustering.Metric.is_order_invariant">
<code class="sig-name descname">is_order_invariant</code><a class="headerlink" href="#dipy.segment.clustering.Metric.is_order_invariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="minimumaveragedirectflipmetric">
<h3><a class="reference internal" href="#dipy.segment.clustering.MinimumAverageDirectFlipMetric" title="dipy.segment.clustering.MinimumAverageDirectFlipMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimumAverageDirectFlipMetric</span></code></a><a class="headerlink" href="#minimumaveragedirectflipmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.MinimumAverageDirectFlipMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">MinimumAverageDirectFlipMetric</code><a class="headerlink" href="#dipy.segment.clustering.MinimumAverageDirectFlipMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.AveragePointwiseEuclideanMetric</span></code></p>
<p>Computes the MDF distance (minimum average direct-flip) between two
sequential data.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<p class="rubric">Notes</p>
<p>The distance between two 2D sequential data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s1</span>       <span class="n">s2</span>

<span class="mi">0</span><span class="o">*</span>   <span class="n">a</span>    <span class="o">*</span><span class="mi">0</span>
  \       <span class="o">|</span>
   \      <span class="o">|</span>
   <span class="mi">1</span><span class="o">*</span>     <span class="o">|</span>
    <span class="o">|</span>  <span class="n">b</span>  <span class="o">*</span><span class="mi">1</span>
    <span class="o">|</span>      \
    <span class="mi">2</span><span class="o">*</span>      \
        <span class="n">c</span>    <span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p>is equal to <span class="math notranslate nohighlight">\(\min((a+b+c)/3, (a'+b'+c')/3)\)</span> where <span class="math notranslate nohighlight">\(a\)</span> is the Euclidean distance
between s1[0] and s2[0], <span class="math notranslate nohighlight">\(b\)</span> between s1[1] and s2[1], <span class="math notranslate nohighlight">\(c\)</span> between s1[2]
and s2[2], <span class="math notranslate nohighlight">\(a'\)</span> between s1[0] and s2[2], <span class="math notranslate nohighlight">\(b'\)</span> between s1[1] and s2[1]
and <span class="math notranslate nohighlight">\(c'\)</span> between s1[2] and s2[0].</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><a class="reference internal" href="#dipy.segment.clustering.MinimumAverageDirectFlipMetric.is_order_invariant" title="dipy.segment.clustering.MinimumAverageDirectFlipMetric.is_order_invariant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></a></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.MinimumAverageDirectFlipMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.MinimumAverageDirectFlipMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.clustering.MinimumAverageDirectFlipMetric.is_order_invariant">
<code class="sig-name descname">is_order_invariant</code><a class="headerlink" href="#dipy.segment.clustering.MinimumAverageDirectFlipMetric.is_order_invariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="quickbundles">
<h3><a class="reference internal" href="#dipy.segment.clustering.QuickBundles" title="dipy.segment.clustering.QuickBundles"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuickBundles</span></code></a><a class="headerlink" href="#quickbundles" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.QuickBundles">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">QuickBundles</code><span class="sig-paren">(</span><em class="sig-param">threshold</em>, <em class="sig-param">metric='MDF_12points'</em>, <em class="sig-param">max_nb_clusters=2147483647</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.QuickBundles" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.segment.clustering.Clustering" title="dipy.segment.clustering.Clustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.clustering.Clustering</span></code></a></p>
<p>Clusters streamlines using QuickBundles <a class="reference internal" href="#r2491d57df3a8-garyfallidis12" id="id21">[Garyfallidis12]</a>.</p>
<p>Given a list of streamlines, the QuickBundles algorithm sequentially
assigns each streamline to its closest bundle in <span class="math notranslate nohighlight">\(\mathcal{O}(Nk)\)</span> where
<span class="math notranslate nohighlight">\(N\)</span> is the number of streamlines and <span class="math notranslate nohighlight">\(k\)</span> is the final number of bundles.
If for a given streamline its closest bundle is farther than <cite>threshold</cite>,
a new bundle is created and the streamline is assigned to it except if the
number of bundles has already exceeded <cite>max_nb_clusters</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>The maximum distance from a bundle for a streamline to be still
considered as part of it.</p>
</dd>
<dt><strong>metric</strong><span class="classifier">str or <cite>Metric</cite> object (optional)</span></dt><dd><p>The distance metric to use when comparing two streamlines. By default,
the Minimum average Direct-Flip (MDF) distance <a class="reference internal" href="#r2491d57df3a8-garyfallidis12" id="id22">[Garyfallidis12]</a> is
used and streamlines are automatically resampled so they have
12 points.</p>
</dd>
<dt><strong>max_nb_clusters</strong><span class="classifier">int</span></dt><dd><p>Limits the creation of bundles.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2491d57df3a8-garyfallidis12"><span class="brackets">Garyfallidis12</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id21">2</a>,<a href="#id22">3</a>,<a href="#id23">4</a>)</span></dt>
<dd><p>Garyfallidis E. et al., QuickBundles a method for
tractography simplification, Frontiers in Neuroscience,
vol 6, no 175, 2012.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.segment.clustering</span> <span class="k">import</span> <span class="n">QuickBundles</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_fnames</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.io.streamline</span> <span class="k">import</span> <span class="n">load_tractogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.tracking.streamline</span> <span class="k">import</span> <span class="n">Streamlines</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fname</span> <span class="o">=</span> <span class="n">get_fnames</span><span class="p">(</span><span class="s1">&#39;fornix&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fornix</span> <span class="o">=</span> <span class="n">load_tractogram</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">bbox_valid_check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">streamlines</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="n">Streamlines</span><span class="p">(</span><span class="n">fornix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Segment fornix with a threshold of 10mm and streamlines resampled</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># to 12 points.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qb</span> <span class="o">=</span> <span class="n">QuickBundles</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">10.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">streamlines</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">clusters</span><span class="p">))</span>
<span class="go">[61, 191, 47, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Resampling streamlines differently is done explicitly as follows.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note this has an impact on the speed and the accuracy (tradeoff).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.segment.metric</span> <span class="k">import</span> <span class="n">ResampleFeature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.segment.metric</span> <span class="k">import</span> <span class="n">AveragePointwiseEuclideanMetric</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feature</span> <span class="o">=</span> <span class="n">ResampleFeature</span><span class="p">(</span><span class="n">nb_points</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metric</span> <span class="o">=</span> <span class="n">AveragePointwiseEuclideanMetric</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qb</span> <span class="o">=</span> <span class="n">QuickBundles</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">streamlines</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">clusters</span><span class="p">))</span>
<span class="go">[58, 142, 72, 28]</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.QuickBundles.cluster" title="dipy.segment.clustering.QuickBundles.cluster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cluster</span></code></a>(streamlines[, ordering])</p></td>
<td><p>Clusters <cite>streamlines</cite> into bundles.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.QuickBundles.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">threshold</em>, <em class="sig-param">metric='MDF_12points'</em>, <em class="sig-param">max_nb_clusters=2147483647</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.QuickBundles.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.QuickBundles.cluster">
<code class="sig-name descname">cluster</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">ordering=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.QuickBundles.cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters <cite>streamlines</cite> into bundles.</p>
<p>Performs quickbundles algorithm using predefined metric and threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">list of 2D arrays</span></dt><dd><p>Each 2D array represents a sequence of 3D points (points, 3).</p>
</dd>
<dt><strong>ordering</strong><span class="classifier">iterable of indices</span></dt><dd><p>Specifies the order in which data points will be clustered.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>`ClusterMapCentroid` object</strong></dt><dd><p>Result of the clustering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="quickbundlesx">
<h3><a class="reference internal" href="#dipy.segment.clustering.QuickBundlesX" title="dipy.segment.clustering.QuickBundlesX"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuickBundlesX</span></code></a><a class="headerlink" href="#quickbundlesx" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.QuickBundlesX">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">QuickBundlesX</code><span class="sig-paren">(</span><em class="sig-param">thresholds</em>, <em class="sig-param">metric='MDF_12points'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.QuickBundlesX" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.segment.clustering.Clustering" title="dipy.segment.clustering.Clustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.clustering.Clustering</span></code></a></p>
<p>Clusters streamlines using QuickBundlesX.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>thresholds</strong><span class="classifier">list of float</span></dt><dd><p>Thresholds to use for each clustering layer. A threshold represents the
maximum distance from a cluster for a streamline to be still considered
as part of it.</p>
</dd>
<dt><strong>metric</strong><span class="classifier">str or <cite>Metric</cite> object (optional)</span></dt><dd><p>The distance metric to use when comparing two streamlines. By default,
the Minimum average Direct-Flip (MDF) distance <a class="reference internal" href="#r88276b257c2b-garyfallidis12" id="id24">[Garyfallidis12]</a> is
used and streamlines are automatically resampled so they have 12
points.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r88276b257c2b-garyfallidis12"><span class="brackets">Garyfallidis12</span><span class="fn-backref">(<a href="#id24">1</a>,<a href="#id25">2</a>)</span></dt>
<dd><p>Garyfallidis E. et al., QuickBundles a method for
tractography simplification, Frontiers in Neuroscience,
vol 6, no 175, 2012.</p>
</dd>
<dt class="label" id="r88276b257c2b-garyfallidis16"><span class="brackets"><a class="fn-backref" href="#id26">Garyfallidis16</a></span></dt>
<dd><p>Garyfallidis E. et al. QuickBundlesX: Sequential
clustering of millions of streamlines in multiple
levels of detail at record execution time. Proceedings
of the, International Society of Magnetic Resonance
in Medicine (ISMRM). Singapore, 4187, 2016.</p>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.clustering.QuickBundlesX.cluster" title="dipy.segment.clustering.QuickBundlesX.cluster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cluster</span></code></a>(streamlines[, ordering])</p></td>
<td><p>Clusters <cite>streamlines</cite> into bundles.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.QuickBundlesX.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">thresholds</em>, <em class="sig-param">metric='MDF_12points'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.QuickBundlesX.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.QuickBundlesX.cluster">
<code class="sig-name descname">cluster</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">ordering=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.QuickBundlesX.cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters <cite>streamlines</cite> into bundles.</p>
<p>Performs QuickbundleX using a predefined metric and thresholds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">list of 2D arrays</span></dt><dd><p>Each 2D array represents a sequence of 3D points (points, 3).</p>
</dd>
<dt><strong>ordering</strong><span class="classifier">iterable of indices</span></dt><dd><p>Specifies the order in which data points will be clustered.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>`TreeClusterMap` object</strong></dt><dd><p>Result of the clustering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="resamplefeature">
<h3><a class="reference internal" href="#dipy.segment.clustering.ResampleFeature" title="dipy.segment.clustering.ResampleFeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResampleFeature</span></code></a><a class="headerlink" href="#resamplefeature" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.ResampleFeature">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">ResampleFeature</code><a class="headerlink" href="#dipy.segment.clustering.ResampleFeature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.featurespeed.CythonFeature</span></code></p>
<p>Extracts features from a sequential datum.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<p>The features being extracted are the points of the sequence once resampled.
This is useful for metrics requiring a constant number of points for all</p>
<blockquote>
<div><p>streamlines.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this feature invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_shape</span></code></p></td>
<td><p>Infers the shape of features extracted from a sequential datum.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.ResampleFeature.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.ResampleFeature.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="treecluster">
<h3><a class="reference internal" href="#dipy.segment.clustering.TreeCluster" title="dipy.segment.clustering.TreeCluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeCluster</span></code></a><a class="headerlink" href="#treecluster" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.TreeCluster">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">TreeCluster</code><span class="sig-paren">(</span><em class="sig-param">threshold</em>, <em class="sig-param">centroid</em>, <em class="sig-param">indices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.TreeCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.segment.clustering.ClusterCentroid" title="dipy.segment.clustering.ClusterCentroid"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.clustering.ClusterCentroid</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>is_leaf</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">assign</span></code>(id_datum, features)</p></td>
<td><p>Assigns a data point to this cluster.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code>()</p></td>
<td><p>Update centroid of this cluster.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>add</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.TreeCluster.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">threshold</em>, <em class="sig-param">centroid</em>, <em class="sig-param">indices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.TreeCluster.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.TreeCluster.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">child</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.TreeCluster.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.TreeCluster.is_leaf">
<em class="property">property </em><code class="sig-name descname">is_leaf</code><a class="headerlink" href="#dipy.segment.clustering.TreeCluster.is_leaf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="treeclustermap">
<h3><a class="reference internal" href="#dipy.segment.clustering.TreeClusterMap" title="dipy.segment.clustering.TreeClusterMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeClusterMap</span></code></a><a class="headerlink" href="#treeclustermap" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.clustering.TreeClusterMap">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">TreeClusterMap</code><span class="sig-paren">(</span><em class="sig-param">root</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.TreeClusterMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.segment.clustering.ClusterMap" title="dipy.segment.clustering.ClusterMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.clustering.ClusterMap</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clusters</strong></dt><dd></dd>
<dt><strong>refdata</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_cluster</span></code>(*clusters)</p></td>
<td><p>Adds one or multiple clusters to this cluster map.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</p></td>
<td><p>Remove all clusters from this cluster map.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clusters_sizes</span></code>()</p></td>
<td><p>Gets the size of every cluster contained in this cluster map.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_large_clusters</span></code>(min_size)</p></td>
<td><p>Gets clusters which contains at least <cite>min_size</cite> elements.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_small_clusters</span></code>(max_size)</p></td>
<td><p>Gets clusters which contains at most <cite>max_size</cite> elements.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_cluster</span></code>(*clusters)</p></td>
<td><p>Remove one or multiple clusters from this cluster map.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code>()</p></td>
<td><p>Gets number of clusters contained in this cluster map.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 69%" />
<col style="width: 31%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>get_clusters</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>iter_preorder</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>traverse_postorder</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.clustering.TreeClusterMap.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">root</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.TreeClusterMap.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.TreeClusterMap.get_clusters">
<code class="sig-name descname">get_clusters</code><span class="sig-paren">(</span><em class="sig-param">wanted_level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.TreeClusterMap.get_clusters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.TreeClusterMap.iter_preorder">
<code class="sig-name descname">iter_preorder</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.TreeClusterMap.iter_preorder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.TreeClusterMap.refdata">
<em class="property">property </em><code class="sig-name descname">refdata</code><a class="headerlink" href="#dipy.segment.clustering.TreeClusterMap.refdata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.segment.clustering.TreeClusterMap.traverse_postorder">
<code class="sig-name descname">traverse_postorder</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">visit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.TreeClusterMap.traverse_postorder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="abstractmethod">
<h3>abstractmethod<a class="headerlink" href="#abstractmethod" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.clustering.abstractmethod">
<code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">abstractmethod</code><span class="sig-paren">(</span><em class="sig-param">funcobj</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.abstractmethod" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator indicating abstract methods.</p>
<p>Requires that the metaclass is ABCMeta or derived from it.  A
class that has a metaclass derived from ABCMeta cannot be
instantiated unless all of its abstract methods are overridden.
The abstract methods can be called using any of the normal
‘super’ call mechanisms.</p>
<p>Usage:</p>
<blockquote>
<div><dl>
<dt>class C(metaclass=ABCMeta):</dt><dd><p>&#64;abstractmethod
def my_abstract_method(self, …):</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="id27">
<h3>nbytes<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.clustering.nbytes">
<code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">nbytes</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.nbytes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id28">
<h3>qbx_and_merge<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.clustering.qbx_and_merge">
<code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">qbx_and_merge</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">thresholds</em>, <em class="sig-param">nb_pts=20</em>, <em class="sig-param">select_randomly=None</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.qbx_and_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Run QuickBundlesX and then run again on the centroids of the last layer</p>
<p>Running again QuickBundles at a layer has the effect of merging
some of the clusters that maybe originally devided because of branching.
This function help obtain a result at a QuickBundles quality but with
QuickBundlesX speed. The merging phase has low cost because it is applied
only on the centroids rather than the entire dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>thresholds</strong><span class="classifier">sequence</span></dt><dd><p>List of distance thresholds for QuickBundlesX.</p>
</dd>
<dt><strong>nb_pts</strong><span class="classifier">int</span></dt><dd><p>Number of points for discretizing each streamline</p>
</dd>
<dt><strong>select_randomly</strong><span class="classifier">int</span></dt><dd><p>Randomly select a specific number of streamlines. If None all the
streamlines are used.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState</span></dt><dd><p>If None then RandomState is initialized internally.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True print information in stdout.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clusters</strong><span class="classifier">obj</span></dt><dd><p>Contains the clusters of the last layer of QuickBundlesX after merging.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf4116ddc3cb6-garyfallidis12"><span class="brackets"><a class="fn-backref" href="#id29">Garyfallidis12</a></span></dt>
<dd><p>Garyfallidis E. et al., QuickBundles a method for
tractography simplification, Frontiers in Neuroscience,
vol 6, no 175, 2012.</p>
</dd>
<dt class="label" id="rf4116ddc3cb6-garyfallidis16"><span class="brackets"><a class="fn-backref" href="#id30">Garyfallidis16</a></span></dt>
<dd><p>Garyfallidis E. et al. QuickBundlesX: Sequential
clustering of millions of streamlines in multiple
levels of detail at record execution time. Proceedings
of the, International Society of Magnetic Resonance
in Medicine (ISMRM). Singapore, 4187, 2016.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id31">
<h3>set_number_of_points<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.clustering.set_number_of_points">
<code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">set_number_of_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.clustering.set_number_of_points" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Change the number of points of streamlines</dt><dd><p>(either by downsampling or upsampling)</p>
</dd>
</dl>
<p>Change the number of points of streamlines in order to obtain
<cite>nb_points</cite>-1 segments of equal length. Points of streamlines will be
modified along the curve.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>If ndarray, must have shape (N,3) where N is the number of points
of the streamline.
If list, each item must be ndarray shape (Ni,3) where Ni is the number
of points of streamline i.
If <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a>, its <cite>common_shape</cite> must be 3.</p>
</dd>
<dt><strong>nb_points</strong><span class="classifier">int</span></dt><dd><p>integer representing number of points wanted along the curve.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>new_streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>Results of the downsampling or upsampling process.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.tracking.streamline</span> <span class="k">import</span> <span class="n">set_number_of_points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>One streamline, a semi-circle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modified_streamline</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamline</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">modified_streamline</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Multiple streamlines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="p">[</span><span class="n">streamline</span><span class="p">,</span> <span class="n">streamline</span><span class="p">[::</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_streamlines</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamlines</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">streamlines</span><span class="p">]</span>
<span class="go">[100, 50]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_streamlines</span><span class="p">]</span>
<span class="go">[10, 10]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id32">
<h3>time<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.clustering.time">
<code class="sig-prename descclassname">dipy.segment.clustering.</code><code class="sig-name descname">time</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; floating point number<a class="headerlink" href="#dipy.segment.clustering.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current time in seconds since the Epoch.
Fractions of a second may be present if the system clock provides them.</p>
</dd></dl>

</div>
<div class="section" id="applymask">
<h3>applymask<a class="headerlink" href="#applymask" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.applymask">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">applymask</code><span class="sig-paren">(</span><em class="sig-param">vol</em>, <em class="sig-param">mask</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.applymask" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask vol with mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vol</strong><span class="classifier">ndarray</span></dt><dd><p>Array with <span class="math notranslate nohighlight">\(V\)</span> dimensions</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>Binary mask.  Has <span class="math notranslate nohighlight">\(M\)</span> dimensions where <span class="math notranslate nohighlight">\(M &lt;= V\)</span>. When <span class="math notranslate nohighlight">\(M &lt; V\)</span>, we
append <span class="math notranslate nohighlight">\(V - M\)</span> dimensions with axis length 1 to <cite>mask</cite> so that <cite>mask</cite>
will broadcast against <cite>vol</cite>.  In the typical case <cite>vol</cite> can be 4D,
<cite>mask</cite> can be 3D, and we append a 1 to the mask shape which (via numpy
broadcasting) has the effect of appling the 3D mask to each 3D slice in
<cite>vol</cite> (<code class="docutils literal notranslate"><span class="pre">vol[...,</span> <span class="pre">0]</span></code> to <code class="docutils literal notranslate"><span class="pre">vol[...,</span> <span class="pre">-1</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>masked_vol</strong><span class="classifier">ndarray</span></dt><dd><p><cite>vol</cite> multiplied by <cite>mask</cite> where <cite>mask</cite> may have been extended to match
extra dimensions in <cite>vol</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="binary-dilation">
<h3>binary_dilation<a class="headerlink" href="#binary-dilation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.binary_dilation">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">binary_dilation</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">structure=None</em>, <em class="sig-param">iterations=1</em>, <em class="sig-param">mask=None</em>, <em class="sig-param">output=None</em>, <em class="sig-param">border_value=0</em>, <em class="sig-param">origin=0</em>, <em class="sig-param">brute_force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.binary_dilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-dimensional binary dilation with the given structuring element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input</strong><span class="classifier">array_like</span></dt><dd><p>Binary array_like to be dilated. Non-zero (True) elements form
the subset to be dilated.</p>
</dd>
<dt><strong>structure</strong><span class="classifier">array_like, optional</span></dt><dd><p>Structuring element used for the dilation. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one.</p>
</dd>
<dt><strong>iterations</strong><span class="classifier">{int, float}, optional</span></dt><dd><p>The dilation is repeated <cite>iterations</cite> times (one, by default).
If iterations is less than 1, the dilation is repeated until the
result does not change anymore.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array_like, optional</span></dt><dd><p>If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.</p>
</dd>
<dt><strong>output</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Array of the same shape as input, into which the output is placed.
By default, a new array is created.</p>
</dd>
<dt><strong>border_value</strong><span class="classifier">int (cast to 0 or 1), optional</span></dt><dd><p>Value at the border in the output array.</p>
</dd>
<dt><strong>origin</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Placement of the filter, by default 0.</p>
</dd>
<dt><strong>brute_force</strong><span class="classifier">boolean, optional</span></dt><dd><p>Memory condition: if False, only the pixels whose value was changed in
the last iteration are tracked as candidates to be updated (dilated)
in the current iteration; if True all pixels are considered as
candidates for dilation, regardless of what happened in the previous
iteration. False by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>binary_dilation</strong><span class="classifier">ndarray of bools</span></dt><dd><p>Dilation of the input by the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">grey_dilation</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_erosion</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_closing</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_opening</span></code>, <a class="reference internal" href="#dipy.segment.mask.generate_binary_structure" title="dipy.segment.mask.generate_binary_structure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Dilation <a class="reference internal" href="#rb16be6b34ad7-1" id="id33">[1]</a> is a mathematical morphology operation <a class="reference internal" href="#rb16be6b34ad7-2" id="id34">[2]</a> that uses a
structuring element for expanding the shapes in an image. The binary
dilation of an image by a structuring element is the locus of the points
covered by the structuring element, when its center lies within the
non-zero points of the image.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb16be6b34ad7-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id33">1</a>,<a href="#id35">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://en.wikipedia.org/wiki/Dilation_%28morphology%29">http://en.wikipedia.org/wiki/Dilation_%28morphology%29</a></p>
</dd>
<dt class="label" id="rb16be6b34ad7-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id34">1</a>,<a href="#id36">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://en.wikipedia.org/wiki/Mathematical_morphology">http://en.wikipedia.org/wiki/Mathematical_morphology</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False],</span>
<span class="go">       [False, False,  True, False, False],</span>
<span class="go">       [False,  True,  True,  True, False],</span>
<span class="go">       [False, False,  True, False, False],</span>
<span class="go">       [False, False, False, False, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 3x3 structuring element with connectivity 1, used by default</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct1</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct1</span>
<span class="go">array([[False,  True, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [False,  True, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 3x3 structuring element with connectivity 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct2</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct2</span>
<span class="go">array([[ True,  True,  True],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [ True,  True,  True]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct1</span><span class="p">,</span>\
<span class="gp">... </span><span class="n">iterations</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="bounding-box">
<h3>bounding_box<a class="headerlink" href="#bounding-box" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.bounding_box">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">bounding_box</code><span class="sig-paren">(</span><em class="sig-param">vol</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bounding box of nonzero intensity voxels in the volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vol</strong><span class="classifier">ndarray</span></dt><dd><p>Volume to compute bounding box on.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>npmins</strong><span class="classifier">list</span></dt><dd><p>Array containg minimum index of each dimension</p>
</dd>
<dt><strong>npmaxs</strong><span class="classifier">list</span></dt><dd><p>Array containg maximum index of each dimension</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="clean-cc-mask">
<h3>clean_cc_mask<a class="headerlink" href="#clean-cc-mask" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.clean_cc_mask">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">clean_cc_mask</code><span class="sig-paren">(</span><em class="sig-param">mask</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.clean_cc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleans a segmentation of the corpus callosum so no random pixels
are included.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>Binary mask of the coarse segmentation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_cc_mask</strong><span class="classifier">ndarray</span></dt><dd><p>Binary mask of the cleaned segmentation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="color-fa">
<h3>color_fa<a class="headerlink" href="#color-fa" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.color_fa">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">color_fa</code><span class="sig-paren">(</span><em class="sig-param">fa</em>, <em class="sig-param">evecs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.color_fa" title="Permalink to this definition">¶</a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>fa</strong><span class="classifier">array-like</span></dt><dd><blockquote>
<div><p>Array of the fractional anisotropy (can be 1D, 2D or 3D)</p>
</div></blockquote>
<dl class="simple">
<dt>evecs<span class="classifier">array-like</span></dt><dd><p>eigen vectors from the tensor model</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">Array with 3 channels for each color as the last dimension.</span></dt><dd><p>Colormap of the FA with red for the x value, y for the green
value and z for the blue value.</p>
</dd>
</dl>
</dd>
</dl>
<p>ec{e}))  imes fa</p>
</dd></dl>

</div>
<div class="section" id="crop">
<h3>crop<a class="headerlink" href="#crop" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.crop">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">crop</code><span class="sig-paren">(</span><em class="sig-param">vol</em>, <em class="sig-param">mins</em>, <em class="sig-param">maxs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crops the input volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vol</strong><span class="classifier">ndarray</span></dt><dd><p>Volume to crop.</p>
</dd>
<dt><strong>mins</strong><span class="classifier">array</span></dt><dd><p>Array containg minimum index of each dimension.</p>
</dd>
<dt><strong>maxs</strong><span class="classifier">array</span></dt><dd><p>Array containg maximum index of each dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vol</strong><span class="classifier">ndarray</span></dt><dd><p>The cropped volume.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="fractional-anisotropy">
<h3>fractional_anisotropy<a class="headerlink" href="#fractional-anisotropy" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.fractional_anisotropy">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">fractional_anisotropy</code><span class="sig-paren">(</span><em class="sig-param">evals</em>, <em class="sig-param">axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.fractional_anisotropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional anisotropy (FA) of a diffusion tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fa</strong><span class="classifier">array</span></dt><dd><p>Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>FA is calculated using the following equation:</p>
<div class="math notranslate nohighlight">
\[FA = \sqrt{\frac{1}{2}\frac{(\lambda_1-\lambda_2)^2+(\lambda_1-
            \lambda_3)^2+(\lambda_2-\lambda_3)^2}{\lambda_1^2+
            \lambda_2^2+\lambda_3^2}}\]</div>
</dd></dl>

</div>
<div class="section" id="generate-binary-structure">
<h3>generate_binary_structure<a class="headerlink" href="#generate-binary-structure" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.generate_binary_structure">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">generate_binary_structure</code><span class="sig-paren">(</span><em class="sig-param">rank</em>, <em class="sig-param">connectivity</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.generate_binary_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a binary structure for binary morphological operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>Number of dimensions of the array to which the structuring element
will be applied, as returned by <cite>np.ndim</cite>.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int</span></dt><dd><p><cite>connectivity</cite> determines which elements of the output array belong
to the structure, i.e. are considered as neighbors of the central
element. Elements up to a squared distance of <cite>connectivity</cite> from
the center are considered neighbors. <cite>connectivity</cite> may range from 1
(no diagonal elements are neighbors) to <cite>rank</cite> (all elements are
neighbors).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray of bools</span></dt><dd><p>Structuring element which may be used for binary morphological
operations, with <cite>rank</cite> dimensions and all dimensions equal to 3.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">iterate_structure</span></code>, <a class="reference internal" href="#dipy.segment.mask.binary_dilation" title="dipy.segment.mask.binary_dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_dilation</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_erosion</span></code></p>
</div>
<p class="rubric">Notes</p>
<p><cite>generate_binary_structure</cite> can only create structuring elements with
dimensions equal to 3, i.e. minimal dimensions. For larger structuring
elements, that are useful e.g. for eroding large objects, one may either
use   <cite>iterate_structure</cite>, or create directly custom arrays with
numpy functions such as <cite>numpy.ones</cite>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span>
<span class="go">array([[False,  True, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [False,  True, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="go">       [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span>
<span class="go">array([[ True,  True,  True],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [ True,  True,  True]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span> <span class="c1"># no diagonal elements</span>
<span class="go">array([[[False, False, False],</span>
<span class="go">        [False,  True, False],</span>
<span class="go">        [False, False, False]],</span>
<span class="go">       [[False,  True, False],</span>
<span class="go">        [ True,  True,  True],</span>
<span class="go">        [False,  True, False]],</span>
<span class="go">       [[False, False, False],</span>
<span class="go">        [False,  True, False],</span>
<span class="go">        [False, False, False]]], dtype=bool)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="median-filter">
<h3>median_filter<a class="headerlink" href="#median-filter" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.median_filter">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">median_filter</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">size=None</em>, <em class="sig-param">footprint=None</em>, <em class="sig-param">output=None</em>, <em class="sig-param">mode='reflect'</em>, <em class="sig-param">cval=0.0</em>, <em class="sig-param">origin=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.median_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a multidimensional median filter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>input</strong><span class="classifier">array_like</span></dt><dd><p>The input array.</p>
</dd>
<dt><strong>size</strong><span class="classifier">scalar or tuple, optional</span></dt><dd><p>See footprint, below. Ignored if footprint is given.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">array, optional</span></dt><dd><p>Either <cite>size</cite> or <cite>footprint</cite> must be defined.  <cite>size</cite> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<cite>footprint</cite> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code class="docutils literal notranslate"><span class="pre">size=(n,m)</span></code> is equivalent
to <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((n,m))</span></code>.  We adjust <cite>size</cite> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <cite>size</cite> is 2, then the actual size used is
(2,2,2). When <cite>footprint</cite> is given, <cite>size</cite> is ignored.</p>
</dd>
<dt><strong>output</strong><span class="classifier">array or dtype, optional</span></dt><dd><p>The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or sequence, optional</span></dt><dd><p>The <cite>mode</cite> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
‘reflect’. The valid values and their behavior is as follows:</p>
<dl class="simple">
<dt>‘reflect’ (<cite>d c b a | a b c d | d c b a</cite>)</dt><dd><p>The input is extended by reflecting about the edge of the last
pixel.</p>
</dd>
<dt>‘constant’ (<cite>k k k k | a b c d | k k k k</cite>)</dt><dd><p>The input is extended by filling all values beyond the edge with
the same constant value, defined by the <cite>cval</cite> parameter.</p>
</dd>
<dt>‘nearest’ (<cite>a a a a | a b c d | d d d d</cite>)</dt><dd><p>The input is extended by replicating the last pixel.</p>
</dd>
<dt>‘mirror’ (<cite>d c b | a b c d | c b a</cite>)</dt><dd><p>The input is extended by reflecting about the center of the last
pixel.</p>
</dd>
<dt>‘wrap’ (<cite>a b c d | a b c d | a b c d</cite>)</dt><dd><p>The input is extended by wrapping around to the opposite edge.</p>
</dd>
</dl>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <cite>mode</cite> is ‘constant’. Default
is 0.0.</p>
</dd>
<dt><strong>origin</strong><span class="classifier">int or sequence, optional</span></dt><dd><p>Controls the placement of the filter on the input array’s pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>median_filter</strong><span class="classifier">ndarray</span></dt><dd><p>Filtered array. Has the same shape as <cite>input</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">misc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>  <span class="c1"># show the filtered result in grayscale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>  <span class="c1"># left side</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>  <span class="c1"># right side</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ascent</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">median_filter</span><span class="p">(</span><span class="n">ascent</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">ascent</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="median-otsu">
<h3>median_otsu<a class="headerlink" href="#median-otsu" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.median_otsu">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">median_otsu</code><span class="sig-paren">(</span><em class="sig-param">input_volume</em>, <em class="sig-param">vol_idx=None</em>, <em class="sig-param">median_radius=4</em>, <em class="sig-param">numpass=4</em>, <em class="sig-param">autocrop=False</em>, <em class="sig-param">dilate=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.median_otsu" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple brain extraction tool method for images from DWI data.</p>
<p>It uses a median filter smoothing of the input_volumes <cite>vol_idx</cite> and an
automatic histogram Otsu thresholding technique, hence the name
<em>median_otsu</em>.</p>
<p>This function is inspired from Mrtrix’s bet which has default values
<code class="docutils literal notranslate"><span class="pre">median_radius=3</span></code>, <code class="docutils literal notranslate"><span class="pre">numpass=2</span></code>. However, from tests on multiple 1.5T
and 3T data     from GE, Philips, Siemens, the most robust choice is
<code class="docutils literal notranslate"><span class="pre">median_radius=4</span></code>, <code class="docutils literal notranslate"><span class="pre">numpass=4</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_volume</strong><span class="classifier">ndarray</span></dt><dd><p>3D or 4D array of the brain volume.</p>
</dd>
<dt><strong>vol_idx</strong><span class="classifier">None or array, optional.</span></dt><dd><p>1D array representing indices of <code class="docutils literal notranslate"><span class="pre">axis=3</span></code> of a 4D <cite>input_volume</cite>.
None is only an acceptable input if <code class="docutils literal notranslate"><span class="pre">input_volume</span></code> is 3D.</p>
</dd>
<dt><strong>median_radius</strong><span class="classifier">int</span></dt><dd><p>Radius (in voxels) of the applied median filter (default: 4).</p>
</dd>
<dt><strong>numpass: int</strong></dt><dd><p>Number of pass of the median filter (default: 4).</p>
</dd>
<dt><strong>autocrop: bool, optional</strong></dt><dd><p>if True, the masked input_volume will also be cropped using the
bounding box defined by the masked data. Should be on if DWI is
upsampled to 1x1x1 resolution. (default: False).</p>
</dd>
<dt><strong>dilate</strong><span class="classifier">None or int, optional</span></dt><dd><p>number of iterations for binary dilation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>maskedvolume</strong><span class="classifier">ndarray</span></dt><dd><p>Masked input_volume</p>
</dd>
<dt><strong>mask</strong><span class="classifier">3D ndarray</span></dt><dd><p>The binary brain mask</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Copyright (C) 2011, the scikit-image team
All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.</p></li>
<li><p>Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in
the documentation and/or other materials provided with the
distribution.</p></li>
<li><p>Neither the name of skimage nor the names of its contributors may be
used to endorse or promote products derived from this software without
specific prior written permission.</p></li>
</ol>
</div></blockquote>
<p>THIS SOFTWARE IS PROVIDED BY THE AUTHOR <a href="#id37"><span class="problematic" id="id38">``</span></a>AS IS’’ AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.</p>
</dd></dl>

</div>
<div class="section" id="multi-median">
<h3>multi_median<a class="headerlink" href="#multi-median" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.multi_median">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">multi_median</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">median_radius</em>, <em class="sig-param">numpass</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.multi_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies median filter multiple times on input data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input</strong><span class="classifier">ndarray</span></dt><dd><p>The input volume to apply filter on.</p>
</dd>
<dt><strong>median_radius</strong><span class="classifier">int</span></dt><dd><p>Radius (in voxels) of the applied median filter</p>
</dd>
<dt><strong>numpass: int</strong></dt><dd><p>Number of pass of the median filter</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>input</strong><span class="classifier">ndarray</span></dt><dd><p>Filtered input volume.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="otsu">
<h3>otsu<a class="headerlink" href="#otsu" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.otsu">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">otsu</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">nbins=256</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.otsu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return threshold value based on Otsu’s method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>image</cite> only contains a single grayscale value.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The input image must be grayscale.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5dc2cb558a94-1"><span class="brackets"><a class="fn-backref" href="#id39">1</a></span></dt>
<dd><p>Wikipedia, <a class="reference external" href="https://en.wikipedia.org/wiki/Otsu's_Method">https://en.wikipedia.org/wiki/Otsu’s_Method</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="k">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_otsu</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&lt;=</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="segment-from-cfa">
<h3>segment_from_cfa<a class="headerlink" href="#segment-from-cfa" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.segment_from_cfa">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">segment_from_cfa</code><span class="sig-paren">(</span><em class="sig-param">tensor_fit</em>, <em class="sig-param">roi</em>, <em class="sig-param">threshold</em>, <em class="sig-param">return_cfa=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.segment_from_cfa" title="Permalink to this definition">¶</a></dt>
<dd><p>Segment the cfa inside roi using the values from threshold as bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor_fit</strong><span class="classifier">TensorFit object</span></dt><dd><p>TensorFit object</p>
</dd>
<dt><strong>roi</strong><span class="classifier">ndarray</span></dt><dd><p>A binary mask, which contains the bounding box for the segmentation.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">array-like</span></dt><dd><p>An iterable that defines the min and max values to use for the
thresholding.
The values are specified as (R_min, R_max, G_min, G_max, B_min, B_max)</p>
</dd>
<dt><strong>return_cfa</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the cfa is also returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>Binary mask of the segmentation.</p>
</dd>
<dt><strong>cfa</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Array with shape = (…, 3), where … is the shape of tensor_fit.
The color fractional anisotropy, ordered as a nd array with the last
dimension of size 3 for the R, G and B channels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="warn">
<h3>warn<a class="headerlink" href="#warn" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.mask.warn">
<code class="sig-prename descclassname">dipy.segment.mask.</code><code class="sig-name descname">warn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.mask.warn" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
<div class="section" id="arclengthfeature">
<h3><a class="reference internal" href="#dipy.segment.metric.ArcLengthFeature" title="dipy.segment.metric.ArcLengthFeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArcLengthFeature</span></code></a><a class="headerlink" href="#arclengthfeature" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.ArcLengthFeature">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">ArcLengthFeature</code><a class="headerlink" href="#dipy.segment.metric.ArcLengthFeature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.featurespeed.CythonFeature</span></code></p>
<p>Extracts features from a sequential datum.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<p>The feature being extracted consists of one scalar representing
the arc length of the sequence (i.e. the sum of the length of all segments).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this feature invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_shape</span></code></p></td>
<td><p>Infers the shape of features extracted from a sequential datum.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.ArcLengthFeature.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.ArcLengthFeature.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id40">
<h3><a class="reference internal" href="#dipy.segment.metric.AveragePointwiseEuclideanMetric" title="dipy.segment.metric.AveragePointwiseEuclideanMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragePointwiseEuclideanMetric</span></code></a><a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.AveragePointwiseEuclideanMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">AveragePointwiseEuclideanMetric</code><a class="headerlink" href="#dipy.segment.metric.AveragePointwiseEuclideanMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.SumPointwiseEuclideanMetric</span></code></p>
<p>Computes the average of pointwise Euclidean distances between two
sequential data.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions). A <cite>feature</cite> object can be specified
in order to calculate the distance between the features, rather than
directly between the sequential data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>feature</strong><span class="classifier"><cite>Feature</cite> object, optional</span></dt><dd><p>It is used to extract features before computing the distance.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The distance between two 2D sequential data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s1</span>       <span class="n">s2</span>

<span class="mi">0</span><span class="o">*</span>   <span class="n">a</span>    <span class="o">*</span><span class="mi">0</span>
  \       <span class="o">|</span>
   \      <span class="o">|</span>
   <span class="mi">1</span><span class="o">*</span>     <span class="o">|</span>
    <span class="o">|</span>  <span class="n">b</span>  <span class="o">*</span><span class="mi">1</span>
    <span class="o">|</span>      \
    <span class="mi">2</span><span class="o">*</span>      \
        <span class="n">c</span>    <span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p>is equal to <span class="math notranslate nohighlight">\((a+b+c)/3\)</span> where <span class="math notranslate nohighlight">\(a\)</span> is the Euclidean distance between s1[0] and
s2[0], <span class="math notranslate nohighlight">\(b\)</span> between s1[1] and s2[1] and <span class="math notranslate nohighlight">\(c\)</span> between s1[2] and s2[2].</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.AveragePointwiseEuclideanMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.AveragePointwiseEuclideanMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="centerofmassfeature">
<h3><a class="reference internal" href="#dipy.segment.metric.CenterOfMassFeature" title="dipy.segment.metric.CenterOfMassFeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">CenterOfMassFeature</span></code></a><a class="headerlink" href="#centerofmassfeature" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.CenterOfMassFeature">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">CenterOfMassFeature</code><a class="headerlink" href="#dipy.segment.metric.CenterOfMassFeature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.featurespeed.CythonFeature</span></code></p>
<p>Extracts features from a sequential datum.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<p>The feature being extracted consists of one N-dimensional point representing
the mean of the points, i.e. the center of mass.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this feature invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_shape</span></code></p></td>
<td><p>Infers the shape of features extracted from a sequential datum.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.CenterOfMassFeature.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.CenterOfMassFeature.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="cosinemetric">
<h3><a class="reference internal" href="#dipy.segment.metric.CosineMetric" title="dipy.segment.metric.CosineMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">CosineMetric</span></code></a><a class="headerlink" href="#cosinemetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.CosineMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">CosineMetric</code><a class="headerlink" href="#dipy.segment.metric.CosineMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.CythonMetric</span></code></p>
<p>Computes the cosine distance between two vectors.</p>
<p>A vector (i.e. a N-dimensional point) is represented as a 2D array with
shape (1, nb_dimensions).</p>
<p class="rubric">Notes</p>
<p>The distance between two vectors <span class="math notranslate nohighlight">\(v_1\)</span> and <span class="math notranslate nohighlight">\(v_2\)</span> is equal to
<span class="math notranslate nohighlight">\(\frac{1}{\pi} \arccos\left(\frac{v_1 \cdot v_2}{\|v_1\| \|v_2\|}\right)\)</span>
and is bounded within <span class="math notranslate nohighlight">\([0,1]\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.CosineMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.CosineMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="euclideanmetric">
<h3><a class="reference internal" href="#dipy.segment.metric.EuclideanMetric" title="dipy.segment.metric.EuclideanMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanMetric</span></code></a><a class="headerlink" href="#euclideanmetric" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.segment.metric.EuclideanMetric">
<code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">EuclideanMetric</code><a class="headerlink" href="#dipy.segment.metric.EuclideanMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.SumPointwiseEuclideanMetric</span></code></p>
</dd></dl>

</div>
<div class="section" id="feature">
<h3><a class="reference internal" href="#dipy.segment.metric.Feature" title="dipy.segment.metric.Feature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Feature</span></code></a><a class="headerlink" href="#feature" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.Feature">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">Feature</code><a class="headerlink" href="#dipy.segment.metric.Feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Extracts features from a sequential datum.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>is_order_invariant</strong><span class="classifier">bool (optional)</span></dt><dd><p>tells if this feature is invariant to the sequence’s ordering. This
means starting from either extremities produces the same features.
(Default: True)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When subclassing <cite>Feature</cite>, one only needs to override the <cite>extract</cite> and
<cite>infer_shape</cite> methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#dipy.segment.metric.Feature.is_order_invariant" title="dipy.segment.metric.Feature.is_order_invariant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></a></dt><dd><p>Is this feature invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.Feature.extract" title="dipy.segment.metric.Feature.extract"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></a></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.Feature.infer_shape" title="dipy.segment.metric.Feature.infer_shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_shape</span></code></a></p></td>
<td><p>Infers the shape of features extracted from a sequential datum.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.Feature.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.Feature.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.metric.Feature.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.Feature.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts features from a sequential datum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>datum</strong><span class="classifier">2D array</span></dt><dd><p>Sequence of N-dimensional points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>2D array</strong></dt><dd><p>Features extracted from <cite>datum</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.metric.Feature.infer_shape">
<code class="sig-name descname">infer_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.Feature.infer_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers the shape of features extracted from a sequential datum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>datum</strong><span class="classifier">2D array</span></dt><dd><p>Sequence of N-dimensional points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>int, 1-tuple or 2-tuple</strong></dt><dd><p>Shape of the features.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.metric.Feature.is_order_invariant">
<code class="sig-name descname">is_order_invariant</code><a class="headerlink" href="#dipy.segment.metric.Feature.is_order_invariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this feature invariant to the sequence’s ordering</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="identityfeature">
<h3><a class="reference internal" href="#dipy.segment.metric.IdentityFeature" title="dipy.segment.metric.IdentityFeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">IdentityFeature</span></code></a><a class="headerlink" href="#identityfeature" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.IdentityFeature">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">IdentityFeature</code><a class="headerlink" href="#dipy.segment.metric.IdentityFeature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.featurespeed.CythonFeature</span></code></p>
<p>Extracts features from a sequential datum.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<p>The features being extracted are the actual sequence’s points. This is
useful for metric that does not require any pre-processing.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this feature invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_shape</span></code></p></td>
<td><p>Infers the shape of features extracted from a sequential datum.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.IdentityFeature.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.IdentityFeature.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id41">
<h3><a class="reference internal" href="#dipy.segment.metric.Metric" title="dipy.segment.metric.Metric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Metric</span></code></a><a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.Metric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">Metric</code><a class="headerlink" href="#dipy.segment.metric.Metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Computes a distance between two sequential data.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions). A <cite>feature</cite> object can be specified
in order to calculate the distance between extracted features, rather
than directly between the sequential data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>feature</strong><span class="classifier"><cite>Feature</cite> object, optional</span></dt><dd><p>It is used to extract features before computing the distance.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When subclassing <cite>Metric</cite>, one only needs to override the <cite>dist</cite> and
<cite>are_compatible</cite> methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#dipy.segment.metric.Metric.feature" title="dipy.segment.metric.Metric.feature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></a></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><a class="reference internal" href="#dipy.segment.metric.Metric.is_order_invariant" title="dipy.segment.metric.Metric.is_order_invariant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></a></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.metric.Metric.are_compatible" title="dipy.segment.metric.Metric.are_compatible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></a></p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.metric.Metric.dist" title="dipy.segment.metric.Metric.dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></a></p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.Metric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.Metric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.metric.Metric.are_compatible">
<code class="sig-name descname">are_compatible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.Metric.are_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p>
<p>Basically this method exists so we don’t have to do this check
inside the <cite>metric.dist</cite> function (speedup).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape1</strong><span class="classifier">int, 1-tuple or 2-tuple</span></dt><dd><p>shape of the first data point’s features</p>
</dd>
<dt><strong>shape2</strong><span class="classifier">int, 1-tuple or 2-tuple</span></dt><dd><p>shape of the second data point’s features</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>are_compatible</strong><span class="classifier">bool</span></dt><dd><p>whether or not shapes are compatible</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.metric.Metric.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.Metric.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a distance between two data points based on their features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>features1</strong><span class="classifier">2D array</span></dt><dd><p>Features of the first data point.</p>
</dd>
<dt><strong>features2</strong><span class="classifier">2D array</span></dt><dd><p>Features of the second data point.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>double</strong></dt><dd><p>Distance between two data points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.metric.Metric.feature">
<code class="sig-name descname">feature</code><a class="headerlink" href="#dipy.segment.metric.Metric.feature" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.metric.Metric.is_order_invariant">
<code class="sig-name descname">is_order_invariant</code><a class="headerlink" href="#dipy.segment.metric.Metric.is_order_invariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="midpointfeature">
<h3><a class="reference internal" href="#dipy.segment.metric.MidpointFeature" title="dipy.segment.metric.MidpointFeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">MidpointFeature</span></code></a><a class="headerlink" href="#midpointfeature" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.MidpointFeature">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">MidpointFeature</code><a class="headerlink" href="#dipy.segment.metric.MidpointFeature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.featurespeed.CythonFeature</span></code></p>
<p>Extracts features from a sequential datum.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<p>The feature being extracted consists of one N-dimensional point representing
the middle point of the sequence (i.e. <a href="#id42"><span class="problematic" id="id43">`</span></a>nb_points//2`th point).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this feature invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_shape</span></code></p></td>
<td><p>Infers the shape of features extracted from a sequential datum.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.MidpointFeature.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.MidpointFeature.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id44">
<h3><a class="reference internal" href="#dipy.segment.metric.MinimumAverageDirectFlipMetric" title="dipy.segment.metric.MinimumAverageDirectFlipMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimumAverageDirectFlipMetric</span></code></a><a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.MinimumAverageDirectFlipMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">MinimumAverageDirectFlipMetric</code><a class="headerlink" href="#dipy.segment.metric.MinimumAverageDirectFlipMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.AveragePointwiseEuclideanMetric</span></code></p>
<p>Computes the MDF distance (minimum average direct-flip) between two
sequential data.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<p class="rubric">Notes</p>
<p>The distance between two 2D sequential data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s1</span>       <span class="n">s2</span>

<span class="mi">0</span><span class="o">*</span>   <span class="n">a</span>    <span class="o">*</span><span class="mi">0</span>
  \       <span class="o">|</span>
   \      <span class="o">|</span>
   <span class="mi">1</span><span class="o">*</span>     <span class="o">|</span>
    <span class="o">|</span>  <span class="n">b</span>  <span class="o">*</span><span class="mi">1</span>
    <span class="o">|</span>      \
    <span class="mi">2</span><span class="o">*</span>      \
        <span class="n">c</span>    <span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p>is equal to <span class="math notranslate nohighlight">\(\min((a+b+c)/3, (a'+b'+c')/3)\)</span> where <span class="math notranslate nohighlight">\(a\)</span> is the Euclidean distance
between s1[0] and s2[0], <span class="math notranslate nohighlight">\(b\)</span> between s1[1] and s2[1], <span class="math notranslate nohighlight">\(c\)</span> between s1[2]
and s2[2], <span class="math notranslate nohighlight">\(a'\)</span> between s1[0] and s2[2], <span class="math notranslate nohighlight">\(b'\)</span> between s1[1] and s2[1]
and <span class="math notranslate nohighlight">\(c'\)</span> between s1[2] and s2[0].</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><a class="reference internal" href="#dipy.segment.metric.MinimumAverageDirectFlipMetric.is_order_invariant" title="dipy.segment.metric.MinimumAverageDirectFlipMetric.is_order_invariant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></a></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.MinimumAverageDirectFlipMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.MinimumAverageDirectFlipMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.metric.MinimumAverageDirectFlipMetric.is_order_invariant">
<code class="sig-name descname">is_order_invariant</code><a class="headerlink" href="#dipy.segment.metric.MinimumAverageDirectFlipMetric.is_order_invariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id45">
<h3><a class="reference internal" href="#dipy.segment.metric.ResampleFeature" title="dipy.segment.metric.ResampleFeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResampleFeature</span></code></a><a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.ResampleFeature">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">ResampleFeature</code><a class="headerlink" href="#dipy.segment.metric.ResampleFeature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.featurespeed.CythonFeature</span></code></p>
<p>Extracts features from a sequential datum.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<p>The features being extracted are the points of the sequence once resampled.
This is useful for metrics requiring a constant number of points for all</p>
<blockquote>
<div><p>streamlines.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this feature invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_shape</span></code></p></td>
<td><p>Infers the shape of features extracted from a sequential datum.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.ResampleFeature.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.ResampleFeature.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sumpointwiseeuclideanmetric">
<h3><a class="reference internal" href="#dipy.segment.metric.SumPointwiseEuclideanMetric" title="dipy.segment.metric.SumPointwiseEuclideanMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SumPointwiseEuclideanMetric</span></code></a><a class="headerlink" href="#sumpointwiseeuclideanmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.SumPointwiseEuclideanMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">SumPointwiseEuclideanMetric</code><a class="headerlink" href="#dipy.segment.metric.SumPointwiseEuclideanMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.CythonMetric</span></code></p>
<p>Computes the sum of pointwise Euclidean distances between two
sequential data.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions). A <cite>feature</cite> object can be specified
in order to calculate the distance between the features, rather than
directly between the sequential data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>feature</strong><span class="classifier"><cite>Feature</cite> object, optional</span></dt><dd><p>It is used to extract features before computing the distance.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The distance between two 2D sequential data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s1</span>       <span class="n">s2</span>

<span class="mi">0</span><span class="o">*</span>   <span class="n">a</span>    <span class="o">*</span><span class="mi">0</span>
  \       <span class="o">|</span>
   \      <span class="o">|</span>
   <span class="mi">1</span><span class="o">*</span>     <span class="o">|</span>
    <span class="o">|</span>  <span class="n">b</span>  <span class="o">*</span><span class="mi">1</span>
    <span class="o">|</span>      \
    <span class="mi">2</span><span class="o">*</span>      \
        <span class="n">c</span>    <span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p>is equal to <span class="math notranslate nohighlight">\(a+b+c\)</span> where <span class="math notranslate nohighlight">\(a\)</span> is the Euclidean distance between s1[0] and
s2[0], <span class="math notranslate nohighlight">\(b\)</span> between s1[1] and s2[1] and <span class="math notranslate nohighlight">\(c\)</span> between s1[2] and s2[2].</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></p></td>
<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></p></td>
<td><p>Computes a distance between two data points based on their features.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.SumPointwiseEuclideanMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.SumPointwiseEuclideanMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="vectorofendpointsfeature">
<h3><a class="reference internal" href="#dipy.segment.metric.VectorOfEndpointsFeature" title="dipy.segment.metric.VectorOfEndpointsFeature"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorOfEndpointsFeature</span></code></a><a class="headerlink" href="#vectorofendpointsfeature" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.metric.VectorOfEndpointsFeature">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">VectorOfEndpointsFeature</code><a class="headerlink" href="#dipy.segment.metric.VectorOfEndpointsFeature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.featurespeed.CythonFeature</span></code></p>
<p>Extracts features from a sequential datum.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<p>The feature being extracted consists of one vector in the N-dimensional
space pointing from one end-point of the sequence to the other
(i.e. <cite>S[-1]-S[0]</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt><dd><p>Is this feature invariant to the sequence’s ordering</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></p></td>
<td><p>Extracts features from a sequential datum.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_shape</span></code></p></td>
<td><p>Infers the shape of features extracted from a sequential datum.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.metric.VectorOfEndpointsFeature.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.VectorOfEndpointsFeature.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="dist">
<h3>dist<a class="headerlink" href="#dist" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.metric.dist">
<code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">dist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a distance between <cite>datum1</cite> and <cite>datum2</cite>.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>metric</strong><span class="classifier"><cite>Metric</cite> object</span></dt><dd><p>Tells how to compute the distance between <cite>datum1</cite> and <cite>datum2</cite>.</p>
</dd>
<dt><strong>datum1</strong><span class="classifier">2D array</span></dt><dd><p>Sequence of N-dimensional points.</p>
</dd>
<dt><strong>datum2</strong><span class="classifier">2D array</span></dt><dd><p>Sequence of N-dimensional points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>double</strong></dt><dd><p>Distance between two data points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="distance-matrix">
<h3>distance_matrix<a class="headerlink" href="#distance-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.metric.distance_matrix">
<code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">distance_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.distance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the distance matrix between two lists of sequential data.</p>
<p>The distance matrix is obtained by computing the pairwise distance of all
tuples spawn by the Cartesian product of <cite>data1</cite> with <cite>data2</cite>. If <cite>data2</cite>
is not provided, the Cartesian product of <cite>data1</cite> with itself is used
instead. A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>metric</strong><span class="classifier"><cite>Metric</cite> object</span></dt><dd><p>Tells how to compute the distance between two sequential data.</p>
</dd>
<dt><strong>data1</strong><span class="classifier">list of 2D arrays</span></dt><dd><p>List of sequences of N-dimensional points.</p>
</dd>
<dt><strong>data2</strong><span class="classifier">list of 2D arrays</span></dt><dd><p>Llist of sequences of N-dimensional points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>2D array (double)</strong></dt><dd><p>Distance matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="mdf">
<h3>mdf<a class="headerlink" href="#mdf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.metric.mdf">
<code class="sig-prename descclassname">dipy.segment.metric.</code><code class="sig-name descname">mdf</code><span class="sig-paren">(</span><em class="sig-param">s1</em>, <em class="sig-param">s2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.metric.mdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the MDF (Minimum average Direct-Flip) distance
<a class="reference internal" href="#r9ec92ef08bd1-garyfallidis12" id="id46">[Garyfallidis12]</a> between two streamlines.</p>
<p>Streamlines must have the same number of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s1</strong><span class="classifier">2D array</span></dt><dd><p>A streamline (sequence of N-dimensional points).</p>
</dd>
<dt><strong>s2</strong><span class="classifier">2D array</span></dt><dd><p>A streamline (sequence of N-dimensional points).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>double</strong></dt><dd><p>Distance between two streamlines.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9ec92ef08bd1-garyfallidis12"><span class="brackets">Garyfallidis12</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id46">2</a>,<a href="#id47">3</a>)</span></dt>
<dd><p>Garyfallidis E. et al., QuickBundles a method for
tractography simplification, Frontiers in Neuroscience,
vol 6, no 175, 2012.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id48">
<h3>otsu<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.threshold.otsu">
<code class="sig-prename descclassname">dipy.segment.threshold.</code><code class="sig-name descname">otsu</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">nbins=256</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.threshold.otsu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return threshold value based on Otsu’s method.
Copied from scikit-image to remove dependency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Threshold value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="upper-bound-by-percent">
<h3>upper_bound_by_percent<a class="headerlink" href="#upper-bound-by-percent" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.threshold.upper_bound_by_percent">
<code class="sig-prename descclassname">dipy.segment.threshold.</code><code class="sig-name descname">upper_bound_by_percent</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">percent=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.threshold.upper_bound_by_percent" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the upper bound for visualization of medical images</p>
<p>Calculate the histogram of the image and go right to left until you find
the bound that contains more than a percentage of the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd></dd>
<dt><strong>percent</strong><span class="classifier">float</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>upper_bound</strong><span class="classifier">float</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="upper-bound-by-rate">
<h3>upper_bound_by_rate<a class="headerlink" href="#upper-bound-by-rate" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.threshold.upper_bound_by_rate">
<code class="sig-prename descclassname">dipy.segment.threshold.</code><code class="sig-name descname">upper_bound_by_rate</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">rate=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.threshold.upper_bound_by_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusts upper intensity boundary using rates</p>
<p>It calculates the image intensity histogram, and based on the rate value it
decide what is the upperbound value for intensity normalization, usually
lower bound is 0. The rate is the ratio between the amount of pixels in
every bins and the bins with highest pixel amount</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">float</span></dt><dd><p>Input intensity value data</p>
</dd>
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>representing the threshold whether a spicific histogram bin that should
be count in the normalization range</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>high</strong><span class="classifier">float</span></dt><dd><p>the upper_bound value for normalization</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="constantobservationmodel">
<h3><a class="reference internal" href="#dipy.segment.tissue.ConstantObservationModel" title="dipy.segment.tissue.ConstantObservationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantObservationModel</span></code></a><a class="headerlink" href="#constantobservationmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.tissue.ConstantObservationModel">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.tissue.</code><code class="sig-name descname">ConstantObservationModel</code><a class="headerlink" href="#dipy.segment.tissue.ConstantObservationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Observation model assuming that the intensity of each class is constant.
The model parameters are the means <span class="math notranslate nohighlight">\(\mu_{k}\)</span> and variances <span class="math notranslate nohighlight">\(\sigma_{k}\)</span>
associated with each tissue class. According to this model, the observed
intensity at voxel <span class="math notranslate nohighlight">\(x\)</span> is given by <span class="math notranslate nohighlight">\(I(x) = \mu_{k} + \eta_{k}\)</span> where <span class="math notranslate nohighlight">\(k\)</span>
is the tissue class of voxel <span class="math notranslate nohighlight">\(x\)</span>, and <span class="math notranslate nohighlight">\(\eta_{k}\)</span> is a Gaussian random
variable with zero mean and variance <span class="math notranslate nohighlight">\(\sigma_{k}^{2}\)</span>. The observation
model is responsible for computing the negative log-likelihood of
observing any given intensity <span class="math notranslate nohighlight">\(z\)</span> at each voxel <span class="math notranslate nohighlight">\(x\)</span> assuming the voxel
belongs to each class <span class="math notranslate nohighlight">\(k\)</span>. It also provides a default parameter
initialization.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.tissue.ConstantObservationModel.initialize_param_uniform" title="dipy.segment.tissue.ConstantObservationModel.initialize_param_uniform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_param_uniform</span></code></a></p></td>
<td><p>Initializes the means and variances uniformly</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.tissue.ConstantObservationModel.negloglikelihood" title="dipy.segment.tissue.ConstantObservationModel.negloglikelihood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">negloglikelihood</span></code></a></p></td>
<td><p>Computes the gaussian negative log-likelihood of each class at each voxel of <cite>image</cite> assuming a gaussian distribution with means and variances given by <cite>mu</cite> and <cite>sigmasq</cite>, respectively (constant models along the full volume).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.tissue.ConstantObservationModel.prob_image" title="dipy.segment.tissue.ConstantObservationModel.prob_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prob_image</span></code></a></p></td>
<td><p>Conditional probability of the label given the image</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.tissue.ConstantObservationModel.seg_stats" title="dipy.segment.tissue.ConstantObservationModel.seg_stats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">seg_stats</span></code></a></p></td>
<td><p>Mean and standard variation for N desired  tissue classes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.tissue.ConstantObservationModel.update_param" title="dipy.segment.tissue.ConstantObservationModel.update_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_param</span></code></a></p></td>
<td><p>Updates the means and the variances in each iteration for all the labels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.tissue.ConstantObservationModel.update_param_new" title="dipy.segment.tissue.ConstantObservationModel.update_param_new"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_param_new</span></code></a></p></td>
<td><p>Updates the means and the variances in each iteration for all the labels.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.tissue.ConstantObservationModel.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.tissue.ConstantObservationModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes an instance of the ConstantObservationModel class</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.tissue.ConstantObservationModel.initialize_param_uniform">
<code class="sig-name descname">initialize_param_uniform</code><a class="headerlink" href="#dipy.segment.tissue.ConstantObservationModel.initialize_param_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the means and variances uniformly</p>
<p>The means are initialized uniformly along the dynamic range of
<cite>image</cite>. The variances are set to 1 for all classes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array,</span></dt><dd><p>3D structural image</p>
</dd>
<dt><strong>nclasses</strong><span class="classifier">int,</span></dt><dd><p>number of desired classes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">array,</span></dt><dd><p>1 x nclasses, mean for each class</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">array,</span></dt><dd><p>1 x nclasses, standard deviation for each class.
Set up to 1.0 for all classes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.tissue.ConstantObservationModel.negloglikelihood">
<code class="sig-name descname">negloglikelihood</code><a class="headerlink" href="#dipy.segment.tissue.ConstantObservationModel.negloglikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the gaussian negative log-likelihood of each class at
each voxel of <cite>image</cite> assuming a gaussian distribution with means and
variances given by <cite>mu</cite> and <cite>sigmasq</cite>, respectively (constant models
along the full volume). The negative log-likelihood will be written
in <cite>nloglike</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray,</span></dt><dd><p>3D gray scale structural image</p>
</dd>
<dt><strong>mu</strong><span class="classifier">ndarray,</span></dt><dd><p>mean of each class</p>
</dd>
<dt><strong>sigmasq</strong><span class="classifier">ndarray,</span></dt><dd><p>variance of each class</p>
</dd>
<dt><strong>nclasses</strong><span class="classifier">int</span></dt><dd><p>number of classes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nloglike</strong><span class="classifier">ndarray,</span></dt><dd><p>4D negloglikelihood for each class in each volume</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.tissue.ConstantObservationModel.prob_image">
<code class="sig-name descname">prob_image</code><a class="headerlink" href="#dipy.segment.tissue.ConstantObservationModel.prob_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditional probability of the label given the image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">ndarray,</span></dt><dd><p>3D structural gray-scale image</p>
</dd>
<dt><strong>nclasses</strong><span class="classifier">int,</span></dt><dd><p>number of tissue classes</p>
</dd>
<dt><strong>mu</strong><span class="classifier">ndarray,</span></dt><dd><p>1 x nclasses, current estimate of the mean of each tissue class</p>
</dd>
<dt><strong>sigmasq</strong><span class="classifier">ndarray,</span></dt><dd><p>1 x nclasses, current estimate of the variance of each
tissue class</p>
</dd>
<dt><strong>P_L_N</strong><span class="classifier">ndarray,</span></dt><dd><p>4D probability map of the label given the neighborhood.</p>
</dd>
<dt><strong>Previously computed by function prob_neighborhood</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>P_L_Y</strong><span class="classifier">ndarray,</span></dt><dd><p>4D probability of the label given the input image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.tissue.ConstantObservationModel.seg_stats">
<code class="sig-name descname">seg_stats</code><a class="headerlink" href="#dipy.segment.tissue.ConstantObservationModel.seg_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean and standard variation for N desired  tissue classes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_image</strong><span class="classifier">ndarray,</span></dt><dd><p>3D structural image</p>
</dd>
<dt><strong>seg_image</strong><span class="classifier">ndarray,</span></dt><dd><p>3D segmented image</p>
</dd>
<dt><strong>nclass</strong><span class="classifier">int,</span></dt><dd><p>number of classes (3 in most cases)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mu, std: ndarrays,</strong></dt><dd><p>1 x nclasses dimension
Mean and standard deviation for each class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.tissue.ConstantObservationModel.update_param">
<code class="sig-name descname">update_param</code><a class="headerlink" href="#dipy.segment.tissue.ConstantObservationModel.update_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the means and the variances in each iteration for all
the labels. This is for equations 25 and 26 of Zhang et. al.,
IEEE Trans. Med. Imag, Vol. 20, No. 1, Jan 2001.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray,</span></dt><dd><p>3D structural gray-scale image</p>
</dd>
<dt><strong>P_L_Y</strong><span class="classifier">ndarray,</span></dt><dd><p>4D probability map of the label given the input image
computed by the expectation maximization (EM) algorithm</p>
</dd>
<dt><strong>mu</strong><span class="classifier">ndarray,</span></dt><dd><p>1 x nclasses, current estimate of the mean of each tissue
class.</p>
</dd>
<dt><strong>nclasses</strong><span class="classifier">int,</span></dt><dd><p>number of tissue classes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mu_upd</strong><span class="classifier">ndarray,</span></dt><dd><p>1 x nclasses, updated mean of each tissue class</p>
</dd>
<dt><strong>var_upd</strong><span class="classifier">ndarray,</span></dt><dd><p>1 x nclasses, updated variance of each tissue class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.tissue.ConstantObservationModel.update_param_new">
<code class="sig-name descname">update_param_new</code><a class="headerlink" href="#dipy.segment.tissue.ConstantObservationModel.update_param_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the means and the variances in each iteration for all
the labels. This is for equations 25 and 26 of the Zhang et al. paper</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray,</span></dt><dd><p>3D structural gray-scale image</p>
</dd>
<dt><strong>P_L_Y</strong><span class="classifier">ndarray,</span></dt><dd><p>4D probability map of the label given the input image
computed by the expectation maximization (EM) algorithm</p>
</dd>
<dt><strong>mu</strong><span class="classifier">ndarray,</span></dt><dd><p>1 x nclasses, current estimate of the mean of each tissue
class.</p>
</dd>
<dt><strong>nclasses</strong><span class="classifier">int,</span></dt><dd><p>number of tissue classes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mu_upd</strong><span class="classifier">ndarray,</span></dt><dd><p>1 x nclasses, updated mean of each tissue class</p>
</dd>
<dt><strong>var_upd</strong><span class="classifier">ndarray,</span></dt><dd><p>1 x nclasses, updated variance of each tissue class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="iteratedconditionalmodes">
<h3><a class="reference internal" href="#dipy.segment.tissue.IteratedConditionalModes" title="dipy.segment.tissue.IteratedConditionalModes"><code class="xref py py-class docutils literal notranslate"><span class="pre">IteratedConditionalModes</span></code></a><a class="headerlink" href="#iteratedconditionalmodes" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.tissue.IteratedConditionalModes">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.tissue.</code><code class="sig-name descname">IteratedConditionalModes</code><a class="headerlink" href="#dipy.segment.tissue.IteratedConditionalModes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.tissue.IteratedConditionalModes.icm_ising" title="dipy.segment.tissue.IteratedConditionalModes.icm_ising"><code class="xref py py-obj docutils literal notranslate"><span class="pre">icm_ising</span></code></a></p></td>
<td><p>Executes one iteration of the ICM algorithm for MRF MAP estimation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.segment.tissue.IteratedConditionalModes.initialize_maximum_likelihood" title="dipy.segment.tissue.IteratedConditionalModes.initialize_maximum_likelihood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_maximum_likelihood</span></code></a></p></td>
<td><p>Initializes the segmentation of an image with given</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.tissue.IteratedConditionalModes.prob_neighborhood" title="dipy.segment.tissue.IteratedConditionalModes.prob_neighborhood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prob_neighborhood</span></code></a></p></td>
<td><p>Conditional probability of the label given the neighborhood Equation 2.18 of the Stan Z.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.tissue.IteratedConditionalModes.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.tissue.IteratedConditionalModes.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.segment.tissue.IteratedConditionalModes.icm_ising">
<code class="sig-name descname">icm_ising</code><a class="headerlink" href="#dipy.segment.tissue.IteratedConditionalModes.icm_ising" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes one iteration of the ICM algorithm for MRF MAP
estimation. The prior distribution of the MRF is a Gibbs
distribution with the Potts/Ising model with parameter <cite>beta</cite>:</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Potts_model">https://en.wikipedia.org/wiki/Potts_model</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nloglike</strong><span class="classifier">ndarray,</span></dt><dd><p>4D shape, nloglike[x,y,z,k] is the negative log likelihood
of class k at voxel (x,y,z)</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float,</span></dt><dd><p>positive scalar, it is the parameter of the Potts/Ising
model. Determines the smoothness of the output segmentation.</p>
</dd>
<dt><strong>seg</strong><span class="classifier">ndarray,</span></dt><dd><p>3D initial segmentation. This segmentation will change by one
iteration of the ICM algorithm</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_seg</strong><span class="classifier">ndarray,</span></dt><dd><p>3D final segmentation</p>
</dd>
<dt><strong>energy</strong><span class="classifier">ndarray,</span></dt><dd><p>3D final energy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.tissue.IteratedConditionalModes.initialize_maximum_likelihood">
<code class="sig-name descname">initialize_maximum_likelihood</code><a class="headerlink" href="#dipy.segment.tissue.IteratedConditionalModes.initialize_maximum_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Initializes the segmentation of an image with given</dt><dd><p>neg-loglikelihood</p>
</dd>
</dl>
<p>Initializes the segmentation of an image with neglog-likelihood field
given by <cite>nloglike</cite>. The class of each voxel is selected as the one
with the minimum neglog-likelihood (i.e. maximum-likelihood
segmentation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nloglike</strong><span class="classifier">ndarray,</span></dt><dd><p>4D shape, nloglike[x,y,z,k] is the likelihhood of class k
for voxel (x, y, z)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>seg</strong><span class="classifier">ndarray,</span></dt><dd><p>3D initial segmentation</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.segment.tissue.IteratedConditionalModes.prob_neighborhood">
<code class="sig-name descname">prob_neighborhood</code><a class="headerlink" href="#dipy.segment.tissue.IteratedConditionalModes.prob_neighborhood" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditional probability of the label given the neighborhood
Equation 2.18 of the Stan Z. Li book (Stan Z. Li, Markov Random Field
Modeling in Image Analysis, 3rd ed., Advances in Pattern Recognition
Series, Springer Verlag 2009.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seg</strong><span class="classifier">ndarray,</span></dt><dd><p>3D tissue segmentation derived from the ICM model</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float,</span></dt><dd><p>scalar that determines the importance of the neighborhood and
the spatial smoothness of the segmentation.
Usually between 0 to 0.5</p>
</dd>
<dt><strong>nclasses</strong><span class="classifier">int,</span></dt><dd><p>number of tissue classes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>PLN</strong><span class="classifier">ndarray,</span></dt><dd><p>4D probability map of the label given the neighborhood of the
voxel.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tissueclassifierhmrf">
<h3><a class="reference internal" href="#dipy.segment.tissue.TissueClassifierHMRF" title="dipy.segment.tissue.TissueClassifierHMRF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TissueClassifierHMRF</span></code></a><a class="headerlink" href="#tissueclassifierhmrf" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.segment.tissue.TissueClassifierHMRF">
<em class="property">class </em><code class="sig-prename descclassname">dipy.segment.tissue.</code><code class="sig-name descname">TissueClassifierHMRF</code><span class="sig-paren">(</span><em class="sig-param">save_history=False</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.tissue.TissueClassifierHMRF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>This class contains the methods for tissue classification using the Markov
Random Fields modeling approach</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.segment.tissue.TissueClassifierHMRF.classify" title="dipy.segment.tissue.TissueClassifierHMRF.classify"><code class="xref py py-obj docutils literal notranslate"><span class="pre">classify</span></code></a>(image, nclasses, beta[, tolerance, …])</p></td>
<td><p>This method uses the Maximum a posteriori - Markov Random Field approach for segmentation by using the Iterative Conditional Modes and Expectation Maximization to estimate the parameters.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.segment.tissue.TissueClassifierHMRF.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">save_history=False</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.tissue.TissueClassifierHMRF.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.segment.tissue.TissueClassifierHMRF.classify">
<code class="sig-name descname">classify</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">nclasses</em>, <em class="sig-param">beta</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">max_iter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.tissue.TissueClassifierHMRF.classify" title="Permalink to this definition">¶</a></dt>
<dd><p>This method uses the Maximum a posteriori - Markov Random Field
approach for segmentation by using the Iterative Conditional Modes and
Expectation Maximization to estimate the parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray,</span></dt><dd><p>3D structural image.</p>
</dd>
<dt><strong>nclasses</strong><span class="classifier">int,</span></dt><dd><p>number of desired classes.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float,</span></dt><dd><p>smoothing parameter, the higher this number the smoother the
output will be.</p>
</dd>
<dt><strong>tolerance: float,</strong></dt><dd><p>value that defines the percentage of change tolerated to
prevent the ICM loop to stop. Default is 1e-05.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">float,</span></dt><dd><p>fixed number of desired iterations. Default is 100.
If the user only specifies this parameter, the tolerance
value will not be considered. If none of these two
parameters</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>initial_segmentation</strong><span class="classifier">ndarray,</span></dt><dd><p>3D segmented image with all tissue types
specified in nclasses.</p>
</dd>
<dt><strong>final_segmentation</strong><span class="classifier">ndarray,</span></dt><dd><p>3D final refined segmentation containing all
tissue types.</p>
</dd>
<dt><strong>PVE</strong><span class="classifier">ndarray,</span></dt><dd><p>3D probability map of each tissue type.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="add-noise">
<h3>add_noise<a class="headerlink" href="#add-noise" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.segment.tissue.add_noise">
<code class="sig-prename descclassname">dipy.segment.tissue.</code><code class="sig-name descname">add_noise</code><span class="sig-paren">(</span><em class="sig-param">signal</em>, <em class="sig-param">snr</em>, <em class="sig-param">S0</em>, <em class="sig-param">noise_type='rician'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.segment.tissue.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add noise of specified distribution to the signal from a single voxel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>signal</strong><span class="classifier">1-d ndarray</span></dt><dd><p>The signal in the voxel.</p>
</dd>
<dt><strong>snr</strong><span class="classifier">float</span></dt><dd><p>The desired signal-to-noise ratio. (See notes below.)
If <cite>snr</cite> is None, return the signal as-is.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>Reference signal for specifying <cite>snr</cite>.</p>
</dd>
<dt><strong>noise_type</strong><span class="classifier">string, optional</span></dt><dd><p>The distribution of noise added. Can be either ‘gaussian’ for Gaussian
distributed noise, ‘rician’ for Rice-distributed noise (default) or
‘rayleigh’ for a Rayleigh distribution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>signal</strong><span class="classifier">array, same shape as the input</span></dt><dd><p>Signal with added noise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>SNR is defined here, following <a class="reference internal" href="#r71e340ddaf7d-1" id="id49">[1]</a>, as <code class="docutils literal notranslate"><span class="pre">S0</span> <span class="pre">/</span> <span class="pre">sigma</span></code>, where <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is
the standard deviation of the two Gaussian distributions forming the real
and imaginary components of the Rician noise distribution (see <a class="reference internal" href="#r71e340ddaf7d-2" id="id50">[2]</a>).</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r71e340ddaf7d-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id49">1</a>,<a href="#id51">2</a>)</span></dt>
<dd><p>Descoteaux, Angelino, Fitzgibbons and Deriche (2007) Regularized,
fast and robust q-ball imaging. MRM, 58: 497-510</p>
</dd>
<dt class="label" id="r71e340ddaf7d-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id50">1</a>,<a href="#id52">2</a>)</span></dt>
<dd><p>Gudbjartson and Patz (2008). The Rician distribution of noisy MRI
data. MRM 34: 910-914.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">800</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signal_w_noise</span> <span class="o">=</span> <span class="n">add_noise</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">100.</span><span class="p">,</span> <span class="n">noise_type</span><span class="o">=</span><span class="s1">&#39;rician&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.sims.html" title="sims"
             >next</a> |</li>
        <li class="right" >
          <a href="dipy.reconst.html" title="reconst"
             >previous</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >API Reference</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2019, dipy developers &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>