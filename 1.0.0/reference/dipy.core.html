
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>DIPY &#8212; dipy 1.0.0 documentation</title>
    <link rel="stylesheet" href="../_static/dipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="data" href="dipy.data.html" />
    <link rel="prev" title="boots" href="dipy.boots.html" />
  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head><body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../index.html">
  <img src="../_static/dipy-banner.png" alt="DIPY logo"  border="0" />
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.data.html" title="data"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dipy.boots.html" title="boots"
             accesskey="P">previous</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">API Reference</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Site Navigation </h4>
  <ul>
    <li><a href="../documentation.html">Documentation</a></li>
    <li><a href="../devel/index.html">Development</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.org/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.org/">NIPY Projects</a></li>
    <li><a class="reference external"
	href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing List</a></li>
    <li><a class="reference external"
	href="http://nipy.org/nipy/license.html">License</a></li>
  </ul>


  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">core</span></code></a><ul>
<li><a class="reference internal" href="#module-dipy.core.geometry">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.geometry</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.gradients">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.gradients</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.graph">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.graph</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.histeq">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.histeq</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.ndindex">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.ndindex</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.onetime">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.onetime</span></code></a><ul>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-dipy.core.optimize">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.optimize</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.profile">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.profile</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.rng">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.rng</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.sphere">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.sphere</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.sphere_stats">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.sphere_stats</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.subdivide_octahedron">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.subdivide_octahedron</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.core.wavelet">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.wavelet</span></code></a><ul>
<li><a class="reference internal" href="#test">test</a></li>
<li><a class="reference internal" href="#cart2sphere">cart2sphere</a></li>
<li><a class="reference internal" href="#cart-distance">cart_distance</a></li>
<li><a class="reference internal" href="#circumradius">circumradius</a></li>
<li><a class="reference internal" href="#compose-matrix">compose_matrix</a></li>
<li><a class="reference internal" href="#compose-transformations">compose_transformations</a></li>
<li><a class="reference internal" href="#decompose-matrix">decompose_matrix</a></li>
<li><a class="reference internal" href="#dist-to-corner">dist_to_corner</a></li>
<li><a class="reference internal" href="#euler-matrix">euler_matrix</a></li>
<li><a class="reference internal" href="#is-hemispherical">is_hemispherical</a></li>
<li><a class="reference internal" href="#lambert-equal-area-projection-cart">lambert_equal_area_projection_cart</a></li>
<li><a class="reference internal" href="#lambert-equal-area-projection-polar">lambert_equal_area_projection_polar</a></li>
<li><a class="reference internal" href="#nearest-pos-semi-def">nearest_pos_semi_def</a></li>
<li><a class="reference internal" href="#normalized-vector">normalized_vector</a></li>
<li><a class="reference internal" href="#perpendicular-directions">perpendicular_directions</a></li>
<li><a class="reference internal" href="#rodrigues-axis-rotation">rodrigues_axis_rotation</a></li>
<li><a class="reference internal" href="#sph2latlon">sph2latlon</a></li>
<li><a class="reference internal" href="#sphere2cart">sphere2cart</a></li>
<li><a class="reference internal" href="#sphere-distance">sphere_distance</a></li>
<li><a class="reference internal" href="#vec2vec-rotmat">vec2vec_rotmat</a></li>
<li><a class="reference internal" href="#vector-cosine">vector_cosine</a></li>
<li><a class="reference internal" href="#vector-norm">vector_norm</a></li>
<li><a class="reference internal" href="#gradienttable"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientTable</span></code></a></li>
<li><a class="reference internal" href="#hemisphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">HemiSphere</span></code></a></li>
<li><a class="reference internal" href="#auto-attr">auto_attr</a></li>
<li><a class="reference internal" href="#check-multi-b">check_multi_b</a></li>
<li><a class="reference internal" href="#disperse-charges">disperse_charges</a></li>
<li><a class="reference internal" href="#generate-bvecs">generate_bvecs</a></li>
<li><a class="reference internal" href="#gradient-table">gradient_table</a></li>
<li><a class="reference internal" href="#gradient-table-from-bvals-bvecs">gradient_table_from_bvals_bvecs</a></li>
<li><a class="reference internal" href="#gradient-table-from-gradient-strength-bvecs">gradient_table_from_gradient_strength_bvecs</a></li>
<li><a class="reference internal" href="#gradient-table-from-qvals-bvecs">gradient_table_from_qvals_bvecs</a></li>
<li><a class="reference internal" href="#inv">inv</a></li>
<li><a class="reference internal" href="#polar">polar</a></li>
<li><a class="reference internal" href="#reorient-bvecs">reorient_bvecs</a></li>
<li><a class="reference internal" href="#round-bvals">round_bvals</a></li>
<li><a class="reference internal" href="#unique-bvals">unique_bvals</a></li>
<li><a class="reference internal" href="#id8">vector_norm</a></li>
<li><a class="reference internal" href="#warn">warn</a></li>
<li><a class="reference internal" href="#graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></li>
<li><a class="reference internal" href="#histeq">histeq</a></li>
<li><a class="reference internal" href="#as-strided">as_strided</a></li>
<li><a class="reference internal" href="#ndindex">ndindex</a></li>
<li><a class="reference internal" href="#onetimeproperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneTimeProperty</span></code></a></li>
<li><a class="reference internal" href="#resetmixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResetMixin</span></code></a></li>
<li><a class="reference internal" href="#id9">auto_attr</a></li>
<li><a class="reference internal" href="#nonnegativeleastsquares"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonNegativeLeastSquares</span></code></a></li>
<li><a class="reference internal" href="#optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code></a></li>
<li><a class="reference internal" href="#sklearnlinearsolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">SKLearnLinearSolver</span></code></a></li>
<li><a class="reference internal" href="#minimize">minimize</a></li>
<li><a class="reference internal" href="#sparse-nnls">sparse_nnls</a></li>
<li><a class="reference internal" href="#spdot">spdot</a></li>
<li><a class="reference internal" href="#profiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Profiler</span></code></a></li>
<li><a class="reference internal" href="#optional-package">optional_package</a></li>
<li><a class="reference internal" href="#lecuyer">LEcuyer</a></li>
<li><a class="reference internal" href="#wichmannhill1982">WichmannHill1982</a></li>
<li><a class="reference internal" href="#wichmannhill2006">WichmannHill2006</a></li>
<li><a class="reference internal" href="#architecture">architecture</a></li>
<li><a class="reference internal" href="#floor">floor</a></li>
<li><a class="reference internal" href="#id51"><code class="xref py py-class docutils literal notranslate"><span class="pre">HemiSphere</span></code></a></li>
<li><a class="reference internal" href="#sphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sphere</span></code></a></li>
<li><a class="reference internal" href="#id52">auto_attr</a></li>
<li><a class="reference internal" href="#id53">cart2sphere</a></li>
<li><a class="reference internal" href="#id54">disperse_charges</a></li>
<li><a class="reference internal" href="#euler-characteristic-check">euler_characteristic_check</a></li>
<li><a class="reference internal" href="#faces-from-sphere-vertices">faces_from_sphere_vertices</a></li>
<li><a class="reference internal" href="#remove-similar-vertices">remove_similar_vertices</a></li>
<li><a class="reference internal" href="#id55">sphere2cart</a></li>
<li><a class="reference internal" href="#unique-edges">unique_edges</a></li>
<li><a class="reference internal" href="#unique-sets">unique_sets</a></li>
<li><a class="reference internal" href="#id56">vector_norm</a></li>
<li><a class="reference internal" href="#permutations"><code class="xref py py-class docutils literal notranslate"><span class="pre">permutations</span></code></a></li>
<li><a class="reference internal" href="#angular-similarity">angular_similarity</a></li>
<li><a class="reference internal" href="#compare-orientation-sets">compare_orientation_sets</a></li>
<li><a class="reference internal" href="#eigenstats">eigenstats</a></li>
<li><a class="reference internal" href="#random-uniform-on-sphere">random_uniform_on_sphere</a></li>
<li><a class="reference internal" href="#id58"><code class="xref py py-class docutils literal notranslate"><span class="pre">HemiSphere</span></code></a></li>
<li><a class="reference internal" href="#create-unit-hemisphere">create_unit_hemisphere</a></li>
<li><a class="reference internal" href="#create-unit-sphere">create_unit_sphere</a></li>
<li><a class="reference internal" href="#afb3d">afb3D</a></li>
<li><a class="reference internal" href="#afb3d-a">afb3D_A</a></li>
<li><a class="reference internal" href="#cshift3d">cshift3D</a></li>
<li><a class="reference internal" href="#dwt3d">dwt3D</a></li>
<li><a class="reference internal" href="#idwt3d">idwt3D</a></li>
<li><a class="reference internal" href="#permutationinverse">permutationinverse</a></li>
<li><a class="reference internal" href="#sfb3d">sfb3D</a></li>
<li><a class="reference internal" href="#sfb3d-a">sfb3D_A</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dipy.boots.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">boots</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dipy.data.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">data</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/dipy.core.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dipy.core">
<span id="core"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">core</span></code><a class="headerlink" href="#module-dipy.core" title="Permalink to this headline">¶</a></h1>
<p>Core objects</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.test" title="dipy.core.test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test</span></code></a>([label, verbose, extra_argv, doctests, …])</p></td>
<td><p>Run tests for module using nose.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="module-dipy.core.geometry">
<span id="module-core-geometry"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.geometry</span></code><a class="headerlink" href="#module-dipy.core.geometry" title="Permalink to this headline">¶</a></h2>
<p>Utility functions for algebra etc</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.cart2sphere" title="dipy.core.geometry.cart2sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart2sphere</span></code></a>(x, y, z)</p></td>
<td><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.cart_distance" title="dipy.core.geometry.cart_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart_distance</span></code></a>(pts1, pts2)</p></td>
<td><p>Cartesian distance between <cite>pts1</cite> and <cite>pts2</cite></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.circumradius" title="dipy.core.geometry.circumradius"><code class="xref py py-obj docutils literal notranslate"><span class="pre">circumradius</span></code></a>(a, b, c)</p></td>
<td><p>a, b and c are 3-dimensional vectors which are the vertices of a triangle.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.compose_matrix" title="dipy.core.geometry.compose_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose_matrix</span></code></a>([scale, shear, angles, …])</p></td>
<td><p>Return 4x4 transformation matrix from sequence of transformations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.compose_transformations" title="dipy.core.geometry.compose_transformations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose_transformations</span></code></a>(*mats)</p></td>
<td><p>Compose multiple 4x4 affine transformations in one 4x4 matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.decompose_matrix" title="dipy.core.geometry.decompose_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_matrix</span></code></a>(matrix)</p></td>
<td><p>Return sequence of transformations from transformation matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.dist_to_corner" title="dipy.core.geometry.dist_to_corner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist_to_corner</span></code></a>(affine)</p></td>
<td><p>Calculate the maximal distance from the center to a corner of a voxel, given an affine</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.euler_matrix" title="dipy.core.geometry.euler_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_matrix</span></code></a>(ai, aj, ak[, axes])</p></td>
<td><p>Return homogeneous rotation matrix from Euler angles and axis sequence.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.is_hemispherical" title="dipy.core.geometry.is_hemispherical"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_hemispherical</span></code></a>(vecs)</p></td>
<td><p>Test whether all points on a unit sphere lie in the same hemisphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.lambert_equal_area_projection_cart" title="dipy.core.geometry.lambert_equal_area_projection_cart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lambert_equal_area_projection_cart</span></code></a>(x, y, z)</p></td>
<td><p>Lambert Equal Area Projection from cartesian vector to plane</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.lambert_equal_area_projection_polar" title="dipy.core.geometry.lambert_equal_area_projection_polar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lambert_equal_area_projection_polar</span></code></a>(theta, phi)</p></td>
<td><p>Lambert Equal Area Projection from polar sphere to plane</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.nearest_pos_semi_def" title="dipy.core.geometry.nearest_pos_semi_def"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nearest_pos_semi_def</span></code></a>(B)</p></td>
<td><p>Least squares positive semi-definite tensor estimation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.normalized_vector" title="dipy.core.geometry.normalized_vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalized_vector</span></code></a>(vec[, axis])</p></td>
<td><p>Return vector divided by its Euclidean (L2) norm</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.perpendicular_directions" title="dipy.core.geometry.perpendicular_directions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">perpendicular_directions</span></code></a>(v[, num, half])</p></td>
<td><p>Computes n evenly spaced perpendicular directions relative to a given vector v</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.rodrigues_axis_rotation" title="dipy.core.geometry.rodrigues_axis_rotation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rodrigues_axis_rotation</span></code></a>(r, theta)</p></td>
<td><p>Rodrigues formula</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.sph2latlon" title="dipy.core.geometry.sph2latlon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sph2latlon</span></code></a>(theta, phi)</p></td>
<td><p>Convert spherical coordinates to latitude and longitude.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.sphere2cart" title="dipy.core.geometry.sphere2cart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphere2cart</span></code></a>(r, theta, phi)</p></td>
<td><p>Spherical to Cartesian coordinates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.sphere_distance" title="dipy.core.geometry.sphere_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphere_distance</span></code></a>(pts1, pts2[, radius, …])</p></td>
<td><p>Distance across sphere surface between <cite>pts1</cite> and <cite>pts2</cite></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.vec2vec_rotmat" title="dipy.core.geometry.vec2vec_rotmat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vec2vec_rotmat</span></code></a>(u, v)</p></td>
<td><p>rotation matrix from 2 unit vectors</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.geometry.vector_cosine" title="dipy.core.geometry.vector_cosine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_cosine</span></code></a>(vecs1, vecs2)</p></td>
<td><p>Cosine of angle between two (sets of) vectors</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.geometry.vector_norm" title="dipy.core.geometry.vector_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_norm</span></code></a>(vec[, axis, keepdims])</p></td>
<td><p>Return vector Euclidean (L2) norm</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.gradients">
<span id="module-core-gradients"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.gradients</span></code><a class="headerlink" href="#module-dipy.core.gradients" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.GradientTable" title="dipy.core.gradients.GradientTable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GradientTable</span></code></a>(gradients[, big_delta, …])</p></td>
<td><p>Diffusion gradient information</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.HemiSphere" title="dipy.core.gradients.HemiSphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HemiSphere</span></code></a>([x, y, z, theta, phi, xyz, …])</p></td>
<td><p>Points on the unit sphere.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.auto_attr" title="dipy.core.gradients.auto_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_attr</span></code></a>(func)</p></td>
<td><p>Decorator to create OneTimeProperty attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.check_multi_b" title="dipy.core.gradients.check_multi_b"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_multi_b</span></code></a>(gtab, n_bvals[, non_zero, bmag])</p></td>
<td><p>Check if you have enough different b-values in your gradient table</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.disperse_charges" title="dipy.core.gradients.disperse_charges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disperse_charges</span></code></a>(hemi, iters[, const])</p></td>
<td><p>Models electrostatic repulsion on the unit sphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.generate_bvecs" title="dipy.core.gradients.generate_bvecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_bvecs</span></code></a>(N[, iters])</p></td>
<td><p>Generates N bvectors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.gradient_table" title="dipy.core.gradients.gradient_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table</span></code></a>(bvals[, bvecs, big_delta, …])</p></td>
<td><p>A general function for creating diffusion MR gradients.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.gradient_table_from_bvals_bvecs" title="dipy.core.gradients.gradient_table_from_bvals_bvecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table_from_bvals_bvecs</span></code></a>(bvals, bvecs)</p></td>
<td><p>Creates a GradientTable from a bvals array and a bvecs array</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.gradient_table_from_gradient_strength_bvecs" title="dipy.core.gradients.gradient_table_from_gradient_strength_bvecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table_from_gradient_strength_bvecs</span></code></a>(…)</p></td>
<td><p>A general function for creating diffusion MR gradients.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.gradient_table_from_qvals_bvecs" title="dipy.core.gradients.gradient_table_from_qvals_bvecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table_from_qvals_bvecs</span></code></a>(qvals, …)</p></td>
<td><p>A general function for creating diffusion MR gradients.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.inv" title="dipy.core.gradients.inv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inv</span></code></a>(a[, overwrite_a, check_finite])</p></td>
<td><p>Compute the inverse of a matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.polar" title="dipy.core.gradients.polar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polar</span></code></a>(a[, side])</p></td>
<td><p>Compute the polar decomposition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.reorient_bvecs" title="dipy.core.gradients.reorient_bvecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorient_bvecs</span></code></a>(gtab, affines)</p></td>
<td><p>Reorient the directions in a GradientTable.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.round_bvals" title="dipy.core.gradients.round_bvals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">round_bvals</span></code></a>(bvals[, bmag])</p></td>
<td><p>“This function rounds the b-values</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.unique_bvals" title="dipy.core.gradients.unique_bvals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique_bvals</span></code></a>(bvals[, bmag, rbvals])</p></td>
<td><p>This function gives the unique rounded b-values of the data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.vector_norm" title="dipy.core.gradients.vector_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_norm</span></code></a>(vec[, axis, keepdims])</p></td>
<td><p>Return vector Euclidean (L2) norm</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.warn" title="dipy.core.gradients.warn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warn</span></code></a></p></td>
<td><p>Issue a warning, or maybe ignore it or raise an exception.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.graph">
<span id="module-core-graph"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.graph</span></code><a class="headerlink" href="#module-dipy.core.graph" title="Permalink to this headline">¶</a></h2>
<p>A simple graph class</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.graph.Graph" title="dipy.core.graph.Graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph</span></code></a>()</p></td>
<td><p>A simple graph class</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.histeq">
<span id="module-core-histeq"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.histeq</span></code><a class="headerlink" href="#module-dipy.core.histeq" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.histeq.histeq" title="dipy.core.histeq.histeq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">histeq</span></code></a>(arr[, num_bins])</p></td>
<td><p>Performs an histogram equalization on <code class="docutils literal notranslate"><span class="pre">arr</span></code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.ndindex">
<span id="module-core-ndindex"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.ndindex</span></code><a class="headerlink" href="#module-dipy.core.ndindex" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.ndindex.as_strided" title="dipy.core.ndindex.as_strided"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_strided</span></code></a>(x[, shape, strides, subok, writeable])</p></td>
<td><p>Create a view into the array with the given shape and strides.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.ndindex.ndindex" title="dipy.core.ndindex.ndindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex</span></code></a>(shape)</p></td>
<td><p>An N-dimensional iterator object to index arrays.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.onetime">
<span id="module-core-onetime"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.onetime</span></code><a class="headerlink" href="#module-dipy.core.onetime" title="Permalink to this headline">¶</a></h2>
<p>Descriptor support for NIPY.</p>
<p>Copyright (c) 2006-2011, NIPY Developers
All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>Redistributions of source code must retain the above copyright</dt><dd><p>notice, this list of conditions and the following disclaimer.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Redistributions in binary form must reproduce the above</dt><dd><p>copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided
with the distribution.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Neither the name of the NIPY Developers nor the names of any</dt><dd><p>contributors may be used to endorse or promote products derived
from this software without specific prior written permission.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
“AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>Utilities to support special Python descriptors [1,2], in particular the use of
a useful pattern for properties we call ‘one time properties’.  These are
object attributes which are declared as properties, but become regular
attributes once they’ve been read the first time.  They can thus be evaluated
later in the object’s life cycle, but once evaluated they become normal, static
attributes with no function call overhead on access or any other constraints.</p>
<p>A special ResetMixin class is provided to add a .reset() method to users who
may want to have their objects capable of resetting these computed properties
to their ‘untriggered’ state.</p>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<p>[1] How-To Guide for Descriptors, Raymond
Hettinger. <a class="reference external" href="http://users.rcn.com/python/download/Descriptor.htm">http://users.rcn.com/python/download/Descriptor.htm</a></p>
<p>[2] Python data model, <a class="reference external" href="http://docs.python.org/reference/datamodel.html">http://docs.python.org/reference/datamodel.html</a></p>
</div>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.onetime.OneTimeProperty" title="dipy.core.onetime.OneTimeProperty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OneTimeProperty</span></code></a>(func)</p></td>
<td><p>A descriptor to make special properties that become normal attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.onetime.ResetMixin" title="dipy.core.onetime.ResetMixin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ResetMixin</span></code></a></p></td>
<td><p>A Mixin class to add a .reset() method to users of OneTimeProperty.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.onetime.auto_attr" title="dipy.core.onetime.auto_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_attr</span></code></a>(func)</p></td>
<td><p>Decorator to create OneTimeProperty attributes.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.optimize">
<span id="module-core-optimize"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.optimize</span></code><a class="headerlink" href="#module-dipy.core.optimize" title="Permalink to this headline">¶</a></h2>
<p>A unified interface for performing and debugging optimization problems.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.optimize.NonNegativeLeastSquares" title="dipy.core.optimize.NonNegativeLeastSquares"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NonNegativeLeastSquares</span></code></a>(*args, **kwargs)</p></td>
<td><p>A sklearn-like interface to scipy.optimize.nnls</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.optimize.Optimizer" title="dipy.core.optimize.Optimizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Optimizer</span></code></a>(fun, x0[, args, method, jac, …])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.optimize.SKLearnLinearSolver" title="dipy.core.optimize.SKLearnLinearSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SKLearnLinearSolver</span></code></a>(*args, **kwargs)</p></td>
<td><p>Provide a sklearn-like uniform interface to algorithms that solve problems of the form: <span class="math notranslate nohighlight">\(y = Ax\)</span> for <span class="math notranslate nohighlight">\(x\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.optimize.minimize" title="dipy.core.optimize.minimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize</span></code></a>(fun, x0[, args, method, jac, hess, …])</p></td>
<td><p>Minimization of scalar function of one or more variables.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.optimize.sparse_nnls" title="dipy.core.optimize.sparse_nnls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_nnls</span></code></a>(y, X[, momentum, step_size, …])</p></td>
<td><p>Solve y=Xh for h, using gradient descent, with X a sparse matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.optimize.spdot" title="dipy.core.optimize.spdot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spdot</span></code></a>(A, B)</p></td>
<td><p>The same as np.dot(A, B), except it works even if A or B or both are sparse matrices.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.profile">
<span id="module-core-profile"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.profile</span></code><a class="headerlink" href="#module-dipy.core.profile" title="Permalink to this headline">¶</a></h2>
<p>Class for profiling cython code</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.profile.Profiler" title="dipy.core.profile.Profiler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Profiler</span></code></a>([call])</p></td>
<td><p>Profile python/cython files or functions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.profile.optional_package" title="dipy.core.profile.optional_package"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optional_package</span></code></a>(name[, trip_msg])</p></td>
<td><p>Return package-like thing and module setup for package <cite>name</cite></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.rng">
<span id="module-core-rng"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.rng</span></code><a class="headerlink" href="#module-dipy.core.rng" title="Permalink to this headline">¶</a></h2>
<p>Random number generation utilities</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.rng.LEcuyer" title="dipy.core.rng.LEcuyer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LEcuyer</span></code></a>()</p></td>
<td><p>Generate uniformly distributed random numbers using the 32-bit generator from figure 3 of:     L’Ecuyer, P.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.rng.WichmannHill1982" title="dipy.core.rng.WichmannHill1982"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WichmannHill1982</span></code></a>()</p></td>
<td><p>Algorithm AS 183 Appl.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.rng.WichmannHill2006" title="dipy.core.rng.WichmannHill2006"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WichmannHill2006</span></code></a>()</p></td>
<td><p>B.A.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.rng.architecture" title="dipy.core.rng.architecture"><code class="xref py py-obj docutils literal notranslate"><span class="pre">architecture</span></code></a>([executable, bits, linkage])</p></td>
<td><p>Queries the given executable (defaults to the Python interpreter binary) for various architecture information.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.rng.floor" title="dipy.core.rng.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>(x)</p></td>
<td><p>Return the floor of x as an Integral.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.sphere">
<span id="module-core-sphere"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.sphere</span></code><a class="headerlink" href="#module-dipy.core.sphere" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere.HemiSphere" title="dipy.core.sphere.HemiSphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HemiSphere</span></code></a>([x, y, z, theta, phi, xyz, …])</p></td>
<td><p>Points on the unit sphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere.Sphere" title="dipy.core.sphere.Sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sphere</span></code></a>([x, y, z, theta, phi, xyz, faces, edges])</p></td>
<td><p>Points on the unit sphere.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere.auto_attr" title="dipy.core.sphere.auto_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_attr</span></code></a>(func)</p></td>
<td><p>Decorator to create OneTimeProperty attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere.cart2sphere" title="dipy.core.sphere.cart2sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart2sphere</span></code></a>(x, y, z)</p></td>
<td><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere.disperse_charges" title="dipy.core.sphere.disperse_charges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disperse_charges</span></code></a>(hemi, iters[, const])</p></td>
<td><p>Models electrostatic repulsion on the unit sphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere.euler_characteristic_check" title="dipy.core.sphere.euler_characteristic_check"><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_characteristic_check</span></code></a>(sphere[, chi])</p></td>
<td><p>Checks the euler characteristic of a sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere.faces_from_sphere_vertices" title="dipy.core.sphere.faces_from_sphere_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_from_sphere_vertices</span></code></a>(vertices)</p></td>
<td><p>Triangulate a set of vertices on the sphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere.remove_similar_vertices" title="dipy.core.sphere.remove_similar_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_similar_vertices</span></code></a></p></td>
<td><p>Remove vertices that are less than <cite>theta</cite> degrees from any other</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere.sphere2cart" title="dipy.core.sphere.sphere2cart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphere2cart</span></code></a>(r, theta, phi)</p></td>
<td><p>Spherical to Cartesian coordinates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere.unique_edges" title="dipy.core.sphere.unique_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique_edges</span></code></a>(faces[, return_mapping])</p></td>
<td><p>Extract all unique edges from given triangular faces.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere.unique_sets" title="dipy.core.sphere.unique_sets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique_sets</span></code></a>(sets[, return_inverse])</p></td>
<td><p>Remove duplicate sets.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere.vector_norm" title="dipy.core.sphere.vector_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_norm</span></code></a>(vec[, axis, keepdims])</p></td>
<td><p>Return vector Euclidean (L2) norm</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.sphere_stats">
<span id="module-core-sphere-stats"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.sphere_stats</span></code><a class="headerlink" href="#module-dipy.core.sphere_stats" title="Permalink to this headline">¶</a></h2>
<p>Statistics on spheres</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere_stats.permutations" title="dipy.core.sphere_stats.permutations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permutations</span></code></a></p></td>
<td><p>permutations(iterable[, r]) –&gt; permutations object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere_stats.angular_similarity" title="dipy.core.sphere_stats.angular_similarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angular_similarity</span></code></a>(S, T)</p></td>
<td><p>Computes the cosine distance of the best match between points of two sets of vectors S and T</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere_stats.compare_orientation_sets" title="dipy.core.sphere_stats.compare_orientation_sets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compare_orientation_sets</span></code></a>(S, T)</p></td>
<td><p>Computes the mean cosine distance of the best match between points of two sets of vectors S and T (angular similarity)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere_stats.eigenstats" title="dipy.core.sphere_stats.eigenstats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenstats</span></code></a>(points[, alpha])</p></td>
<td><p>Principal direction and confidence ellipse</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere_stats.random_uniform_on_sphere" title="dipy.core.sphere_stats.random_uniform_on_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_uniform_on_sphere</span></code></a>([n, coords])</p></td>
<td><p>Random unit vectors from a uniform distribution on the sphere.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.subdivide_octahedron">
<span id="module-core-subdivide-octahedron"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.subdivide_octahedron</span></code><a class="headerlink" href="#module-dipy.core.subdivide_octahedron" title="Permalink to this headline">¶</a></h2>
<p>Create a unit sphere by subdividing all triangles of an octahedron
recursively.</p>
<p>The unit sphere has a radius of 1, which also means that all points in this
sphere (assumed to have centre at [0, 0, 0]) have an absolute value (modulus)
of 1. Another feature of the unit sphere is that the unit normals of this
sphere are exactly the same as the vertices.</p>
<p>This recursive method will avoid the common problem of the polar singularity,
produced by 2d (lon-lat) parameterization methods.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.subdivide_octahedron.HemiSphere" title="dipy.core.subdivide_octahedron.HemiSphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HemiSphere</span></code></a>([x, y, z, theta, phi, xyz, …])</p></td>
<td><p>Points on the unit sphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.subdivide_octahedron.create_unit_hemisphere" title="dipy.core.subdivide_octahedron.create_unit_hemisphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_unit_hemisphere</span></code></a>([recursion_level])</p></td>
<td><p>Creates a unit sphere by subdividing a unit octahedron, returns half the sphere.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.subdivide_octahedron.create_unit_sphere" title="dipy.core.subdivide_octahedron.create_unit_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_unit_sphere</span></code></a>([recursion_level])</p></td>
<td><p>Creates a unit sphere by subdividing a unit octahedron.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.core.wavelet">
<span id="module-core-wavelet"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">core.wavelet</span></code><a class="headerlink" href="#module-dipy.core.wavelet" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.wavelet.afb3D" title="dipy.core.wavelet.afb3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">afb3D</span></code></a>(x, af1[, af2, af3])</p></td>
<td><p>3D Analysis Filter Bank</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.wavelet.afb3D_A" title="dipy.core.wavelet.afb3D_A"><code class="xref py py-obj docutils literal notranslate"><span class="pre">afb3D_A</span></code></a>(x, af, d)</p></td>
<td><p>3D Analysis Filter Bank</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.wavelet.cshift3D" title="dipy.core.wavelet.cshift3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cshift3D</span></code></a>(x, m, d)</p></td>
<td><p>3D Circular Shift</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.wavelet.dwt3D" title="dipy.core.wavelet.dwt3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dwt3D</span></code></a>(x, J, af)</p></td>
<td><p>3-D Discrete Wavelet Transform</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.wavelet.idwt3D" title="dipy.core.wavelet.idwt3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">idwt3D</span></code></a>(w, J, sf)</p></td>
<td><p>Inverse 3-D Discrete Wavelet Transform</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.wavelet.permutationinverse" title="dipy.core.wavelet.permutationinverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permutationinverse</span></code></a>(perm)</p></td>
<td><p>Function generating inverse of the permutation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.wavelet.sfb3D" title="dipy.core.wavelet.sfb3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sfb3D</span></code></a>(lo, hi, sf1[, sf2, sf3])</p></td>
<td><p>3D Synthesis Filter Bank</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.wavelet.sfb3D_A" title="dipy.core.wavelet.sfb3D_A"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sfb3D_A</span></code></a>(lo, hi, sf, d)</p></td>
<td><p>3D Synthesis Filter Bank</p></td>
</tr>
</tbody>
</table>
<div class="section" id="test">
<h3>test<a class="headerlink" href="#test" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.test">
<code class="sig-prename descclassname">dipy.core.</code><code class="sig-name descname">test</code><span class="sig-paren">(</span><em class="sig-param">label='fast'</em>, <em class="sig-param">verbose=1</em>, <em class="sig-param">extra_argv=None</em>, <em class="sig-param">doctests=False</em>, <em class="sig-param">coverage=False</em>, <em class="sig-param">raise_warnings=None</em>, <em class="sig-param">timer=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Run tests for module using nose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">{‘fast’, ‘full’, ‘’, attribute identifier}, optional</span></dt><dd><p>Identifies the tests to run. This can be a string to pass to
the nosetests executable with the ‘-A’ option, or one of several
special values.  Special values are:</p>
<ul class="simple">
<li><p>‘fast’ - the default - which corresponds to the <code class="docutils literal notranslate"><span class="pre">nosetests</span> <span class="pre">-A</span></code>
option of ‘not slow’.</p></li>
<li><p>‘full’ - fast (as above) and slow tests as in the
‘no -A’ option to nosetests - this is the same as ‘’.</p></li>
<li><p>None or ‘’ - run all tests.</p></li>
<li><p>attribute_identifier - string passed directly to nosetests as ‘-A’.</p></li>
</ul>
</dd>
<dt><strong>verbose</strong><span class="classifier">int, optional</span></dt><dd><p>Verbosity value for test outputs, in the range 1-10. Default is 1.</p>
</dd>
<dt><strong>extra_argv</strong><span class="classifier">list, optional</span></dt><dd><p>List with any extra arguments to pass to nosetests.</p>
</dd>
<dt><strong>doctests</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, run doctests in module. Default is False.</p>
</dd>
<dt><strong>coverage</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, report coverage of NumPy code. Default is False.
(This requires the
<a class="reference external" href="https://nedbatchelder.com/code/modules/coveragehtml">coverage module</a>).</p>
</dd>
<dt><strong>raise_warnings</strong><span class="classifier">None, str or sequence of warnings, optional</span></dt><dd><p>This specifies which warnings to configure as ‘raise’ instead
of being shown once during the test execution. Valid strings are:</p>
<ul class="simple">
<li><p>“develop” : equals <code class="docutils literal notranslate"><span class="pre">(Warning,)</span></code></p></li>
<li><p>“release” : equals <code class="docutils literal notranslate"><span class="pre">()</span></code>, do not raise on any warnings.</p></li>
</ul>
</dd>
<dt><strong>timer</strong><span class="classifier">bool or int, optional</span></dt><dd><p>Timing of individual tests with <code class="docutils literal notranslate"><span class="pre">nose-timer</span></code> (which needs to be
installed).  If True, time tests and report on all of them.
If an integer (say <code class="docutils literal notranslate"><span class="pre">N</span></code>), report timing results for <code class="docutils literal notranslate"><span class="pre">N</span></code> slowest
tests.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">object</span></dt><dd><p>Returns the result of running the tests as a
<code class="docutils literal notranslate"><span class="pre">nose.result.TextTestResult</span></code> object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Each NumPy module exposes <cite>test</cite> in its namespace to run all tests for it.
For example, to run all tests for numpy.lib:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">test</span><span class="p">()</span> <span class="c1">#doctest: +SKIP</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">test</span><span class="p">()</span> <span class="c1">#doctest: +SKIP</span>
<span class="go">Running unit tests for numpy.lib</span>
<span class="gp">...</span>
<span class="go">Ran 976 tests in 3.933s</span>
</pre></div>
</div>
<p>OK</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">errors</span> <span class="c1">#doctest: +SKIP</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">knownfail</span> <span class="c1">#doctest: +SKIP</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="cart2sphere">
<h3>cart2sphere<a class="headerlink" href="#cart2sphere" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.cart2sphere">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">cart2sphere</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.cart2sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions and derivation
of the formulae.</p>
<p><span class="math notranslate nohighlight">\(0\le\theta\mathrm{(theta)}\le\pi\)</span> and <span class="math notranslate nohighlight">\(-\pi\le\phi\mathrm{(phi)}\le\pi\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>x coordinate in Cartesian space</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong><span class="classifier">array_like</span></dt><dd><p>z coordinate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>r</strong><span class="classifier">array</span></dt><dd><p>radius</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array</span></dt><dd><p>inclination (polar) angle</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array</span></dt><dd><p>azimuth angle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="cart-distance">
<h3>cart_distance<a class="headerlink" href="#cart-distance" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.cart_distance">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">cart_distance</code><span class="sig-paren">(</span><em class="sig-param">pts1</em>, <em class="sig-param">pts2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.cart_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian distance between <cite>pts1</cite> and <cite>pts2</cite></p>
<p>If either of <cite>pts1</cite> or <cite>pts2</cite> is 2D, then we take the first
dimension to index points, and the second indexes coordinate.  More
generally, we take the last dimension to be the coordinate
dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pts1</strong><span class="classifier">(N,R) or (R,) array_like</span></dt><dd><p>where N is the number of points and R is the number of
coordinates defining a point (<code class="docutils literal notranslate"><span class="pre">R==3</span></code> for 3D)</p>
</dd>
<dt><strong>pts2</strong><span class="classifier">(N,R) or (R,) array_like</span></dt><dd><p>where N is the number of points and R is the number of
coordinates defining a point (<code class="docutils literal notranslate"><span class="pre">R==3</span></code> for 3D).  It should be
possible to broadcast <cite>pts1</cite> against <cite>pts2</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d</strong><span class="classifier">(N,) or (0,) array</span></dt><dd><p>Cartesian distances between corresponding points in <cite>pts1</cite> and
<cite>pts2</cite></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dipy.core.geometry.sphere_distance" title="dipy.core.geometry.sphere_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphere_distance</span></code></a></dt><dd><p>distance between points on sphere surface</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cart_distance</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">3.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="circumradius">
<h3>circumradius<a class="headerlink" href="#circumradius" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.circumradius">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">circumradius</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">c</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.circumradius" title="Permalink to this definition">¶</a></dt>
<dd><p>a, b and c are 3-dimensional vectors which are the vertices of a
triangle. The function returns the circumradius of the triangle, i.e
the radius of the smallest circle that can contain the triangle. In
the degenerate case when the 3 points are collinear it returns
half the distance between the furthest apart points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a, b, c</strong><span class="classifier">(3,) array_like</span></dt><dd><p>the three vertices of the triangle</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>circumradius</strong><span class="classifier">float</span></dt><dd><p>the desired circumradius</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="compose-matrix">
<h3>compose_matrix<a class="headerlink" href="#compose-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.compose_matrix">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">compose_matrix</code><span class="sig-paren">(</span><em class="sig-param">scale=None</em>, <em class="sig-param">shear=None</em>, <em class="sig-param">angles=None</em>, <em class="sig-param">translate=None</em>, <em class="sig-param">perspective=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.compose_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 4x4 transformation matrix from sequence of
transformations.</p>
<p>Code modified from the work of Christoph Gohlke link provided here
<a class="reference external" href="http://www.lfd.uci.edu/~gohlke/code/transformations.py.html">http://www.lfd.uci.edu/~gohlke/code/transformations.py.html</a></p>
<p>This is the inverse of the <code class="docutils literal notranslate"><span class="pre">decompose_matrix</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">(3,) array_like</span></dt><dd><p>Scaling factors.</p>
</dd>
<dt><strong>shear</strong><span class="classifier">array_like</span></dt><dd><p>Shear factors for x-y, x-z, y-z axes.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">array_like</span></dt><dd><p>Euler angles about static x, y, z axes.</p>
</dd>
<dt><strong>translate</strong><span class="classifier">array_like</span></dt><dd><p>Translation vector along x, y, z axes.</p>
</dd>
<dt><strong>perspective</strong><span class="classifier">array_like</span></dt><dd><p>Perspective partition of matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">4x4 array</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dipy.core.geometry</span> <span class="k">as</span> <span class="nn">gm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">persp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M0</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">compose_matrix</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="compose-transformations">
<h3>compose_transformations<a class="headerlink" href="#compose-transformations" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.compose_transformations">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">compose_transformations</code><span class="sig-paren">(</span><em class="sig-param">*mats</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.compose_transformations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose multiple 4x4 affine transformations in one 4x4 matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mat1</strong><span class="classifier">array, (4, 4)</span></dt><dd></dd>
<dt><strong>mat2</strong><span class="classifier">array, (4, 4)</span></dt><dd></dd>
<dt><strong>…</strong></dt><dd></dd>
<dt><strong>matN</strong><span class="classifier">array, (4, 4)</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matN x … x mat2 x mat1</strong><span class="classifier">array, (4, 4)</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="decompose-matrix">
<h3>decompose_matrix<a class="headerlink" href="#decompose-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.decompose_matrix">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">decompose_matrix</code><span class="sig-paren">(</span><em class="sig-param">matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.decompose_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sequence of transformations from transformation matrix.</p>
<p>Code modified from the excellent work of Christoph Gohlke link provided
here: <a class="reference external" href="http://www.lfd.uci.edu/~gohlke/code/transformations.py.html">http://www.lfd.uci.edu/~gohlke/code/transformations.py.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">array_like</span></dt><dd><p>Non-degenerative homogeneous transformation matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>Three scaling factors.</p>
</dd>
<dt><strong>shear</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>Shear factors for x-y, x-z, y-z axes.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>Euler angles about static x, y, z axes.</p>
</dd>
<dt><strong>translate</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>Translation vector along x, y, z axes.</p>
</dd>
<dt><strong>perspective</strong><span class="classifier">ndarray</span></dt><dd><p>Perspective partition of matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If matrix is of wrong type or degenerative.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span> <span class="o">=</span> <span class="n">decompose_matrix</span><span class="p">(</span><span class="n">T0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="dist-to-corner">
<h3>dist_to_corner<a class="headerlink" href="#dist-to-corner" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.dist_to_corner">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">dist_to_corner</code><span class="sig-paren">(</span><em class="sig-param">affine</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.dist_to_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the maximal distance from the center to a corner of a voxel,
given an affine</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">4 by 4 array.</span></dt><dd><p>The spatial transformation from the measurement to the scanner space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dist: float</strong></dt><dd><p>The maximal distance to the corner of a voxel, given voxel size encoded
in the affine.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="euler-matrix">
<h3>euler_matrix<a class="headerlink" href="#euler-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.euler_matrix">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">euler_matrix</code><span class="sig-paren">(</span><em class="sig-param">ai</em>, <em class="sig-param">aj</em>, <em class="sig-param">ak</em>, <em class="sig-param">axes='sxyz'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.euler_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return homogeneous rotation matrix from Euler angles and axis sequence.</p>
<p>Code modified from the work of Christoph Gohlke link provided here
<a class="reference external" href="http://www.lfd.uci.edu/~gohlke/code/transformations.py.html">http://www.lfd.uci.edu/~gohlke/code/transformations.py.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ai, aj, ak</strong><span class="classifier">Euler’s roll, pitch and yaw angles</span></dt><dd></dd>
<dt><strong>axes</strong><span class="classifier">One of 24 axis sequences as string or encoded tuple</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">ndarray (4, 4)</span></dt><dd></dd>
<dt><strong>Code modified from the work of Christoph Gohlke link provided here</strong></dt><dd></dd>
<dt><strong>http://www.lfd.uci.edu/~gohlke/code/transformations.py.html</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;syxz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.34786452</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">0.383436184</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">,</span> <span class="n">ak</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">axes</span> <span class="ow">in</span> <span class="n">_AXES2TUPLE</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">_</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">,</span> <span class="n">ak</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">axes</span> <span class="ow">in</span> <span class="n">_TUPLE2AXES</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">_</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">,</span> <span class="n">ak</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="is-hemispherical">
<h3>is_hemispherical<a class="headerlink" href="#is-hemispherical" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.is_hemispherical">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">is_hemispherical</code><span class="sig-paren">(</span><em class="sig-param">vecs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.is_hemispherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether all points on a unit sphere lie in the same hemisphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vecs</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>2D numpy array with shape (N, 3) where N is the number of points.
All points must lie on the unit sphere.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_hemi</strong><span class="classifier">bool</span></dt><dd><p>If True, one can find a hemisphere that contains all the points.
If False, then the points do not lie in any hemisphere</p>
</dd>
<dt><strong>pole</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>If <cite>is_hemi == True</cite>, then pole is the “central” pole of the
input vectors. Otherwise, pole is the zero vector.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p><a class="reference external" href="https://rstudio-pubs-static.s3.amazonaws.com/27121_a22e51b47c544980bad594d5e0bb2d04.html">https://rstudio-pubs-static.s3.amazonaws.com/27121_a22e51b47c544980bad594d5e0bb2d04.html</a>  # noqa</p>
</dd></dl>

</div>
<div class="section" id="lambert-equal-area-projection-cart">
<h3>lambert_equal_area_projection_cart<a class="headerlink" href="#lambert-equal-area-projection-cart" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.lambert_equal_area_projection_cart">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">lambert_equal_area_projection_cart</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.lambert_equal_area_projection_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Lambert Equal Area Projection from cartesian vector to plane</p>
<p>Return positions in <span class="math notranslate nohighlight">\((y_1,y_2)\)</span> plane corresponding to the
directions of the vectors with cartesian coordinates xyz under the
Lambert Equal Area Projection mapping (see Mardia and Jupp (2000),
Directional Statistics, p. 161).</p>
<p>The Lambert EAP maps the upper hemisphere to the planar disc of radius 1
and the lower hemisphere to the planar annulus between radii 1 and 2,
The Lambert EAP maps the upper hemisphere to the planar disc of radius 1
and the lower hemisphere to the planar annulus between radii 1 and 2.
and <em>vice versa</em>.</p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>x coordinate in Cartesion space</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong><span class="classifier">array_like</span></dt><dd><p>z coordinate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">(N,2) array</span></dt><dd><p>planar coordinates of points following mapping by Lambert’s EAP.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="lambert-equal-area-projection-polar">
<h3>lambert_equal_area_projection_polar<a class="headerlink" href="#lambert-equal-area-projection-polar" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.lambert_equal_area_projection_polar">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">lambert_equal_area_projection_polar</code><span class="sig-paren">(</span><em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.lambert_equal_area_projection_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Lambert Equal Area Projection from polar sphere to plane</p>
<p>Return positions in (y1,y2) plane corresponding to the points
with polar coordinates (theta, phi) on the unit sphere, under the
Lambert Equal Area Projection mapping (see Mardia and Jupp (2000),
Directional Statistics, p. 161).</p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(0 \le \theta \le \pi\)</span> and <span class="math notranslate nohighlight">\(0 \le \phi \le 2 \pi\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|(y_1,y_2)| \le 2\)</span></p></li>
</ul>
<p>The Lambert EAP maps the upper hemisphere to the planar disc of radius 1
and the lower hemisphere to the planar annulus between radii 1 and 2,
and <em>vice versa</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">array_like</span></dt><dd><p>theta spherical coordinates</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array_like</span></dt><dd><p>phi spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">(N,2) array</span></dt><dd><p>planar coordinates of points following mapping by Lambert’s EAP.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="nearest-pos-semi-def">
<h3>nearest_pos_semi_def<a class="headerlink" href="#nearest-pos-semi-def" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.nearest_pos_semi_def">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">nearest_pos_semi_def</code><span class="sig-paren">(</span><em class="sig-param">B</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.nearest_pos_semi_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Least squares positive semi-definite tensor estimation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>B</strong><span class="classifier">(3,3) array_like</span></dt><dd><p>B matrix - symmetric. We do not check the symmetry.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>npds</strong><span class="classifier">(3,3) array</span></dt><dd><p>Estimated nearest positive semi-definite array to matrix <cite>B</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r3ce6ea211245-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Niethammer M, San Jose Estepar R, Bouix S, Shenton M, Westin CF.
On diffusion tensor estimation. Conf Proc IEEE Eng Med Biol Soc.
2006;1:2622-5. PubMed PMID: 17946125; PubMed Central PMCID:
PMC2791793.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nearest_pos_semi_def</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">array([[ 0.75,  0.  ,  0.  ],</span>
<span class="go">       [ 0.  ,  0.75,  0.  ],</span>
<span class="go">       [ 0.  ,  0.  ,  0.  ]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="normalized-vector">
<h3>normalized_vector<a class="headerlink" href="#normalized-vector" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.normalized_vector">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">normalized_vector</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.normalized_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector divided by its Euclidean (L2) norm</p>
<p>See <a class="reference internal" href="../glossary.html#term-unit-vector"><span class="xref std std-term">unit vector</span></a> and <a class="reference internal" href="../glossary.html#term-euclidean-norm"><span class="xref std std-term">Euclidean norm</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vec</strong><span class="classifier">array_like shape (3,)</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nvec</strong><span class="classifier">array shape (3,)</span></dt><dd><p>vector divided by L2 norm</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l2n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">vec</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nvec</span> <span class="o">=</span> <span class="n">normalized_vector</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">l2n</span><span class="p">,</span> <span class="n">nvec</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalized_vector</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="perpendicular-directions">
<h3>perpendicular_directions<a class="headerlink" href="#perpendicular-directions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.perpendicular_directions">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">perpendicular_directions</code><span class="sig-paren">(</span><em class="sig-param">v</em>, <em class="sig-param">num=30</em>, <em class="sig-param">half=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.perpendicular_directions" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes n evenly spaced perpendicular directions relative to a given
vector v</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">array (3,)</span></dt><dd><p>Array containing the three cartesian coordinates of vector v</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Number of perpendicular directions to generate</p>
</dd>
<dt><strong>half</strong><span class="classifier">bool, optional</span></dt><dd><p>If half is True, perpendicular directions are sampled on half of the
unit circumference perpendicular to v, otherwive perpendicular
directions are sampled on the full circumference. Default of half is
False</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>psamples</strong><span class="classifier">array (n, 3)</span></dt><dd><p>array of vectors perpendicular to v</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Perpendicular directions are estimated using the following two step
procedure:</p>
<blockquote>
<div><p>1) the perpendicular directions are first sampled in a unit
circumference parallel to the plane normal to the x-axis.</p>
<p>2) Samples are then rotated and aligned to the plane normal to vector
v. The rotational matrix for this rotation is constructed as reference
frame basis which axis are the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>The first axis is vector v</p></li>
<li><p>The second axis is defined as the normalized vector given by the</p></li>
</ul>
<p>cross product between vector v and the unit vector aligned to the
x-axis
- The third axis is defined as the cross product between the
previous computed vector and vector v.</p>
</div></blockquote>
</div></blockquote>
<p>Following this two steps, coordinates of the final perpendicular directions
are given as:</p>
<div class="math notranslate nohighlight">
\[\left [ -\sin(a_{i}) \sqrt{{v_{y}}^{2}+{v_{z}}^{2}}
\; , \;
\frac{v_{x}v_{y}\sin(a_{i})-v_{z}\cos(a_{i})}
{\sqrt{{v_{y}}^{2}+{v_{z}}^{2}}}
\; , \;
\frac{v_{x}v_{z}\sin(a_{i})-v_{y}\cos(a_{i})}
{\sqrt{{v_{y}}^{2}+{v_{z}}^{2}}} \right  ]\]</div>
<p>This procedure has a singularity when vector v is aligned to the x-axis. To
solve this singularity, perpendicular directions in procedure’s step 1 are
defined in the plane normal to y-axis and the second axis of the rotated
frame of reference is computed as the normalized vector given by the cross
product between vector v and the unit vector aligned to the y-axis.
Following this, the coordinates of the perpendicular directions are given
as:</p>
<blockquote>
<div><p>left [ -frac{left (v_{x}v_{y}sin(a_{i})+v_{z}cos(a_{i}) right )}
{sqrt{{v_{x}}^{2}+{v_{z}}^{2}}}
; , ;
sin(a_{i}) sqrt{{v_{x}}^{2}+{v_{z}}^{2}}
; , ;
frac{v_{y}v_{z}sin(a_{i})+v_{x}cos(a_{i})}
{sqrt{{v_{x}}^{2}+{v_{z}}^{2}}} right  ]</p>
</div></blockquote>
<p>For more details on this calculation, see ` here &lt;<a class="reference external" href="http://gsoc2015dipydki.blogspot.it/2015/07/rnh-post-8-computing-perpendicular.html">http://gsoc2015dipydki.blogspot.it/2015/07/rnh-post-8-computing-perpendicular.html</a>&gt;`_.</p>
</dd></dl>

</div>
<div class="section" id="rodrigues-axis-rotation">
<h3>rodrigues_axis_rotation<a class="headerlink" href="#rodrigues-axis-rotation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.rodrigues_axis_rotation">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">rodrigues_axis_rotation</code><span class="sig-paren">(</span><em class="sig-param">r</em>, <em class="sig-param">theta</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.rodrigues_axis_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Rodrigues formula</p>
<p>Rotation matrix for rotation around axis r for angle theta.</p>
<p>The rotation matrix is given by the Rodrigues formula:</p>
<p>R = Id + sin(theta)*Sn + (1-cos(theta))*Sn^2</p>
<p>with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>       <span class="mi">0</span>  <span class="o">-</span><span class="n">nz</span>  <span class="n">ny</span>
<span class="n">Sn</span> <span class="o">=</span>   <span class="n">nz</span>   <span class="mi">0</span> <span class="o">-</span><span class="n">nx</span>
      <span class="o">-</span><span class="n">ny</span>  <span class="n">nx</span>   <span class="mi">0</span>
</pre></div>
</div>
<p>where n = r / ||r||</p>
<p>In case the angle ||r|| is very small, the above formula may lead
to numerical instabilities. We instead use a Taylor expansion
around theta=0:</p>
<p>R = I + sin(theta)/tetha Sr + (1-cos(theta))/teta2 Sr^2</p>
<p>leading to:</p>
<p>R = I + (1-theta2/6)*Sr + (1/2-theta2/24)*Sr^2</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>r</strong><span class="classifier">array_like shape (3,), axis</span></dt><dd></dd>
<dt><strong>theta</strong><span class="classifier">float, angle in degrees</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">array, shape (3,3), rotation matrix</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.geometry</span> <span class="k">import</span> <span class="n">rodrigues_axis_rotation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">=</span><span class="n">rodrigues_axis_rotation</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">40</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ur</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ur</span><span class="p">,</span><span class="n">u</span><span class="p">))))</span>
<span class="go">40.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sph2latlon">
<h3>sph2latlon<a class="headerlink" href="#sph2latlon" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.sph2latlon">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">sph2latlon</code><span class="sig-paren">(</span><em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.sph2latlon" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert spherical coordinates to latitude and longitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lat, lon</strong><span class="classifier">ndarray</span></dt><dd><p>Latitude and longitude.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="sphere2cart">
<h3>sphere2cart<a class="headerlink" href="#sphere2cart" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.sphere2cart">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">sphere2cart</code><span class="sig-paren">(</span><em class="sig-param">r</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.sphere2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical to Cartesian coordinates</p>
<p>This is the standard physics convention where <cite>theta</cite> is the
inclination (polar) angle, and <cite>phi</cite> is the azimuth angle.</p>
<p>Imagine a sphere with center (0,0,0).  Orient it with the z axis
running south-north, the y axis running west-east and the x axis
from posterior to anterior.  <cite>theta</cite> (the inclination angle) is the
angle to rotate from the z-axis (the zenith) around the y-axis,
towards the x axis.  Thus the rotation is counter-clockwise from the
point of view of positive y.  <cite>phi</cite> (azimuth) gives the angle of
rotation around the z-axis towards the y axis.  The rotation is
counter-clockwise from the point of view of positive z.</p>
<p>Equivalently, given a point P on the sphere, with coordinates x, y,
z, <cite>theta</cite> is the angle between P and the z-axis, and <cite>phi</cite> is
the angle between the projection of P onto the XY plane, and the X
axis.</p>
<p>Geographical nomenclature designates theta as ‘co-latitude’, and phi
as ‘longitude’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>r</strong><span class="classifier">array_like</span></dt><dd><p>radius</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like</span></dt><dd><p>inclination or polar angle</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array_like</span></dt><dd><p>azimuth angle</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array</span></dt><dd><p>x coordinate(s) in Cartesion space</p>
</dd>
<dt><strong>y</strong><span class="classifier">array</span></dt><dd><p>y coordinate(s) in Cartesian space</p>
</dd>
<dt><strong>z</strong><span class="classifier">array</span></dt><dd><p>z coordinate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See these pages:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Spherical_coordinate_system">http://en.wikipedia.org/wiki/Spherical_coordinate_system</a></p></li>
<li><p><a class="reference external" href="http://mathworld.wolfram.com/SphericalCoordinates.html">http://mathworld.wolfram.com/SphericalCoordinates.html</a></p></li>
</ul>
<p>for excellent discussion of the many different conventions
possible.  Here we use the physics conventions, used in the
wikipedia page.</p>
<p>Derivations of the formulae are simple. Consider a vector x, y, z of
length r (norm of x, y, z).  The inclination angle (theta) can be
found from: cos(theta) == z / r -&gt; z == r * cos(theta).  This gives
the hypotenuse of the projection onto the XY plane, which we will
call Q. Q == r*sin(theta). Now x / Q == cos(phi) -&gt; x == r *
sin(theta) * cos(phi) and so on.</p>
<p>We have deliberately named this function <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">sph2cart</span></code> to distinguish it from the Matlab function of that
name, because the Matlab function uses an unusual convention for the
angles that we did not want to replicate.  The Matlab function is
trivial to implement with the formulae given in the Matlab help.</p>
</dd></dl>

</div>
<div class="section" id="sphere-distance">
<h3>sphere_distance<a class="headerlink" href="#sphere-distance" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.sphere_distance">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">sphere_distance</code><span class="sig-paren">(</span><em class="sig-param">pts1</em>, <em class="sig-param">pts2</em>, <em class="sig-param">radius=None</em>, <em class="sig-param">check_radius=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.sphere_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance across sphere surface between <cite>pts1</cite> and <cite>pts2</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pts1</strong><span class="classifier">(N,R) or (R,) array_like</span></dt><dd><p>where N is the number of points and R is the number of
coordinates defining a point (<code class="docutils literal notranslate"><span class="pre">R==3</span></code> for 3D)</p>
</dd>
<dt><strong>pts2</strong><span class="classifier">(N,R) or (R,) array_like</span></dt><dd><p>where N is the number of points and R is the number of
coordinates defining a point (<code class="docutils literal notranslate"><span class="pre">R==3</span></code> for 3D).  It should be
possible to broadcast <cite>pts1</cite> against <cite>pts2</cite></p>
</dd>
<dt><strong>radius</strong><span class="classifier">None or float, optional</span></dt><dd><p>Radius of sphere.  Default is to work out radius from mean of the
length of each point vector</p>
</dd>
<dt><strong>check_radius</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, check if the points are on the sphere surface - i.e
check if the vector lengths in <cite>pts1</cite> and <cite>pts2</cite> are close to
<cite>radius</cite>.  Default is True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d</strong><span class="classifier">(N,) or (0,) array</span></dt><dd><p>Distances between corresponding points in <cite>pts1</cite> and <cite>pts2</cite>
across the spherical surface, i.e. the great circle distance</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dipy.core.geometry.cart_distance" title="dipy.core.geometry.cart_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart_distance</span></code></a></dt><dd><p>cartesian distance between points</p>
</dd>
<dt><a class="reference internal" href="#dipy.core.geometry.vector_cosine" title="dipy.core.geometry.vector_cosine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_cosine</span></code></a></dt><dd><p>cosine of angle between vectors</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.4f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sphere_distance</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">1.5708</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.4f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sphere_distance</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">4.7124</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="vec2vec-rotmat">
<h3>vec2vec_rotmat<a class="headerlink" href="#vec2vec-rotmat" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.vec2vec_rotmat">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">vec2vec_rotmat</code><span class="sig-paren">(</span><em class="sig-param">u</em>, <em class="sig-param">v</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.vec2vec_rotmat" title="Permalink to this definition">¶</a></dt>
<dd><p>rotation matrix from 2 unit vectors</p>
<p>u, v being unit 3d vectors return a 3x3 rotation matrix R than aligns u to
v.</p>
<p>In general there are many rotations that will map u to v. If S is any
rotation using v as an axis then R.S will also map u to v since (S.R)u =
S(Ru) = Sv = v.  The rotation R returned by vec2vec_rotmat leaves fixed the
perpendicular to the plane spanned by u and v.</p>
<p>The transpose of R will align v to u.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u</strong><span class="classifier">array, shape(3,)</span></dt><dd></dd>
<dt><strong>v</strong><span class="classifier">array, shape(3,)</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">array, shape(3,3)</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.geometry</span> <span class="k">import</span> <span class="n">vec2vec_rotmat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">=</span><span class="n">vec2vec_rotmat</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
<span class="go">array([ 1.,  0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="vector-cosine">
<h3>vector_cosine<a class="headerlink" href="#vector-cosine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.vector_cosine">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">vector_cosine</code><span class="sig-paren">(</span><em class="sig-param">vecs1</em>, <em class="sig-param">vecs2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.vector_cosine" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine of angle between two (sets of) vectors</p>
<p>The cosine of the angle between two vectors <code class="docutils literal notranslate"><span class="pre">v1</span></code> and <code class="docutils literal notranslate"><span class="pre">v2</span></code> is
given by the inner product of <code class="docutils literal notranslate"><span class="pre">v1</span></code> and <code class="docutils literal notranslate"><span class="pre">v2</span></code> divided by the
product of the vector lengths:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v2</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vecs1</strong><span class="classifier">(N, R) or (R,) array_like</span></dt><dd><p>N vectors (as rows) or single vector.  Vectors have R elements.</p>
</dd>
<dt><strong>vecs1</strong><span class="classifier">(N, R) or (R,) array_like</span></dt><dd><p>N vectors (as rows) or single vector.  Vectors have R elements.
It should be possible to broadcast <cite>vecs1</cite> against <cite>vecs2</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vcos</strong><span class="classifier">(N,) or (0,) array</span></dt><dd><p>Vector cosines.  To get the angles you will need <code class="docutils literal notranslate"><span class="pre">np.arccos</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The vector cosine will be the same as the correlation only if all
the input vectors have zero mean.</p>
</dd></dl>

</div>
<div class="section" id="vector-norm">
<h3>vector_norm<a class="headerlink" href="#vector-norm" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.geometry.vector_norm">
<code class="sig-prename descclassname">dipy.core.geometry.</code><code class="sig-name descname">vector_norm</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.geometry.vector_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector Euclidean (L2) norm</p>
<p>See <a class="reference internal" href="../glossary.html#term-unit-vector"><span class="xref std std-term">unit vector</span></a> and <a class="reference internal" href="../glossary.html#term-euclidean-norm"><span class="xref std std-term">Euclidean norm</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vec</strong><span class="classifier">array_like</span></dt><dd><p>Vectors to norm.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Axis over which to norm. By default norm over last axis. If <cite>axis</cite> is
None, <cite>vec</cite> is flattened then normed.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool</span></dt><dd><p>If True, the output will have the same number of dimensions as <cite>vec</cite>,
with shape 1 on <cite>axis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">array</span></dt><dd><p>Euclidean norms of vectors.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">77</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="go">array([ 17.,  85.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 17.],</span>
<span class="go">       [ 85.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([  8.,  39.,  77.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gradienttable">
<h3><a class="reference internal" href="#dipy.core.gradients.GradientTable" title="dipy.core.gradients.GradientTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientTable</span></code></a><a class="headerlink" href="#gradienttable" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.gradients.GradientTable">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">GradientTable</code><span class="sig-paren">(</span><em class="sig-param">gradients</em>, <em class="sig-param">big_delta=None</em>, <em class="sig-param">small_delta=None</em>, <em class="sig-param">b0_threshold=50</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.GradientTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Diffusion gradient information</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gradients</strong><span class="classifier">array_like (N, 3)</span></dt><dd><p>Diffusion gradients. The direction of each of these vectors corresponds
to the b-vector, and the length corresponds to the b-value.</p>
</dd>
<dt><strong>b0_threshold</strong><span class="classifier">float</span></dt><dd><p>Gradients with b-value less than or equal to <cite>b0_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dipy.core.gradients.gradient_table" title="dipy.core.gradients.gradient_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The GradientTable object is immutable. Do NOT assign attributes.
If you have your gradient table in a bval &amp; bvec format, we recommend
using the factory function gradient_table</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gradients</strong><span class="classifier">(N,3) ndarray</span></dt><dd><p>diffusion gradients</p>
</dd>
<dt><strong>bvals</strong><span class="classifier">(N,) ndarray</span></dt><dd><p>The b-value, or magnitude, of each gradient direction.</p>
</dd>
<dt><strong>qvals: (N,) ndarray</strong></dt><dd><p>The q-value for each gradient direction. Needs big and small
delta.</p>
</dd>
<dt><strong>bvecs</strong><span class="classifier">(N,3) ndarray</span></dt><dd><p>The direction, represented as a unit vector, of each gradient.</p>
</dd>
<dt><strong>b0s_mask</strong><span class="classifier">(N,) ndarray</span></dt><dd><p>Boolean array indicating which gradients have no diffusion
weighting, ie b-value is close to 0.</p>
</dd>
<dt><strong>b0_threshold</strong><span class="classifier">float</span></dt><dd><p>Gradients with b-value less than or equal to <cite>b0_threshold</cite> are
considered to not have diffusion weighting.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 68%" />
<col style="width: 32%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>b0s_mask</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>bvals</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>bvecs</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>gradient_strength</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>qvals</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>tau</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.gradients.GradientTable.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">gradients</em>, <em class="sig-param">big_delta=None</em>, <em class="sig-param">small_delta=None</em>, <em class="sig-param">b0_threshold=50</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.GradientTable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for GradientTable class</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.GradientTable.b0s_mask">
<code class="sig-name descname">b0s_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.GradientTable.b0s_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.GradientTable.bvals">
<code class="sig-name descname">bvals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.GradientTable.bvals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.GradientTable.bvecs">
<code class="sig-name descname">bvecs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.GradientTable.bvecs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.GradientTable.gradient_strength">
<code class="sig-name descname">gradient_strength</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.GradientTable.gradient_strength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.GradientTable.info">
<em class="property">property </em><code class="sig-name descname">info</code><a class="headerlink" href="#dipy.core.gradients.GradientTable.info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.GradientTable.qvals">
<code class="sig-name descname">qvals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.GradientTable.qvals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.GradientTable.tau">
<code class="sig-name descname">tau</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.GradientTable.tau" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="hemisphere">
<h3><a class="reference internal" href="#dipy.core.gradients.HemiSphere" title="dipy.core.gradients.HemiSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">HemiSphere</span></code></a><a class="headerlink" href="#hemisphere" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.gradients.HemiSphere">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">HemiSphere</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">phi=None</em>, <em class="sig-param">xyz=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">edges=None</em>, <em class="sig-param">tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.HemiSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.core.sphere.Sphere" title="dipy.core.sphere.Sphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.core.sphere.Sphere</span></code></a></p>
<p>Points on the unit sphere.</p>
<p>A HemiSphere is similar to a Sphere but it takes antipodal symmetry into
account. Antipodal symmetry means that point v on a HemiSphere is the same
as the point -v. Duplicate points are discarded when constructing a
HemiSphere (including antipodal duplicates). <cite>edges</cite> and <cite>faces</cite> are
remapped to the remaining points as closely as possible.</p>
<p>The HemiSphere can be constructed using one of three conventions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">HemiSphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">HemiSphere</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">HemiSphere</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x, y, z</strong><span class="classifier">1-D array_like</span></dt><dd><p>Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>theta, phi</strong><span class="classifier">1-D array_like</span></dt><dd><p>Vertices as spherical coordinates.  Theta and phi are the inclination
and azimuth angles respectively.</p>
</dd>
<dt><strong>xyz</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Indices into vertices that form triangular faces.  If unspecified,
the faces are computed using a Delaunay triangulation.</p>
</dd>
<dt><strong>edges</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Edges between vertices.  If unspecified, the edges are
derived from the faces.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Angle in degrees. Vertices that are less than tol degrees apart are
treated as duplicates.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sphere</span></code></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong></dt><dd></dd>
<dt><strong>y</strong></dt><dd></dd>
<dt><strong>z</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.HemiSphere.find_closest" title="dipy.core.gradients.HemiSphere.find_closest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_closest</span></code></a>(xyz)</p></td>
<td><p>Find the index of the vertex in the Sphere closest to the input vector, taking into account antipodal symmetry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.HemiSphere.from_sphere" title="dipy.core.gradients.HemiSphere.from_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_sphere</span></code></a>(sphere[, tol])</p></td>
<td><p>Create instance from a Sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.gradients.HemiSphere.mirror" title="dipy.core.gradients.HemiSphere.mirror"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mirror</span></code></a>()</p></td>
<td><p>Create a full Sphere from a HemiSphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.gradients.HemiSphere.subdivide" title="dipy.core.gradients.HemiSphere.subdivide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code></a>([n])</p></td>
<td><p>Create a more subdivided HemiSphere</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>edges</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>faces</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>vertices</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.gradients.HemiSphere.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">phi=None</em>, <em class="sig-param">xyz=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">edges=None</em>, <em class="sig-param">tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.HemiSphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a HemiSphere from points</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.HemiSphere.faces">
<code class="sig-name descname">faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.HemiSphere.faces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.HemiSphere.find_closest">
<code class="sig-name descname">find_closest</code><span class="sig-paren">(</span><em class="sig-param">xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.HemiSphere.find_closest" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the vertex in the Sphere closest to the input vector,
taking into account antipodal symmetry</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">array-like, 3 elements</span></dt><dd><p>A unit vector</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The index into the Sphere.vertices array that gives the closest
vertex (in angle).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.HemiSphere.from_sphere">
<em class="property">classmethod </em><code class="sig-name descname">from_sphere</code><span class="sig-paren">(</span><em class="sig-param">sphere</em>, <em class="sig-param">tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.HemiSphere.from_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create instance from a Sphere</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.HemiSphere.mirror">
<code class="sig-name descname">mirror</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.HemiSphere.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a full Sphere from a HemiSphere</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.gradients.HemiSphere.subdivide">
<code class="sig-name descname">subdivide</code><span class="sig-paren">(</span><em class="sig-param">n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.HemiSphere.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a more subdivided HemiSphere</p>
<p>See Sphere.subdivide for full documentation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="auto-attr">
<h3>auto_attr<a class="headerlink" href="#auto-attr" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.auto_attr">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">auto_attr</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.auto_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">method</span></dt><dd><p>The method that will be called the first time to compute a value.
Afterwards, the method’s name will be a standard attribute holding the
value of this computation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="check-multi-b">
<h3>check_multi_b<a class="headerlink" href="#check-multi-b" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.check_multi_b">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">check_multi_b</code><span class="sig-paren">(</span><em class="sig-param">gtab</em>, <em class="sig-param">n_bvals</em>, <em class="sig-param">non_zero=True</em>, <em class="sig-param">bmag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.check_multi_b" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if you have enough different b-values in your gradient table</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable class instance.</span></dt><dd></dd>
<dt><strong>n_bvals</strong><span class="classifier">int</span></dt><dd><p>The number of different b-values you are checking for.</p>
</dd>
<dt><strong>non_zero</strong><span class="classifier">bool</span></dt><dd><p>Whether to check only non-zero bvalues. In this case, we will require
at least <cite>n_bvals</cite> <em>non-zero</em> b-values (where non-zero is defined
depending on the <cite>gtab</cite> object’s <cite>b0_threshold</cite> attribute)</p>
</dd>
<dt><strong>bmag</strong><span class="classifier">int</span></dt><dd><p>The order of magnitude of the b-values used. The function will
normalize the b-values relative <span class="math notranslate nohighlight">\(10^{bmag}\)</span>. Default: derive this
value from the maximal b-value provided:
<span class="math notranslate nohighlight">\(bmag=log_{10}(max(bvals)) - 1\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>bool</strong><span class="classifier">Whether there are at least <cite>n_bvals</cite> different b-values in the</span></dt><dd></dd>
<dt><strong>gradient table used.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="disperse-charges">
<h3>disperse_charges<a class="headerlink" href="#disperse-charges" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.disperse_charges">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">disperse_charges</code><span class="sig-paren">(</span><em class="sig-param">hemi</em>, <em class="sig-param">iters</em>, <em class="sig-param">const=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.disperse_charges" title="Permalink to this definition">¶</a></dt>
<dd><p>Models electrostatic repulsion on the unit sphere</p>
<p>Places charges on a sphere and simulates the repulsive forces felt by each
one. Allows the charges to move for some number of iterations and returns
their final location as well as the total potential of the system at each
step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hemi</strong><span class="classifier">HemiSphere</span></dt><dd><p>Points on a unit sphere.</p>
</dd>
<dt><strong>iters</strong><span class="classifier">int</span></dt><dd><p>Number of iterations to run.</p>
</dd>
<dt><strong>const</strong><span class="classifier">float</span></dt><dd><p>Using a smaller const could provide a more accurate result, but will
need more iterations to converge.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hemi</strong><span class="classifier">HemiSphere</span></dt><dd><p>Distributed points on a unit sphere.</p>
</dd>
<dt><strong>potential</strong><span class="classifier">ndarray</span></dt><dd><p>The electrostatic potential at each iteration. This can be useful to
check if the repulsion converged to a minimum.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is meant to be used with diffusion imaging so antipodal
symmetry is assumed. Therefor each charge must not only be unique, but if
there is a charge at +x, there cannot be a charge at -x. These are treated
as the same location and because the distance between the two charges will
be zero, the result will be unstable.</p>
</dd></dl>

</div>
<div class="section" id="generate-bvecs">
<h3>generate_bvecs<a class="headerlink" href="#generate-bvecs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.generate_bvecs">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">generate_bvecs</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">iters=5000</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.generate_bvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates N bvectors.</p>
<p>Uses dipy.core.sphere.disperse_charges to model electrostatic repulsion on
a unit sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>The number of bvectors to generate. This should be equal to the number
of bvals used.</p>
</dd>
<dt><strong>iters</strong><span class="classifier">int</span></dt><dd><p>Number of iterations to run.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bvecs</strong><span class="classifier">(N,3) ndarray</span></dt><dd><p>The generated directions, represented as a unit vector, of each
gradient.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="gradient-table">
<h3>gradient_table<a class="headerlink" href="#gradient-table" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.gradient_table">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">gradient_table</code><span class="sig-paren">(</span><em class="sig-param">bvals</em>, <em class="sig-param">bvecs=None</em>, <em class="sig-param">big_delta=None</em>, <em class="sig-param">small_delta=None</em>, <em class="sig-param">b0_threshold=50</em>, <em class="sig-param">atol=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.gradient_table" title="Permalink to this definition">¶</a></dt>
<dd><p>A general function for creating diffusion MR gradients.</p>
<p>It reads, loads and prepares scanner parameters like the b-values and
b-vectors so that they can be useful during the reconstruction process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bvals</strong><span class="classifier">can be any of the four options</span></dt><dd><ol class="arabic simple">
<li><p>an array of shape (N,) or (1, N) or (N, 1) with the b-values.</p></li>
<li><p>a path for the file which contains an array like the above (1).</p></li>
<li><p>an array of shape (N, 4) or (4, N). Then this parameter is
considered to be a b-table which contains both bvals and bvecs. In
this case the next parameter is skipped.</p></li>
<li><p>a path for the file which contains an array like the one at (3).</p></li>
</ol>
</dd>
<dt><strong>bvecs</strong><span class="classifier">can be any of two options</span></dt><dd><ol class="arabic simple">
<li><p>an array of shape (N, 3) or (3, N) with the b-vectors.</p></li>
<li><p>a path for the file which contains an array like the previous.</p></li>
</ol>
</dd>
<dt><strong>big_delta</strong><span class="classifier">float</span></dt><dd><p>acquisition pulse separation time in seconds (default None)</p>
</dd>
<dt><strong>small_delta</strong><span class="classifier">float</span></dt><dd><p>acquisition pulse duration time in seconds (default None)</p>
</dd>
<dt><strong>b0_threshold</strong><span class="classifier">float</span></dt><dd><p>All b-values with values less than or equal to <cite>bo_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>All b-vectors need to be unit vectors up to a tolerance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gradients</strong><span class="classifier">GradientTable</span></dt><dd><p>A GradientTable with all the gradient information.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>Often b0s (b-values which correspond to images without diffusion
weighting) have 0 values however in some cases the scanner cannot
provide b0s of an exact 0 value and it gives a bit higher values
e.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</p></li>
<li><p>We assume that the minimum number of b-values is 7.</p></li>
<li><p>B-vectors should be unit vectors.</p></li>
</ol>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="k">import</span> <span class="n">gradient_table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span> <span class="o">=</span> <span class="mi">1500</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sq2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gradient-table-from-bvals-bvecs">
<h3>gradient_table_from_bvals_bvecs<a class="headerlink" href="#gradient-table-from-bvals-bvecs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.gradient_table_from_bvals_bvecs">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">gradient_table_from_bvals_bvecs</code><span class="sig-paren">(</span><em class="sig-param">bvals</em>, <em class="sig-param">bvecs</em>, <em class="sig-param">b0_threshold=50</em>, <em class="sig-param">atol=0.01</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.gradient_table_from_bvals_bvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a GradientTable from a bvals array and a bvecs array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bvals</strong><span class="classifier">array_like (N,)</span></dt><dd><p>The b-value, or magnitude, of each gradient direction.</p>
</dd>
<dt><strong>bvecs</strong><span class="classifier">array_like (N, 3)</span></dt><dd><p>The direction, represented as a unit vector, of each gradient.</p>
</dd>
<dt><strong>b0_threshold</strong><span class="classifier">float</span></dt><dd><p>Gradients with b-value less than or equal to <cite>bo_threshold</cite> are
considered to not have diffusion weighting.</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Each vector in <cite>bvecs</cite> must be a unit vectors up to a tolerance of
<cite>atol</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gradients</strong><span class="classifier">GradientTable</span></dt><dd><p>A GradientTable with all the gradient information.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Other keyword inputs are passed to GradientTable.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dipy.core.gradients.GradientTable" title="dipy.core.gradients.GradientTable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GradientTable</span></code></a>, <a class="reference internal" href="#dipy.core.gradients.gradient_table" title="dipy.core.gradients.gradient_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="gradient-table-from-gradient-strength-bvecs">
<h3>gradient_table_from_gradient_strength_bvecs<a class="headerlink" href="#gradient-table-from-gradient-strength-bvecs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.gradient_table_from_gradient_strength_bvecs">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">gradient_table_from_gradient_strength_bvecs</code><span class="sig-paren">(</span><em class="sig-param">gradient_strength</em>, <em class="sig-param">bvecs</em>, <em class="sig-param">big_delta</em>, <em class="sig-param">small_delta</em>, <em class="sig-param">b0_threshold=50</em>, <em class="sig-param">atol=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.gradient_table_from_gradient_strength_bvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>A general function for creating diffusion MR gradients.</p>
<p>It reads, loads and prepares scanner parameters like the b-values and
b-vectors so that they can be useful during the reconstruction process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gradient_strength</strong><span class="classifier">an array of shape (N,),</span></dt><dd><p>gradient strength given in T/mm</p>
</dd>
<dt><strong>bvecs</strong><span class="classifier">can be any of two options</span></dt><dd><ol class="arabic simple">
<li><p>an array of shape (N, 3) or (3, N) with the b-vectors.</p></li>
<li><p>a path for the file which contains an array like the previous.</p></li>
</ol>
</dd>
<dt><strong>big_delta</strong><span class="classifier">float or array of shape (N,)</span></dt><dd><p>acquisition pulse separation time in seconds</p>
</dd>
<dt><strong>small_delta</strong><span class="classifier">float</span></dt><dd><p>acquisition pulse duration time in seconds</p>
</dd>
<dt><strong>b0_threshold</strong><span class="classifier">float</span></dt><dd><p>All b-values with values less than or equal to <cite>bo_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>All b-vectors need to be unit vectors up to a tolerance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gradients</strong><span class="classifier">GradientTable</span></dt><dd><p>A GradientTable with all the gradient information.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>Often b0s (b-values which correspond to images without diffusion
weighting) have 0 values however in some cases the scanner cannot
provide b0s of an exact 0 value and it gives a bit higher values
e.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</p></li>
<li><p>We assume that the minimum number of b-values is 7.</p></li>
<li><p>B-vectors should be unit vectors.</p></li>
</ol>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="k">import</span> <span class="p">(</span>
<span class="gp">... </span>   <span class="n">gradient_table_from_gradient_strength_bvecs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient_strength</span> <span class="o">=</span> <span class="o">.</span><span class="mf">03e-3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>  <span class="c1"># clinical strength at 30 mT/m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big_delta</span> <span class="o">=</span> <span class="o">.</span><span class="mi">03</span>  <span class="c1"># pulse separation of 30ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_delta</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># pulse duration of 10ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient_strength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sq2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table_from_gradient_strength_bvecs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">gradient_strength</span><span class="p">,</span> <span class="n">bvecs</span><span class="p">,</span> <span class="n">big_delta</span><span class="p">,</span> <span class="n">small_delta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gradient-table-from-qvals-bvecs">
<h3>gradient_table_from_qvals_bvecs<a class="headerlink" href="#gradient-table-from-qvals-bvecs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.gradient_table_from_qvals_bvecs">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">gradient_table_from_qvals_bvecs</code><span class="sig-paren">(</span><em class="sig-param">qvals</em>, <em class="sig-param">bvecs</em>, <em class="sig-param">big_delta</em>, <em class="sig-param">small_delta</em>, <em class="sig-param">b0_threshold=50</em>, <em class="sig-param">atol=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.gradient_table_from_qvals_bvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>A general function for creating diffusion MR gradients.</p>
<p>It reads, loads and prepares scanner parameters like the b-values and
b-vectors so that they can be useful during the reconstruction process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qvals</strong><span class="classifier">an array of shape (N,),</span></dt><dd><p>q-value given in 1/mm</p>
</dd>
<dt><strong>bvecs</strong><span class="classifier">can be any of two options</span></dt><dd><ol class="arabic simple">
<li><p>an array of shape (N, 3) or (3, N) with the b-vectors.</p></li>
<li><p>a path for the file which contains an array like the previous.</p></li>
</ol>
</dd>
<dt><strong>big_delta</strong><span class="classifier">float or array of shape (N,)</span></dt><dd><p>acquisition pulse separation time in seconds</p>
</dd>
<dt><strong>small_delta</strong><span class="classifier">float</span></dt><dd><p>acquisition pulse duration time in seconds</p>
</dd>
<dt><strong>b0_threshold</strong><span class="classifier">float</span></dt><dd><p>All b-values with values less than or equal to <cite>bo_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>All b-vectors need to be unit vectors up to a tolerance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gradients</strong><span class="classifier">GradientTable</span></dt><dd><p>A GradientTable with all the gradient information.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>Often b0s (b-values which correspond to images without diffusion
weighting) have 0 values however in some cases the scanner cannot
provide b0s of an exact 0 value and it gives a bit higher values
e.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</p></li>
<li><p>We assume that the minimum number of b-values is 7.</p></li>
<li><p>B-vectors should be unit vectors.</p></li>
</ol>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="k">import</span> <span class="n">gradient_table_from_qvals_bvecs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qvals</span> <span class="o">=</span> <span class="mf">30.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big_delta</span> <span class="o">=</span> <span class="o">.</span><span class="mi">03</span>  <span class="c1"># pulse separation of 30ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_delta</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># pulse duration of 10ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sq2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table_from_qvals_bvecs</span><span class="p">(</span><span class="n">qvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">big_delta</span><span class="p">,</span> <span class="n">small_delta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="inv">
<h3>inv<a class="headerlink" href="#inv" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.inv">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">inv</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">overwrite_a=False</em>, <em class="sig-param">check_finite=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of a matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Square matrix to be inverted.</p>
</dd>
<dt><strong>overwrite_a</strong><span class="classifier">bool, optional</span></dt><dd><p>Discard data in <cite>a</cite> (may improve performance). Default is False.</p>
</dd>
<dt><strong>check_finite</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ainv</strong><span class="classifier">ndarray</span></dt><dd><p>Inverse of the matrix <cite>a</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>LinAlgError</strong></dt><dd><p>If <cite>a</cite> is singular.</p>
</dd>
<dt><strong>ValueError</strong></dt><dd><p>If <cite>a</cite> is not square, or not 2-dimensional.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[-2. ,  1. ],</span>
<span class="go">       [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="polar">
<h3>polar<a class="headerlink" href="#polar" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.polar">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">polar</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">side='right'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the polar decomposition.</p>
<p>Returns the factors of the polar decomposition <a class="reference internal" href="#rd4832748c26d-1" id="id2">[1]</a> <cite>u</cite> and <cite>p</cite> such
that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">up</span></code> (if <cite>side</cite> is “right”) or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">pu</span></code> (if <cite>side</cite> is
“left”), where <cite>p</cite> is positive semidefinite.  Depending on the shape
of <cite>a</cite>, either the rows or columns of <cite>u</cite> are orthonormal.  When <cite>a</cite>
is a square array, <cite>u</cite> is a square unitary array.  When <cite>a</cite> is not
square, the “canonical polar decomposition” <a class="reference internal" href="#rd4832748c26d-2" id="id3">[2]</a> is computed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(m, n) array_like</span></dt><dd><p>The array to be factored.</p>
</dd>
<dt><strong>side</strong><span class="classifier">{‘left’, ‘right’}, optional</span></dt><dd><p>Determines whether a right or left polar decomposition is computed.
If <cite>side</cite> is “right”, then <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">up</span></code>.  If <cite>side</cite> is “left”,  then
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">pu</span></code>.  The default is “right”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">(m, n) ndarray</span></dt><dd><p>If <cite>a</cite> is square, then <cite>u</cite> is unitary.  If m &gt; n, then the columns
of <cite>a</cite> are orthonormal, and if m &lt; n, then the rows of <cite>u</cite> are
orthonormal.</p>
</dd>
<dt><strong>p</strong><span class="classifier">ndarray</span></dt><dd><p><cite>p</cite> is Hermitian positive semidefinite.  If <cite>a</cite> is nonsingular, <cite>p</cite>
is positive definite.  The shape of <cite>p</cite> is (n, n) or (m, m), depending
on whether <cite>side</cite> is “right” or “left”, respectively.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd4832748c26d-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id4">2</a>)</span></dt>
<dd><p>R. A. Horn and C. R. Johnson, “Matrix Analysis”, Cambridge
University Press, 1985.</p>
</dd>
<dt class="label" id="rd4832748c26d-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p>N. J. Higham, “Functions of Matrices: Theory and Computation”,
SIAM, 2008.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">polar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([[ 0.85749293, -0.51449576],</span>
<span class="go">       [ 0.51449576,  0.85749293]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">array([[ 1.88648444,  1.2004901 ],</span>
<span class="go">       [ 1.2004901 ,  3.94446746]])</span>
</pre></div>
</div>
<p>A non-square example, with m &lt; n:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([[-0.21196618, -0.42393237,  0.88054056],</span>
<span class="go">       [ 0.39378971,  0.78757942,  0.4739708 ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">array([[ 0.48470147,  0.96940295,  1.15122648],</span>
<span class="go">       [ 0.96940295,  1.9388059 ,  2.30245295],</span>
<span class="go">       [ 1.15122648,  2.30245295,  3.65696431]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>   <span class="c1"># Verify the decomposition.</span>
<span class="go">array([[ 0.5,  1. ,  2. ],</span>
<span class="go">       [ 1.5,  3. ,  4. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>   <span class="c1"># The rows of u are orthonormal.</span>
<span class="go">array([[  1.00000000e+00,  -2.07353665e-17],</span>
<span class="go">       [ -2.07353665e-17,   1.00000000e+00]])</span>
</pre></div>
</div>
<p>Another non-square example, with m &gt; n:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([[-0.21196618,  0.39378971],</span>
<span class="go">       [-0.42393237,  0.78757942],</span>
<span class="go">       [ 0.88054056,  0.4739708 ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">array([[ 1.23116567,  1.93241587],</span>
<span class="go">       [ 1.93241587,  4.84930602]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>   <span class="c1"># Verify the decomposition.</span>
<span class="go">array([[ 0.5,  1.5],</span>
<span class="go">       [ 1. ,  3. ],</span>
<span class="go">       [ 2. ,  4. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>  <span class="c1"># The columns of u are orthonormal.</span>
<span class="go">array([[  1.00000000e+00,  -1.26363763e-16],</span>
<span class="go">       [ -1.26363763e-16,   1.00000000e+00]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="reorient-bvecs">
<h3>reorient_bvecs<a class="headerlink" href="#reorient-bvecs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.reorient_bvecs">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">reorient_bvecs</code><span class="sig-paren">(</span><em class="sig-param">gtab</em>, <em class="sig-param">affines</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.reorient_bvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorient the directions in a GradientTable.</p>
<p>When correcting for motion, rotation of the diffusion-weighted volumes
might cause systematic bias in rotationally invariant measures, such as FA
and MD, and also cause characteristic biases in tractography, unless the
gradient directions are appropriately reoriented to compensate for this
effect <a class="reference internal" href="#re5af466232f4-leemans2009" id="id6">[Leemans2009]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>The nominal gradient table with which the data were acquired.</p>
</dd>
<dt><strong>affines</strong><span class="classifier">list or ndarray of shape (n, 4, 4) or (n, 3, 3)</span></dt><dd><p>Each entry in this list or array contain either an affine
transformation (4,4) or a rotation matrix (3, 3).
In both cases, the transformations encode the rotation that was applied
to the image corresponding to one of the non-zero gradient directions
(ordered according to their order in <cite>gtab.bvecs[~gtab.b0s_mask]</cite>)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance with the reoriented directions</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re5af466232f4-leemans2009"><span class="brackets">Leemans2009</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id7">2</a>)</span></dt>
<dd><p>The B-Matrix Must Be Rotated When Correcting for
Subject Motion in DTI Data. Leemans, A. and Jones, D.K. (2009).
MRM, 61: 1336-1349</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="round-bvals">
<h3>round_bvals<a class="headerlink" href="#round-bvals" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.round_bvals">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">round_bvals</code><span class="sig-paren">(</span><em class="sig-param">bvals</em>, <em class="sig-param">bmag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.round_bvals" title="Permalink to this definition">¶</a></dt>
<dd><p>“This function rounds the b-values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bvals</strong><span class="classifier">ndarray</span></dt><dd><p>Array containing the b-values</p>
</dd>
<dt><strong>bmag</strong><span class="classifier">int</span></dt><dd><p>The order of magnitude to round the b-values. If not given b-values
will be rounded relative to the order of magnitude
<span class="math notranslate nohighlight">\(bmag = (bmagmax - 1)\)</span>, where bmaxmag is the magnitude order of the
larger b-value.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——</strong></dt><dd></dd>
<dt><strong>rbvals</strong><span class="classifier">ndarray</span></dt><dd><p>Array containing the rounded b-values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="unique-bvals">
<h3>unique_bvals<a class="headerlink" href="#unique-bvals" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.unique_bvals">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">unique_bvals</code><span class="sig-paren">(</span><em class="sig-param">bvals</em>, <em class="sig-param">bmag=None</em>, <em class="sig-param">rbvals=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.unique_bvals" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gives the unique rounded b-values of the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bvals</strong><span class="classifier">ndarray</span></dt><dd><p>Array containing the b-values</p>
</dd>
<dt><strong>bmag</strong><span class="classifier">int</span></dt><dd><p>The order of magnitude that the bvalues have to differ to be
considered an unique b-value. B-values are also rounded up to
this order of magnitude. Default: derive this value from the
maximal b-value provided: <span class="math notranslate nohighlight">\(bmag=log_{10}(max(bvals)) - 1\)</span>.</p>
</dd>
<dt><strong>rbvals</strong><span class="classifier">bool, optional</span></dt><dd><p>If True function also returns all individual rounded b-values.
Default: False</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——</strong></dt><dd></dd>
<dt><strong>ubvals</strong><span class="classifier">ndarray</span></dt><dd><p>Array containing the rounded unique b-values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id8">
<h3>vector_norm<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.vector_norm">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">vector_norm</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.vector_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector Euclidean (L2) norm</p>
<p>See <a class="reference internal" href="../glossary.html#term-unit-vector"><span class="xref std std-term">unit vector</span></a> and <a class="reference internal" href="../glossary.html#term-euclidean-norm"><span class="xref std std-term">Euclidean norm</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vec</strong><span class="classifier">array_like</span></dt><dd><p>Vectors to norm.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Axis over which to norm. By default norm over last axis. If <cite>axis</cite> is
None, <cite>vec</cite> is flattened then normed.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool</span></dt><dd><p>If True, the output will have the same number of dimensions as <cite>vec</cite>,
with shape 1 on <cite>axis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">array</span></dt><dd><p>Euclidean norms of vectors.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">77</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="go">array([ 17.,  85.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 17.],</span>
<span class="go">       [ 85.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([  8.,  39.,  77.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="warn">
<h3>warn<a class="headerlink" href="#warn" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.gradients.warn">
<code class="sig-prename descclassname">dipy.core.gradients.</code><code class="sig-name descname">warn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.gradients.warn" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
<div class="section" id="graph">
<h3><a class="reference internal" href="#dipy.core.graph.Graph" title="dipy.core.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a><a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.graph.Graph">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.graph.</code><code class="sig-name descname">Graph</code><a class="headerlink" href="#dipy.core.graph.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A simple graph class</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 69%" />
<col style="width: 31%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>add_edge</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>add_node</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>all_paths</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>children</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>del_node</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>del_node_and_edges</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>down</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>down_short</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>parents</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>shortest_path</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>up</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>up_short</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.graph.Graph.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A graph class with nodes and edges :-)</p>
<p>This class allows us to:</p>
<ol class="arabic simple">
<li><p>find the shortest path</p></li>
<li><p>find all paths</p></li>
<li><p>add/delete nodes and edges</p></li>
<li><p>get parent &amp; children nodes</p></li>
</ol>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.graph</span> <span class="k">import</span> <span class="n">Graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">=</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">up_short</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;, &#39;b&#39;, &#39;a&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.add_edge">
<code class="sig-name descname">add_edge</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">m</em>, <em class="sig-param">ws=True</em>, <em class="sig-param">wp=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.add_edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.add_node">
<code class="sig-name descname">add_node</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">attr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.add_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.all_paths">
<code class="sig-name descname">all_paths</code><span class="sig-paren">(</span><em class="sig-param">graph</em>, <em class="sig-param">start</em>, <em class="sig-param">end=None</em>, <em class="sig-param">path=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.all_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.children">
<code class="sig-name descname">children</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.children" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.del_node">
<code class="sig-name descname">del_node</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.del_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.del_node_and_edges">
<code class="sig-name descname">del_node_and_edges</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.del_node_and_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.down">
<code class="sig-name descname">down</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.down" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.down_short">
<code class="sig-name descname">down_short</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.down_short" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.parents">
<code class="sig-name descname">parents</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.parents" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.shortest_path">
<code class="sig-name descname">shortest_path</code><span class="sig-paren">(</span><em class="sig-param">graph</em>, <em class="sig-param">start</em>, <em class="sig-param">end=None</em>, <em class="sig-param">path=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.up">
<code class="sig-name descname">up</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.up" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.graph.Graph.up_short">
<code class="sig-name descname">up_short</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.graph.Graph.up_short" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="histeq">
<h3>histeq<a class="headerlink" href="#histeq" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.histeq.histeq">
<code class="sig-prename descclassname">dipy.core.histeq.</code><code class="sig-name descname">histeq</code><span class="sig-paren">(</span><em class="sig-param">arr</em>, <em class="sig-param">num_bins=256</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.histeq.histeq" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an histogram equalization on <code class="docutils literal notranslate"><span class="pre">arr</span></code>.
This was taken from:
<a class="reference external" href="http://www.janeriksolem.net/2009/06/histogram-equalization-with-python-and.html">http://www.janeriksolem.net/2009/06/histogram-equalization-with-python-and.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">ndarray</span></dt><dd><p>Image on which to perform histogram equalization.</p>
</dd>
<dt><strong>num_bins</strong><span class="classifier">int</span></dt><dd><p>Number of bins used to construct the histogram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ndarray</span></dt><dd><p>Histogram equalized image.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="as-strided">
<h3>as_strided<a class="headerlink" href="#as-strided" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.ndindex.as_strided">
<code class="sig-prename descclassname">dipy.core.ndindex.</code><code class="sig-name descname">as_strided</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">strides=None</em>, <em class="sig-param">subok=False</em>, <em class="sig-param">writeable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.ndindex.as_strided" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a view into the array with the given shape and strides.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function has to be used with extreme care, see notes.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>Array to create a new.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">sequence of int, optional</span></dt><dd><p>The shape of the new array. Defaults to <code class="docutils literal notranslate"><span class="pre">x.shape</span></code>.</p>
</dd>
<dt><strong>strides</strong><span class="classifier">sequence of int, optional</span></dt><dd><p>The strides of the new array. Defaults to <code class="docutils literal notranslate"><span class="pre">x.strides</span></code>.</p>
</dd>
<dt><strong>subok</strong><span class="classifier">bool, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.</span></p>
</div>
<p>If True, subclasses are preserved.</p>
</dd>
<dt><strong>writeable</strong><span class="classifier">bool, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.</span></p>
</div>
<p>If set to False, the returned array will always be readonly.
Otherwise it will be writable if the original array was. It
is advisable to set this to False if possible (see Notes).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>view</strong><span class="classifier">ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast_to</span></code></dt><dd><p>broadcast an array to a given shape.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code></dt><dd><p>reshape an array.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">as_strided</span></code> creates a view into the array given the exact strides
and shape. This means it manipulates the internal data structure of
ndarray and, if done incorrectly, the array elements can point to
invalid memory and can corrupt results or crash your program.
It is advisable to always use the original <code class="docutils literal notranslate"><span class="pre">x.strides</span></code> when
calculating new strides to avoid reliance on a contiguous memory
layout.</p>
<p>Furthermore, arrays created with this function often contain self
overlapping memory, so that two elements are identical.
Vectorized write operations on such arrays will typically be
unpredictable. They may even give different results for small, large,
or transposed arrays.
Since writing to these arrays has to be tested and done with great
care, you may want to use <code class="docutils literal notranslate"><span class="pre">writeable=False</span></code> to avoid accidental write
operations.</p>
<p>For these reasons it is advisable to avoid <code class="docutils literal notranslate"><span class="pre">as_strided</span></code> when
possible.</p>
</dd></dl>

</div>
<div class="section" id="ndindex">
<h3>ndindex<a class="headerlink" href="#ndindex" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.ndindex.ndindex">
<code class="sig-prename descclassname">dipy.core.ndindex.</code><code class="sig-name descname">ndindex</code><span class="sig-paren">(</span><em class="sig-param">shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.ndindex.ndindex" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">tuple of ints</span></dt><dd><p>The dimensions of the array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="k">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="onetimeproperty">
<h3><a class="reference internal" href="#dipy.core.onetime.OneTimeProperty" title="dipy.core.onetime.OneTimeProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneTimeProperty</span></code></a><a class="headerlink" href="#onetimeproperty" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.onetime.OneTimeProperty">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.onetime.</code><code class="sig-name descname">OneTimeProperty</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.onetime.OneTimeProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A descriptor to make special properties that become normal attributes.</p>
<p>This is meant to be used mostly by the auto_attr decorator in this module.</p>
<dl class="method">
<dt id="dipy.core.onetime.OneTimeProperty.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.onetime.OneTimeProperty.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a OneTimeProperty instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">method</span></dt><dd><p>The method that will be called the first time to compute a value.
Afterwards, the method’s name will be a standard attribute holding
the value of this computation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="resetmixin">
<h3><a class="reference internal" href="#dipy.core.onetime.ResetMixin" title="dipy.core.onetime.ResetMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResetMixin</span></code></a><a class="headerlink" href="#resetmixin" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.onetime.ResetMixin">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.onetime.</code><code class="sig-name descname">ResetMixin</code><a class="headerlink" href="#dipy.core.onetime.ResetMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A Mixin class to add a .reset() method to users of OneTimeProperty.</p>
<p>By default, auto attributes once computed, become static.  If they happen
to depend on other parts of an object and those parts change, their values
may now be invalid.</p>
<p>This class offers a .reset() method that users can call <em>explicitly</em> when
they know the state of their objects may have changed and they want to
ensure that <em>all</em> their special attributes should be invalidated.  Once
reset() is called, all their auto attributes are reset to their
OneTimeProperty descriptors, and their accessor functions will be triggered
again.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If a class has a set of attributes that are OneTimeProperty, but that
can be initialized from any one of them, do NOT use this mixin!  For
instance, UniformTimeSeries can be initialized with only sampling_rate
and t0, sampling_interval and time are auto-computed.  But if you were
to reset() a UniformTimeSeries, it would lose all 4, and there would be
then no way to break the circular dependency chains.</p>
<p>If this becomes a problem in practice (for our analyzer objects it
isn’t, as they don’t have the above pattern), we can extend reset() to
check for a _no_reset set of names in the instance which are meant to be
kept protected.  But for now this is NOT done, so caveat emptor.</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">ResetMixin</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;*** y computation executed ***&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>About to access y twice, the second time no computation is done:
&gt;&gt;&gt; a.y
<strong>* y computation executed *</strong>
5.0
&gt;&gt;&gt; a.y
5.0</p>
<p>Changing x
&gt;&gt;&gt; a.x = 20</p>
<p>a.y doesn’t change to 10, since it is a static attribute:
&gt;&gt;&gt; a.y
5.0</p>
<p>We now reset a, and this will then force all auto attributes to recompute
the next time we access them:
&gt;&gt;&gt; a.reset()</p>
<p>About to access y twice again after reset():
&gt;&gt;&gt; a.y
<strong>* y computation executed *</strong>
10.0
&gt;&gt;&gt; a.y
10.0</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.onetime.ResetMixin.reset" title="dipy.core.onetime.ResetMixin.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</p></td>
<td><p>Reset all OneTimeProperty attributes that may have fired already.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.onetime.ResetMixin.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.onetime.ResetMixin.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.onetime.ResetMixin.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.onetime.ResetMixin.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset all OneTimeProperty attributes that may have fired already.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id9">
<h3>auto_attr<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.onetime.auto_attr">
<code class="sig-prename descclassname">dipy.core.onetime.</code><code class="sig-name descname">auto_attr</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.onetime.auto_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">method</span></dt><dd><p>The method that will be called the first time to compute a value.
Afterwards, the method’s name will be a standard attribute holding the
value of this computation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nonnegativeleastsquares">
<h3><a class="reference internal" href="#dipy.core.optimize.NonNegativeLeastSquares" title="dipy.core.optimize.NonNegativeLeastSquares"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonNegativeLeastSquares</span></code></a><a class="headerlink" href="#nonnegativeleastsquares" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.optimize.NonNegativeLeastSquares">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.optimize.</code><code class="sig-name descname">NonNegativeLeastSquares</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.NonNegativeLeastSquares" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.core.optimize.SKLearnLinearSolver" title="dipy.core.optimize.SKLearnLinearSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.core.optimize.SKLearnLinearSolver</span></code></a></p>
<p>A sklearn-like interface to scipy.optimize.nnls</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.optimize.NonNegativeLeastSquares.fit" title="dipy.core.optimize.NonNegativeLeastSquares.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, y)</p></td>
<td><p>Fit the NonNegativeLeastSquares linear model to data</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code>(X)</p></td>
<td><p>Predict using the result of the model</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.optimize.NonNegativeLeastSquares.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.NonNegativeLeastSquares.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.NonNegativeLeastSquares.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.NonNegativeLeastSquares.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the NonNegativeLeastSquares linear model to data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="optimizer">
<h3><a class="reference internal" href="#dipy.core.optimize.Optimizer" title="dipy.core.optimize.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code></a><a class="headerlink" href="#optimizer" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.optimize.Optimizer">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.optimize.</code><code class="sig-name descname">Optimizer</code><span class="sig-paren">(</span><em class="sig-param">fun</em>, <em class="sig-param">x0</em>, <em class="sig-param">args=()</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">jac=None</em>, <em class="sig-param">hess=None</em>, <em class="sig-param">hessp=None</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">constraints=()</em>, <em class="sig-param">tol=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.Optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evolution</strong></dt><dd></dd>
<dt><strong>fopt</strong></dt><dd></dd>
<dt><strong>message</strong></dt><dd></dd>
<dt><strong>nfev</strong></dt><dd></dd>
<dt><strong>nit</strong></dt><dd></dd>
<dt><strong>xopt</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>print_summary</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.optimize.Optimizer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">fun</em>, <em class="sig-param">x0</em>, <em class="sig-param">args=()</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">jac=None</em>, <em class="sig-param">hess=None</em>, <em class="sig-param">hessp=None</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">constraints=()</em>, <em class="sig-param">tol=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.Optimizer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for handling minimization of scalar function of one or more
variables.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>fun</strong><span class="classifier">callable</span></dt><dd><p>Objective function.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">ndarray</span></dt><dd><p>Initial guess.</p>
</dd>
<dt><strong>args</strong><span class="classifier">tuple, optional</span></dt><dd><p>Extra arguments passed to the objective function and its
derivatives (Jacobian, Hessian).</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>Type of solver.  Should be one of</p>
<blockquote>
<div><ul class="simple">
<li><p>‘Nelder-Mead’</p></li>
<li><p>‘Powell’</p></li>
<li><p>‘CG’</p></li>
<li><p>‘BFGS’</p></li>
<li><p>‘Newton-CG’</p></li>
<li><p>‘Anneal’</p></li>
<li><p>‘L-BFGS-B’</p></li>
<li><p>‘TNC’</p></li>
<li><p>‘COBYLA’</p></li>
<li><p>‘SLSQP’</p></li>
<li><p>‘dogleg’</p></li>
<li><p>‘trust-ncg’</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>jac</strong><span class="classifier">bool or callable, optional</span></dt><dd><p>Jacobian of objective function. Only for CG, BFGS, Newton-CG,
dogleg, trust-ncg.
If <cite>jac</cite> is a Boolean and is True, <cite>fun</cite> is assumed to return the
value of Jacobian along with the objective function. If False, the
Jacobian will be estimated numerically.
<cite>jac</cite> can also be a callable returning the Jacobian of the
objective. In this case, it must accept the same arguments
as <cite>fun</cite>.</p>
</dd>
<dt><strong>hess, hessp</strong><span class="classifier">callable, optional</span></dt><dd><p>Hessian of objective function or Hessian of objective function
times an arbitrary vector p.  Only for Newton-CG,
dogleg, trust-ncg.
Only one of <cite>hessp</cite> or <cite>hess</cite> needs to be given.  If <cite>hess</cite> is
provided, then <cite>hessp</cite> will be ignored.  If neither <cite>hess</cite> nor
<cite>hessp</cite> is provided, then the hessian product will be approximated
using finite differences on <cite>jac</cite>. <cite>hessp</cite> must compute the Hessian
times an arbitrary vector.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">sequence, optional</span></dt><dd><p>Bounds for variables (only for L-BFGS-B, TNC and SLSQP).
<code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining
the bounds on that parameter. Use None for one of <code class="docutils literal notranslate"><span class="pre">min</span></code> or
<code class="docutils literal notranslate"><span class="pre">max</span></code> when there is no bound in that direction.</p>
</dd>
<dt><strong>constraints</strong><span class="classifier">dict or sequence of dict, optional</span></dt><dd><p>Constraints definition (only for COBYLA and SLSQP).
Each constraint is defined in a dictionary with fields:</p>
<blockquote>
<div><dl class="simple">
<dt>type<span class="classifier">str</span></dt><dd><p>Constraint type: ‘eq’ for equality, ‘ineq’ for inequality.</p>
</dd>
<dt>fun<span class="classifier">callable</span></dt><dd><p>The function defining the constraint.</p>
</dd>
<dt>jac<span class="classifier">callable, optional</span></dt><dd><p>The Jacobian of <cite>fun</cite> (only for SLSQP).</p>
</dd>
<dt>args<span class="classifier">sequence, optional</span></dt><dd><p>Extra arguments to be passed to the function and Jacobian.</p>
</dd>
</dl>
</div></blockquote>
<p>Equality constraint means that the constraint function result is to
be zero whereas inequality means that it is to be non-negative.
Note that COBYLA only supports inequality constraints.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance for termination. For detailed control, use
solver-specific options.</p>
</dd>
<dt><strong>callback</strong><span class="classifier">callable, optional</span></dt><dd><p>Called after each iteration, as <code class="docutils literal notranslate"><span class="pre">callback(xk)</span></code>, where <code class="docutils literal notranslate"><span class="pre">xk</span></code> is
the current parameter vector. Only available using Scipy &gt;= 0.12.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>A dictionary of solver options. All methods accept the following
generic options:</p>
<blockquote>
<div><dl class="simple">
<dt>maxiter<span class="classifier">int</span></dt><dd><p>Maximum number of iterations to perform.</p>
</dd>
<dt>disp<span class="classifier">bool</span></dt><dd><p>Set to True to print convergence messages.</p>
</dd>
</dl>
</div></blockquote>
<p>For method-specific options, see
<cite>show_options(‘minimize’, method)</cite>.</p>
</dd>
<dt><strong>evolution</strong><span class="classifier">bool, optional</span></dt><dd><p>save history of x for each iteration. Only available using Scipy
&gt;= 0.12.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.Optimizer.evolution">
<em class="property">property </em><code class="sig-name descname">evolution</code><a class="headerlink" href="#dipy.core.optimize.Optimizer.evolution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.Optimizer.fopt">
<em class="property">property </em><code class="sig-name descname">fopt</code><a class="headerlink" href="#dipy.core.optimize.Optimizer.fopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.Optimizer.message">
<em class="property">property </em><code class="sig-name descname">message</code><a class="headerlink" href="#dipy.core.optimize.Optimizer.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.Optimizer.nfev">
<em class="property">property </em><code class="sig-name descname">nfev</code><a class="headerlink" href="#dipy.core.optimize.Optimizer.nfev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.Optimizer.nit">
<em class="property">property </em><code class="sig-name descname">nit</code><a class="headerlink" href="#dipy.core.optimize.Optimizer.nit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.Optimizer.print_summary">
<code class="sig-name descname">print_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.Optimizer.print_summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.Optimizer.xopt">
<em class="property">property </em><code class="sig-name descname">xopt</code><a class="headerlink" href="#dipy.core.optimize.Optimizer.xopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="sklearnlinearsolver">
<h3><a class="reference internal" href="#dipy.core.optimize.SKLearnLinearSolver" title="dipy.core.optimize.SKLearnLinearSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">SKLearnLinearSolver</span></code></a><a class="headerlink" href="#sklearnlinearsolver" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.optimize.SKLearnLinearSolver">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.optimize.</code><code class="sig-name descname">SKLearnLinearSolver</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.SKLearnLinearSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Provide a sklearn-like uniform interface to algorithms that solve problems
of the form: <span class="math notranslate nohighlight">\(y = Ax\)</span> for <span class="math notranslate nohighlight">\(x\)</span></p>
<p>Sub-classes of SKLearnLinearSolver should provide a ‘fit’ method that have
the following signature: <cite>SKLearnLinearSolver.fit(X, y)</cite>, which would set
an attribute <cite>SKLearnLinearSolver.coef_</cite>, with the shape (X.shape[1],),
such that an estimate of y can be calculated as:
<cite>y_hat = np.dot(X, SKLearnLinearSolver.coef_.T)</cite></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.optimize.SKLearnLinearSolver.fit" title="dipy.core.optimize.SKLearnLinearSolver.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, y)</p></td>
<td><p>Implement for all derived classes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.optimize.SKLearnLinearSolver.predict" title="dipy.core.optimize.SKLearnLinearSolver.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(X)</p></td>
<td><p>Predict using the result of the model</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.optimize.SKLearnLinearSolver.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.SKLearnLinearSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.SKLearnLinearSolver.fit">
<em class="property">abstract </em><code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.SKLearnLinearSolver.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement for all derived classes</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.optimize.SKLearnLinearSolver.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.SKLearnLinearSolver.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict using the result of the model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">array-like (n_samples, n_features)</span></dt><dd><p>Samples.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C</strong><span class="classifier">array, shape = (n_samples,)</span></dt><dd><p>Predicted values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="minimize">
<h3>minimize<a class="headerlink" href="#minimize" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.optimize.minimize">
<code class="sig-prename descclassname">dipy.core.optimize.</code><code class="sig-name descname">minimize</code><span class="sig-paren">(</span><em class="sig-param">fun</em>, <em class="sig-param">x0</em>, <em class="sig-param">args=()</em>, <em class="sig-param">method=None</em>, <em class="sig-param">jac=None</em>, <em class="sig-param">hess=None</em>, <em class="sig-param">hessp=None</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">constraints=()</em>, <em class="sig-param">tol=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimization of scalar function of one or more variables.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>fun</strong><span class="classifier">callable</span></dt><dd><p>The objective function to be minimized.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></code></p>
</div></blockquote>
<p>where x is an 1-D array with shape (n,) and <cite>args</cite>
is a tuple of the fixed parameters needed to completely
specify the function.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">ndarray, shape (n,)</span></dt><dd><p>Initial guess. Array of real elements of size (n,),
where ‘n’ is the number of independent variables.</p>
</dd>
<dt><strong>args</strong><span class="classifier">tuple, optional</span></dt><dd><p>Extra arguments passed to the objective function and its
derivatives (<cite>fun</cite>, <cite>jac</cite> and <cite>hess</cite> functions).</p>
</dd>
<dt><strong>method</strong><span class="classifier">str or callable, optional</span></dt><dd><p>Type of solver.  Should be one of</p>
<blockquote>
<div><ul class="simple">
<li><p>‘Nelder-Mead’ <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘Powell’      <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘CG’          <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘BFGS’        <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘Newton-CG’   <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘L-BFGS-B’    <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘TNC’         <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘COBYLA’      <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘SLSQP’       <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘trust-constr’<span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘dogleg’      <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘trust-ncg’   <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘trust-exact’ <span class="xref std std-ref">(see here)</span></p></li>
<li><p>‘trust-krylov’ <span class="xref std std-ref">(see here)</span></p></li>
<li><p>custom - a callable object (added in version 0.14.0),
see below for description.</p></li>
</ul>
</div></blockquote>
<p>If not given, chosen to be one of <code class="docutils literal notranslate"><span class="pre">BFGS</span></code>, <code class="docutils literal notranslate"><span class="pre">L-BFGS-B</span></code>, <code class="docutils literal notranslate"><span class="pre">SLSQP</span></code>,
depending if the problem has constraints or bounds.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">{callable,  ‘2-point’, ‘3-point’, ‘cs’, bool}, optional</span></dt><dd><p>Method for computing the gradient vector. Only for CG, BFGS,
Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg, trust-krylov,
trust-exact and trust-constr. If it is a callable, it should be a
function that returns the gradient vector:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">*args)</span> <span class="pre">-&gt;</span> <span class="pre">array_like,</span> <span class="pre">shape</span> <span class="pre">(n,)</span></code></p>
</div></blockquote>
<p>where x is an array with shape (n,) and <cite>args</cite> is a tuple with
the fixed parameters. Alternatively, the keywords
{‘2-point’, ‘3-point’, ‘cs’} select a finite
difference scheme for numerical estimation of the gradient. Options
‘3-point’ and ‘cs’ are available only to ‘trust-constr’.
If <cite>jac</cite> is a Boolean and is True, <cite>fun</cite> is assumed to return the
gradient along with the objective function. If False, the gradient
will be estimated using ‘2-point’ finite difference estimation.</p>
</dd>
<dt><strong>hess</strong><span class="classifier">{callable, ‘2-point’, ‘3-point’, ‘cs’, HessianUpdateStrategy},  optional</span></dt><dd><p>Method for computing the Hessian matrix. Only for Newton-CG, dogleg,
trust-ncg,  trust-krylov, trust-exact and trust-constr. If it is
callable, it should return the  Hessian matrix:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">hess(x,</span> <span class="pre">*args)</span> <span class="pre">-&gt;</span> <span class="pre">{LinearOperator,</span> <span class="pre">spmatrix,</span> <span class="pre">array},</span> <span class="pre">(n,</span> <span class="pre">n)</span></code></p>
</div></blockquote>
<p>where x is a (n,) ndarray and <cite>args</cite> is a tuple with the fixed
parameters. LinearOperator and sparse matrix returns are
allowed only for ‘trust-constr’ method. Alternatively, the keywords
{‘2-point’, ‘3-point’, ‘cs’} select a finite difference scheme
for numerical estimation. Or, objects implementing
<cite>HessianUpdateStrategy</cite> interface can be used to approximate
the Hessian. Available quasi-Newton methods implementing
this interface are:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>BFGS</cite>;</p></li>
<li><p><cite>SR1</cite>.</p></li>
</ul>
</div></blockquote>
<p>Whenever the gradient is estimated via finite-differences,
the Hessian cannot be estimated with options
{‘2-point’, ‘3-point’, ‘cs’} and needs to be
estimated using one of the quasi-Newton strategies.
Finite-difference options {‘2-point’, ‘3-point’, ‘cs’} and
<cite>HessianUpdateStrategy</cite> are available only for ‘trust-constr’ method.</p>
</dd>
<dt><strong>hessp</strong><span class="classifier">callable, optional</span></dt><dd><p>Hessian of objective function times an arbitrary vector p. Only for
Newton-CG, trust-ncg, trust-krylov, trust-constr.
Only one of <cite>hessp</cite> or <cite>hess</cite> needs to be given.  If <cite>hess</cite> is
provided, then <cite>hessp</cite> will be ignored.  <cite>hessp</cite> must compute the
Hessian times an arbitrary vector:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">hessp(x,</span> <span class="pre">p,</span> <span class="pre">*args)</span> <span class="pre">-&gt;</span>&#160; <span class="pre">ndarray</span> <span class="pre">shape</span> <span class="pre">(n,)</span></code></p>
</div></blockquote>
<p>where x is a (n,) ndarray, p is an arbitrary vector with
dimension (n,) and <cite>args</cite> is a tuple with the fixed
parameters.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">sequence or <cite>Bounds</cite>, optional</span></dt><dd><p>Bounds on variables for L-BFGS-B, TNC, SLSQP and
trust-constr methods. There are two ways to specify the bounds:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Instance of <cite>Bounds</cite> class.</p></li>
<li><p>Sequence of <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <cite>x</cite>. None
is used to specify no bound.</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>constraints</strong><span class="classifier">{Constraint, dict} or List of {Constraint, dict}, optional</span></dt><dd><p>Constraints definition (only for COBYLA, SLSQP and trust-constr).
Constraints for ‘trust-constr’ are defined as a single object or a
list of objects specifying constraints to the optimization problem.
Available constraints are:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>LinearConstraint</cite></p></li>
<li><p><cite>NonlinearConstraint</cite></p></li>
</ul>
</div></blockquote>
<p>Constraints for COBYLA, SLSQP are defined as a list of dictionaries.
Each dictionary with fields:</p>
<blockquote>
<div><dl class="simple">
<dt>type<span class="classifier">str</span></dt><dd><p>Constraint type: ‘eq’ for equality, ‘ineq’ for inequality.</p>
</dd>
<dt>fun<span class="classifier">callable</span></dt><dd><p>The function defining the constraint.</p>
</dd>
<dt>jac<span class="classifier">callable, optional</span></dt><dd><p>The Jacobian of <cite>fun</cite> (only for SLSQP).</p>
</dd>
<dt>args<span class="classifier">sequence, optional</span></dt><dd><p>Extra arguments to be passed to the function and Jacobian.</p>
</dd>
</dl>
</div></blockquote>
<p>Equality constraint means that the constraint function result is to
be zero whereas inequality means that it is to be non-negative.
Note that COBYLA only supports inequality constraints.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance for termination. For detailed control, use solver-specific
options.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>A dictionary of solver options. All methods accept the following
generic options:</p>
<blockquote>
<div><dl class="simple">
<dt>maxiter<span class="classifier">int</span></dt><dd><p>Maximum number of iterations to perform.</p>
</dd>
<dt>disp<span class="classifier">bool</span></dt><dd><p>Set to True to print convergence messages.</p>
</dd>
</dl>
</div></blockquote>
<p>For method-specific options, see <code class="xref py py-func docutils literal notranslate"><span class="pre">show_options()</span></code>.</p>
</dd>
<dt><strong>callback</strong><span class="classifier">callable, optional</span></dt><dd><p>Called after each iteration. For ‘trust-constr’ it is a callable with
the signature:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">callback(xk,</span> <span class="pre">OptimizeResult</span> <span class="pre">state)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></code></p>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">xk</span></code> is the current parameter vector. and <code class="docutils literal notranslate"><span class="pre">state</span></code>
is an <cite>OptimizeResult</cite> object, with the same fields
as the ones from the return.  If callback returns True
the algorithm execution is terminated.
For all the other methods, the signature is:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">callback(xk)</span></code></p>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">xk</span></code> is the current parameter vector.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>res</strong><span class="classifier">OptimizeResult</span></dt><dd><p>The optimization result represented as a <code class="docutils literal notranslate"><span class="pre">OptimizeResult</span></code> object.
Important attributes are: <code class="docutils literal notranslate"><span class="pre">x</span></code> the solution array, <code class="docutils literal notranslate"><span class="pre">success</span></code> a
Boolean flag indicating if the optimizer exited successfully and
<code class="docutils literal notranslate"><span class="pre">message</span></code> which describes the cause of the termination. See
<cite>OptimizeResult</cite> for a description of other attributes.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize_scalar</span></code></dt><dd><p>Interface to minimization algorithms for scalar univariate functions</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">show_options</span></code></dt><dd><p>Additional options accepted by the solvers</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This section describes the available solvers that can be selected by the
‘method’ parameter. The default method is <em>BFGS</em>.</p>
<p><strong>Unconstrained minimization</strong></p>
<p>Method <span class="xref std std-ref">Nelder-Mead</span> uses the
Simplex algorithm <a class="reference internal" href="#r397802e85ee1-1" id="id10">[1]</a>, <a class="reference internal" href="#r397802e85ee1-2" id="id11">[2]</a>. This algorithm is robust in many
applications. However, if numerical computation of derivative can be
trusted, other algorithms using the first and/or second derivatives
information might be preferred for their better performance in
general.</p>
<p>Method <span class="xref std std-ref">Powell</span> is a modification
of Powell’s method <a class="reference internal" href="#r397802e85ee1-3" id="id12">[3]</a>, <a class="reference internal" href="#r397802e85ee1-4" id="id13">[4]</a> which is a conjugate direction
method. It performs sequential one-dimensional minimizations along
each vector of the directions set (<cite>direc</cite> field in <cite>options</cite> and
<cite>info</cite>), which is updated at each iteration of the main
minimization loop. The function need not be differentiable, and no
derivatives are taken.</p>
<p>Method <span class="xref std std-ref">CG</span> uses a nonlinear conjugate
gradient algorithm by Polak and Ribiere, a variant of the
Fletcher-Reeves method described in <a class="reference internal" href="#r397802e85ee1-5" id="id14">[5]</a> pp.  120-122. Only the
first derivatives are used.</p>
<p>Method <span class="xref std std-ref">BFGS</span> uses the quasi-Newton
method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) <a class="reference internal" href="#r397802e85ee1-5" id="id15">[5]</a>
pp. 136. It uses the first derivatives only. BFGS has proven good
performance even for non-smooth optimizations. This method also
returns an approximation of the Hessian inverse, stored as
<cite>hess_inv</cite> in the OptimizeResult object.</p>
<p>Method <span class="xref std std-ref">Newton-CG</span> uses a
Newton-CG algorithm <a class="reference internal" href="#r397802e85ee1-5" id="id16">[5]</a> pp. 168 (also known as the truncated
Newton method). It uses a CG method to the compute the search
direction. See also <em>TNC</em> method for a box-constrained
minimization with a similar algorithm. Suitable for large-scale
problems.</p>
<p>Method <span class="xref std std-ref">dogleg</span> uses the dog-leg
trust-region algorithm <a class="reference internal" href="#r397802e85ee1-5" id="id17">[5]</a> for unconstrained minimization. This
algorithm requires the gradient and Hessian; furthermore the
Hessian is required to be positive definite.</p>
<p>Method <span class="xref std std-ref">trust-ncg</span> uses the
Newton conjugate gradient trust-region algorithm <a class="reference internal" href="#r397802e85ee1-5" id="id18">[5]</a> for
unconstrained minimization. This algorithm requires the gradient
and either the Hessian or a function that computes the product of
the Hessian with a given vector. Suitable for large-scale problems.</p>
<p>Method <span class="xref std std-ref">trust-krylov</span> uses
the Newton GLTR trust-region algorithm <a class="reference internal" href="#r397802e85ee1-14" id="id19">[14]</a>, <a class="reference internal" href="#r397802e85ee1-15" id="id20">[15]</a> for unconstrained
minimization. This algorithm requires the gradient
and either the Hessian or a function that computes the product of
the Hessian with a given vector. Suitable for large-scale problems.
On indefinite problems it requires usually less iterations than the
<cite>trust-ncg</cite> method and is recommended for medium and large-scale problems.</p>
<p>Method <span class="xref std std-ref">trust-exact</span>
is a trust-region method for unconstrained minimization in which
quadratic subproblems are solved almost exactly <a class="reference internal" href="#r397802e85ee1-13" id="id21">[13]</a>. This
algorithm requires the gradient and the Hessian (which is
<em>not</em> required to be positive definite). It is, in many
situations, the Newton method to converge in fewer iteraction
and the most recommended for small and medium-size problems.</p>
<p><strong>Bound-Constrained minimization</strong></p>
<p>Method <span class="xref std std-ref">L-BFGS-B</span> uses the L-BFGS-B
algorithm <a class="reference internal" href="#r397802e85ee1-6" id="id22">[6]</a>, <a class="reference internal" href="#r397802e85ee1-7" id="id23">[7]</a> for bound constrained minimization.</p>
<p>Method <span class="xref std std-ref">TNC</span> uses a truncated Newton
algorithm <a class="reference internal" href="#r397802e85ee1-5" id="id24">[5]</a>, <a class="reference internal" href="#r397802e85ee1-8" id="id25">[8]</a> to minimize a function with variables subject
to bounds. This algorithm uses gradient information; it is also
called Newton Conjugate-Gradient. It differs from the <em>Newton-CG</em>
method described above as it wraps a C implementation and allows
each variable to be given upper and lower bounds.</p>
<p><strong>Constrained Minimization</strong></p>
<p>Method <span class="xref std std-ref">COBYLA</span> uses the
Constrained Optimization BY Linear Approximation (COBYLA) method
<a class="reference internal" href="#r397802e85ee1-9" id="id26">[9]</a>, <a class="reference internal" href="#r397802e85ee1-10" id="id27">[10]</a>, <a class="reference internal" href="#r397802e85ee1-11" id="id28">[11]</a>. The algorithm is based on linear
approximations to the objective function and each constraint. The
method wraps a FORTRAN implementation of the algorithm. The
constraints functions ‘fun’ may return either a single number
or an array or list of numbers.</p>
<p>Method <span class="xref std std-ref">SLSQP</span> uses Sequential
Least SQuares Programming to minimize a function of several
variables with any combination of bounds, equality and inequality
constraints. The method wraps the SLSQP Optimization subroutine
originally implemented by Dieter Kraft <a class="reference internal" href="#r397802e85ee1-12" id="id29">[12]</a>. Note that the
wrapper handles infinite values in bounds by converting them into
large floating values.</p>
<p>Method <span class="xref std std-ref">trust-constr</span> is a
trust-region algorithm for constrained optimization. It swiches
between two implementations depending on the problem definition.
It is the most versatile constrained minimization algorithm
implemented in SciPy and the most appropriate for large-scale problems.
For equality constrained problems it is an implementation of Byrd-Omojokun
Trust-Region SQP method described in <a class="reference internal" href="#r397802e85ee1-17" id="id30">[17]</a> and in <a class="reference internal" href="#r397802e85ee1-5" id="id31">[5]</a>, p. 549. When
inequality constraints  are imposed as well, it swiches to the trust-region
interior point  method described in <a class="reference internal" href="#r397802e85ee1-16" id="id32">[16]</a>. This interior point algorithm,
in turn, solves inequality constraints by introducing slack variables
and solving a sequence of equality-constrained barrier problems
for progressively smaller values of the barrier parameter.
The previously described equality constrained SQP method is
used to solve the subproblems with increasing levels of accuracy
as the iterate gets closer to a solution.</p>
<p><strong>Finite-Difference Options</strong></p>
<p>For Method <span class="xref std std-ref">trust-constr</span>
the gradient and the Hessian may be approximated using
three finite-difference schemes: {‘2-point’, ‘3-point’, ‘cs’}.
The scheme ‘cs’ is, potentially, the most accurate but it
requires the function to correctly handles complex inputs and to
be differentiable in the complex plane. The scheme ‘3-point’ is more
accurate than ‘2-point’ but requires twice as much operations.</p>
<p><strong>Custom minimizers</strong></p>
<p>It may be useful to pass a custom minimization method, for example
when using a frontend to this method such as <cite>scipy.optimize.basinhopping</cite>
or a different library.  You can simply pass a callable as the <code class="docutils literal notranslate"><span class="pre">method</span></code>
parameter.</p>
<p>The callable is called as <code class="docutils literal notranslate"><span class="pre">method(fun,</span> <span class="pre">x0,</span> <span class="pre">args,</span> <span class="pre">**kwargs,</span> <span class="pre">**options)</span></code>
where <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> corresponds to any other parameters passed to <cite>minimize</cite>
(such as <cite>callback</cite>, <cite>hess</cite>, etc.), except the <cite>options</cite> dict, which has
its contents also passed as <cite>method</cite> parameters pair by pair.  Also, if
<cite>jac</cite> has been passed as a bool type, <cite>jac</cite> and <cite>fun</cite> are mangled so that
<cite>fun</cite> returns just the function values and <cite>jac</cite> is converted to a function
returning the Jacobian.  The method shall return an <code class="docutils literal notranslate"><span class="pre">OptimizeResult</span></code>
object.</p>
<p>The provided <cite>method</cite> callable must be able to accept (and possibly ignore)
arbitrary parameters; the set of parameters accepted by <cite>minimize</cite> may
expand in future versions and then these parameters will be passed to
the method.  You can find an example in the scipy.optimize tutorial.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.11.0.</span></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r397802e85ee1-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id10">1</a>,<a href="#id33">2</a>)</span></dt>
<dd><p>Nelder, J A, and R Mead. 1965. A Simplex Method for Function
Minimization. The Computer Journal 7: 308-13.</p>
</dd>
<dt class="label" id="r397802e85ee1-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id11">1</a>,<a href="#id34">2</a>)</span></dt>
<dd><p>Wright M H. 1996. Direct search methods: Once scorned, now
respectable, in Numerical Analysis 1995: Proceedings of the 1995
Dundee Biennial Conference in Numerical Analysis (Eds. D F
Griffiths and G A Watson). Addison Wesley Longman, Harlow, UK.
191-208.</p>
</dd>
<dt class="label" id="r397802e85ee1-3"><span class="brackets">3</span><span class="fn-backref">(<a href="#id12">1</a>,<a href="#id35">2</a>)</span></dt>
<dd><p>Powell, M J D. 1964. An efficient method for finding the minimum of
a function of several variables without calculating derivatives. The
Computer Journal 7: 155-162.</p>
</dd>
<dt class="label" id="r397802e85ee1-4"><span class="brackets">4</span><span class="fn-backref">(<a href="#id13">1</a>,<a href="#id36">2</a>)</span></dt>
<dd><p>Press W, S A Teukolsky, W T Vetterling and B P Flannery.
Numerical Recipes (any edition), Cambridge University Press.</p>
</dd>
<dt class="label" id="r397802e85ee1-5"><span class="brackets">5</span><span class="fn-backref">(<a href="#id14">1</a>,<a href="#id15">2</a>,<a href="#id16">3</a>,<a href="#id17">4</a>,<a href="#id18">5</a>,<a href="#id24">6</a>,<a href="#id31">7</a>,<a href="#id37">8</a>,<a href="#id50">9</a>)</span></dt>
<dd><p>Nocedal, J, and S J Wright. 2006. Numerical Optimization.
Springer New York.</p>
</dd>
<dt class="label" id="r397802e85ee1-6"><span class="brackets">6</span><span class="fn-backref">(<a href="#id22">1</a>,<a href="#id38">2</a>)</span></dt>
<dd><p>Byrd, R H and P Lu and J. Nocedal. 1995. A Limited Memory
Algorithm for Bound Constrained Optimization. SIAM Journal on
Scientific and Statistical Computing 16 (5): 1190-1208.</p>
</dd>
<dt class="label" id="r397802e85ee1-7"><span class="brackets">7</span><span class="fn-backref">(<a href="#id23">1</a>,<a href="#id39">2</a>)</span></dt>
<dd><p>Zhu, C and R H Byrd and J Nocedal. 1997. L-BFGS-B: Algorithm
778: L-BFGS-B, FORTRAN routines for large scale bound constrained
optimization. ACM Transactions on Mathematical Software 23 (4):
550-560.</p>
</dd>
<dt class="label" id="r397802e85ee1-8"><span class="brackets">8</span><span class="fn-backref">(<a href="#id25">1</a>,<a href="#id40">2</a>)</span></dt>
<dd><p>Nash, S G. Newton-Type Minimization Via the Lanczos Method.
1984. SIAM Journal of Numerical Analysis 21: 770-778.</p>
</dd>
<dt class="label" id="r397802e85ee1-9"><span class="brackets">9</span><span class="fn-backref">(<a href="#id26">1</a>,<a href="#id41">2</a>)</span></dt>
<dd><p>Powell, M J D. A direct search optimization method that models
the objective and constraint functions by linear interpolation.
1994. Advances in Optimization and Numerical Analysis, eds. S. Gomez
and J-P Hennart, Kluwer Academic (Dordrecht), 51-67.</p>
</dd>
<dt class="label" id="r397802e85ee1-10"><span class="brackets">10</span><span class="fn-backref">(<a href="#id27">1</a>,<a href="#id42">2</a>)</span></dt>
<dd><p>Powell M J D. Direct search algorithms for optimization
calculations. 1998. Acta Numerica 7: 287-336.</p>
</dd>
<dt class="label" id="r397802e85ee1-11"><span class="brackets">11</span><span class="fn-backref">(<a href="#id28">1</a>,<a href="#id43">2</a>)</span></dt>
<dd><p>Powell M J D. A view of algorithms for optimization without
derivatives. 2007.Cambridge University Technical Report DAMTP
2007/NA03</p>
</dd>
<dt class="label" id="r397802e85ee1-12"><span class="brackets">12</span><span class="fn-backref">(<a href="#id29">1</a>,<a href="#id44">2</a>)</span></dt>
<dd><p>Kraft, D. A software package for sequential quadratic
programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace
Center – Institute for Flight Mechanics, Koln, Germany.</p>
</dd>
<dt class="label" id="r397802e85ee1-13"><span class="brackets">13</span><span class="fn-backref">(<a href="#id21">1</a>,<a href="#id45">2</a>)</span></dt>
<dd><p>Conn, A. R., Gould, N. I., and Toint, P. L.
Trust region methods. 2000. Siam. pp. 169-200.</p>
</dd>
<dt class="label" id="r397802e85ee1-14"><span class="brackets">14</span><span class="fn-backref">(<a href="#id19">1</a>,<a href="#id46">2</a>)</span></dt>
<dd><p>F. Lenders, C. Kirches, A. Potschka: “trlib: A vector-free
implementation of the GLTR method for iterative solution of
the trust region problem”, <a class="reference external" href="https://arxiv.org/abs/1611.04718">https://arxiv.org/abs/1611.04718</a></p>
</dd>
<dt class="label" id="r397802e85ee1-15"><span class="brackets">15</span><span class="fn-backref">(<a href="#id20">1</a>,<a href="#id47">2</a>)</span></dt>
<dd><p>N. Gould, S. Lucidi, M. Roma, P. Toint: “Solving the
Trust-Region Subproblem using the Lanczos Method”,
SIAM J. Optim., 9(2), 504–525, (1999).</p>
</dd>
<dt class="label" id="r397802e85ee1-16"><span class="brackets">16</span><span class="fn-backref">(<a href="#id32">1</a>,<a href="#id48">2</a>)</span></dt>
<dd><p>Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999.
An interior point algorithm for large-scale nonlinear  programming.
SIAM Journal on Optimization 9.4: 877-900.</p>
</dd>
<dt class="label" id="r397802e85ee1-17"><span class="brackets">17</span><span class="fn-backref">(<a href="#id30">1</a>,<a href="#id49">2</a>)</span></dt>
<dd><p>Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998. On the
implementation of an algorithm for large-scale equality constrained
optimization. SIAM Journal on Optimization 8.3: 682-706.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Let us consider the problem of minimizing the Rosenbrock function. This
function (and its respective derivatives) is implemented in <cite>rosen</cite>
(resp. <cite>rosen_der</cite>, <cite>rosen_hess</cite>) in the <cite>scipy.optimize</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">rosen</span><span class="p">,</span> <span class="n">rosen_der</span>
</pre></div>
</div>
<p>A simple application of the <em>Nelder-Mead</em> method is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.,  1.,  1.,  1.,  1.])</span>
</pre></div>
</div>
<p>Now using the <em>BFGS</em> algorithm, using the first derivative and a few
options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 26</span>
<span class="go">         Function evaluations: 31</span>
<span class="go">         Gradient evaluations: 31</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.,  1.,  1.,  1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
<span class="go">Optimization terminated successfully.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">hess_inv</span>
<span class="go">array([[ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary</span>
<span class="go">       [ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269],</span>
<span class="go">       [ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151],</span>
<span class="go">       [ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ],</span>
<span class="go">       [ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]])</span>
</pre></div>
</div>
<p>Next, consider a minimization problem with several constraints (namely
Example 16.4 from <a class="reference internal" href="#r397802e85ee1-5" id="id50">[5]</a>). The objective function is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>There are three constraints defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cons</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">})</span>
</pre></div>
</div>
<p>And variables must be positive, hence the following bounds:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bnds</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
</pre></div>
</div>
<p>The optimization problem is solved using the SLSQP method as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bnds</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">)</span>
</pre></div>
</div>
<p>It should converge to the theoretical solution (1.4 ,1.7).</p>
</dd></dl>

</div>
<div class="section" id="sparse-nnls">
<h3>sparse_nnls<a class="headerlink" href="#sparse-nnls" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.optimize.sparse_nnls">
<code class="sig-prename descclassname">dipy.core.optimize.</code><code class="sig-name descname">sparse_nnls</code><span class="sig-paren">(</span><em class="sig-param">y</em>, <em class="sig-param">X</em>, <em class="sig-param">momentum=1</em>, <em class="sig-param">step_size=0.01</em>, <em class="sig-param">non_neg=True</em>, <em class="sig-param">check_error_iter=10</em>, <em class="sig-param">max_error_checks=10</em>, <em class="sig-param">converge_on_sse=0.99</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.sparse_nnls" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve y=Xh for h, using gradient descent, with X a sparse matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1-d array of shape (N)</span></dt><dd><p>The data. Needs to be dense.</p>
</dd>
<dt><strong>X</strong><span class="classifier">ndarray. May be either sparse or dense. Shape (N, M)</span></dt><dd><p>The regressors</p>
</dd>
<dt><strong>momentum</strong><span class="classifier">float, optional (default: 1).</span></dt><dd><p>The persistence of the gradient.</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">float, optional (default: 0.01).</span></dt><dd><p>The increment of parameter update in each iteration</p>
</dd>
<dt><strong>non_neg</strong><span class="classifier">Boolean, optional (default: True)</span></dt><dd><p>Whether to enforce non-negativity of the solution.</p>
</dd>
<dt><strong>check_error_iter</strong><span class="classifier">int (default:10)</span></dt><dd><p>How many rounds to run between error evaluation for
convergence-checking.</p>
</dd>
<dt><strong>max_error_checks</strong><span class="classifier">int (default: 10)</span></dt><dd><p>Don’t check errors more than this number of times if no improvement in
r-squared is seen.</p>
</dd>
<dt><strong>converge_on_sse</strong><span class="classifier">float (default: 0.99)</span></dt><dd><p>a percentage improvement in SSE that is required each time to say
that things are still going well.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h_best</strong><span class="classifier">The best estimate of the parameters.</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="spdot">
<h3>spdot<a class="headerlink" href="#spdot" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.optimize.spdot">
<code class="sig-prename descclassname">dipy.core.optimize.</code><code class="sig-name descname">spdot</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.optimize.spdot" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as np.dot(A, B), except it works even if A or B or both
are sparse matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A, B</strong><span class="classifier">arrays of shape (m, n), (n, k)</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>The matrix product AB. If both A and B are sparse, the result will be a</strong></dt><dd></dd>
<dt><strong>sparse matrix. Otherwise, a dense result is returned</strong></dt><dd></dd>
<dt><strong>See discussion here:</strong></dt><dd></dd>
<dt><strong>http://mail.scipy.org/pipermail/scipy-user/2010-November/027700.html</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="profiler">
<h3><a class="reference internal" href="#dipy.core.profile.Profiler" title="dipy.core.profile.Profiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Profiler</span></code></a><a class="headerlink" href="#profiler" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.profile.Profiler">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.profile.</code><code class="sig-name descname">Profiler</code><span class="sig-paren">(</span><em class="sig-param">call=None</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.profile.Profiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Profile python/cython files or functions</p>
<p>If you are profiling cython code you need to add
# cython: profile=True on the top of your .pyx file</p>
<p>and for the functions that you do not want to profile you can use
this decorator in your cython files</p>
<p>&#64;cython.profile(False)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>caller</strong><span class="classifier">file or function call</span></dt><dd></dd>
<dt><strong>args</strong><span class="classifier">function arguments</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p><a class="reference external" href="http://docs.cython.org/src/tutorial/profiling_tutorial.html">http://docs.cython.org/src/tutorial/profiling_tutorial.html</a>
<a class="reference external" href="http://docs.python.org/library/profile.html">http://docs.python.org/library/profile.html</a>
<a class="reference external" href="http://packages.python.org/line_profiler/">http://packages.python.org/line_profiler/</a></p>
<p class="rubric">Examples</p>
<p>from dipy.core.profile import Profiler
import numpy as np
p=Profiler(np.sum,np.random.rand(1000000,3))
fname=’test.py’
p=Profiler(fname)
p.print_stats(10)
p.print_stats(‘det’)</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stats</strong><span class="classifier">function, stats.print_stats(10) will prin the 10 slower functions</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.profile.Profiler.print_stats" title="dipy.core.profile.Profiler.print_stats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_stats</span></code></a>([N])</p></td>
<td><p>Print stats for profiling</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.profile.Profiler.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">call=None</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.profile.Profiler.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.profile.Profiler.print_stats">
<code class="sig-name descname">print_stats</code><span class="sig-paren">(</span><em class="sig-param">N=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.profile.Profiler.print_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Print stats for profiling</p>
<p>You can use it in all different ways developed in pstats
for example
print_stats(10) will give you the 10 slowest calls
or
print_stats(‘function_name’)
will give you the stats for all the calls with name ‘function_name’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">stats.print_stats argument</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="optional-package">
<h3>optional_package<a class="headerlink" href="#optional-package" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.profile.optional_package">
<code class="sig-prename descclassname">dipy.core.profile.</code><code class="sig-name descname">optional_package</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">trip_msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.profile.optional_package" title="Permalink to this definition">¶</a></dt>
<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>package name</p>
</dd>
<dt><strong>trip_msg</strong><span class="classifier">None or str</span></dt><dd><p>message to give when someone tries to use the return package, but we
could not import it, and have returned a TripWire object instead.
Default message if None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>pkg_like</strong><span class="classifier">module or <code class="docutils literal notranslate"><span class="pre">TripWire</span></code> instance</span></dt><dd><p>If we can import the package, return it.  Otherwise return an object
raising an error when accessed</p>
</dd>
<dt><strong>have_pkg</strong><span class="classifier">bool</span></dt><dd><p>True if import for package was successful, false otherwise</p>
</dd>
<dt><strong>module_setup</strong><span class="classifier">function</span></dt><dd><p>callable usually set as <code class="docutils literal notranslate"><span class="pre">setup_module</span></code> in calling namespace, to allow
skipping tests.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Typical use would be something like this at the top of a module using an
optional package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.utils.optpkg</span> <span class="k">import</span> <span class="n">optional_package</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pkg</span><span class="p">,</span> <span class="n">have_pkg</span><span class="p">,</span> <span class="n">setup_module</span> <span class="o">=</span> <span class="n">optional_package</span><span class="p">(</span><span class="s1">&#39;not_a_package&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course in this case the package doesn’t exist, and so, in the module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">have_pkg</span>
<span class="go">False</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pkg</span><span class="o">.</span><span class="n">some_function</span><span class="p">()</span> <span class="c1">#doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TripWireError</span>: <span class="n">We need package not_a_package for these functions, but</span>
<span class="go">``import not_a_package`` raised an ImportError</span>
</pre></div>
</div>
<p>If the module does exist - we get the module</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pkg</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_package</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Or a submodule if that’s what we asked for</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subpkg</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_package</span><span class="p">(</span><span class="s1">&#39;os.path&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">subpkg</span><span class="p">,</span> <span class="s1">&#39;dirname&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="lecuyer">
<h3>LEcuyer<a class="headerlink" href="#lecuyer" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.rng.LEcuyer">
<code class="sig-prename descclassname">dipy.core.rng.</code><code class="sig-name descname">LEcuyer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.rng.LEcuyer" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate uniformly distributed random numbers using the 32-bit
generator from figure 3 of:</p>
<blockquote>
<div><p>L’Ecuyer, P. Efficient and portable combined random number
generators, C.A.C.M., vol. 31, 742-749 &amp; 774-?, June 1988.</p>
</div></blockquote>
<p>The cycle length is claimed to be 2.30584E+18</p>
</dd></dl>

</div>
<div class="section" id="wichmannhill1982">
<h3>WichmannHill1982<a class="headerlink" href="#wichmannhill1982" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.rng.WichmannHill1982">
<code class="sig-prename descclassname">dipy.core.rng.</code><code class="sig-name descname">WichmannHill1982</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.rng.WichmannHill1982" title="Permalink to this definition">¶</a></dt>
<dd><p>Algorithm AS 183 Appl. Statist. (1982) vol.31, no.2</p>
<p>Returns a pseudo-random number rectangularly distributed
between 0 and 1.   The cycle length is 6.95E+12 (See page 123
of Applied Statistics (1984) vol.33), not as claimed in the
original article.</p>
<p>ix, iy and iz should be set to integer values between 1 and
30000 before the first entry.</p>
<p>Integer arithmetic up to 5212632 is required.</p>
</dd></dl>

</div>
<div class="section" id="wichmannhill2006">
<h3>WichmannHill2006<a class="headerlink" href="#wichmannhill2006" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.rng.WichmannHill2006">
<code class="sig-prename descclassname">dipy.core.rng.</code><code class="sig-name descname">WichmannHill2006</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.rng.WichmannHill2006" title="Permalink to this definition">¶</a></dt>
<dd><p>B.A. Wichmann, I.D. Hill, Generating good pseudo-random numbers,
Computational Statistics &amp; Data Analysis, Volume 51, Issue 3, 1
December 2006, Pages 1614-1622, ISSN 0167-9473, DOI:
10.1016/j.csda.2006.05.019.
(<a class="reference external" href="http://www.sciencedirect.com/science/article/B6V8V-4K7F86W-2/2/a3a33291b8264e4c882a8f21b6e43351">http://www.sciencedirect.com/science/article/B6V8V-4K7F86W-2/2/a3a33291b8264e4c882a8f21b6e43351</a>)
for advice on generating many sequences for use together, and on
alternative algorithms and codes</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core</span> <span class="k">import</span> <span class="n">rng</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">rng</span><span class="o">.</span><span class="n">iy</span><span class="p">,</span> <span class="n">rng</span><span class="o">.</span><span class="n">iz</span><span class="p">,</span> <span class="n">rng</span><span class="o">.</span><span class="n">it</span> <span class="o">=</span> <span class="mi">100001</span><span class="p">,</span> <span class="mi">200002</span><span class="p">,</span> <span class="mi">300003</span><span class="p">,</span> <span class="mi">400004</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">rng</span><span class="o">.</span><span class="n">WichmannHill2006</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="architecture">
<h3>architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.rng.architecture">
<code class="sig-prename descclassname">dipy.core.rng.</code><code class="sig-name descname">architecture</code><span class="sig-paren">(</span><em class="sig-param">executable='/Users/koudoro/anaconda/envs/dipy_dev_3/bin/python'</em>, <em class="sig-param">bits=''</em>, <em class="sig-param">linkage=''</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.rng.architecture" title="Permalink to this definition">¶</a></dt>
<dd><p>Queries the given executable (defaults to the Python interpreter
binary) for various architecture information.</p>
<p>Returns a tuple (bits, linkage) which contains information about
the bit architecture and the linkage format used for the
executable. Both values are returned as strings.</p>
<p>Values that cannot be determined are returned as given by the
parameter presets. If bits is given as ‘’, the sizeof(pointer)
(or sizeof(long) on Python version &lt; 1.5.2) is used as
indicator for the supported pointer size.</p>
<p>The function relies on the system’s “file” command to do the
actual work. This is available on most if not all Unix
platforms. On some non-Unix platforms where the “file” command
does not exist and the executable is set to the Python interpreter
binary defaults from _default_architecture are used.</p>
</dd></dl>

</div>
<div class="section" id="floor">
<h3>floor<a class="headerlink" href="#floor" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.rng.floor">
<code class="sig-prename descclassname">dipy.core.rng.</code><code class="sig-name descname">floor</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.rng.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the floor of x as an Integral.
This is the largest integer &lt;= x.</p>
</dd></dl>

</div>
<div class="section" id="id51">
<h3><a class="reference internal" href="#dipy.core.sphere.HemiSphere" title="dipy.core.sphere.HemiSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">HemiSphere</span></code></a><a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.sphere.HemiSphere">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">HemiSphere</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">phi=None</em>, <em class="sig-param">xyz=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">edges=None</em>, <em class="sig-param">tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.HemiSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.core.sphere.Sphere" title="dipy.core.sphere.Sphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.core.sphere.Sphere</span></code></a></p>
<p>Points on the unit sphere.</p>
<p>A HemiSphere is similar to a Sphere but it takes antipodal symmetry into
account. Antipodal symmetry means that point v on a HemiSphere is the same
as the point -v. Duplicate points are discarded when constructing a
HemiSphere (including antipodal duplicates). <cite>edges</cite> and <cite>faces</cite> are
remapped to the remaining points as closely as possible.</p>
<p>The HemiSphere can be constructed using one of three conventions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">HemiSphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">HemiSphere</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">HemiSphere</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x, y, z</strong><span class="classifier">1-D array_like</span></dt><dd><p>Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>theta, phi</strong><span class="classifier">1-D array_like</span></dt><dd><p>Vertices as spherical coordinates.  Theta and phi are the inclination
and azimuth angles respectively.</p>
</dd>
<dt><strong>xyz</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Indices into vertices that form triangular faces.  If unspecified,
the faces are computed using a Delaunay triangulation.</p>
</dd>
<dt><strong>edges</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Edges between vertices.  If unspecified, the edges are
derived from the faces.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Angle in degrees. Vertices that are less than tol degrees apart are
treated as duplicates.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dipy.core.sphere.Sphere" title="dipy.core.sphere.Sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sphere</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong></dt><dd></dd>
<dt><strong>y</strong></dt><dd></dd>
<dt><strong>z</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere.HemiSphere.find_closest" title="dipy.core.sphere.HemiSphere.find_closest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_closest</span></code></a>(xyz)</p></td>
<td><p>Find the index of the vertex in the Sphere closest to the input vector, taking into account antipodal symmetry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere.HemiSphere.from_sphere" title="dipy.core.sphere.HemiSphere.from_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_sphere</span></code></a>(sphere[, tol])</p></td>
<td><p>Create instance from a Sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere.HemiSphere.mirror" title="dipy.core.sphere.HemiSphere.mirror"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mirror</span></code></a>()</p></td>
<td><p>Create a full Sphere from a HemiSphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere.HemiSphere.subdivide" title="dipy.core.sphere.HemiSphere.subdivide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code></a>([n])</p></td>
<td><p>Create a more subdivided HemiSphere</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>edges</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>faces</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>vertices</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.sphere.HemiSphere.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">phi=None</em>, <em class="sig-param">xyz=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">edges=None</em>, <em class="sig-param">tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.HemiSphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a HemiSphere from points</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.HemiSphere.faces">
<code class="sig-name descname">faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.HemiSphere.faces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.HemiSphere.find_closest">
<code class="sig-name descname">find_closest</code><span class="sig-paren">(</span><em class="sig-param">xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.HemiSphere.find_closest" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the vertex in the Sphere closest to the input vector,
taking into account antipodal symmetry</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">array-like, 3 elements</span></dt><dd><p>A unit vector</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The index into the Sphere.vertices array that gives the closest
vertex (in angle).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.HemiSphere.from_sphere">
<em class="property">classmethod </em><code class="sig-name descname">from_sphere</code><span class="sig-paren">(</span><em class="sig-param">sphere</em>, <em class="sig-param">tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.HemiSphere.from_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create instance from a Sphere</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.HemiSphere.mirror">
<code class="sig-name descname">mirror</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.HemiSphere.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a full Sphere from a HemiSphere</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.HemiSphere.subdivide">
<code class="sig-name descname">subdivide</code><span class="sig-paren">(</span><em class="sig-param">n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.HemiSphere.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a more subdivided HemiSphere</p>
<p>See Sphere.subdivide for full documentation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sphere">
<h3><a class="reference internal" href="#dipy.core.sphere.Sphere" title="dipy.core.sphere.Sphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sphere</span></code></a><a class="headerlink" href="#sphere" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.sphere.Sphere">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">Sphere</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">phi=None</em>, <em class="sig-param">xyz=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">edges=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Points on the unit sphere.</p>
<p>The sphere can be constructed using one of three conventions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x, y, z</strong><span class="classifier">1-D array_like</span></dt><dd><p>Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>theta, phi</strong><span class="classifier">1-D array_like</span></dt><dd><p>Vertices as spherical coordinates.  Theta and phi are the inclination
and azimuth angles respectively.</p>
</dd>
<dt><strong>xyz</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Indices into vertices that form triangular faces.  If unspecified,
the faces are computed using a Delaunay triangulation.</p>
</dd>
<dt><strong>edges</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Edges between vertices.  If unspecified, the edges are
derived from the faces.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong></dt><dd></dd>
<dt><strong>y</strong></dt><dd></dd>
<dt><strong>z</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.sphere.Sphere.find_closest" title="dipy.core.sphere.Sphere.find_closest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_closest</span></code></a>(xyz)</p></td>
<td><p>Find the index of the vertex in the Sphere closest to the input vector</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.sphere.Sphere.subdivide" title="dipy.core.sphere.Sphere.subdivide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code></a>([n])</p></td>
<td><p>Subdivides each face of the sphere into four new faces.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>edges</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>faces</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>vertices</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.sphere.Sphere.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">phi=None</em>, <em class="sig-param">xyz=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">edges=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.Sphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.Sphere.edges">
<code class="sig-name descname">edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.Sphere.edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.Sphere.faces">
<code class="sig-name descname">faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.Sphere.faces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.Sphere.find_closest">
<code class="sig-name descname">find_closest</code><span class="sig-paren">(</span><em class="sig-param">xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.Sphere.find_closest" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the vertex in the Sphere closest to the input vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">array-like, 3 elements</span></dt><dd><p>A unit vector</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The index into the Sphere.vertices array that gives the closest
vertex (in angle).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.Sphere.subdivide">
<code class="sig-name descname">subdivide</code><span class="sig-paren">(</span><em class="sig-param">n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.Sphere.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivides each face of the sphere into four new faces.</p>
<p>New vertices are created at a, b, and c. Then each face [x, y, z] is
divided into faces [x, a, c], [y, a, b], [z, b, c], and [a, b, c].</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   y
   /               /               a/____
/\    /            /  \  /             /____\/____          x      c     z
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>The number of subdivisions to preform.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_sphere</strong><span class="classifier">Sphere</span></dt><dd><p>The subdivided sphere.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.Sphere.vertices">
<code class="sig-name descname">vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.Sphere.vertices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.Sphere.x">
<em class="property">property </em><code class="sig-name descname">x</code><a class="headerlink" href="#dipy.core.sphere.Sphere.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.Sphere.y">
<em class="property">property </em><code class="sig-name descname">y</code><a class="headerlink" href="#dipy.core.sphere.Sphere.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.sphere.Sphere.z">
<em class="property">property </em><code class="sig-name descname">z</code><a class="headerlink" href="#dipy.core.sphere.Sphere.z" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id52">
<h3>auto_attr<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.auto_attr">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">auto_attr</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.auto_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">method</span></dt><dd><p>The method that will be called the first time to compute a value.
Afterwards, the method’s name will be a standard attribute holding the
value of this computation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id53">
<h3>cart2sphere<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.cart2sphere">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">cart2sphere</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.cart2sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions and derivation
of the formulae.</p>
<p><span class="math notranslate nohighlight">\(0\le\theta\mathrm{(theta)}\le\pi\)</span> and <span class="math notranslate nohighlight">\(-\pi\le\phi\mathrm{(phi)}\le\pi\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>x coordinate in Cartesian space</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong><span class="classifier">array_like</span></dt><dd><p>z coordinate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>r</strong><span class="classifier">array</span></dt><dd><p>radius</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array</span></dt><dd><p>inclination (polar) angle</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array</span></dt><dd><p>azimuth angle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id54">
<h3>disperse_charges<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.disperse_charges">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">disperse_charges</code><span class="sig-paren">(</span><em class="sig-param">hemi</em>, <em class="sig-param">iters</em>, <em class="sig-param">const=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.disperse_charges" title="Permalink to this definition">¶</a></dt>
<dd><p>Models electrostatic repulsion on the unit sphere</p>
<p>Places charges on a sphere and simulates the repulsive forces felt by each
one. Allows the charges to move for some number of iterations and returns
their final location as well as the total potential of the system at each
step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hemi</strong><span class="classifier">HemiSphere</span></dt><dd><p>Points on a unit sphere.</p>
</dd>
<dt><strong>iters</strong><span class="classifier">int</span></dt><dd><p>Number of iterations to run.</p>
</dd>
<dt><strong>const</strong><span class="classifier">float</span></dt><dd><p>Using a smaller const could provide a more accurate result, but will
need more iterations to converge.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hemi</strong><span class="classifier">HemiSphere</span></dt><dd><p>Distributed points on a unit sphere.</p>
</dd>
<dt><strong>potential</strong><span class="classifier">ndarray</span></dt><dd><p>The electrostatic potential at each iteration. This can be useful to
check if the repulsion converged to a minimum.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is meant to be used with diffusion imaging so antipodal
symmetry is assumed. Therefor each charge must not only be unique, but if
there is a charge at +x, there cannot be a charge at -x. These are treated
as the same location and because the distance between the two charges will
be zero, the result will be unstable.</p>
</dd></dl>

</div>
<div class="section" id="euler-characteristic-check">
<h3>euler_characteristic_check<a class="headerlink" href="#euler-characteristic-check" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.euler_characteristic_check">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">euler_characteristic_check</code><span class="sig-paren">(</span><em class="sig-param">sphere</em>, <em class="sig-param">chi=2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.euler_characteristic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the euler characteristic of a sphere</p>
<p>If <span class="math notranslate nohighlight">\(f\)</span> = number of faces, <span class="math notranslate nohighlight">\(e\)</span> = number_of_edges and <span class="math notranslate nohighlight">\(v\)</span> = number of
vertices, the Euler formula says <span class="math notranslate nohighlight">\(f-e+v = 2\)</span> for a mesh on a sphere. More
generally, whether <span class="math notranslate nohighlight">\(f -e + v == \chi\)</span> where <span class="math notranslate nohighlight">\(\chi\)</span> is the Euler
characteristic of the mesh.</p>
<ul class="simple">
<li><p>Open chain (track) has <span class="math notranslate nohighlight">\(\chi=1\)</span></p></li>
<li><p>Closed chain (loop) has <span class="math notranslate nohighlight">\(\chi=0\)</span></p></li>
<li><p>Disk has <span class="math notranslate nohighlight">\(\chi=1\)</span></p></li>
<li><p>Sphere has <span class="math notranslate nohighlight">\(\chi=2\)</span></p></li>
<li><p>HemiSphere has <span class="math notranslate nohighlight">\(\chi=1\)</span></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>A Sphere instance with vertices, edges and faces attributes.</p>
</dd>
<dt><strong>chi</strong><span class="classifier">int, optional</span></dt><dd><p>The Euler characteristic of the mesh to be checked</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>check</strong><span class="classifier">bool</span></dt><dd><p>True if the mesh has Euler characteristic <span class="math notranslate nohighlight">\(\chi\)</span></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">euler_characteristic_check</span><span class="p">(</span><span class="n">unit_octahedron</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hemisphere</span> <span class="o">=</span> <span class="n">HemiSphere</span><span class="o">.</span><span class="n">from_sphere</span><span class="p">(</span><span class="n">unit_icosahedron</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler_characteristic_check</span><span class="p">(</span><span class="n">hemisphere</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="faces-from-sphere-vertices">
<h3>faces_from_sphere_vertices<a class="headerlink" href="#faces-from-sphere-vertices" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.faces_from_sphere_vertices">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">faces_from_sphere_vertices</code><span class="sig-paren">(</span><em class="sig-param">vertices</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.faces_from_sphere_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangulate a set of vertices on the sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(M, 3) ndarray</span></dt><dd><p>XYZ coordinates of vertices on the sphere.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>faces</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Indices into vertices; forms triangular faces.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="remove-similar-vertices">
<h3>remove_similar_vertices<a class="headerlink" href="#remove-similar-vertices" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.remove_similar_vertices">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">remove_similar_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.remove_similar_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove vertices that are less than <cite>theta</cite> degrees from any other</p>
<p>Returns vertices that are at least theta degrees from any other vertex.
Vertex v and -v are considered the same so if v and -v are both in
<cite>vertices</cite> only one is kept. Also if v and w are both in vertices, w must
be separated by theta degrees from both v and -v to be unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>N unit vectors.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>The minimum separation between vertices in degrees.</p>
</dd>
<dt><strong>return_mapping</strong><span class="classifier">{False, True}, optional</span></dt><dd><p>If True, return <cite>mapping</cite> as well as <cite>vertices</cite> and maybe <cite>indices</cite>
(see below).</p>
</dd>
<dt><strong>return_indices</strong><span class="classifier">{False, True}, optional</span></dt><dd><p>If True, return <cite>indices</cite> as well as <cite>vertices</cite> and maybe <cite>mapping</cite>
(see below).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>unique_vertices</strong><span class="classifier">(M, 3) ndarray</span></dt><dd><p>Vertices sufficiently separated from one another.</p>
</dd>
<dt><strong>mapping</strong><span class="classifier">(N,) ndarray</span></dt><dd><p>For each element <code class="docutils literal notranslate"><span class="pre">vertices[i]</span></code> (<span class="math notranslate nohighlight">\(i \in 0..N-1\)</span>), the index <span class="math notranslate nohighlight">\(j\)</span> to a
vertex in <cite>unique_vertices</cite> that is less than <cite>theta</cite> degrees from
<code class="docutils literal notranslate"><span class="pre">vertices[i]</span></code>.  Only returned if <cite>return_mapping</cite> is True.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">(N,) ndarray</span></dt><dd><p><cite>indices</cite> gives the reverse of <cite>mapping</cite>.  For each element
<code class="docutils literal notranslate"><span class="pre">unique_vertices[j]</span></code> (<span class="math notranslate nohighlight">\(j \in 0..M-1\)</span>), the index <span class="math notranslate nohighlight">\(i\)</span> to a vertex in
<cite>vertices</cite> that is less than <cite>theta</cite> degrees from
<code class="docutils literal notranslate"><span class="pre">unique_vertices[j]</span></code>.  If there is more than one element of
<cite>vertices</cite> that is less than theta degrees from <cite>unique_vertices[j]</cite>,
return the first (lowest index) matching value.  Only return if
<cite>return_indices</cite> is True.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id55">
<h3>sphere2cart<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.sphere2cart">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">sphere2cart</code><span class="sig-paren">(</span><em class="sig-param">r</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.sphere2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical to Cartesian coordinates</p>
<p>This is the standard physics convention where <cite>theta</cite> is the
inclination (polar) angle, and <cite>phi</cite> is the azimuth angle.</p>
<p>Imagine a sphere with center (0,0,0).  Orient it with the z axis
running south-north, the y axis running west-east and the x axis
from posterior to anterior.  <cite>theta</cite> (the inclination angle) is the
angle to rotate from the z-axis (the zenith) around the y-axis,
towards the x axis.  Thus the rotation is counter-clockwise from the
point of view of positive y.  <cite>phi</cite> (azimuth) gives the angle of
rotation around the z-axis towards the y axis.  The rotation is
counter-clockwise from the point of view of positive z.</p>
<p>Equivalently, given a point P on the sphere, with coordinates x, y,
z, <cite>theta</cite> is the angle between P and the z-axis, and <cite>phi</cite> is
the angle between the projection of P onto the XY plane, and the X
axis.</p>
<p>Geographical nomenclature designates theta as ‘co-latitude’, and phi
as ‘longitude’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>r</strong><span class="classifier">array_like</span></dt><dd><p>radius</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like</span></dt><dd><p>inclination or polar angle</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array_like</span></dt><dd><p>azimuth angle</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array</span></dt><dd><p>x coordinate(s) in Cartesion space</p>
</dd>
<dt><strong>y</strong><span class="classifier">array</span></dt><dd><p>y coordinate(s) in Cartesian space</p>
</dd>
<dt><strong>z</strong><span class="classifier">array</span></dt><dd><p>z coordinate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See these pages:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Spherical_coordinate_system">http://en.wikipedia.org/wiki/Spherical_coordinate_system</a></p></li>
<li><p><a class="reference external" href="http://mathworld.wolfram.com/SphericalCoordinates.html">http://mathworld.wolfram.com/SphericalCoordinates.html</a></p></li>
</ul>
<p>for excellent discussion of the many different conventions
possible.  Here we use the physics conventions, used in the
wikipedia page.</p>
<p>Derivations of the formulae are simple. Consider a vector x, y, z of
length r (norm of x, y, z).  The inclination angle (theta) can be
found from: cos(theta) == z / r -&gt; z == r * cos(theta).  This gives
the hypotenuse of the projection onto the XY plane, which we will
call Q. Q == r*sin(theta). Now x / Q == cos(phi) -&gt; x == r *
sin(theta) * cos(phi) and so on.</p>
<p>We have deliberately named this function <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">sph2cart</span></code> to distinguish it from the Matlab function of that
name, because the Matlab function uses an unusual convention for the
angles that we did not want to replicate.  The Matlab function is
trivial to implement with the formulae given in the Matlab help.</p>
</dd></dl>

</div>
<div class="section" id="unique-edges">
<h3>unique_edges<a class="headerlink" href="#unique-edges" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.unique_edges">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">unique_edges</code><span class="sig-paren">(</span><em class="sig-param">faces</em>, <em class="sig-param">return_mapping=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.unique_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all unique edges from given triangular faces.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>faces</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Vertex indices forming triangular faces.</p>
</dd>
<dt><strong>return_mapping</strong><span class="classifier">bool</span></dt><dd><p>If true, a mapping to the edges of each face is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>edges</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Unique edges.</p>
</dd>
<dt><strong>mapping</strong><span class="classifier">(N, 3)</span></dt><dd><p>For each face, [x, y, z], a mapping to it’s edges [a, b, c].</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   y
   /               /               a/    
/                  /                   /__________          x      c     z
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="unique-sets">
<h3>unique_sets<a class="headerlink" href="#unique-sets" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.unique_sets">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">unique_sets</code><span class="sig-paren">(</span><em class="sig-param">sets</em>, <em class="sig-param">return_inverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.unique_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove duplicate sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sets</strong><span class="classifier">array (N, k)</span></dt><dd><p>N sets of size k.</p>
</dd>
<dt><strong>return_inverse</strong><span class="classifier">bool</span></dt><dd><p>If True, also returns the indices of unique_sets that can be used
to reconstruct <cite>sets</cite> (the original ordering of each set may not be
preserved).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>unique_sets</strong><span class="classifier">array</span></dt><dd><p>Unique sets.</p>
</dd>
<dt><strong>inverse</strong><span class="classifier">array (N,)</span></dt><dd><p>The indices to reconstruct <cite>sets</cite> from <cite>unique_sets</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id56">
<h3>vector_norm<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere.vector_norm">
<code class="sig-prename descclassname">dipy.core.sphere.</code><code class="sig-name descname">vector_norm</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere.vector_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector Euclidean (L2) norm</p>
<p>See <a class="reference internal" href="../glossary.html#term-unit-vector"><span class="xref std std-term">unit vector</span></a> and <a class="reference internal" href="../glossary.html#term-euclidean-norm"><span class="xref std std-term">Euclidean norm</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vec</strong><span class="classifier">array_like</span></dt><dd><p>Vectors to norm.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Axis over which to norm. By default norm over last axis. If <cite>axis</cite> is
None, <cite>vec</cite> is flattened then normed.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool</span></dt><dd><p>If True, the output will have the same number of dimensions as <cite>vec</cite>,
with shape 1 on <cite>axis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">array</span></dt><dd><p>Euclidean norms of vectors.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">77</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="go">array([ 17.,  85.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 17.],</span>
<span class="go">       [ 85.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([  8.,  39.,  77.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="permutations">
<h3><a class="reference internal" href="#dipy.core.sphere_stats.permutations" title="dipy.core.sphere_stats.permutations"><code class="xref py py-class docutils literal notranslate"><span class="pre">permutations</span></code></a><a class="headerlink" href="#permutations" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.sphere_stats.permutations">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.sphere_stats.</code><code class="sig-name descname">permutations</code><a class="headerlink" href="#dipy.core.sphere_stats.permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>permutations(iterable[, r]) –&gt; permutations object</p>
<p>Return successive r-length permutations of elements in the iterable.</p>
<p>permutations(range(3), 2) –&gt; (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)</p>
<dl class="method">
<dt id="dipy.core.sphere_stats.permutations.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere_stats.permutations.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="angular-similarity">
<h3>angular_similarity<a class="headerlink" href="#angular-similarity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere_stats.angular_similarity">
<code class="sig-prename descclassname">dipy.core.sphere_stats.</code><code class="sig-name descname">angular_similarity</code><span class="sig-paren">(</span><em class="sig-param">S</em>, <em class="sig-param">T</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere_stats.angular_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the cosine distance of the best match between
points of two sets of vectors S and T</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S</strong><span class="classifier">array, shape (m,d)</span></dt><dd></dd>
<dt><strong>T</strong><span class="classifier">array, shape (n,d)</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_cosine_distance:float</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.sphere_stats</span> <span class="k">import</span> <span class="n">angular_similarity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">2.7071067811865475</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">]])</span>
</pre></div>
</div>
<p>Now we use <code class="docutils literal notranslate"><span class="pre">print</span></code> to reduce the precision of of the printed output
(so the doctests don’t detect unimportant differences)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">))</span>
<span class="go">0.707106781187</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">))</span>
<span class="go">0.707106781187</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">angular_similarity</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">))</span>
<span class="go">0.707106781187</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="compare-orientation-sets">
<h3>compare_orientation_sets<a class="headerlink" href="#compare-orientation-sets" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere_stats.compare_orientation_sets">
<code class="sig-prename descclassname">dipy.core.sphere_stats.</code><code class="sig-name descname">compare_orientation_sets</code><span class="sig-paren">(</span><em class="sig-param">S</em>, <em class="sig-param">T</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere_stats.compare_orientation_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the mean cosine distance of the best match between
points of two sets of vectors S and T (angular similarity)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S</strong><span class="classifier">array, shape (m,d)</span></dt><dd><p>First set of vectors.</p>
</dd>
<dt><strong>T</strong><span class="classifier">array, shape (n,d)</span></dt><dd><p>Second set of vectors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_mean_cosine</strong><span class="classifier">float</span></dt><dd><p>Maximum mean cosine distance.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.sphere_stats</span> <span class="k">import</span> <span class="n">compare_orientation_sets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compare_orientation_sets</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compare_orientation_sets</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.sphere_stats</span> <span class="k">import</span> <span class="n">compare_orientation_sets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compare_orientation_sets</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="eigenstats">
<h3>eigenstats<a class="headerlink" href="#eigenstats" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere_stats.eigenstats">
<code class="sig-prename descclassname">dipy.core.sphere_stats.</code><code class="sig-name descname">eigenstats</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">alpha=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere_stats.eigenstats" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal direction and confidence ellipse</p>
<p>Implements equations in section 6.3.1(ii) of Fisher, Lewis and
Embleton, supplemented by equations in section 3.2.5.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">arraey_like (N,3)</span></dt><dd><p>array of points on the sphere of radius 1 in <span class="math notranslate nohighlight">\(\mathbb{R}^3\)</span></p>
</dd>
<dt><strong>alpha</strong><span class="classifier">real or None</span></dt><dd><p>1 minus the coverage for the confidence ellipsoid, e.g. 0.05 for 95%
coverage.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>centre</strong><span class="classifier">vector (3,)</span></dt><dd><p>centre of ellipsoid</p>
</dd>
<dt><strong>b1</strong><span class="classifier">vector (2,)</span></dt><dd><p>lengths of semi-axes of ellipsoid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="random-uniform-on-sphere">
<h3>random_uniform_on_sphere<a class="headerlink" href="#random-uniform-on-sphere" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.sphere_stats.random_uniform_on_sphere">
<code class="sig-prename descclassname">dipy.core.sphere_stats.</code><code class="sig-name descname">random_uniform_on_sphere</code><span class="sig-paren">(</span><em class="sig-param">n=1</em>, <em class="sig-param">coords='xyz'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.sphere_stats.random_uniform_on_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Random unit vectors from a uniform distribution on the sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of random vectors</p>
</dd>
<dt><strong>coords</strong><span class="classifier">{‘xyz’, ‘radians’, ‘degrees’}</span></dt><dd><p>‘xyz’ for cartesian form
‘radians’ for spherical form in rads
‘degrees’ for spherical form in degrees</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>X</strong><span class="classifier">array, shape (n,3) if coords=’xyz’ or shape (n,2) otherwise</span></dt><dd><p>Uniformly distributed vectors on the unit sphere.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The uniform distribution on the sphere, parameterized by spherical
coordinates <span class="math notranslate nohighlight">\((\theta, \phi)\)</span>, should verify <span class="math notranslate nohighlight">\(\phi\sim U[0,2\pi]\)</span>, while
<span class="math notranslate nohighlight">\(z=\cos(\theta)\sim U[-1,1]\)</span>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r855e1bb248b7-1"><span class="brackets"><a class="fn-backref" href="#id57">1</a></span></dt>
<dd><p><a class="reference external" href="http://mathworld.wolfram.com/SpherePointPicking.html">http://mathworld.wolfram.com/SpherePointPicking.html</a>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.sphere_stats</span> <span class="k">import</span> <span class="n">random_uniform_on_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">random_uniform_on_sphere</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;radians&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">random_uniform_on_sphere</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id58">
<h3><a class="reference internal" href="#dipy.core.subdivide_octahedron.HemiSphere" title="dipy.core.subdivide_octahedron.HemiSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">HemiSphere</span></code></a><a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.core.subdivide_octahedron.HemiSphere">
<em class="property">class </em><code class="sig-prename descclassname">dipy.core.subdivide_octahedron.</code><code class="sig-name descname">HemiSphere</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">phi=None</em>, <em class="sig-param">xyz=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">edges=None</em>, <em class="sig-param">tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.subdivide_octahedron.HemiSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.core.sphere.Sphere" title="dipy.core.sphere.Sphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.core.sphere.Sphere</span></code></a></p>
<p>Points on the unit sphere.</p>
<p>A HemiSphere is similar to a Sphere but it takes antipodal symmetry into
account. Antipodal symmetry means that point v on a HemiSphere is the same
as the point -v. Duplicate points are discarded when constructing a
HemiSphere (including antipodal duplicates). <cite>edges</cite> and <cite>faces</cite> are
remapped to the remaining points as closely as possible.</p>
<p>The HemiSphere can be constructed using one of three conventions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">HemiSphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">HemiSphere</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">HemiSphere</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x, y, z</strong><span class="classifier">1-D array_like</span></dt><dd><p>Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>theta, phi</strong><span class="classifier">1-D array_like</span></dt><dd><p>Vertices as spherical coordinates.  Theta and phi are the inclination
and azimuth angles respectively.</p>
</dd>
<dt><strong>xyz</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Indices into vertices that form triangular faces.  If unspecified,
the faces are computed using a Delaunay triangulation.</p>
</dd>
<dt><strong>edges</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Edges between vertices.  If unspecified, the edges are
derived from the faces.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Angle in degrees. Vertices that are less than tol degrees apart are
treated as duplicates.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sphere</span></code></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong></dt><dd></dd>
<dt><strong>y</strong></dt><dd></dd>
<dt><strong>z</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.subdivide_octahedron.HemiSphere.find_closest" title="dipy.core.subdivide_octahedron.HemiSphere.find_closest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_closest</span></code></a>(xyz)</p></td>
<td><p>Find the index of the vertex in the Sphere closest to the input vector, taking into account antipodal symmetry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.subdivide_octahedron.HemiSphere.from_sphere" title="dipy.core.subdivide_octahedron.HemiSphere.from_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_sphere</span></code></a>(sphere[, tol])</p></td>
<td><p>Create instance from a Sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.core.subdivide_octahedron.HemiSphere.mirror" title="dipy.core.subdivide_octahedron.HemiSphere.mirror"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mirror</span></code></a>()</p></td>
<td><p>Create a full Sphere from a HemiSphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.core.subdivide_octahedron.HemiSphere.subdivide" title="dipy.core.subdivide_octahedron.HemiSphere.subdivide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code></a>([n])</p></td>
<td><p>Create a more subdivided HemiSphere</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>edges</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>faces</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>vertices</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.core.subdivide_octahedron.HemiSphere.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">phi=None</em>, <em class="sig-param">xyz=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">edges=None</em>, <em class="sig-param">tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.subdivide_octahedron.HemiSphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a HemiSphere from points</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.subdivide_octahedron.HemiSphere.faces">
<code class="sig-name descname">faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.subdivide_octahedron.HemiSphere.faces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.core.subdivide_octahedron.HemiSphere.find_closest">
<code class="sig-name descname">find_closest</code><span class="sig-paren">(</span><em class="sig-param">xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.subdivide_octahedron.HemiSphere.find_closest" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the vertex in the Sphere closest to the input vector,
taking into account antipodal symmetry</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">array-like, 3 elements</span></dt><dd><p>A unit vector</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The index into the Sphere.vertices array that gives the closest
vertex (in angle).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.core.subdivide_octahedron.HemiSphere.from_sphere">
<em class="property">classmethod </em><code class="sig-name descname">from_sphere</code><span class="sig-paren">(</span><em class="sig-param">sphere</em>, <em class="sig-param">tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.subdivide_octahedron.HemiSphere.from_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create instance from a Sphere</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.subdivide_octahedron.HemiSphere.mirror">
<code class="sig-name descname">mirror</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.subdivide_octahedron.HemiSphere.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a full Sphere from a HemiSphere</p>
</dd></dl>

<dl class="method">
<dt id="dipy.core.subdivide_octahedron.HemiSphere.subdivide">
<code class="sig-name descname">subdivide</code><span class="sig-paren">(</span><em class="sig-param">n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.subdivide_octahedron.HemiSphere.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a more subdivided HemiSphere</p>
<p>See Sphere.subdivide for full documentation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="create-unit-hemisphere">
<h3>create_unit_hemisphere<a class="headerlink" href="#create-unit-hemisphere" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.subdivide_octahedron.create_unit_hemisphere">
<code class="sig-prename descclassname">dipy.core.subdivide_octahedron.</code><code class="sig-name descname">create_unit_hemisphere</code><span class="sig-paren">(</span><em class="sig-param">recursion_level=2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.subdivide_octahedron.create_unit_hemisphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a unit sphere by subdividing a unit octahedron, returns half
the sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>recursion_level</strong><span class="classifier">int</span></dt><dd><p>Level of subdivision, recursion_level=1 will return an octahedron,
anything bigger will return a more subdivided sphere. The sphere will
have <span class="math notranslate nohighlight">\((4^recursion_level+2)/2\)</span> vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>HemiSphere :</strong></dt><dd><p>Half of a unit sphere.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dipy.core.subdivide_octahedron.create_unit_sphere" title="dipy.core.subdivide_octahedron.create_unit_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_unit_sphere</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sphere</span></code>, <a class="reference internal" href="#dipy.core.subdivide_octahedron.HemiSphere" title="dipy.core.subdivide_octahedron.HemiSphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HemiSphere</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="create-unit-sphere">
<h3>create_unit_sphere<a class="headerlink" href="#create-unit-sphere" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.subdivide_octahedron.create_unit_sphere">
<code class="sig-prename descclassname">dipy.core.subdivide_octahedron.</code><code class="sig-name descname">create_unit_sphere</code><span class="sig-paren">(</span><em class="sig-param">recursion_level=2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.subdivide_octahedron.create_unit_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a unit sphere by subdividing a unit octahedron.</p>
<p>Starts with a unit octahedron and subdivides the faces, projecting the
resulting points onto the surface of a unit sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>recursion_level</strong><span class="classifier">int</span></dt><dd><p>Level of subdivision, recursion_level=1 will return an octahedron,
anything bigger will return a more subdivided sphere. The sphere will
have <span class="math notranslate nohighlight">\(4^recursion_level+2\)</span> vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Sphere :</strong></dt><dd><p>The unit sphere.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dipy.core.subdivide_octahedron.create_unit_hemisphere" title="dipy.core.subdivide_octahedron.create_unit_hemisphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_unit_hemisphere</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sphere</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="afb3d">
<h3>afb3D<a class="headerlink" href="#afb3d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.wavelet.afb3D">
<code class="sig-prename descclassname">dipy.core.wavelet.</code><code class="sig-name descname">afb3D</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">af1</em>, <em class="sig-param">af2=None</em>, <em class="sig-param">af3=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.wavelet.afb3D" title="Permalink to this definition">¶</a></dt>
<dd><p>3D Analysis Filter Bank</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">3D ndarray</span></dt><dd><p>N1 by N2 by N3 array matrix, where
1) N1, N2, N3 all even
2) N1 &gt;= 2*len(af1)
3) N2 &gt;= 2*len(af2)
4) N3 &gt;= 2*len(af3)</p>
</dd>
<dt><strong>afi</strong><span class="classifier">2D ndarray</span></dt><dd><p>analysis filters for dimension i
afi[:, 1] - lowpass filter
afi[:, 2] - highpass filter</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lo</strong><span class="classifier">1D array</span></dt><dd><p>lowpass subband</p>
</dd>
<dt><strong>hi</strong><span class="classifier">1D array</span></dt><dd><p>highpass subbands, h[d]- d = 1..7</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="afb3d-a">
<h3>afb3D_A<a class="headerlink" href="#afb3d-a" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.wavelet.afb3D_A">
<code class="sig-prename descclassname">dipy.core.wavelet.</code><code class="sig-name descname">afb3D_A</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">af</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.wavelet.afb3D_A" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>3D Analysis Filter Bank</dt><dd><p>(along one dimension only)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">3D ndarray</span></dt><dd><dl class="simple">
<dt>N1xN2xN2 matrix, where min(N1,N2,N3) &gt; 2*length(filter)</dt><dd><p>(Ni are even)</p>
</dd>
</dl>
</dd>
<dt><strong>af</strong><span class="classifier">2D ndarray</span></dt><dd><p>analysis filter for the columns
af[:, 1] - lowpass filter
af[:, 2] - highpass filter</p>
</dd>
<dt><strong>d</strong><span class="classifier">int</span></dt><dd><p>dimension of filtering (d = 1, 2 or 3)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lo</strong><span class="classifier">1D array</span></dt><dd><p>lowpass subbands</p>
</dd>
<dt><strong>hi</strong><span class="classifier">1D array</span></dt><dd><p>highpass subbands</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="cshift3d">
<h3>cshift3D<a class="headerlink" href="#cshift3d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.wavelet.cshift3D">
<code class="sig-prename descclassname">dipy.core.wavelet.</code><code class="sig-name descname">cshift3D</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">m</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.wavelet.cshift3D" title="Permalink to this definition">¶</a></dt>
<dd><p>3D Circular Shift</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">3D ndarray</span></dt><dd><p>N1 by N2 by N3 array</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>amount of shift</p>
</dd>
<dt><strong>d</strong><span class="classifier">int</span></dt><dd><p>dimension of shift (d = 1,2,3)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">3D ndarray</span></dt><dd><p>array x will be shifed by m samples down
along dimension d</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="dwt3d">
<h3>dwt3D<a class="headerlink" href="#dwt3d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.wavelet.dwt3D">
<code class="sig-prename descclassname">dipy.core.wavelet.</code><code class="sig-name descname">dwt3D</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">J</em>, <em class="sig-param">af</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.wavelet.dwt3D" title="Permalink to this definition">¶</a></dt>
<dd><p>3-D Discrete Wavelet Transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">3D ndarray</span></dt><dd><p>N1 x N2 x N3 matrix
1) Ni all even
2) min(Ni) &gt;= 2^(J-1)*length(af)</p>
</dd>
<dt><strong>J</strong><span class="classifier">int</span></dt><dd><p>number of stages</p>
</dd>
<dt><strong>af</strong><span class="classifier">2D ndarray</span></dt><dd><p>analysis filters</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">cell array</span></dt><dd><p>wavelet coefficients</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="idwt3d">
<h3>idwt3D<a class="headerlink" href="#idwt3d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.wavelet.idwt3D">
<code class="sig-prename descclassname">dipy.core.wavelet.</code><code class="sig-name descname">idwt3D</code><span class="sig-paren">(</span><em class="sig-param">w</em>, <em class="sig-param">J</em>, <em class="sig-param">sf</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.wavelet.idwt3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse 3-D Discrete Wavelet Transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>w</strong><span class="classifier">cell array</span></dt><dd><p>wavelet coefficient</p>
</dd>
<dt><strong>J</strong><span class="classifier">int</span></dt><dd><p>number of stages</p>
</dd>
<dt><strong>sf</strong><span class="classifier">2D ndarray</span></dt><dd><p>synthesis filters</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">3D ndarray</span></dt><dd><p>output array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="permutationinverse">
<h3>permutationinverse<a class="headerlink" href="#permutationinverse" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.wavelet.permutationinverse">
<code class="sig-prename descclassname">dipy.core.wavelet.</code><code class="sig-name descname">permutationinverse</code><span class="sig-paren">(</span><em class="sig-param">perm</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.wavelet.permutationinverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Function generating inverse of the permutation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">1D array</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inverse</strong><span class="classifier">1D array</span></dt><dd><p>permutation inverse of the input</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="sfb3d">
<h3>sfb3D<a class="headerlink" href="#sfb3d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.wavelet.sfb3D">
<code class="sig-prename descclassname">dipy.core.wavelet.</code><code class="sig-name descname">sfb3D</code><span class="sig-paren">(</span><em class="sig-param">lo</em>, <em class="sig-param">hi</em>, <em class="sig-param">sf1</em>, <em class="sig-param">sf2=None</em>, <em class="sig-param">sf3=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.wavelet.sfb3D" title="Permalink to this definition">¶</a></dt>
<dd><p>3D Synthesis Filter Bank</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lo</strong><span class="classifier">1D array</span></dt><dd><p>lowpass subbands</p>
</dd>
<dt><strong>hi</strong><span class="classifier">1D array</span></dt><dd><p>highpass subbands</p>
</dd>
<dt><strong>sfi</strong><span class="classifier">2D ndarray</span></dt><dd><p>synthesis filters for dimension i</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">3D ndarray</span></dt><dd><p>output array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="sfb3d-a">
<h3>sfb3D_A<a class="headerlink" href="#sfb3d-a" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.core.wavelet.sfb3D_A">
<code class="sig-prename descclassname">dipy.core.wavelet.</code><code class="sig-name descname">sfb3D_A</code><span class="sig-paren">(</span><em class="sig-param">lo</em>, <em class="sig-param">hi</em>, <em class="sig-param">sf</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.core.wavelet.sfb3D_A" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>3D Synthesis Filter Bank</dt><dd><p>(along single dimension only)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lo</strong><span class="classifier">1D array</span></dt><dd><p>lowpass subbands</p>
</dd>
<dt><strong>hi</strong><span class="classifier">1D array</span></dt><dd><p>highpass subbands</p>
</dd>
<dt><strong>sf</strong><span class="classifier">2D ndarray</span></dt><dd><p>synthesis filters</p>
</dd>
<dt><strong>d</strong><span class="classifier">int</span></dt><dd><p>dimension of filtering</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">3D ndarray</span></dt><dd><p>the N1xN2xN3 matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.data.html" title="data"
             >next</a> |</li>
        <li class="right" >
          <a href="dipy.boots.html" title="boots"
             >previous</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >API Reference</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2019, dipy developers &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>