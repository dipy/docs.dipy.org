
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_built\reconstruction\reconst_shore_metrics.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_built_reconstruction_reconst_shore_metrics.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_built_reconstruction_reconst_shore_metrics.py:


===========================
Calculate SHORE scalar maps
===========================

We show how to calculate two SHORE-based scalar maps: return to origin
probability (RTOP) [Descoteaux2011]_ and mean square displacement (MSD)
[Wu2007]_, [Wu2008]_ on your data. SHORE can be used with any multiple b-value
dataset like multi-shell or DSI.

First import the necessary modules:

.. GENERATED FROM PYTHON SOURCE LINES 13-22

.. code-block:: Python


    import numpy as np
    import matplotlib.pyplot as plt
    from dipy.core.gradients import gradient_table
    from dipy.data import get_fnames
    from dipy.io.gradients import read_bvals_bvecs
    from dipy.io.image import load_nifti
    from dipy.reconst.shore import ShoreModel








.. GENERATED FROM PYTHON SOURCE LINES 23-24

Download and get the data filenames for this tutorial.

.. GENERATED FROM PYTHON SOURCE LINES 24-27

.. code-block:: Python


    fraw, fbval, fbvec = get_fnames('taiwan_ntu_dsi')








.. GENERATED FROM PYTHON SOURCE LINES 28-33

img contains a nibabel Nifti1Image object (data) and gtab contains a
GradientTable object (gradient information e.g. b-values). For example, to
read the b-values it is possible to write print(gtab.bvals).

Load the raw diffusion data and the affine.

.. GENERATED FROM PYTHON SOURCE LINES 33-41

.. code-block:: Python


    data, affine = load_nifti(fraw)
    bvals, bvecs = read_bvals_bvecs(fbval, fbvec)
    bvecs[1:] = (bvecs[1:] /
                 np.sqrt(np.sum(bvecs[1:] * bvecs[1:], axis=1))[:, None])
    gtab = gradient_table(bvals, bvecs)
    print('data.shape (%d, %d, %d, %d)' % data.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data.shape (96, 96, 60, 203)




.. GENERATED FROM PYTHON SOURCE LINES 42-43

Instantiate the Model.

.. GENERATED FROM PYTHON SOURCE LINES 43-46

.. code-block:: Python


    asm = ShoreModel(gtab)








.. GENERATED FROM PYTHON SOURCE LINES 47-48

Let's just use only one slice only from the data.

.. GENERATED FROM PYTHON SOURCE LINES 48-51

.. code-block:: Python


    dataslice = data[30:70, 20:80, data.shape[2] // 2]








.. GENERATED FROM PYTHON SOURCE LINES 52-53

Fit the signal with the model and calculate the SHORE coefficients.

.. GENERATED FROM PYTHON SOURCE LINES 53-56

.. code-block:: Python


    asmfit = asm.fit(dataslice)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|                                                                                                                                          | 0/2400 [00:00<?, ?it/s]C:\Users\skoudoro\Devel\dipy\dipy\core\geometry.py:130: RuntimeWarning: invalid value encountered in arccos
      theta = np.arccos(np.divide(z, r, where=r > 0))
      0%|                                                                                                                                  | 1/2400 [00:00<06:41,  5.98it/s]      6%|███████▉                                                                                                                       | 151/2400 [00:00<00:03, 691.41it/s]     13%|███████████████▉                                                                                                              | 304/2400 [00:00<00:02, 1022.22it/s]     19%|███████████████████████▉                                                                                                      | 455/2400 [00:00<00:01, 1196.99it/s]     25%|███████████████████████████████▉                                                                                              | 608/2400 [00:00<00:01, 1308.83it/s]     32%|████████████████████████████████████████                                                                                      | 764/2400 [00:00<00:01, 1387.29it/s]     38%|████████████████████████████████████████████████                                                                              | 915/2400 [00:00<00:01, 1424.78it/s]     44%|███████████████████████████████████████████████████████▋                                                                     | 1068/2400 [00:00<00:00, 1456.23it/s]     51%|███████████████████████████████████████████████████████████████▌                                                             | 1220/2400 [00:00<00:00, 1474.55it/s]     57%|███████████████████████████████████████████████████████████████████████▎                                                     | 1370/2400 [00:01<00:00, 1476.43it/s]     63%|███████████████████████████████████████████████████████████████████████████████▎                                             | 1522/2400 [00:01<00:00, 1488.35it/s]     70%|███████████████████████████████████████████████████████████████████████████████████████                                      | 1672/2400 [00:01<00:00, 1481.71it/s]     76%|███████████████████████████████████████████████████████████████████████████████████████████████▍                             | 1833/2400 [00:01<00:00, 1520.02it/s]     83%|███████████████████████████████████████████████████████████████████████████████████████████████████████▍                     | 1986/2400 [00:01<00:00, 1515.18it/s]     89%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████▎             | 2138/2400 [00:01<00:00, 1515.25it/s]     95%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▎     | 2290/2400 [00:01<00:00, 1513.11it/s]    100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2400/2400 [00:01<00:00, 1370.41it/s]




.. GENERATED FROM PYTHON SOURCE LINES 57-59

Calculate the analytical RTOP on the signal
that corresponds to the integral of the signal.

.. GENERATED FROM PYTHON SOURCE LINES 59-63

.. code-block:: Python


    print('Calculating... rtop_signal')
    rtop_signal = asmfit.rtop_signal()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... rtop_signal




.. GENERATED FROM PYTHON SOURCE LINES 64-66

Now we calculate the analytical RTOP on the propagator,
that corresponds to its central value.

.. GENERATED FROM PYTHON SOURCE LINES 66-70

.. code-block:: Python


    print('Calculating... rtop_pdf')
    rtop_pdf = asmfit.rtop_pdf()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... rtop_pdf




.. GENERATED FROM PYTHON SOURCE LINES 71-73

In theory, these two measures must be equal,
to show that we calculate the mean square error on this two measures.

.. GENERATED FROM PYTHON SOURCE LINES 73-77

.. code-block:: Python


    mse = np.sum((rtop_signal - rtop_pdf) ** 2) / rtop_signal.size
    print(f"MSE = {mse:f}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    MSE = 0.000000




.. GENERATED FROM PYTHON SOURCE LINES 78-79

Let's calculate the analytical mean square displacement on the propagator.

.. GENERATED FROM PYTHON SOURCE LINES 79-83

.. code-block:: Python


    print('Calculating... msd')
    msd = asmfit.msd()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... msd




.. GENERATED FROM PYTHON SOURCE LINES 84-85

Show the maps and save them to a file.

.. GENERATED FROM PYTHON SOURCE LINES 85-101

.. code-block:: Python


    fig = plt.figure(figsize=(6, 6))
    ax1 = fig.add_subplot(2, 2, 1, title='rtop_signal')
    ax1.set_axis_off()
    ind = ax1.imshow(rtop_signal.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    ax2 = fig.add_subplot(2, 2, 2, title='rtop_pdf')
    ax2.set_axis_off()
    ind = ax2.imshow(rtop_pdf.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    ax3 = fig.add_subplot(2, 2, 3, title='msd')
    ax3.set_axis_off()
    ind = ax3.imshow(msd.T, interpolation='nearest', origin='lower', vmin=0)
    plt.colorbar(ind)
    plt.savefig('SHORE_maps.png')




.. image-sg:: /examples_built/reconstruction/images/sphx_glr_reconst_shore_metrics_001.png
   :alt: reconst shore metrics
   :srcset: /examples_built/reconstruction/images/sphx_glr_reconst_shore_metrics_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 102-120

.. rst-class:: centered small fst-italic fw-semibold

RTOP and MSD calculated using the SHORE model.


References
----------

.. [Descoteaux2011] Descoteaux M. et al., "Multiple q-shell diffusion
   propagator imaging", Medical Image Analysis, vol 15, No. 4, p. 603-621,
   2011.

.. [Wu2007] Wu Y. et al., "Hybrid diffusion imaging", NeuroImage, vol 36, p.
   617-629, 2007.

.. [Wu2008] Wu Y. et al., "Computation of Diffusion Function Measures in
   q-Space Using Magnetic Resonance Hybrid Diffusion Imaging", IEEE
   TRANSACTIONS ON MEDICAL IMAGING, vol. 27, No. 6, p. 858-865, 2008.

.. GENERATED FROM PYTHON SOURCE LINES 122-124

.. include:: ../../links_names.inc



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 4.180 seconds)


.. _sphx_glr_download_examples_built_reconstruction_reconst_shore_metrics.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: reconst_shore_metrics.ipynb <reconst_shore_metrics.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: reconst_shore_metrics.py <reconst_shore_metrics.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
