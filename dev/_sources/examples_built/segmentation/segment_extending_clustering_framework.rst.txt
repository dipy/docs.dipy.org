
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_built/segmentation/segment_extending_clustering_framework.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_built_segmentation_segment_extending_clustering_framework.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_built_segmentation_segment_extending_clustering_framework.py:


==========================================================
Enhancing QuickBundles with different metrics and features
==========================================================

QuickBundles :footcite:p:`Garyfallidis2012a` is a flexible algorithm that
requires only a distance metric and an adjacency threshold to perform
clustering. There is a wide variety of metrics that could be used to cluster
streamlines.

The purpose of this tutorial is to show how to easily create new ``Feature``
and new ``Metric`` classes that can be used by QuickBundles.

.. _clustering-framework:

Clustering framework
====================
DIPY_ provides a simple, flexible and fast framework to do clustering of
sequential data (e.g. streamlines).

A *sequential datum* in DIPY is represented as a numpy array of size
:math:`(N       imes D)`, where each row of the array represents a $D$ dimensional
point of the sequence. A set of these sequences is represented as a list of
numpy arrays of size :math:`(N_i        imes D)` for :math:`i=1:M` where $M$ is the
number of sequences in the set.

This clustering framework is modular and divided in three parts:

#. Feature extraction

#. Distance computation

#. Clustering algorithm

The **feature extraction** part includes any preprocessing needed to be done on
the data before computing distances between them (e.g. resampling the number of
points of a streamline). To define a new way of extracting features, one has to
subclass ``Feature`` (see below).

The **distance computation** part includes any metric capable of evaluating a
distance between two sets of features previously extracted from the data. To
define a new way of extracting features, one has to subclass ``Metric`` (see
below).

The **clustering algorithm** part represents the clustering algorithm itself
(e.g. QuickBundles, K-means, Hierarchical Clustering). More precisely, it
includes any algorithms taking as input a list of sequential data and
outputting a ``ClusterMap`` object.


Extending `Feature`
===================
This section will guide you through the creation of a new feature extraction
method that can be used in the context of this clustering framework. For a
list of available features in DIPY see
:ref:`sphx_glr_examples_built_segmentation_segment_clustering_features.py`.

Assuming a set of streamlines, the type of features we want to extract is the
arc length (i.e. the sum of the length of each segment for a given streamline).

Let's start by importing the necessary modules.

.. GENERATED FROM PYTHON SOURCE LINES 63-74

.. code-block:: Python


    import numpy as np

    from dipy.data import get_fnames
    from dipy.io.streamline import load_tractogram
    from dipy.segment.clustering import QuickBundles
    from dipy.segment.featurespeed import Feature, VectorOfEndpointsFeature
    from dipy.segment.metric import Metric, SumPointwiseEuclideanMetric
    from dipy.tracking.streamline import Streamlines, length
    from dipy.viz import actor, colormap, window








.. GENERATED FROM PYTHON SOURCE LINES 75-83

We now define the class ``ArcLengthFeature`` that will perform the desired
feature extraction. When subclassing ``Feature``, two methods have to be
redefined: ``infer_shape`` and ``extract``.

Also, an important property about feature extraction is whether or not
its process is invariant to the order of the points within a streamline.
This is needed as there is no way one can tell which extremity of a
streamline is the beginning and which one is the end.

.. GENERATED FROM PYTHON SOURCE LINES 83-102

.. code-block:: Python



    class ArcLengthFeature(Feature):
        """Computes the arc length of a streamline."""

        def __init__(self):
            # The arc length stays the same even if the streamline is reversed.
            super(ArcLengthFeature, self).__init__(is_order_invariant=True)

        def infer_shape(self, streamline):
            """Infers the shape of features extracted from `streamline`."""
            # Arc length is a scalar
            return 1

        def extract(self, streamline):
            """Extracts features from `streamline`."""
            return length(streamline)









.. GENERATED FROM PYTHON SOURCE LINES 103-109

The new feature extraction ``ArcLengthFeature`` is ready to be used. Let's
use it to cluster a set of streamlines by their arc length. For educational
purposes we will try to cluster a small streamline bundle known from
neuroanatomy as the fornix.

We start by loading the fornix streamlines.

.. GENERATED FROM PYTHON SOURCE LINES 109-115

.. code-block:: Python


    fname = get_fnames(name="fornix")
    fornix = load_tractogram(fname, "same", bbox_valid_check=False).streamlines

    streamlines = Streamlines(fornix)








.. GENERATED FROM PYTHON SOURCE LINES 116-118

Perform QuickBundles clustering using the metric
``SumPointwiseEuclideanMetric`` and our ``ArcLengthFeature``.

.. GENERATED FROM PYTHON SOURCE LINES 118-123

.. code-block:: Python


    metric = SumPointwiseEuclideanMetric(feature=ArcLengthFeature())
    qb = QuickBundles(threshold=2.0, metric=metric)
    clusters = qb.cluster(streamlines)








.. GENERATED FROM PYTHON SOURCE LINES 124-125

We will now visualize the clustering result.

.. GENERATED FROM PYTHON SOURCE LINES 125-142

.. code-block:: Python


    # Color each streamline according to the cluster they belong to.
    cmap = colormap.create_colormap(np.ravel(clusters.centroids))
    colormap_full = np.ones((len(streamlines), 3))
    for cluster, color in zip(clusters, cmap):
        colormap_full[cluster.indices] = color

    scene = window.Scene()
    scene.SetBackground(1, 1, 1)
    scene.add(actor.streamtube(streamlines, colors=colormap_full))
    window.record(scene=scene, out_path="fornix_clusters_arclength.png", size=(600, 600))

    # Enables/disables interactive visualization
    interactive = False
    if interactive:
        window.show(scene)




.. image-sg:: /examples_built/segmentation/images/sphx_glr_segment_extending_clustering_framework_001.png
   :alt: segment extending clustering framework
   :srcset: /examples_built/segmentation/images/sphx_glr_segment_extending_clustering_framework_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 143-166

.. rst-class:: centered small fst-italic fw-semibold

Showing the different clusters obtained by using the arc length.


Extending `Metric`
==================
This section will guide you through the creation of a new metric that can be
used in the context of this clustering framework. For a list of available
metrics in DIPY see
:ref:`sphx_glr_examples_built_segmentation_segment_clustering_metrics.py`.

Assuming a set of streamlines, we want a metric that computes the cosine
distance giving the vector between endpoints of each streamline (i.e. one
minus the cosine of the angle between two vectors). For more information
about this distance check
`<https://en.wikipedia.org/wiki/Cosine_similarity>`_.

We now define the class ``CosineMetric`` that will perform the desired
distance computation. When subclassing ``Metric``, two methods have to be
redefined: ``are_compatible`` and ``dist``. Moreover, when implementing the
``dist`` method, one needs to make sure the distance returned is symmetric
(i.e. `dist(A, B) == dist(B, A)`).

.. GENERATED FROM PYTHON SOURCE LINES 166-198

.. code-block:: Python



    class CosineMetric(Metric):
        """Compute the cosine distance between two streamlines."""

        def __init__(self):
            # For simplicity, features will be the vector between endpoints of a
            # streamline.
            super(CosineMetric, self).__init__(feature=VectorOfEndpointsFeature())

        def are_compatible(self, shape1, shape2):
            """Check if two features are vectors of same dimension.

            Basically this method exists so that we don't have to check
            inside the `dist` method (speedup).
            """
            return shape1 == shape2 and shape1[0] == 1

        def dist(self, v1, v2):
            """Compute a the cosine distance between two vectors."""

            def norm(x):
                return np.sqrt(np.sum(x**2))

            cos_theta = np.dot(v1, v2.T) / (norm(v1) * norm(v2))

            # Make sure it's in [-1, 1], i.e. within domain of arccosine
            cos_theta = np.minimum(cos_theta, 1.0)
            cos_theta = np.maximum(cos_theta, -1.0)
            return np.arccos(cos_theta) / np.pi  # Normalized cosine distance









.. GENERATED FROM PYTHON SOURCE LINES 199-205

The new distance ``CosineMetric`` is ready to be used. Let's use
it to cluster a set of streamlines according to the cosine distance of the
vector between their endpoints. For educational purposes we will try to
cluster a small streamline bundle known from neuroanatomy as the fornix.

We start by loading the fornix streamlines.

.. GENERATED FROM PYTHON SOURCE LINES 205-210

.. code-block:: Python


    fname = get_fnames(name="fornix")
    fornix = load_tractogram(fname, "same", bbox_valid_check=False)
    streamlines = fornix.streamlines








.. GENERATED FROM PYTHON SOURCE LINES 211-212

Perform QuickBundles clustering using our metric ``CosineMetric``.

.. GENERATED FROM PYTHON SOURCE LINES 212-217

.. code-block:: Python


    metric = CosineMetric()
    qb = QuickBundles(threshold=0.1, metric=metric)
    clusters = qb.cluster(streamlines)








.. GENERATED FROM PYTHON SOURCE LINES 218-219

We will now visualize the clustering result.

.. GENERATED FROM PYTHON SOURCE LINES 219-233

.. code-block:: Python


    # Color each streamline according to the cluster they belong to.
    cmap = colormap.create_colormap(np.arange(len(clusters)))
    colormap_full = np.ones((len(streamlines), 3))
    for cluster, color in zip(clusters, cmap):
        colormap_full[cluster.indices] = color

    scene = window.Scene()
    scene.SetBackground(1, 1, 1)
    scene.add(actor.streamtube(streamlines, colors=colormap_full))
    window.record(scene=scene, out_path="fornix_clusters_cosine.png", size=(600, 600))
    if interactive:
        window.show(scene)




.. image-sg:: /examples_built/segmentation/images/sphx_glr_segment_extending_clustering_framework_002.png
   :alt: segment extending clustering framework
   :srcset: /examples_built/segmentation/images/sphx_glr_segment_extending_clustering_framework_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 234-245

.. rst-class:: centered small fst-italic fw-semibold

Showing the different clusters obtained by using the cosine metric.



References
----------

.. footbibliography::


.. GENERATED FROM PYTHON SOURCE LINES 247-249

.. include:: ../../links_names.inc



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.225 seconds)


.. _sphx_glr_download_examples_built_segmentation_segment_extending_clustering_framework.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: segment_extending_clustering_framework.ipynb <segment_extending_clustering_framework.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: segment_extending_clustering_framework.py <segment_extending_clustering_framework.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: segment_extending_clustering_framework.zip <segment_extending_clustering_framework.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
