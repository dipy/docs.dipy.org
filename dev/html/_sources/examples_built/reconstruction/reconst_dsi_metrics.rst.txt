
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_built\reconstruction\reconst_dsi_metrics.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_built_reconstruction_reconst_dsi_metrics.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_built_reconstruction_reconst_dsi_metrics.py:


===============================
Calculate DSI-based scalar maps
===============================

We show how to calculate two DSI-based scalar maps: return to origin
probability (RTOP) [Descoteaux2011]_ and mean square displacement (MSD)
[Wu2007]_, [Wu2008]_ on your dataset.

First import the necessary modules:

.. GENERATED FROM PYTHON SOURCE LINES 12-21

.. code-block:: Python


    import numpy as np
    import matplotlib.pyplot as plt
    from dipy.core.gradients import gradient_table
    from dipy.data import get_fnames
    from dipy.io.gradients import read_bvals_bvecs
    from dipy.io.image import load_nifti
    from dipy.reconst.dsi import DiffusionSpectrumModel








.. GENERATED FROM PYTHON SOURCE LINES 22-23

Download and get the data filenames for this tutorial.

.. GENERATED FROM PYTHON SOURCE LINES 23-26

.. code-block:: Python


    fraw, fbval, fbvec = get_fnames('taiwan_ntu_dsi')








.. GENERATED FROM PYTHON SOURCE LINES 27-32

img contains a nibabel Nifti1Image object (data) and gtab contains a
GradientTable object (gradient information e.g. b-values). For example to
read the b-values it is possible to write print(gtab.bvals).

Load the raw diffusion data and the affine.

.. GENERATED FROM PYTHON SOURCE LINES 32-41

.. code-block:: Python


    data, affine = load_nifti(fraw)
    bvals, bvecs = read_bvals_bvecs(fbval, fbvec)
    bvecs[1:] = (bvecs[1:] /
                     np.sqrt(np.sum(bvecs[1:] * bvecs[1:], axis=1))[:, None])
    gtab = gradient_table(bvals, bvecs)

    print('data.shape (%d, %d, %d, %d)' % data.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data.shape (96, 96, 60, 203)




.. GENERATED FROM PYTHON SOURCE LINES 42-43

Instantiate the Model and apply it to the data.

.. GENERATED FROM PYTHON SOURCE LINES 43-46

.. code-block:: Python


    dsmodel = DiffusionSpectrumModel(gtab, qgrid_size=35, filter_width=18.5)








.. GENERATED FROM PYTHON SOURCE LINES 47-48

Let's just use one slice only from the data.

.. GENERATED FROM PYTHON SOURCE LINES 48-51

.. code-block:: Python


    dataslice = data[30:70, 20:80, data.shape[2] // 2]








.. GENERATED FROM PYTHON SOURCE LINES 52-53

Normalize the signal by the b0

.. GENERATED FROM PYTHON SOURCE LINES 53-56

.. code-block:: Python


    dataslice = dataslice / (dataslice[..., 0, None]).astype(float)








.. GENERATED FROM PYTHON SOURCE LINES 57-59

Calculate the return to origin probability on the signal
that corresponds to the integral of the signal.

.. GENERATED FROM PYTHON SOURCE LINES 59-63

.. code-block:: Python


    print('Calculating... rtop_signal')
    rtop_signal = dsmodel.fit(dataslice).rtop_signal()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... rtop_signal
      0%|                                                                                                                                          | 0/2400 [00:00<?, ?it/s]    100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2400/2400 [00:00<00:00, 480034.79it/s]




.. GENERATED FROM PYTHON SOURCE LINES 64-70

Now we calculate the return to origin probability on the propagator, that
corresponds to its central value. By default the propagator is divided by
its sum in order to obtain a properly normalized pdf, however this
normalization changes the values of RTOP, therefore in order to compare it
with the RTOP previously calculated on the signal we turn the normalized
parameter to false.

.. GENERATED FROM PYTHON SOURCE LINES 70-74

.. code-block:: Python


    print('Calculating... rtop_pdf')
    rtop_pdf = dsmodel.fit(dataslice).rtop_pdf(normalized=False)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... rtop_pdf
      0%|                                                                                                                                          | 0/2400 [00:00<?, ?it/s]    100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2400/2400 [00:00<00:00, 480057.69it/s]




.. GENERATED FROM PYTHON SOURCE LINES 75-77

In theory, these two measures must be equal,
to show that we calculate the mean square error on this two measures.

.. GENERATED FROM PYTHON SOURCE LINES 77-81

.. code-block:: Python


    mse = np.sum((rtop_signal - rtop_pdf) ** 2) / rtop_signal.size
    print("mse = %f" % mse)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    mse = 0.000000




.. GENERATED FROM PYTHON SOURCE LINES 82-84

Leaving the normalized parameter to the default changes the values of the
RTOP but not the contrast between the voxels.

.. GENERATED FROM PYTHON SOURCE LINES 84-88

.. code-block:: Python


    print('Calculating... rtop_pdf_norm')
    rtop_pdf_norm = dsmodel.fit(dataslice).rtop_pdf()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... rtop_pdf_norm
      0%|                                                                                                                                          | 0/2400 [00:00<?, ?it/s]    100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2400/2400 [00:00<00:00, 600043.49it/s]




.. GENERATED FROM PYTHON SOURCE LINES 89-90

Let's calculate the mean square displacement on the normalized propagator.

.. GENERATED FROM PYTHON SOURCE LINES 90-94

.. code-block:: Python


    print('Calculating... msd_norm')
    msd_norm = dsmodel.fit(dataslice).msd_discrete()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... msd_norm
      0%|                                                                                                                                          | 0/2400 [00:00<?, ?it/s]    100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2400/2400 [00:00<00:00, 600043.49it/s]




.. GENERATED FROM PYTHON SOURCE LINES 95-97

Turning the normalized parameter to false makes it possible to calculate
the mean square displacement on the propagator without normalization.

.. GENERATED FROM PYTHON SOURCE LINES 97-101

.. code-block:: Python


    print('Calculating... msd')
    msd = dsmodel.fit(dataslice).msd_discrete(normalized=False)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... msd
      0%|                                                                                                                                          | 0/2400 [00:00<?, ?it/s]    100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2400/2400 [00:00<00:00, 467809.72it/s]




.. GENERATED FROM PYTHON SOURCE LINES 102-103

Show the RTOP images and save them in rtop.png.

.. GENERATED FROM PYTHON SOURCE LINES 103-119

.. code-block:: Python


    fig = plt.figure(figsize=(6, 6))
    ax1 = fig.add_subplot(2, 2, 1, title='rtop_signal')
    ax1.set_axis_off()
    ind = ax1.imshow(rtop_signal.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    ax2 = fig.add_subplot(2, 2, 2, title='rtop_pdf_norm')
    ax2.set_axis_off()
    ind = ax2.imshow(rtop_pdf_norm.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    ax3 = fig.add_subplot(2, 2, 3, title='rtop_pdf')
    ax3.set_axis_off()
    ind = ax3.imshow(rtop_pdf.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    plt.savefig('rtop.png')




.. image-sg:: /examples_built/reconstruction/images/sphx_glr_reconst_dsi_metrics_001.png
   :alt: reconst dsi metrics
   :srcset: /examples_built/reconstruction/images/sphx_glr_reconst_dsi_metrics_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    C:\Users\skoudoro\Devel\dipy\doc\examples_revamped\reconstruction\reconst_dsi_metrics.py:104: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`). Consider using `matplotlib.pyplot.close()`.
      fig = plt.figure(figsize=(6, 6))




.. GENERATED FROM PYTHON SOURCE LINES 120-126

.. rst-class:: centered small fst-italic fw-semibold

Return to origin probability.


Show the MSD images and save them in msd.png.

.. GENERATED FROM PYTHON SOURCE LINES 126-138

.. code-block:: Python


    fig = plt.figure(figsize=(7, 3))
    ax1 = fig.add_subplot(1, 2, 1, title='msd_norm')
    ax1.set_axis_off()
    ind = ax1.imshow(msd_norm.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    ax2 = fig.add_subplot(1, 2, 2, title='msd')
    ax2.set_axis_off()
    ind = ax2.imshow(msd.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    plt.savefig('msd.png')




.. image-sg:: /examples_built/reconstruction/images/sphx_glr_reconst_dsi_metrics_002.png
   :alt: reconst dsi metrics
   :srcset: /examples_built/reconstruction/images/sphx_glr_reconst_dsi_metrics_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 139-154

.. rst-class:: centered small fst-italic fw-semibold

Mean square displacement.


.. [Descoteaux2011] Descoteaux M. et al., "Multiple q-shell diffusion
   propagator imaging", Medical Image Analysis, vol 15, no 4, p. 603-621,
   2011.

.. [Wu2007] Wu Y. et al., "Hybrid diffusion imaging", NeuroImage, vol 36,
   p. 617-629, 2007.

.. [Wu2008] Wu Y. et al., "Computation of Diffusion Function Measures in
   q-Space Using Magnetic Resonance Hybrid Diffusion Imaging", IEEE
   Transactions on Medical Imaging, vol 27, no 6, p. 858-865, 2008.

.. GENERATED FROM PYTHON SOURCE LINES 156-158

.. include:: ../../links_names.inc



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 17.412 seconds)


.. _sphx_glr_download_examples_built_reconstruction_reconst_dsi_metrics.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: reconst_dsi_metrics.ipynb <reconst_dsi_metrics.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: reconst_dsi_metrics.py <reconst_dsi_metrics.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
