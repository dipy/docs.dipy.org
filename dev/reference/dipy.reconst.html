
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>reconst &#8212; dipy 1.11.0 documentation</title>
  
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/css/dipy.css?v=cedb193d" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

  
<link rel="stylesheet" href="../_static/styles/grg-sphinx-theme.css"/>

    <script src="../_static/documentation_options.js?v=6cf1fb80"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-D610GKJZRC"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-D610GKJZRC');
            </script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-D610GKJZRC');
            </script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'reference/dipy.reconst';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://docs.dipy.org/dev/_static/version_switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '1.11.0';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <link rel="icon" href="../_static/dipy-favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="segment" href="dipy.segment.html" />
    <link rel="prev" title="nn" href="dipy.nn.html" />
  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
<nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
     
  

<a class="navbar-brand logo" href="https://dipy.org">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/dipy-logo.png" class="logo__image only-light" alt="DIPY"/>
    <script>document.write(`<img src="../_static/dipy-logo.png" class="logo__image only-dark" alt="DIPY"/>`);</script>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  
  <ul class="bd-navbar-elements navbar-nav">
    
          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Docs
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
      <li class="nav-item">
        <a class="nav-link" href="../index.html">
          Overview
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../examples_built/index.html">
          Tutorials
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../recipes.html">
          Recipes
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../interfaces/index.html">
          CLI / Workflows
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="index.html">
          API
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../reference_cmd/index.html">
          CLI API
        </a>
      </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Workshops
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Latest
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2024" target="_blank">
            DIPY Workshop 2024 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Past
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2023" target="_blank">
            DIPY Workshop 2023 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2022" target="_blank">
            DIPY Workshop 2022 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2021" target="_blank">
            DIPY Workshop 2021 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2020" target="_blank">
            DIPY Workshop 2020 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2019" target="_blank">
            DIPY Workshop 2019 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Community
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        News
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/calendar">
            Calendar
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://mail.python.org/mailman3/lists/dipy.python.org/" target="_blank">
            Newsletters <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/blog">
            Blog
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://www.youtube.com/c/diffusionimaginginpython" target="_blank">
            Youtube <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Help
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://app.gitter.im/#/room/%23dipy_dipy:gitter.im" target="_blank">
            Live Chat (Gitter) <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://github.com/dipy/dipy/discussions" target="_blank">
            Github Discussions <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    About
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/team">
            Team
          </a>
        </li>

      <li class="nav-item">
        <a class="nav-link" href="../faq.html">
          FAQ
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../user_guide/mission.html">
          Mission Statement
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../stateoftheart.html">
          Releases
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../cite.html">
          Cite
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../glossary.html">
          Glossary
        </a>
      </li>
                </ul>
            </li>
          
  </ul>
  
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
      
        <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dipy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/dipymri" title="Twitter/X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Twitter/X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/c/diffusionimaginginpython" title="YouTube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">YouTube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/dipy/" title="LinkedIn" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">LinkedIn</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

</nav>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  
  <ul class="bd-navbar-elements navbar-nav">
    
          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Docs
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
      <li class="nav-item">
        <a class="nav-link" href="../index.html">
          Overview
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../examples_built/index.html">
          Tutorials
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../recipes.html">
          Recipes
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../interfaces/index.html">
          CLI / Workflows
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="index.html">
          API
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../reference_cmd/index.html">
          CLI API
        </a>
      </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Workshops
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Latest
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2024" target="_blank">
            DIPY Workshop 2024 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Past
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2023" target="_blank">
            DIPY Workshop 2023 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2022" target="_blank">
            DIPY Workshop 2022 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2021" target="_blank">
            DIPY Workshop 2021 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2020" target="_blank">
            DIPY Workshop 2020 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2019" target="_blank">
            DIPY Workshop 2019 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Community
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        News
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/calendar">
            Calendar
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://mail.python.org/mailman3/lists/dipy.python.org/" target="_blank">
            Newsletters <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/blog">
            Blog
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://www.youtube.com/c/diffusionimaginginpython" target="_blank">
            Youtube <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Help
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://app.gitter.im/#/room/%23dipy_dipy:gitter.im" target="_blank">
            Live Chat (Gitter) <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://github.com/dipy/dipy/discussions" target="_blank">
            Github Discussions <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    About
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/team">
            Team
          </a>
        </li>

      <li class="nav-item">
        <a class="nav-link" href="../faq.html">
          FAQ
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../user_guide/mission.html">
          Mission Statement
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../stateoftheart.html">
          Releases
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../cite.html">
          Cite
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../glossary.html">
          Glossary
        </a>
      </li>
                </ul>
            </li>
          
  </ul>
  
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
        
          <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-3"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-3"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-3"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-3">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dipy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/dipymri" title="Twitter/X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Twitter/X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/c/diffusionimaginginpython" title="YouTube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">YouTube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/dipy/" title="LinkedIn" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">LinkedIn</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="dipy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dipy</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.align.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">align</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.core.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">core</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.data.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.denoise.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">denoise</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.direction.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">direction</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.io.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.nn.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nn</span></code></a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.segment.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">segment</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.sims.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sims</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.stats.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stats</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.tracking.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracking</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.version.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.viz.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">viz</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.workflows.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">workflows</span></code></a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">API Reference</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><code...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="module-dipy.reconst">
<span id="reconst"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst</span></code><a class="headerlink" href="#module-dipy.reconst" title="Link to this heading">#</a></h1>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
</tbody>
</table>
</div>
<section id="module-dipy.reconst.base">
<span id="module-reconst-base"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.base</span></code><a class="headerlink" href="#module-dipy.reconst.base" title="Link to this heading">#</a></h2>
<p>Base-classes for reconstruction models and reconstruction fits.</p>
<p>All the models in the reconst module follow the same template: a Model object
is used to represent the abstract properties of the model, that are independent
of the specifics of the data . These properties are reused whenever fitting a
particular set of data (different voxels, for example).</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</p></td>
<td><p>Abstract class for signal reconstruction models</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstFit</span></code></a>(model, data)</p></td>
<td><p>Abstract class which holds the fit result of ReconstModel</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.bingham">
<span id="module-reconst-bingham"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.bingham</span></code><a class="headerlink" href="#module-dipy.reconst.bingham" title="Link to this heading">#</a></h2>
<p>Tools for fitting Bingham distributions to orientation distribution
functions (ODF), as described in <a class="footnote-reference brackets" href="#footcite-riffert2014" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. The resulting
distributions can further be used to compute ODF-lobe-specific measures such as
the fiber density (FD) and fiber spread (FS) <a class="footnote-reference brackets" href="#footcite-riffert2014" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> and the
orientation dispersion index (ODI) <a class="footnote-reference brackets" href="#footcite-netohenriques2018" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading">#</a></h3>
<div class="docutils container" id="id4">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-riffert2014" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>,<a role="doc-backlink" href="#id18">3</a>,<a role="doc-backlink" href="#id22">4</a>,<a role="doc-backlink" href="#id23">5</a>)</span>
<p>Till W. Riffert, Jan Schreiber, Alfred Anwander, and Thomas R. Knösche. Beyond fractional anisotropy: Extraction of bundle-specific structural metrics from crossing fiber models. <em>NeuroImage</em>, 100:176–191, 2014. URL: <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1053811914004923">https://www.sciencedirect.com/science/article/pii/S1053811914004923</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2014.06.015">doi:10.1016/j.neuroimage.2014.06.015</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-netohenriques2018" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id3">1</a>,<a role="doc-backlink" href="#id24">2</a>,<a role="doc-backlink" href="#id27">3</a>,<a role="doc-backlink" href="#id282">4</a>,<a role="doc-backlink" href="#id283">5</a>,<a role="doc-backlink" href="#id284">6</a>,<a role="doc-backlink" href="#id285">7</a>,<a role="doc-backlink" href="#id300">8</a>,<a role="doc-backlink" href="#id301">9</a>)</span>
<p>Rafael Neto Henriques. <em>Advanced Methods for Diffusion MRI Data Analysis and their Application to the Healthy Ageing Brain</em>. PhD thesis, Cambridge University, Cambridge, United Kingdom, 2018. URL: <a class="reference external" href="https://doi.org/10.17863/CAM.29356">https://doi.org/10.17863/CAM.29356</a>, <a class="reference external" href="https://doi.org/10.17863/CAM.29356">doi:10.17863/CAM.29356</a>.</p>
</aside>
</aside>
</div>
</section>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics" title="dipy.reconst.bingham.BinghamMetrics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BinghamMetrics</span></code></a>(model_params)</p></td>
<td><p>Class for Bingham Metrics.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.bingham_to_sf" title="dipy.reconst.bingham.bingham_to_sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bingham_to_sf</span></code></a>(bingham_params, sphere, *[, mask])</p></td>
<td><p>Reconstruct ODFs from fitted Bingham parameters on multiple voxels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.bingham_fiber_density" title="dipy.reconst.bingham.bingham_fiber_density"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bingham_fiber_density</span></code></a>(bingham_params, *[, ...])</p></td>
<td><p>Compute fiber density for each lobe for a given Bingham ODF.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.bingham_fiber_spread" title="dipy.reconst.bingham.bingham_fiber_spread"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bingham_fiber_spread</span></code></a>(f0, fd)</p></td>
<td><p>Compute fiber spread for each lobe for a given Bingham volume.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.k2odi" title="dipy.reconst.bingham.k2odi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">k2odi</span></code></a>(k)</p></td>
<td><p>Convert the Bingham/Watson concentration parameter k to the orientation dispersion index (ODI).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.odi2k" title="dipy.reconst.bingham.odi2k"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odi2k</span></code></a>(odi)</p></td>
<td><p>Convert the orientation dispersion index (ODI) to the Bingham/Watson concentration parameter k.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.weighted_voxel_metric" title="dipy.reconst.bingham.weighted_voxel_metric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weighted_voxel_metric</span></code></a>(bmetric, bfd)</p></td>
<td><p>Compute density-weighted scalar maps for metrics of Bingham functions fitted to multiple ODF lobes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.sf_to_bingham" title="dipy.reconst.bingham.sf_to_bingham"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sf_to_bingham</span></code></a>(odf, sphere, max_search_angle, *)</p></td>
<td><p>Fit the Bingham function from an image volume of ODFs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.sh_to_bingham" title="dipy.reconst.bingham.sh_to_bingham"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_bingham</span></code></a>(sh, sphere, max_search_angle, *)</p></td>
<td><p>Fit the Bingham function from an image volume of spherical harmonics (SH) representing ODFs.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.cache">
<span id="module-reconst-cache"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cache</span></code><a class="headerlink" href="#module-dipy.reconst.cache" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a>()</p></td>
<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.cross_validation">
<span id="module-reconst-cross-validation"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cross_validation</span></code><a class="headerlink" href="#module-dipy.reconst.cross_validation" title="Link to this heading">#</a></h2>
<p>Cross-validation analysis of diffusion models.</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cross_validation.coeff_of_determination" title="dipy.reconst.cross_validation.coeff_of_determination"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coeff_of_determination</span></code></a>(data, model, *[, axis])</p></td>
<td><p>Calculate the coefficient of determination for a model prediction, relative to data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cross_validation.kfold_xval" title="dipy.reconst.cross_validation.kfold_xval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kfold_xval</span></code></a>(model, data, folds, *model_args, ...)</p></td>
<td><p>Perform k-fold cross-validation.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.csdeconv">
<span id="module-reconst-csdeconv"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.csdeconv</span></code><a class="headerlink" href="#module-dipy.reconst.csdeconv" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse" title="dipy.reconst.csdeconv.AxSymShResponse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a>(S0, dwi_response, *[, bvalue])</p></td>
<td><p>A simple wrapper for response functions represented using only axially symmetric, even spherical harmonic functions (ie, m == 0 and l is even).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a>(gtab, ...[, ...])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="dipy.reconst.csdeconv.ConstrainedSDTModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a>(gtab, ratio, *[, ...])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.estimate_response" title="dipy.reconst.csdeconv.estimate_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_response</span></code></a>(gtab, evals, S0)</p></td>
<td><p>Estimate single fiber response function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat" title="dipy.reconst.csdeconv.forward_sdt_deconv_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward_sdt_deconv_mat</span></code></a>(ratio, l_values, *[, ...])</p></td>
<td><p>Build forward sharpening deconvolution transform (SDT) matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.csdeconv" title="dipy.reconst.csdeconv.csdeconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csdeconv</span></code></a>(dwsignal, X, B_reg, *[, tau, ...])</p></td>
<td><p>Constrained-regularized spherical deconvolution (CSD).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.odf_deconv" title="dipy.reconst.csdeconv.odf_deconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_deconv</span></code></a>(odf_sh, R, B_reg, *[, lambda_, ...])</p></td>
<td><p>ODF constrained-regularized spherical deconvolution using the Sharpening Deconvolution Transform (SDT).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.odf_sh_to_sharp" title="dipy.reconst.csdeconv.odf_sh_to_sharp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sh_to_sharp</span></code></a>(odfs_sh, sphere, *[, basis, ...])</p></td>
<td><p>Sharpen odfs using the sharpening deconvolution transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.mask_for_response_ssst" title="dipy.reconst.csdeconv.mask_for_response_ssst"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mask_for_response_ssst</span></code></a>(gtab, data, *[, ...])</p></td>
<td><p>Computation of mask for single-shell single-tissue (ssst) response</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.response_from_mask_ssst" title="dipy.reconst.csdeconv.response_from_mask_ssst"><code class="xref py py-obj docutils literal notranslate"><span class="pre">response_from_mask_ssst</span></code></a>(gtab, data, mask)</p></td>
<td><p>Computation of single-shell single-tissue (ssst) response</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.auto_response_ssst" title="dipy.reconst.csdeconv.auto_response_ssst"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_response_ssst</span></code></a>(gtab, data, *[, ...])</p></td>
<td><p>Automatic estimation of single-shell single-tissue (ssst) response</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.recursive_response" title="dipy.reconst.csdeconv.recursive_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recursive_response</span></code></a>(gtab, data, *[, mask, ...])</p></td>
<td><p>Recursive calibration of response function using peak threshold.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas" title="dipy.reconst.csdeconv.fa_trace_to_lambdas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa_trace_to_lambdas</span></code></a>([fa, trace])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.cti">
<span id="module-reconst-cti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cti</span></code><a class="headerlink" href="#module-dipy.reconst.cti" title="Link to this heading">#</a></h2>
<p>Classes and functions for fitting the correlation tensor model</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorModel" title="dipy.reconst.cti.CorrelationTensorModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CorrelationTensorModel</span></code></a>(gtab1, gtab2, *args)</p></td>
<td><p>Class for the Correlation Tensor Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit" title="dipy.reconst.cti.CorrelationTensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CorrelationTensorFit</span></code></a>(model, model_params)</p></td>
<td><p>Class for fitting the Correlation Tensor Model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.from_qte_to_cti" title="dipy.reconst.cti.from_qte_to_cti"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_qte_to_cti</span></code></a>(C)</p></td>
<td><p>Rescales the qte C elements to the C elements used in CTI.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cti.multi_gaussian_k_from_c" title="dipy.reconst.cti.multi_gaussian_k_from_c"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_gaussian_k_from_c</span></code></a>(ccti, MD)</p></td>
<td><p>Computes the multiple Gaussian diffusion kurtosis tensor from the covariance tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.split_cti_params" title="dipy.reconst.cti.split_cti_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_cti_params</span></code></a>(cti_params)</p></td>
<td><p>Splits CTI params into DTI, DKI, CTI portions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cti.cti_prediction" title="dipy.reconst.cti.cti_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cti_prediction</span></code></a>(cti_params, gtab1, gtab2, *)</p></td>
<td><p>Predict a signal given correlation tensor imaging parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.params_to_cti_params" title="dipy.reconst.cti.params_to_cti_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">params_to_cti_params</span></code></a>(result, *[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cti.ls_fit_cti" title="dipy.reconst.cti.ls_fit_cti"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ls_fit_cti</span></code></a>(design_matrix, data, ...[, ...])</p></td>
<td><p>Compute the diffusion kurtosis and covariance tensors using an ordinary or weighted linear least squares approach</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.dki">
<span id="module-reconst-dki"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki</span></code><a class="headerlink" href="#module-dipy.reconst.dki" title="Link to this heading">#</a></h2>
<p>Classes and functions for fitting the diffusion kurtosis model.</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="dipy.reconst.dki.DiffusionKurtosisModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a>(gtab, *args[, ...])</p></td>
<td><p>Class for the Diffusion Kurtosis Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a>(model, model_params, *)</p></td>
<td><p>Class for fitting the Diffusion Kurtosis Model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.carlson_rf" title="dipy.reconst.dki.carlson_rf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">carlson_rf</span></code></a>(x, y, z, *[, errtol])</p></td>
<td><p>Compute the Carlson's incomplete elliptic integral of the first kind.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.carlson_rd" title="dipy.reconst.dki.carlson_rd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">carlson_rd</span></code></a>(x, y, z, *[, errtol])</p></td>
<td><p>Compute the Carlson's incomplete elliptic integral of the second kind.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.directional_diffusion" title="dipy.reconst.dki.directional_diffusion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_diffusion</span></code></a>(dt, V, *[, ...])</p></td>
<td><p>Compute apparent diffusion coefficient (adc).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.directional_diffusion_variance" title="dipy.reconst.dki.directional_diffusion_variance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_diffusion_variance</span></code></a>(kt, V)</p></td>
<td><p>Calculate the apparent diffusion variance (adv) in each direction of a sphere for a single voxel</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.directional_kurtosis" title="dipy.reconst.dki.directional_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_kurtosis</span></code></a>(dt, md, kt, V, *[, ...])</p></td>
<td><p>Calculate the apparent kurtosis coefficient (akc) in each direction of a sphere for a single voxel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.apparent_kurtosis_coef" title="dipy.reconst.dki.apparent_kurtosis_coef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apparent_kurtosis_coef</span></code></a>(dki_params, sphere, *)</p></td>
<td><p>Calculate the apparent kurtosis coefficient (AKC) in each direction of a sphere.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.mean_kurtosis" title="dipy.reconst.dki.mean_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_kurtosis</span></code></a>(dki_params, *[, min_kurtosis, ...])</p></td>
<td><p>Compute mean kurtosis (MK) from the kurtosis tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.radial_kurtosis" title="dipy.reconst.dki.radial_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_kurtosis</span></code></a>(dki_params, *[, ...])</p></td>
<td><p>Compute radial kurtosis (RK) of a diffusion kurtosis tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.axial_kurtosis" title="dipy.reconst.dki.axial_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axial_kurtosis</span></code></a>(dki_params, *[, ...])</p></td>
<td><p>Compute axial kurtosis (AK) from the kurtosis tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.kurtosis_maximum" title="dipy.reconst.dki.kurtosis_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis_maximum</span></code></a>(dki_params, *[, sphere, ...])</p></td>
<td><p>Compute kurtosis maximum value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.mean_kurtosis_tensor" title="dipy.reconst.dki.mean_kurtosis_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_kurtosis_tensor</span></code></a>(dki_params, *[, ...])</p></td>
<td><p>Compute mean of the kurtosis tensor (MKT).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.radial_tensor_kurtosis" title="dipy.reconst.dki.radial_tensor_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_tensor_kurtosis</span></code></a>(dki_params, *[, ...])</p></td>
<td><p>Compute the rescaled radial tensor kurtosis (RTK).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.kurtosis_fractional_anisotropy" title="dipy.reconst.dki.kurtosis_fractional_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis_fractional_anisotropy</span></code></a>(dki_params)</p></td>
<td><p>Compute the anisotropy of the kurtosis tensor (KFA).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.dki_prediction" title="dipy.reconst.dki.dki_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dki_prediction</span></code></a>(dki_params, gtab, *[, S0])</p></td>
<td><p>Predict a signal given diffusion kurtosis imaging parameters</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.params_to_dki_params" title="dipy.reconst.dki.params_to_dki_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">params_to_dki_params</span></code></a>(result, *[, ...])</p></td>
<td><p>Convert the 21 unique elements of the diffusion and kurtosis tensors to the parameter format adopted in DIPY</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.ls_fit_dki" title="dipy.reconst.dki.ls_fit_dki"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ls_fit_dki</span></code></a>(design_matrix, data, ...[, ...])</p></td>
<td><p>Compute the diffusion and kurtosis tensors using an ordinary or weighted linear least squares approach.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.cls_fit_dki" title="dipy.reconst.dki.cls_fit_dki"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cls_fit_dki</span></code></a>(design_matrix, data, ...[, ...])</p></td>
<td><p>Compute the diffusion and kurtosis tensors using a constrained ordinary or weighted linear least squares approach.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.Wrotate" title="dipy.reconst.dki.Wrotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wrotate</span></code></a>(kt, Basis)</p></td>
<td><p>Rotate a kurtosis tensor from the standard Cartesian coordinate system to another coordinate system basis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.Wrotate_element" title="dipy.reconst.dki.Wrotate_element"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wrotate_element</span></code></a>(kt, indi, indj, indk, indl, B)</p></td>
<td><p>Compute the specified index element of a kurtosis tensor rotated to the coordinate system basis B</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.Wcons" title="dipy.reconst.dki.Wcons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wcons</span></code></a>(k_elements)</p></td>
<td><p>Construct the full 4D kurtosis tensors from its 15 independent elements</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.split_dki_param" title="dipy.reconst.dki.split_dki_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_dki_param</span></code></a>(dki_params)</p></td>
<td><p>Extract the diffusion tensor eigenvalues, the diffusion tensor eigenvector matrix, and the 15 independent elements of the kurtosis tensor from the model parameters estimated from the DKI model</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.dki_micro">
<span id="module-reconst-dki-micro"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki_micro</span></code><a class="headerlink" href="#module-dipy.reconst.dki_micro" title="Link to this heading">#</a></h2>
<p>Classes and functions for fitting the DKI-based microstructural model</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a>(gtab, *args[, ...])</p></td>
<td><p>Class for the Diffusion Kurtosis Microstructural Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a>(model, model_params)</p></td>
<td><p>Class for fitting the Diffusion Kurtosis Microstructural Model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.axonal_water_fraction" title="dipy.reconst.dki_micro.axonal_water_fraction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axonal_water_fraction</span></code></a>(dki_params, *[, ...])</p></td>
<td><p>Computes the axonal water fraction from DKI.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.diffusion_components" title="dipy.reconst.dki_micro.diffusion_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diffusion_components</span></code></a>(dki_params, *[, ...])</p></td>
<td><p>Extracts the restricted and hindered diffusion tensors of well aligned fibers from diffusion kurtosis imaging parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.dkimicro_prediction" title="dipy.reconst.dki_micro.dkimicro_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dkimicro_prediction</span></code></a>(params, gtab, *[, S0])</p></td>
<td><p>Signal prediction given the DKI microstructure model parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.tortuosity" title="dipy.reconst.dki_micro.tortuosity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tortuosity</span></code></a>(hindered_ad, hindered_rd)</p></td>
<td><p>Computes the tortuosity of the hindered diffusion compartment given its axial and radial diffusivities</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.dsi">
<span id="module-reconst-dsi"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dsi</span></code><a class="headerlink" href="#module-dipy.reconst.dsi" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a>(gtab, *[, ...])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a>(model, data)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a>(gtab, *[, ...])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a>(model, data)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.create_qspace" title="dipy.reconst.dsi.create_qspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_qspace</span></code></a>(gtab, origin)</p></td>
<td><p>create the 3D grid which holds the signal values (q-space)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.create_qtable" title="dipy.reconst.dsi.create_qtable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_qtable</span></code></a>(gtab, origin)</p></td>
<td><p>create a normalized version of gradients</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.hanning_filter" title="dipy.reconst.dsi.hanning_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hanning_filter</span></code></a>(gtab, filter_width, origin)</p></td>
<td><p>create a hanning window</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.pdf_interp_coords" title="dipy.reconst.dsi.pdf_interp_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf_interp_coords</span></code></a>(sphere, rradius, origin)</p></td>
<td><p>Precompute coordinates for ODF calculation from the PDF</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.pdf_odf" title="dipy.reconst.dsi.pdf_odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf_odf</span></code></a>(Pr, rradius, interp_coords)</p></td>
<td><p>Calculates the real ODF from the diffusion propagator(PDF) Pr</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.half_to_full_qspace" title="dipy.reconst.dsi.half_to_full_qspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">half_to_full_qspace</span></code></a>(data, gtab)</p></td>
<td><p>Half to full Cartesian grid mapping</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.project_hemisph_bvecs" title="dipy.reconst.dsi.project_hemisph_bvecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project_hemisph_bvecs</span></code></a>(gtab)</p></td>
<td><p>Project any near identical bvecs to the other hemisphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.threshold_propagator" title="dipy.reconst.dsi.threshold_propagator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold_propagator</span></code></a>(P, *[, estimated_snr])</p></td>
<td><p>Applies hard threshold on the propagator to remove background noise for the deconvolution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.gen_PSF" title="dipy.reconst.dsi.gen_PSF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_PSF</span></code></a>(qgrid_sampling, siz_x, siz_y, siz_z)</p></td>
<td><p>Generate a PSF for DSI Deconvolution by taking the ifft of the binary q-space sampling mask and truncating it to keep only the center.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.LR_deconv" title="dipy.reconst.dsi.LR_deconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LR_deconv</span></code></a>(prop, psf, *[, numit, acc_factor])</p></td>
<td><p>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.dti">
<span id="module-reconst-dti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dti</span></code><a class="headerlink" href="#module-dipy.reconst.dti" title="Link to this heading">#</a></h2>
<p>Classes and functions for fitting tensors.</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorModel" title="dipy.reconst.dti.TensorModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorModel</span></code></a>(gtab, *args[, fit_method, ...])</p></td>
<td><p>Diffusion Tensor</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorFit</span></code></a>(model, model_params, *[, model_S0])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.fractional_anisotropy" title="dipy.reconst.dti.fractional_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractional_anisotropy</span></code></a>(evals, *[, axis])</p></td>
<td><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.geodesic_anisotropy" title="dipy.reconst.dti.geodesic_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geodesic_anisotropy</span></code></a>(evals, *[, axis])</p></td>
<td><p>Geodesic anisotropy (GA) of a diffusion tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.mean_diffusivity" title="dipy.reconst.dti.mean_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_diffusivity</span></code></a>(evals, *[, axis])</p></td>
<td><p>Mean Diffusivity (MD) of a diffusion tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.axial_diffusivity" title="dipy.reconst.dti.axial_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axial_diffusivity</span></code></a>(evals, *[, axis])</p></td>
<td><p>Axial Diffusivity (AD) of a diffusion tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.radial_diffusivity" title="dipy.reconst.dti.radial_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_diffusivity</span></code></a>(evals, *[, axis])</p></td>
<td><p>Radial Diffusivity (RD) of a diffusion tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.trace" title="dipy.reconst.dti.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>(evals, *[, axis])</p></td>
<td><p>Trace of a diffusion tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.color_fa" title="dipy.reconst.dti.color_fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code></a>(fa, evecs)</p></td>
<td><p>Color fractional anisotropy of diffusion tensor</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.determinant" title="dipy.reconst.dti.determinant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">determinant</span></code></a>(q_form)</p></td>
<td><p>The determinant of a tensor, given in quadratic form</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.isotropic" title="dipy.reconst.dti.isotropic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isotropic</span></code></a>(q_form)</p></td>
<td><p>Calculate the isotropic part of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.deviatoric" title="dipy.reconst.dti.deviatoric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deviatoric</span></code></a>(q_form)</p></td>
<td><p>Calculate the deviatoric (anisotropic) part of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.norm" title="dipy.reconst.dti.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>(q_form)</p></td>
<td><p>Calculate the Frobenius norm of a tensor quadratic form</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.mode" title="dipy.reconst.dti.mode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code></a>(q_form)</p></td>
<td><p>Mode (MO) of a diffusion tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.linearity" title="dipy.reconst.dti.linearity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code></a>(evals, *[, axis])</p></td>
<td><p>The linearity of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.planarity" title="dipy.reconst.dti.planarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code></a>(evals, *[, axis])</p></td>
<td><p>The planarity of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.sphericity" title="dipy.reconst.dti.sphericity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code></a>(evals, *[, axis])</p></td>
<td><p>The sphericity of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.apparent_diffusion_coef" title="dipy.reconst.dti.apparent_diffusion_coef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apparent_diffusion_coef</span></code></a>(q_form, sphere)</p></td>
<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction of a sphere.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.tensor_prediction" title="dipy.reconst.dti.tensor_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_prediction</span></code></a>(dti_params, gtab, S0)</p></td>
<td><p>Predict a signal given tensor parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.iter_fit_tensor" title="dipy.reconst.dti.iter_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_fit_tensor</span></code></a>(*[, step])</p></td>
<td><p>Wrap a fit_tensor func and iterate over chunks of data with given length</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.wls_fit_tensor" title="dipy.reconst.dti.wls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_tensor</span></code></a>(design_matrix, data, *[, ...])</p></td>
<td><p>Computes weighted least squares (WLS) fit to calculate self-diffusion tensor using a linear regression model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.ols_fit_tensor" title="dipy.reconst.dti.ols_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ols_fit_tensor</span></code></a>(design_matrix, data, *[, ...])</p></td>
<td><p>Computes ordinary least squares (OLS) fit to calculate self-diffusion tensor using a linear regression model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.nlls_fit_tensor" title="dipy.reconst.dti.nlls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlls_fit_tensor</span></code></a>(design_matrix, data, *[, ...])</p></td>
<td><p>Fit the cumulant expansion params (e.g. DTI, DKI) using non-linear least-squares.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.restore_fit_tensor" title="dipy.reconst.dti.restore_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">restore_fit_tensor</span></code></a>(design_matrix, data, *[, ...])</p></td>
<td><p>Compute a robust tensor fit using the RESTORE algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.iterative_fit_tensor" title="dipy.reconst.dti.iterative_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iterative_fit_tensor</span></code></a>(design_matrix, data, *)</p></td>
<td><p>Iteratively Reweighted fitting for the DTI/DKI model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.robust_fit_tensor_wls" title="dipy.reconst.dti.robust_fit_tensor_wls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">robust_fit_tensor_wls</span></code></a>(design_matrix, data, *)</p></td>
<td><p>Iteratively Reweighted fitting for WLS for the DTI/DKI model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.robust_fit_tensor_nlls" title="dipy.reconst.dti.robust_fit_tensor_nlls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">robust_fit_tensor_nlls</span></code></a>(design_matrix, data, *)</p></td>
<td><p>Iteratively Reweighted fitting for NLLS for the DTI/DKI model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.from_lower_triangular" title="dipy.reconst.dti.from_lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_lower_triangular</span></code></a>(D)</p></td>
<td><p>Returns a tensor given the six unique tensor elements</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.lower_triangular" title="dipy.reconst.dti.lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_triangular</span></code></a>(tensor, *[, b0])</p></td>
<td><p>Returns the six lower triangular values of the tensor ordered as (Dxx, Dxy, Dyy, Dxz, Dyz, Dzz) and a dummy variable if b0 is not None.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a>(tensor, *[, min_diffusivity])</p></td>
<td><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.design_matrix" title="dipy.reconst.dti.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>(gtab, *[, dtype])</p></td>
<td><p>Constructs design matrix for DTI weighted least squares or least squares fitting.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.quantize_evecs" title="dipy.reconst.dti.quantize_evecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantize_evecs</span></code></a>(evecs, *[, odf_vertices])</p></td>
<td><p>Find the closest orientation of an evenly distributed sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.eig_from_lo_tri" title="dipy.reconst.dti.eig_from_lo_tri"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eig_from_lo_tri</span></code></a>(data, *[, min_diffusivity])</p></td>
<td><p>Calculates tensor eigenvalues/eigenvectors from an array containing the lower diagonal form of the six unique tensor elements.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.forecast">
<span id="module-reconst-forecast"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.forecast</span></code><a class="headerlink" href="#module-dipy.reconst.forecast" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.ForecastModel" title="dipy.reconst.forecast.ForecastModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForecastModel</span></code></a>(gtab, *[, sh_order_max, ...])</p></td>
<td><p>Fiber ORientation Estimated using Continuous Axially Symmetric Tensors (FORECAST).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit" title="dipy.reconst.forecast.ForecastFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForecastFit</span></code></a>(model, data, sh_coef, d_par, d_perp)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.find_signal_means" title="dipy.reconst.forecast.find_signal_means"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_signal_means</span></code></a>(b_unique, data_norm, ...)</p></td>
<td><p>Calculate the mean signal for each shell.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.forecast_error_func" title="dipy.reconst.forecast.forecast_error_func"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forecast_error_func</span></code></a>(x, b_unique, E)</p></td>
<td><p>Calculates the difference between the mean signal calculated using the parameter vector x and the average signal E using FORECAST and SMT</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.psi_l" title="dipy.reconst.forecast.psi_l"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psi_l</span></code></a>(ell, b)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.forecast_matrix" title="dipy.reconst.forecast.forecast_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forecast_matrix</span></code></a>(sh_order_max, d_par, d_perp, ...)</p></td>
<td><p>Compute the FORECAST radial matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.rho_matrix" title="dipy.reconst.forecast.rho_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rho_matrix</span></code></a>(sh_order_max, vecs)</p></td>
<td><p>Compute the SH matrix <span class="math notranslate nohighlight">\(\rho\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.lb_forecast" title="dipy.reconst.forecast.lb_forecast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lb_forecast</span></code></a>(sh_order_max)</p></td>
<td><p>Returns the Laplace-Beltrami regularization matrix for FORECAST</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.fwdti">
<span id="module-reconst-fwdti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.fwdti</span></code><a class="headerlink" href="#module-dipy.reconst.fwdti" title="Link to this heading">#</a></h2>
<p>Classes and functions for fitting tensors without free water
contamination</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel" title="dipy.reconst.fwdti.FreeWaterTensorModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a>(gtab, *args[, fit_method])</p></td>
<td><p>Class for the Free Water Elimination Diffusion Tensor Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit" title="dipy.reconst.fwdti.FreeWaterTensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a>(model, model_params)</p></td>
<td><p>Class for fitting the Free Water Tensor Model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.fwdti_prediction" title="dipy.reconst.fwdti.fwdti_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fwdti_prediction</span></code></a>(params, gtab, *[, S0, Diso])</p></td>
<td><p>Signal prediction given the free water DTI model parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.wls_iter" title="dipy.reconst.fwdti.wls_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_iter</span></code></a>(design_matrix, sig, S0, *[, Diso, ...])</p></td>
<td><p>Applies weighted linear least squares fit of the water free elimination model to single voxel signals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.wls_fit_tensor" title="dipy.reconst.fwdti.wls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_tensor</span></code></a>(gtab, data, *[, Diso, mask, ...])</p></td>
<td><p>Computes weighted least squares (WLS) fit to calculate self-diffusion tensor using a linear regression model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.nls_iter" title="dipy.reconst.fwdti.nls_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nls_iter</span></code></a>(design_matrix, sig, S0, *[, Diso, ...])</p></td>
<td><p>Applies non linear least squares fit of the water free elimination model to single voxel signals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.nls_fit_tensor" title="dipy.reconst.fwdti.nls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nls_fit_tensor</span></code></a>(gtab, data, *[, mask, Diso, ...])</p></td>
<td><p>Fit the water elimination tensor model using the non-linear least-squares.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.lower_triangular_to_cholesky" title="dipy.reconst.fwdti.lower_triangular_to_cholesky"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_triangular_to_cholesky</span></code></a>(tensor_elements)</p></td>
<td><p>Performs Cholesky decomposition of the diffusion tensor</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.cholesky_to_lower_triangular" title="dipy.reconst.fwdti.cholesky_to_lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cholesky_to_lower_triangular</span></code></a>(R)</p></td>
<td><p>Convert Cholesky decomposition elements to the diffusion tensor elements</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.gqi">
<span id="module-reconst-gqi"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.gqi</span></code><a class="headerlink" href="#module-dipy.reconst.gqi" title="Link to this heading">#</a></h2>
<p>Classes and functions for generalized q-sampling</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="dipy.reconst.gqi.GeneralizedQSamplingModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a>(gtab, *[, method, ...])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="dipy.reconst.gqi.GeneralizedQSamplingFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a>(model, data)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.normalize_qa" title="dipy.reconst.gqi.normalize_qa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_qa</span></code></a>(qa, *[, max_qa])</p></td>
<td><p>Normalize quantitative anisotropy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.squared_radial_component" title="dipy.reconst.gqi.squared_radial_component"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squared_radial_component</span></code></a>(x, *[, tol])</p></td>
<td><p>Part of the GQI2 integral</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.npa" title="dipy.reconst.gqi.npa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">npa</span></code></a>(self, odf, *[, width])</p></td>
<td><p>non-parametric anisotropy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.equatorial_zone_vertices" title="dipy.reconst.gqi.equatorial_zone_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equatorial_zone_vertices</span></code></a>(vertices, pole, *)</p></td>
<td><p>finds the 'vertices' in the equatorial zone conjugate to 'pole' with width half 'width' degrees</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.polar_zone_vertices" title="dipy.reconst.gqi.polar_zone_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polar_zone_vertices</span></code></a>(vertices, pole, *[, width])</p></td>
<td><p>finds the 'vertices' in the equatorial band around the 'pole' of radius 'width' degrees</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.upper_hemi_map" title="dipy.reconst.gqi.upper_hemi_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper_hemi_map</span></code></a>(v)</p></td>
<td><p>maps a 3-vector into the z-upper hemisphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.equatorial_maximum" title="dipy.reconst.gqi.equatorial_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equatorial_maximum</span></code></a>(vertices, odf, pole, width)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.patch_vertices" title="dipy.reconst.gqi.patch_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">patch_vertices</span></code></a>(vertices, pole, width)</p></td>
<td><p>find 'vertices' within the cone of 'width' degrees around 'pole'</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.patch_maximum" title="dipy.reconst.gqi.patch_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">patch_maximum</span></code></a>(vertices, odf, pole, width)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.odf_sum" title="dipy.reconst.gqi.odf_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sum</span></code></a>(odf)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.patch_sum" title="dipy.reconst.gqi.patch_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">patch_sum</span></code></a>(vertices, odf, pole, width)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.triple_odf_maxima" title="dipy.reconst.gqi.triple_odf_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triple_odf_maxima</span></code></a>(vertices, odf, width)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.ivim">
<span id="module-reconst-ivim"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.ivim</span></code><a class="headerlink" href="#module-dipy.reconst.ivim" title="Link to this heading">#</a></h2>
<p>Classes and functions for fitting ivim model</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelTRR" title="dipy.reconst.ivim.IvimModelTRR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IvimModelTRR</span></code></a>(gtab, *[, split_b_D, ...])</p></td>
<td><p>Ivim model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP" title="dipy.reconst.ivim.IvimModelVP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IvimModelVP</span></code></a>(gtab, *[, bounds, maxiter, xtol])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimFit" title="dipy.reconst.ivim.IvimFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IvimFit</span></code></a>(model, model_params)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.ivim_prediction" title="dipy.reconst.ivim.ivim_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ivim_prediction</span></code></a>(params, gtab)</p></td>
<td><p>The Intravoxel incoherent motion (IVIM) model function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.f_D_star_prediction" title="dipy.reconst.ivim.f_D_star_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_D_star_prediction</span></code></a>(params, gtab, S0, D)</p></td>
<td><p>Function used to predict IVIM signal when S0 and D are known by considering f and D_star as the unknown parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.f_D_star_error" title="dipy.reconst.ivim.f_D_star_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_D_star_error</span></code></a>(params, gtab, signal, S0, D)</p></td>
<td><p>Error function used to fit f and D_star keeping S0 and D fixed</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.ivim_model_selector" title="dipy.reconst.ivim.ivim_model_selector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ivim_model_selector</span></code></a>(gtab, *[, fit_method])</p></td>
<td><p>Selector function to switch between the 2-stage Trust-Region Reflective based NLLS fitting method (also containing the linear fit): <cite>trr</cite> and the Variable Projections based fitting method: <cite>varpro</cite>.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.mapmri">
<span id="module-reconst-mapmri"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.mapmri</span></code><a class="headerlink" href="#module-dipy.reconst.mapmri" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriModel" title="dipy.reconst.mapmri.MapmriModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MapmriModel</span></code></a>(gtab, *[, radial_order, ...])</p></td>
<td><p>Mean Apparent Propagator MRI (MAPMRI) of the diffusion signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit" title="dipy.reconst.mapmri.MapmriFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MapmriFit</span></code></a>(model, mapmri_coef, mu, R, lopt, *)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.isotropic_scale_factor" title="dipy.reconst.mapmri.isotropic_scale_factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isotropic_scale_factor</span></code></a>(mu_squared)</p></td>
<td><p>Estimated isotropic scaling factor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_index_matrix" title="dipy.reconst.mapmri.mapmri_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_index_matrix</span></code></a>(radial_order)</p></td>
<td><p>Calculates the indices for the MAPMRI basis in x, y and z.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.b_mat" title="dipy.reconst.mapmri.b_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b_mat</span></code></a>(index_matrix)</p></td>
<td><p>Calculates the B coefficients from</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.b_mat_isotropic" title="dipy.reconst.mapmri.b_mat_isotropic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b_mat_isotropic</span></code></a>(index_matrix)</p></td>
<td><p>Calculates the isotropic B coefficients.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_phi_1d" title="dipy.reconst.mapmri.mapmri_phi_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_phi_1d</span></code></a>(n, q, mu)</p></td>
<td><p>One dimensional MAPMRI basis function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_phi_matrix" title="dipy.reconst.mapmri.mapmri_phi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_phi_matrix</span></code></a>(radial_order, mu, q_gradients)</p></td>
<td><p>Compute the MAPMRI phi matrix for the signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_psi_1d" title="dipy.reconst.mapmri.mapmri_psi_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_psi_1d</span></code></a>(n, x, mu)</p></td>
<td><p>One dimensional MAPMRI propagator basis function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_psi_matrix" title="dipy.reconst.mapmri.mapmri_psi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_psi_matrix</span></code></a>(radial_order, mu, rgrad)</p></td>
<td><p>Compute the MAPMRI psi matrix for the propagator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_odf_matrix" title="dipy.reconst.mapmri.mapmri_odf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_odf_matrix</span></code></a>(radial_order, mu, s, vertices)</p></td>
<td><p>Compute the MAPMRI ODF matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_phi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_phi_matrix</span></code></a>(radial_order, mu, q)</p></td>
<td><p>Three dimensional isotropic MAPMRI signal basis function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis" title="dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_signal_basis</span></code></a>(j, ...)</p></td>
<td><p>Radial part of the isotropic 1D-SHORE signal basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent" title="dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_independent</span></code></a>(...)</p></td>
<td><p>Computed the mu independent part of the signal design matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent" title="dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_dependent</span></code></a>(...)</p></td>
<td><p>Computed the mu dependent part of the signal design matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_psi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_psi_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Three dimensional isotropic MAPMRI propagator basis function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis" title="dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_pdf_basis</span></code></a>(j, ...)</p></td>
<td><p>Radial part of the isotropic 1D-SHORE propagator basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent" title="dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_independent</span></code></a>(...)</p></td>
<td><p>Computes mu independent part of K.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent" title="dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_dependent</span></code></a>(...)</p></td>
<td><p>Computes mu dependent part of M.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.binomialfloat" title="dipy.reconst.mapmri.binomialfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">binomialfloat</span></code></a>(n, k)</p></td>
<td><p>Custom Binomial function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_odf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Compute the isotropic MAPMRI ODF matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_sh_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Compute the isotropic MAPMRI ODF matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix</span></code></a>(...)</p></td>
<td><p>Computes the Laplacian regularization matrix for MAP-MRI's isotropic implementation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</span></code></a>(...)</p></td>
<td><p>Computes the Laplacian regularization matrix for MAP-MRI's isotropic implementation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_index_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_index_matrix</span></code></a>(radial_order)</p></td>
<td><p>Calculates the indices for the isotropic MAPMRI basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.create_rspace" title="dipy.reconst.mapmri.create_rspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_rspace</span></code></a>(gridsize, radius_max)</p></td>
<td><p>Create the real space table, that contains the points in which to compute the pdf.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.delta" title="dipy.reconst.mapmri.delta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delta</span></code></a>(n, m)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.map_laplace_u" title="dipy.reconst.mapmri.map_laplace_u"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_laplace_u</span></code></a>(n, m)</p></td>
<td><p>S(n, m) static matrix for Laplacian regularization.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.map_laplace_t" title="dipy.reconst.mapmri.map_laplace_t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_laplace_t</span></code></a>(n, m)</p></td>
<td><p>L(m, n) static matrix for Laplacian regularization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.map_laplace_s" title="dipy.reconst.mapmri.map_laplace_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_laplace_s</span></code></a>(n, m)</p></td>
<td><p>R(m,n) static matrix for Laplacian regularization.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_STU_reg_matrices" title="dipy.reconst.mapmri.mapmri_STU_reg_matrices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_STU_reg_matrices</span></code></a>(radial_order)</p></td>
<td><p>Generate the static portions of the Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix" title="dipy.reconst.mapmri.mapmri_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_laplacian_reg_matrix</span></code></a>(ind_mat, mu, ...)</p></td>
<td><p>Put the Laplacian regularization matrix together.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.generalized_crossvalidation_array" title="dipy.reconst.mapmri.generalized_crossvalidation_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generalized_crossvalidation_array</span></code></a>(data, M, LR, *)</p></td>
<td><p>Generalized Cross Validation Function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.generalized_crossvalidation" title="dipy.reconst.mapmri.generalized_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generalized_crossvalidation</span></code></a>(data, M, LR, *)</p></td>
<td><p>Generalized Cross Validation Function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.gcv_cost_function" title="dipy.reconst.mapmri.gcv_cost_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gcv_cost_function</span></code></a>(weight, args)</p></td>
<td><p>The GCV cost function that is iterated.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.mcsd">
<span id="module-reconst-mcsd"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.mcsd</span></code><a class="headerlink" href="#module-dipy.reconst.mcsd" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellResponse" title="dipy.reconst.mcsd.MultiShellResponse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiShellResponse</span></code></a>(response, sh_order_max, ...)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellDeconvModel" title="dipy.reconst.mcsd.MultiShellDeconvModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiShellDeconvModel</span></code></a>(gtab, response[, ...])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.MSDeconvFit" title="dipy.reconst.mcsd.MSDeconvFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MSDeconvFit</span></code></a>(model, coeff, mask)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.QpFitter" title="dipy.reconst.mcsd.QpFitter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QpFitter</span></code></a>(X, reg)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.multi_tissue_basis" title="dipy.reconst.mcsd.multi_tissue_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_tissue_basis</span></code></a>(gtab, sh_order_max, iso_comp)</p></td>
<td><p>Builds a basis for multi-shell multi-tissue CSD model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.solve_qp" title="dipy.reconst.mcsd.solve_qp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_qp</span></code></a>(P, Q, G, H)</p></td>
<td><p>Helper function to set up and solve the Quadratic Program (QP) in CVXPY.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.multi_shell_fiber_response" title="dipy.reconst.mcsd.multi_shell_fiber_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_shell_fiber_response</span></code></a>(sh_order_max, ...)</p></td>
<td><p>Fiber response function estimation for multi-shell data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.mask_for_response_msmt" title="dipy.reconst.mcsd.mask_for_response_msmt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mask_for_response_msmt</span></code></a>(gtab, data, *[, ...])</p></td>
<td><p>Computation of masks for multi-shell multi-tissue (msmt) response</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.response_from_mask_msmt" title="dipy.reconst.mcsd.response_from_mask_msmt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">response_from_mask_msmt</span></code></a>(gtab, data, mask_wm, ...)</p></td>
<td><p>Computation of multi-shell multi-tissue (msmt) response</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.auto_response_msmt" title="dipy.reconst.mcsd.auto_response_msmt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_response_msmt</span></code></a>(gtab, data, *[, tol, ...])</p></td>
<td><p>Automatic estimation of multi-shell multi-tissue (msmt) response</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.msdki">
<span id="module-reconst-msdki"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.msdki</span></code><a class="headerlink" href="#module-dipy.reconst.msdki" title="Link to this heading">#</a></h2>
<p>Classes and functions for fitting the mean signal diffusion kurtosis
model</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel" title="dipy.reconst.msdki.MeanDiffusionKurtosisModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel</span></code></a>(gtab, *args[, ...])</p></td>
<td><p>Mean signal Diffusion Kurtosis Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit</span></code></a>(model, model_params, *)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.mean_signal_bvalue" title="dipy.reconst.msdki.mean_signal_bvalue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_signal_bvalue</span></code></a>(data, gtab, *[, bmag])</p></td>
<td><p>Computes the average signal across different diffusion directions for each unique b-value</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.msk_from_awf" title="dipy.reconst.msdki.msk_from_awf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msk_from_awf</span></code></a>(f)</p></td>
<td><p>Computes mean signal kurtosis from axonal water fraction estimates of the SMT2 model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.awf_from_msk" title="dipy.reconst.msdki.awf_from_msk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">awf_from_msk</span></code></a>(msk, *[, mask])</p></td>
<td><p>Computes the axonal water fraction from the mean signal kurtosis assuming the 2-compartmental spherical mean technique model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.msdki_prediction" title="dipy.reconst.msdki.msdki_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msdki_prediction</span></code></a>(msdki_params, gtab, *[, S0])</p></td>
<td><p>Predict the mean signal given the parameters of the mean signal DKI, an GradientTable object and S0 signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.wls_fit_msdki" title="dipy.reconst.msdki.wls_fit_msdki"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_msdki</span></code></a>(design_matrix, msignal, ng, *)</p></td>
<td><p>Fits the mean signal diffusion kurtosis imaging based on a weighted least square solution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.design_matrix" title="dipy.reconst.msdki.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>(ubvals)</p></td>
<td><p>Constructs design matrix for the mean signal diffusion kurtosis model</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.multi_voxel">
<span id="module-reconst-multi-voxel"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.multi_voxel</span></code><a class="headerlink" href="#module-dipy.reconst.multi_voxel" title="Link to this heading">#</a></h2>
<p>Tools to easily make multi voxel models</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="dipy.reconst.multi_voxel.MultiVoxelFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a>(model, fit_array, mask)</p></td>
<td><p>Holds an array of fits and allows access to their attributes and methods</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.multi_voxel.CallableArray" title="dipy.reconst.multi_voxel.CallableArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CallableArray</span></code></a></p></td>
<td><p>An array which can be called like a function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.multi_voxel.multi_voxel_fit" title="dipy.reconst.multi_voxel.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>
<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.odf">
<span id="module-reconst-odf"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.odf</span></code><a class="headerlink" href="#module-dipy.reconst.odf" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfModel</span></code></a>(gtab)</p></td>
<td><p>An abstract class to be sub-classed by specific odf models</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfFit</span></code></a>(model, data)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.odf.gfa" title="dipy.reconst.odf.gfa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gfa</span></code></a>(samples)</p></td>
<td><p>The general fractional anisotropy of a function evaluated on the unit sphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.odf.minmax_normalize" title="dipy.reconst.odf.minmax_normalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minmax_normalize</span></code></a>(samples, *[, out])</p></td>
<td><p>Min-max normalization of a function evaluated on the unit sphere</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.qtdmri">
<span id="module-reconst-qtdmri"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.qtdmri</span></code><a class="headerlink" href="#module-dipy.reconst.qtdmri" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriModel" title="dipy.reconst.qtdmri.QtdmriModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a>(gtab, *[, radial_order, ...])</p></td>
<td><p>The q:math:<cite>tau</cite>-dMRI model to analytically and continuously represent the q:math:<cite>tau</cite> diffusion signal attenuation over diffusion sensitization q and diffusion time <span class="math notranslate nohighlight">\(\tau\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit" title="dipy.reconst.qtdmri.QtdmriFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a>(model, qtdmri_coef, us, ut, ...)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix" title="dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_to_mapmri_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Generate the matrix that maps the qtdmri coefficients to MAP-MRI coefficients for the anisotropic case.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_to_mapmri_matrix</span></code></a>(...)</p></td>
<td><p>Generate the matrix that maps the spherical qtdmri coefficients to MAP-MRI coefficients for the isotropic case.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_temporal_normalization" title="dipy.reconst.qtdmri.qtdmri_temporal_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_temporal_normalization</span></code></a>(ut)</p></td>
<td><p>Normalization factor for the temporal basis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_mapmri_normalization" title="dipy.reconst.qtdmri.qtdmri_mapmri_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_mapmri_normalization</span></code></a>(mu)</p></td>
<td><p>Normalization factor for Cartesian MAP-MRI basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization" title="dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_mapmri_isotropic_normalization</span></code></a>(j, ell, u0)</p></td>
<td><p>Normalization factor for Spherical MAP-MRI basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix" title="dipy.reconst.qtdmri.qtdmri_signal_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_signal_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix" title="dipy.reconst.qtdmri.qtdmri_eap_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_eap_matrix</span></code></a>(radial_order, time_order, ...)</p></td>
<td><p>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_signal_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_eap_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.radial_basis_opt" title="dipy.reconst.qtdmri.radial_basis_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_basis_opt</span></code></a>(j, ell, us, q)</p></td>
<td><p>Spatial basis dependent on spatial scaling factor us</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.angular_basis_opt" title="dipy.reconst.qtdmri.angular_basis_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angular_basis_opt</span></code></a>(ell, m, q, theta, phi)</p></td>
<td><p>Angular basis independent of spatial scaling factor us.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.radial_basis_EAP_opt" title="dipy.reconst.qtdmri.radial_basis_EAP_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_basis_EAP_opt</span></code></a>(j, ell, us, r)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.angular_basis_EAP_opt" title="dipy.reconst.qtdmri.angular_basis_EAP_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angular_basis_EAP_opt</span></code></a>(j, ell, m, r, theta, phi)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.temporal_basis" title="dipy.reconst.qtdmri.temporal_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">temporal_basis</span></code></a>(o, ut, tau)</p></td>
<td><p>Temporal basis dependent on temporal scaling factor ut</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_index_matrix" title="dipy.reconst.qtdmri.qtdmri_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_index_matrix</span></code></a>(radial_order, time_order)</p></td>
<td><p>Computes the SHORE basis order indices according to [1].</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_index_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Computes the SHORE basis order indices according to [1].</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix" title="dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_laplacian_reg_matrix</span></code></a>(ind_mat, us, ut, *)</p></td>
<td><p>Computes the cartesian qt-dMRI Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_laplacian_reg_matrix</span></code></a>(...[, ...])</p></td>
<td><p>Computes the spherical qt-dMRI Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part23_reg_matrix_q" title="dipy.reconst.qtdmri.part23_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part23_reg_matrix_q</span></code></a>(ind_mat, U_mat, T_mat, us)</p></td>
<td><p>Partial cartesian spatial Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part23_iso_reg_matrix_q" title="dipy.reconst.qtdmri.part23_iso_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part23_iso_reg_matrix_q</span></code></a>(ind_mat, us)</p></td>
<td><p>Partial spherical spatial Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part4_reg_matrix_q" title="dipy.reconst.qtdmri.part4_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part4_reg_matrix_q</span></code></a>(ind_mat, U_mat, us)</p></td>
<td><p>Partial cartesian spatial Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part4_iso_reg_matrix_q" title="dipy.reconst.qtdmri.part4_iso_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part4_iso_reg_matrix_q</span></code></a>(ind_mat, us)</p></td>
<td><p>Partial spherical spatial Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part1_reg_matrix_tau" title="dipy.reconst.qtdmri.part1_reg_matrix_tau"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part1_reg_matrix_tau</span></code></a>(ind_mat, ut)</p></td>
<td><p>Partial temporal Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part23_reg_matrix_tau" title="dipy.reconst.qtdmri.part23_reg_matrix_tau"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part23_reg_matrix_tau</span></code></a>(ind_mat, ut)</p></td>
<td><p>Partial temporal Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part4_reg_matrix_tau" title="dipy.reconst.qtdmri.part4_reg_matrix_tau"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part4_reg_matrix_tau</span></code></a>(ind_mat, ut)</p></td>
<td><p>Partial temporal Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.H" title="dipy.reconst.qtdmri.H"><code class="xref py py-obj docutils literal notranslate"><span class="pre">H</span></code></a>(value)</p></td>
<td><p>Step function of H(x)=1 if x&gt;=0 and zero otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.generalized_crossvalidation" title="dipy.reconst.qtdmri.generalized_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generalized_crossvalidation</span></code></a>(data, M, LR, *)</p></td>
<td><p>Generalized Cross Validation Function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.GCV_cost_function" title="dipy.reconst.qtdmri.GCV_cost_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GCV_cost_function</span></code></a>(weight, arguments)</p></td>
<td><p>Generalized Cross Validation Function that is iterated.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_scaling" title="dipy.reconst.qtdmri.qtdmri_isotropic_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_scaling</span></code></a>(data, q, tau)</p></td>
<td><p>Constructs design matrix for fitting an exponential to the diffusion time points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling" title="dipy.reconst.qtdmri.qtdmri_anisotropic_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_anisotropic_scaling</span></code></a>(data, q, bvecs, tau)</p></td>
<td><p>Constructs design matrix for fitting an exponential to the diffusion time points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.design_matrix_spatial" title="dipy.reconst.qtdmri.design_matrix_spatial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix_spatial</span></code></a>(bvecs, qvals)</p></td>
<td><p>Constructs design matrix for DTI weighted least squares or least squares fitting.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.create_rt_space_grid" title="dipy.reconst.qtdmri.create_rt_space_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_rt_space_grid</span></code></a>(grid_size_r, ...)</p></td>
<td><p>Generates EAP grid (for potential positivity constraint).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_number_of_coefficients" title="dipy.reconst.qtdmri.qtdmri_number_of_coefficients"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_number_of_coefficients</span></code></a>(radial_order, ...)</p></td>
<td><p>Computes the total number of coefficients of the qtdmri basis given a radial and temporal order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.l1_crossvalidation" title="dipy.reconst.qtdmri.l1_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">l1_crossvalidation</span></code></a>(b0s_mask, E, M, *[, ...])</p></td>
<td><p>cross-validation function to find the optimal weight of alpha for sparsity regularization</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.elastic_crossvalidation" title="dipy.reconst.qtdmri.elastic_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">elastic_crossvalidation</span></code></a>(b0s_mask, E, M, L, ...)</p></td>
<td><p>cross-validation function to find the optimal weight of alpha for sparsity regularization when also Laplacian regularization is used.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow" title="dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualise_gradient_table_G_Delta_rainbow</span></code></a>(gtab, *)</p></td>
<td><p>This function visualizes a q-tau acquisition scheme as a function of gradient strength and pulse separation (big_delta).</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.qti">
<span id="module-reconst-qti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.qti</span></code><a class="headerlink" href="#module-dipy.reconst.qti" title="Link to this heading">#</a></h2>
<p>Classes and functions for fitting the covariance tensor model of q-space
trajectory imaging (QTI) by Westin <em>et al.</em><a class="footnote-reference brackets" href="#footcite-westin2016" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<section id="id6">
<h3>References<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<div class="docutils container" id="id7">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-westin2016" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id5">1</a>,<a role="doc-backlink" href="#id350">2</a>)</span>
<p>Carl-Fredrik Westin, Hans Knutsson, Ofer Pasternak, Filip Szczepankiewicz, Evren Özarslan, Danielle van Westen, Cecilia Mattisson, Mats Bogren, Lauren J. O’Donnell, Marek Kubicki, Daniel Topgaard, and Markus Nilsson. Q-space trajectory imaging for multidimensional diffusion MRI of the human brain. <em>NeuroImage</em>, 135:345–362, 2016. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.02.039">https://doi.org/10.1016/j.neuroimage.2016.02.039</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.02.039">doi:10.1016/j.neuroimage.2016.02.039</a>.</p>
</aside>
</aside>
</div>
</section>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiModel" title="dipy.reconst.qti.QtiModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtiModel</span></code></a>(gtab, *[, fit_method, cvxpy_solver])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit" title="dipy.reconst.qti.QtiFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtiFit</span></code></a>(params)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.from_3x3_to_6x1" title="dipy.reconst.qti.from_3x3_to_6x1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_3x3_to_6x1</span></code></a>(T)</p></td>
<td><p>Convert symmetric 3 x 3 matrices into 6 x 1 vectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.from_6x1_to_3x3" title="dipy.reconst.qti.from_6x1_to_3x3"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_6x1_to_3x3</span></code></a>(V)</p></td>
<td><p>Convert 6 x 1 vectors into symmetric 3 x 3 matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.from_6x6_to_21x1" title="dipy.reconst.qti.from_6x6_to_21x1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_6x6_to_21x1</span></code></a>(T)</p></td>
<td><p>Convert symmetric 6 x 6 matrices into 21 x 1 vectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.from_21x1_to_6x6" title="dipy.reconst.qti.from_21x1_to_6x6"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_21x1_to_6x6</span></code></a>(V)</p></td>
<td><p>Convert 21 x 1 vectors into symmetric 6 x 6 matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.cvxpy_1x6_to_3x3" title="dipy.reconst.qti.cvxpy_1x6_to_3x3"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cvxpy_1x6_to_3x3</span></code></a>(V)</p></td>
<td><p>Convert a 1 x 6 vector into a symmetric 3 x 3 matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.cvxpy_1x21_to_6x6" title="dipy.reconst.qti.cvxpy_1x21_to_6x6"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cvxpy_1x21_to_6x6</span></code></a>(V)</p></td>
<td><p>Convert 1 x 21 vector into a symmetric 6 x 6 matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.dtd_covariance" title="dipy.reconst.qti.dtd_covariance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtd_covariance</span></code></a>(DTD)</p></td>
<td><p>Calculate covariance of a diffusion tensor distribution (DTD).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.qti_signal" title="dipy.reconst.qti.qti_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qti_signal</span></code></a>(gtab, D, C, *[, S0])</p></td>
<td><p>Generate signals using the covariance tensor signal representation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.design_matrix" title="dipy.reconst.qti.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>(btens)</p></td>
<td><p>Calculate the design matrix from the b-tensors.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.rumba">
<span id="module-reconst-rumba"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.rumba</span></code><a class="headerlink" href="#module-dipy.reconst.rumba" title="Link to this heading">#</a></h2>
<p>Robust and Unbiased Model-BAsed Spherical Deconvolution (RUMBA-SD)</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaSDModel" title="dipy.reconst.rumba.RumbaSDModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RumbaSDModel</span></code></a>(gtab, *[, wm_response, ...])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit" title="dipy.reconst.rumba.RumbaFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RumbaFit</span></code></a>(model, model_params)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.rumba_deconv" title="dipy.reconst.rumba.rumba_deconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rumba_deconv</span></code></a>(data, kernel, *[, n_iter, ...])</p></td>
<td><p>Fit fODF and GM/CSF volume fractions for a voxel using RUMBA-SD.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.rumba.mbessel_ratio" title="dipy.reconst.rumba.mbessel_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mbessel_ratio</span></code></a>(n, x)</p></td>
<td><p>Fast computation of modified Bessel function ratio (first kind).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.generate_kernel" title="dipy.reconst.rumba.generate_kernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_kernel</span></code></a>(gtab, sphere, wm_response, ...)</p></td>
<td><p>Generate deconvolution kernel</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.rumba.rumba_deconv_global" title="dipy.reconst.rumba.rumba_deconv_global"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rumba_deconv_global</span></code></a>(data, kernel, mask, *[, ...])</p></td>
<td><p>Fit fODF for all voxels simultaneously using RUMBA-SD.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.sfm">
<span id="module-reconst-sfm"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.sfm</span></code><a class="headerlink" href="#module-dipy.reconst.sfm" title="Link to this heading">#</a></h2>
<p>The Sparse Fascicle Model.</p>
<p>This is an implementation of the sparse fascicle model described in
Rokem <em>et al.</em><a class="footnote-reference brackets" href="#footcite-rokem2015" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>. The multi b-value version of this model is described
in Rokem <em>et al.</em><a class="footnote-reference brackets" href="#footcite-rokem2014" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
<section id="id10">
<h3>References<a class="headerlink" href="#id10" title="Link to this heading">#</a></h3>
<div class="docutils container" id="id11">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-rokem2015" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">4</a><span class="fn-bracket">]</span></span>
<p>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick N. Kay, Aviv Mezer, Stefan van der Walt, and Brian A. Wandell. Evaluating the Accuracy of Diffusion MRI Models in White Matter. <em>PLOS ONE</em>, 10(4):1–26, April 2015. URL: <a class="reference external" href="https://doi.org/10.1371/journal.pone.0123272">https://doi.org/10.1371/journal.pone.0123272</a>, <a class="reference external" href="https://doi.org/10.1371/journal.pone.0123272">doi:10.1371/journal.pone.0123272</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-rokem2014" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id9">1</a>,<a role="doc-backlink" href="#id29">2</a>)</span>
<p>Ariel Rokem, Kimberly L. Chan, Jason D. Yeatman, Franco Pestilli, and Brian A. Wandel. Evaluating the accuracy of diffusion models at multiple b-values with cross-validation. In <em>Joint Annual Meeting ISMRM-ESMRMB 2014 SMRT 23rd Annual Meeting</em>, volume. Milan, Italy, 2014. International Society for Magnetic Resonance in Medicine (ISMRM).</p>
</aside>
</aside>
</div>
</section>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a>(gtab)</p></td>
<td><p>A base-class for the representation of isotropic signals.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a>(model, params)</p></td>
<td><p>A fit object for representing the isotropic signal as the mean of the diffusion-weighted signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="dipy.reconst.sfm.ExponentialIsotropicModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a>(gtab)</p></td>
<td><p>Representing the isotropic signal as a fit to an exponential decay function with b-values</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="dipy.reconst.sfm.ExponentialIsotropicFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a>(model, params)</p></td>
<td><p>A fit to the ExponentialIsotropicModel object, based on data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel" title="dipy.reconst.sfm.SparseFascicleModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a>(gtab, *[, sphere, ...])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit" title="dipy.reconst.sfm.SparseFascicleFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a>(model, beta, S0, iso)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.sfm_design_matrix" title="dipy.reconst.sfm.sfm_design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sfm_design_matrix</span></code></a>(gtab, sphere, response, *)</p></td>
<td><p>Construct the SFM design matrix</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.shm">
<span id="module-reconst-shm"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shm</span></code><a class="headerlink" href="#module-dipy.reconst.shm" title="Link to this heading">#</a></h2>
<p>Tools for using spherical harmonic models to fit diffusion data.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-aganj2009" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-tristanvega2009a" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>, and <a class="footnote-reference brackets" href="#footcite-tristanvega2010" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.</p>
<section id="id16">
<h3>References<a class="headerlink" href="#id16" title="Link to this heading">#</a></h3>
<div class="docutils container" id="id17">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-aganj2009" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id12">1</a>,<a role="doc-backlink" href="#id361">2</a>)</span>
<p>Iman Aganj, Christophe Lenglet, and Guillermo Sapiro. ODF reconstruction in q-ball imaging with solid angle consideration. In <em>2009 IEEE International Symposium on Biomedical Imaging: From Nano to Macro</em>, volume, 1398–1401. 2009. <a class="reference external" href="https://doi.org/10.1109/ISBI.2009.5193327">doi:10.1109/ISBI.2009.5193327</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-descoteaux2007" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id42">2</a>,<a role="doc-backlink" href="#id45">3</a>,<a role="doc-backlink" href="#id364">4</a>,<a role="doc-backlink" href="#id369">5</a>,<a role="doc-backlink" href="#id372">6</a>,<a role="doc-backlink" href="#id376">7</a>,<a role="doc-backlink" href="#id383">8</a>,<a role="doc-backlink" href="#id386">9</a>,<a role="doc-backlink" href="#id389">10</a>,<a role="doc-backlink" href="#id392">11</a>,<a role="doc-backlink" href="#id397">12</a>,<a role="doc-backlink" href="#id398">13</a>,<a role="doc-backlink" href="#id403">14</a>,<a role="doc-backlink" href="#id404">15</a>)</span>
<p>Maxime Descoteaux, Elaine Angelino, Shaun Fitzgibbons, and Rachid Deriche. Regularized, fast, and robust analytical Q-ball imaging. <em>Magnetic Resonance in Medicine</em>, 58(3):497–510, 2007. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.21277">https://doi.org/10.1002/mrm.21277</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.21277">doi:10.1002/mrm.21277</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-tristanvega2009a" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id14">1</a>,<a role="doc-backlink" href="#id362">2</a>)</span>
<p>Antonio Tristán-Vega, Carl-Fredrik Westin, and Santiago Aja-Fernández. Estimation of fiber Orientation Probability Density Functions in High Angular Resolution Diffusion Imaging. <em>NeuroImage</em>, 47(2):638–650, August 2009. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2009.04.049">https://doi.org/10.1016/j.neuroimage.2009.04.049</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2009.04.049">doi:10.1016/j.neuroimage.2009.04.049</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-tristanvega2010" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id15">1</a>,<a role="doc-backlink" href="#id363">2</a>)</span>
<p>Antonio Tristán-Vega, Carl-Fredrik Westin, and Santiago Aja-Fernández. A new methodology for the estimation of fiber populations in the white matter of the brain with the Funk–Radon transform. <em>NeuroImage</em>, 49(2):1301–1315, 2010. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2009.09.070">https://doi.org/10.1016/j.neuroimage.2009.09.070</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2009.09.070">doi:10.1016/j.neuroimage.2009.09.070</a>.</p>
</aside>
</aside>
</div>
<p>Note about the Transpose:
In the literature the matrix representation of these methods is often written
as Y = Bx where B is some design matrix and Y and x are column vectors. In our
case the input data, a dwi stored as a nifti file for example, is stored as row
vectors (ndarrays) of the form (x, y, z, n), where n is the number of diffusion
directions. We could transpose and reshape the data to be (n, x*y*z), so that
we could directly plug it into the above equation. However, I have chosen to
keep the data as is and implement the relevant equations rewritten in the
following form: Y.T = x.T B.T, or in python syntax data = np.dot(sh_coef, B.T)
where data is Y.T and sh_coef is x.T.</p>
</section>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a>(gtab)</p></td>
<td><p>To be subclassed by all models that return a SphHarmFit when fit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a>(gtab, sh_order_max, *[, ...])</p></td>
<td><p>To be subclassed by Qball type models.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a>(model, shm_coef, mask)</p></td>
<td><p>Diffusion data fit to a spherical harmonic model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.CsaOdfModel" title="dipy.reconst.shm.CsaOdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a>(gtab, sh_order_max, *[, smooth, ...])</p></td>
<td><p>Implementation of Constant Solid Angle reconstruction method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.OpdtModel" title="dipy.reconst.shm.OpdtModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OpdtModel</span></code></a>(gtab, sh_order_max, *[, smooth, ...])</p></td>
<td><p>Implementation of Orientation Probability Density Transform reconstruction method.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.QballModel" title="dipy.reconst.shm.QballModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QballModel</span></code></a>(gtab, sh_order_max, *[, smooth, ...])</p></td>
<td><p>Implementation of regularized Qball reconstruction method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="dipy.reconst.shm.ResidualBootstrapWrapper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a>(signal_object, B, ...)</p></td>
<td><p>Returns a residual bootstrap sample of the signal_object when indexed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.forward_sdeconv_mat" title="dipy.reconst.shm.forward_sdeconv_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward_sdeconv_mat</span></code></a>(r_rh, l_values)</p></td>
<td><p>Build forward spherical deconvolution matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.sh_to_rh" title="dipy.reconst.shm.sh_to_rh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_rh</span></code></a>(r_sh, m_values, l_values)</p></td>
<td><p>Spherical harmonics (SH) to rotational harmonics (RH)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.gen_dirac" title="dipy.reconst.shm.gen_dirac"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_dirac</span></code></a>(m_values, l_values, theta, phi, *)</p></td>
<td><p>Generate Dirac delta function orientated in (theta, phi) on the sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.spherical_harmonics" title="dipy.reconst.shm.spherical_harmonics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spherical_harmonics</span></code></a>(m_values, l_values, ...)</p></td>
<td><p>Compute spherical harmonics.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sph_harm" title="dipy.reconst.shm.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a>(m_values, l_values, theta, phi)</p></td>
<td><p>Compute real spherical harmonics.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sh_tournier_from_index" title="dipy.reconst.shm.real_sh_tournier_from_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sh_tournier_from_index</span></code></a>(m_values, ...[, ...])</p></td>
<td><p>Compute real spherical harmonics.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sh_descoteaux_from_index" title="dipy.reconst.shm.real_sh_descoteaux_from_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sh_descoteaux_from_index</span></code></a>(m_values, ...)</p></td>
<td><p>Compute real spherical harmonics.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sh_tournier" title="dipy.reconst.shm.real_sh_tournier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sh_tournier</span></code></a>(sh_order_max, theta, phi, *)</p></td>
<td><p>Compute real spherical harmonics.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sh_descoteaux" title="dipy.reconst.shm.real_sh_descoteaux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sh_descoteaux</span></code></a>(sh_order_max, theta, phi, *)</p></td>
<td><p>Compute real spherical harmonics.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sym_sh_mrtrix" title="dipy.reconst.shm.real_sym_sh_mrtrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sym_sh_mrtrix</span></code></a>(sh_order_max, theta, phi)</p></td>
<td><p>dipy.reconst.shm.real_sym_sh_mrtrix is deprecated, Please use dipy.reconst.shm.real_sh_tournier instead</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sym_sh_basis" title="dipy.reconst.shm.real_sym_sh_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sym_sh_basis</span></code></a>(sh_order_max, theta, phi)</p></td>
<td><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.sph_harm_ind_list" title="dipy.reconst.shm.sph_harm_ind_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sph_harm_ind_list</span></code></a>(sh_order_max, *[, full_basis])</p></td>
<td><p>Returns the order (<code class="docutils literal notranslate"><span class="pre">l</span></code>) and phase_factor (<code class="docutils literal notranslate"><span class="pre">m</span></code>) of all the symmetric spherical harmonics of order less then or equal to <code class="docutils literal notranslate"><span class="pre">sh_order_max</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.order_from_ncoef" title="dipy.reconst.shm.order_from_ncoef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order_from_ncoef</span></code></a>(ncoef, *[, full_basis])</p></td>
<td><p>Given a number <code class="docutils literal notranslate"><span class="pre">n</span></code> of coefficients, calculate back the <code class="docutils literal notranslate"><span class="pre">sh_order_max</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.smooth_pinv" title="dipy.reconst.shm.smooth_pinv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth_pinv</span></code></a>(B, L)</p></td>
<td><p>Regularized pseudo-inverse</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.lazy_index" title="dipy.reconst.shm.lazy_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lazy_index</span></code></a>(index)</p></td>
<td><p>Produces a lazy index</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_data</span></code></a>(data, where_b0, *[, ...])</p></td>
<td><p>Normalizes the data with respect to the mean b0</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.hat" title="dipy.reconst.shm.hat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hat</span></code></a>(B)</p></td>
<td><p>Returns the hat matrix for the design matrix B</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.lcr_matrix" title="dipy.reconst.shm.lcr_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lcr_matrix</span></code></a>(H)</p></td>
<td><p>Returns a matrix for computing leveraged, centered residuals from data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.bootstrap_data_array" title="dipy.reconst.shm.bootstrap_data_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bootstrap_data_array</span></code></a>(data, H, R, *[, permute])</p></td>
<td><p>Applies the Residual Bootstraps to the data given H and R</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.bootstrap_data_voxel" title="dipy.reconst.shm.bootstrap_data_voxel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bootstrap_data_voxel</span></code></a>(data, H, R, *[, permute])</p></td>
<td><p>Like bootstrap_data_array but faster when for a single voxel</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.sf_to_sh" title="dipy.reconst.shm.sf_to_sh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sf_to_sh</span></code></a>(sf, sphere, *[, sh_order_max, ...])</p></td>
<td><p>Spherical function to spherical harmonics (SH).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.sh_to_sf" title="dipy.reconst.shm.sh_to_sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_sf</span></code></a>(sh, sphere, *[, sh_order_max, ...])</p></td>
<td><p>Spherical harmonics (SH) to spherical function (SF).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.sh_to_sf_matrix" title="dipy.reconst.shm.sh_to_sf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_sf_matrix</span></code></a>(sphere, *[, sh_order_max, ...])</p></td>
<td><p>Matrix that transforms Spherical harmonics (SH) to spherical function (SF).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.calculate_max_order" title="dipy.reconst.shm.calculate_max_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_max_order</span></code></a>(n_coeffs, *[, full_basis])</p></td>
<td><p>Calculate the maximal harmonic order (l), given that you know the number of parameters that were estimated.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.anisotropic_power" title="dipy.reconst.shm.anisotropic_power"><code class="xref py py-obj docutils literal notranslate"><span class="pre">anisotropic_power</span></code></a>(sh_coeffs, *[, ...])</p></td>
<td><p>Calculate anisotropic power map with a given SH coefficient matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.convert_sh_to_full_basis" title="dipy.reconst.shm.convert_sh_to_full_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_sh_to_full_basis</span></code></a>(sh_coeffs)</p></td>
<td><p>Given an array of SH coeffs from a symmetric basis, returns the coefficients for the full SH basis by filling odd order SH coefficients with zeros</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.convert_sh_from_legacy" title="dipy.reconst.shm.convert_sh_from_legacy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_sh_from_legacy</span></code></a>(sh_coeffs, sh_basis, *)</p></td>
<td><p>Convert SH coefficients in legacy SH basis to SH coefficients of the new SH basis for <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> or <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> bases.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.convert_sh_to_legacy" title="dipy.reconst.shm.convert_sh_to_legacy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_sh_to_legacy</span></code></a>(sh_coeffs, sh_basis, *)</p></td>
<td><p>Convert SH coefficients in new SH basis to SH coefficients for the legacy SH basis for <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> or <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> bases.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.convert_sh_descoteaux_tournier" title="dipy.reconst.shm.convert_sh_descoteaux_tournier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_sh_descoteaux_tournier</span></code></a>(sh_coeffs)</p></td>
<td><p>Convert SH coefficients between legacy-descoteaux07 and tournier07.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.shore">
<span id="module-reconst-shore"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shore</span></code><a class="headerlink" href="#module-dipy.reconst.shore" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreModel" title="dipy.reconst.shore.ShoreModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShoreModel</span></code></a>(gtab, *[, radial_order, zeta, ...])</p></td>
<td><p>Simple Harmonic Oscillator based Reconstruction and Estimation (SHORE) of the diffusion signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit" title="dipy.reconst.shore.ShoreFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShoreFit</span></code></a>(model, shore_coef)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_matrix" title="dipy.reconst.shore.shore_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_matrix</span></code></a>(radial_order, zeta, gtab, *[, tau])</p></td>
<td><p>Compute the SHORE matrix for modified Merlet's 3D-SHORE.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_matrix_pdf" title="dipy.reconst.shore.shore_matrix_pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_matrix_pdf</span></code></a>(radial_order, zeta, rtab)</p></td>
<td><p>Compute the SHORE propagator matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_matrix_odf" title="dipy.reconst.shore.shore_matrix_odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_matrix_odf</span></code></a>(radial_order, zeta, ...)</p></td>
<td><p>Compute the SHORE ODF matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.l_shore" title="dipy.reconst.shore.l_shore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">l_shore</span></code></a>(radial_order)</p></td>
<td><p>Returns the angular regularisation matrix for SHORE basis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.n_shore" title="dipy.reconst.shore.n_shore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_shore</span></code></a>(radial_order)</p></td>
<td><p>Returns the angular regularisation matrix for SHORE basis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.create_rspace" title="dipy.reconst.shore.create_rspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_rspace</span></code></a>(gridsize, radius_max)</p></td>
<td><p>Create the real space table, that contains the points in which</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_indices" title="dipy.reconst.shore.shore_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_indices</span></code></a>(radial_order, index)</p></td>
<td><p>Given the basis order and the index, return the shore indices n, l, m for modified Merlet's 3D-SHORE</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_order" title="dipy.reconst.shore.shore_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_order</span></code></a>(n, ell, m)</p></td>
<td><p>Given the indices (n,l,m) of the basis, return the minimum order for those indices and their index for modified Merlet's 3D-SHORE.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.utils">
<span id="module-reconst-utils"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.utils</span></code><a class="headerlink" href="#module-dipy.reconst.utils" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.utils.dki_design_matrix" title="dipy.reconst.utils.dki_design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dki_design_matrix</span></code></a>(gtab)</p></td>
<td><p>Construct B design matrix for DKI.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.utils.cti_design_matrix" title="dipy.reconst.utils.cti_design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cti_design_matrix</span></code></a>(gtab1, gtab2)</p></td>
<td><p>Construct B design matrix for CTI.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.utils.convert_tensors" title="dipy.reconst.utils.convert_tensors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_tensors</span></code></a>(tensor, from_format, to_format)</p></td>
<td><p>Convert tensors from one format to another.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-dipy.reconst.weights_method">
<span id="module-reconst-weights-method"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.weights_method</span></code><a class="headerlink" href="#module-dipy.reconst.weights_method" title="Link to this heading">#</a></h2>
<p>Functions for defining weights for iterative fitting methods.</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.weights_method.simple_cutoff" title="dipy.reconst.weights_method.simple_cutoff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">simple_cutoff</span></code></a>(residuals, log_residuals, ...)</p></td>
<td><p>Define outliers based on the signal (rather than the log-signal).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.weights_method.two_eyes_cutoff" title="dipy.reconst.weights_method.two_eyes_cutoff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">two_eyes_cutoff</span></code></a>(residuals, log_residuals, ...)</p></td>
<td><p>Define outliers with two-eyes approach.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.weights_method.weights_method_wls_m_est" title="dipy.reconst.weights_method.weights_method_wls_m_est"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weights_method_wls_m_est</span></code></a>(data, pred_sig, ...)</p></td>
<td><p>Calculate M-estimator weights for WLS model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.weights_method.weights_method_nlls_m_est" title="dipy.reconst.weights_method.weights_method_nlls_m_est"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weights_method_nlls_m_est</span></code></a>(data, pred_sig, ...)</p></td>
<td><p>Calculate M-estimator weights for NLLS model.</p></td>
</tr>
</tbody>
</table>
</div>
<section id="reconstmodel">
<h3><a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#reconstmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.base.ReconstModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.base.</span></span><span class="sig-name descname"><span class="pre">ReconstModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/base.html#ReconstModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.base.ReconstModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>fit</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.base.ReconstModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/base.html#ReconstModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.base.ReconstModel.fit" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="reconstfit">
<h3><a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><a class="headerlink" href="#reconstfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.base.ReconstFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.base.</span></span><span class="sig-name descname"><span class="pre">ReconstFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/base.html#ReconstFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.base.ReconstFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
</dd></dl>

</section>
<section id="binghammetrics">
<h3><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics" title="dipy.reconst.bingham.BinghamMetrics"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinghamMetrics</span></code></a><a class="headerlink" href="#binghammetrics" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.bingham.</span></span><span class="sig-name descname"><span class="pre">BinghamMetrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class for Bingham Metrics.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.amplitude_lobe" title="dipy.reconst.bingham.BinghamMetrics.amplitude_lobe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">amplitude_lobe</span></code></a>()</p></td>
<td><p>Maximum Bingham Amplitude for each ODF lobe.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.fd_lobe" title="dipy.reconst.bingham.BinghamMetrics.fd_lobe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fd_lobe</span></code></a>()</p></td>
<td><p>Fiber Density computed as the integral of the Bingham functions fitted for each ODF lobe.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.fd_voxel" title="dipy.reconst.bingham.BinghamMetrics.fd_voxel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fd_voxel</span></code></a>()</p></td>
<td><p>Voxel fiber density (sum of fd estimates of all ODF lobes).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.fs_lobe" title="dipy.reconst.bingham.BinghamMetrics.fs_lobe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fs_lobe</span></code></a>()</p></td>
<td><p>Fiber spread computed for each ODF lobe.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.fs_voxel" title="dipy.reconst.bingham.BinghamMetrics.fs_voxel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fs_voxel</span></code></a>()</p></td>
<td><p>Voxel fiber spread (weighted average of fiber spread across all lobes where the weights are each lobe's fd estimate).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.kappa1_lobe" title="dipy.reconst.bingham.BinghamMetrics.kappa1_lobe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kappa1_lobe</span></code></a>()</p></td>
<td><p>Concentration parameter k1 for each ODF lobe.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.kappa2_lobe" title="dipy.reconst.bingham.BinghamMetrics.kappa2_lobe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kappa2_lobe</span></code></a>()</p></td>
<td><p>Concentration parameter k2 for each ODF lobe.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.kappa_total_lobe" title="dipy.reconst.bingham.BinghamMetrics.kappa_total_lobe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kappa_total_lobe</span></code></a>()</p></td>
<td><p>Overall concentration parameters for an ODF peak.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.odf" title="dipy.reconst.bingham.BinghamMetrics.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</p></td>
<td><p>Reconstruct ODFs from fitted Bingham parameters on multiple voxels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.odi1_lobe" title="dipy.reconst.bingham.BinghamMetrics.odi1_lobe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odi1_lobe</span></code></a>()</p></td>
<td><p>Orientation Dispersion index 1 computed for each ODF lobe from concentration parameter kappa1.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.odi1_voxel" title="dipy.reconst.bingham.BinghamMetrics.odi1_voxel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odi1_voxel</span></code></a>()</p></td>
<td><p>Voxel Orientation Dispersion Index 1 (weighted average of odi1 across all lobes where the weights are each lobe's fd estimate).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.odi2_lobe" title="dipy.reconst.bingham.BinghamMetrics.odi2_lobe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odi2_lobe</span></code></a>()</p></td>
<td><p>Orientation Dispersion index 2 computed for each ODF lobe from concentration parameter kappa2.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.odi2_voxel" title="dipy.reconst.bingham.BinghamMetrics.odi2_voxel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odi2_voxel</span></code></a>()</p></td>
<td><p>Voxel Orientation Dispersion Index 2 (weighted average of odi2 across all lobes where the weights are each lobe's fd estimate).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.odi_total_lobe" title="dipy.reconst.bingham.BinghamMetrics.odi_total_lobe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odi_total_lobe</span></code></a>()</p></td>
<td><p>Overall Orientation Dispersion Index (ODI) for an ODF lobe.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.bingham.BinghamMetrics.odi_total_voxel" title="dipy.reconst.bingham.BinghamMetrics.odi_total_voxel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odi_total_voxel</span></code></a>()</p></td>
<td><p>Voxel total Orientation Dispersion Index (weighted average of odf_total across all lobes where the weights are each lobe's fd estimate).</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.amplitude_lobe">
<span class="sig-name descname"><span class="pre">amplitude_lobe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.amplitude_lobe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.amplitude_lobe" title="Link to this definition">#</a></dt>
<dd><p>Maximum Bingham Amplitude for each ODF lobe.
Measured in the unit 1/mm^3*rad.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.fd_lobe">
<span class="sig-name descname"><span class="pre">fd_lobe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.fd_lobe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.fd_lobe" title="Link to this definition">#</a></dt>
<dd><p>Fiber Density computed as the integral of the Bingham functions
fitted for each ODF lobe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.fd_voxel">
<span class="sig-name descname"><span class="pre">fd_voxel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.fd_voxel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.fd_voxel" title="Link to this definition">#</a></dt>
<dd><p>Voxel fiber density (sum of fd estimates of all ODF lobes).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.fs_lobe">
<span class="sig-name descname"><span class="pre">fs_lobe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.fs_lobe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.fs_lobe" title="Link to this definition">#</a></dt>
<dd><p>Fiber spread computed for each ODF lobe.</p>
<p class="rubric">Notes</p>
<p>Fiber spread (fs) is defined as fs = fd/f0 and characterizes the
spread of the lobe, i.e. the higher the fs, the wider the lobe
<a class="footnote-reference brackets" href="#footcite-riffert2014" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.fs_voxel">
<span class="sig-name descname"><span class="pre">fs_voxel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.fs_voxel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.fs_voxel" title="Link to this definition">#</a></dt>
<dd><p>Voxel fiber spread (weighted average of fiber spread across all
lobes where the weights are each lobe’s fd estimate).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.kappa1_lobe">
<span class="sig-name descname"><span class="pre">kappa1_lobe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.kappa1_lobe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.kappa1_lobe" title="Link to this definition">#</a></dt>
<dd><p>Concentration parameter k1 for each ODF lobe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.kappa2_lobe">
<span class="sig-name descname"><span class="pre">kappa2_lobe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.kappa2_lobe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.kappa2_lobe" title="Link to this definition">#</a></dt>
<dd><p>Concentration parameter k2 for each ODF lobe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.kappa_total_lobe">
<span class="sig-name descname"><span class="pre">kappa_total_lobe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.kappa_total_lobe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.kappa_total_lobe" title="Link to this definition">#</a></dt>
<dd><p>Overall concentration parameters for an ODF peak.</p>
<p>The overall (combined) concentration parameters for each lobe is
defined by equation 19 in <a class="footnote-reference brackets" href="#footcite-tariq2016" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a> as</p>
<div class="math notranslate nohighlight">
\[k_{total} = sqrt{(k_1 * k_2)}\]</div>
<p class="rubric">References</p>
<div class="docutils container" id="id20">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-tariq2016" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id19">1</a>,<a role="doc-backlink" href="#id21">2</a>)</span>
<p>Maira Tariq, Torben Schneider, Daniel C. Alexander, Claudia A. Gandini Wheeler-Kingshott, and Hui Zhang. Bingham-Noddi: Mapping anisotropic orientation dispersion of neurites using diffusion MRI. <em>NeuroImage</em>, 133:207–223, 2016. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.01.046">https://doi.org/10.1016/j.neuroimage.2016.01.046</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.01.046">doi:10.1016/j.neuroimage.2016.01.046</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.odf" title="Link to this definition">#</a></dt>
<dd><p>Reconstruct ODFs from fitted Bingham parameters on multiple voxels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere: `Sphere` class instance</strong></dt><dd><p>The Sphere providing the discrete directions for ODF
reconstruction.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ODF</strong><span class="classifier">ndarray (…, n_directions)</span></dt><dd><p>The value of the odf on each point of <cite>sphere</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.odi1_lobe">
<span class="sig-name descname"><span class="pre">odi1_lobe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.odi1_lobe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.odi1_lobe" title="Link to this definition">#</a></dt>
<dd><p>Orientation Dispersion index 1 computed for each ODF lobe from
concentration parameter kappa1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.odi1_voxel">
<span class="sig-name descname"><span class="pre">odi1_voxel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.odi1_voxel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.odi1_voxel" title="Link to this definition">#</a></dt>
<dd><p>Voxel Orientation Dispersion Index 1 (weighted average of odi1
across all lobes where the weights are each lobe’s fd estimate).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.odi2_lobe">
<span class="sig-name descname"><span class="pre">odi2_lobe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.odi2_lobe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.odi2_lobe" title="Link to this definition">#</a></dt>
<dd><p>Orientation Dispersion index 2 computed for each ODF lobe from
concentration parameter kappa2.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.odi2_voxel">
<span class="sig-name descname"><span class="pre">odi2_voxel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.odi2_voxel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.odi2_voxel" title="Link to this definition">#</a></dt>
<dd><p>Voxel Orientation Dispersion Index 2 (weighted average of odi2
across all lobes where the weights are each lobe’s fd estimate).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.odi_total_lobe">
<span class="sig-name descname"><span class="pre">odi_total_lobe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.odi_total_lobe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.odi_total_lobe" title="Link to this definition">#</a></dt>
<dd><p>Overall Orientation Dispersion Index (ODI) for an ODF lobe.</p>
<p>Overall Orientation Dispersion Index (ODI) computed for an
ODF lobe from the overall concentration parameter (k_total).
Defined by equation 20 in <a class="footnote-reference brackets" href="#footcite-tariq2016" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.bingham.BinghamMetrics.odi_total_voxel">
<span class="sig-name descname"><span class="pre">odi_total_voxel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#BinghamMetrics.odi_total_voxel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.BinghamMetrics.odi_total_voxel" title="Link to this definition">#</a></dt>
<dd><p>Voxel total Orientation Dispersion Index (weighted average of
odf_total across all lobes where the weights are each lobe’s
fd estimate).</p>
</dd></dl>

</dd></dl>

</section>
<section id="bingham-to-sf">
<h3>bingham_to_sf<a class="headerlink" href="#bingham-to-sf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.bingham.bingham_to_sf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.bingham.</span></span><span class="sig-name descname"><span class="pre">bingham_to_sf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bingham_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#bingham_to_sf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.bingham_to_sf" title="Link to this definition">#</a></dt>
<dd><p>Reconstruct ODFs from fitted Bingham parameters on multiple voxels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bingham_params</strong><span class="classifier">ndarray (…., nl, 12)</span></dt><dd><p>ndarray containing the model parameters of Binghams fitted to ODFs in
the following order:
- Maximum value of the Bingham function (f0, index 0);
- concentration parameters k1 and k2 (indexes 1 and 2);
- elements of Bingham’s main direction (indexes 3-5);
- elements of Bingham’s dispersion major axis (indexes 6-8);
- elements of Bingham’s dispersion minor axis (indexes 9-11).</p>
</dd>
<dt><strong>sphere: `Sphere` class instance</strong></dt><dd><p>The Sphere providing the odf’s discrete directions</p>
</dd>
<dt><strong>mask: ndarray, optional</strong></dt><dd><p>Map marking the coordinates in the data that should be analyzed.
Default (None) means all voxels in the volume will be analyzed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ODF</strong><span class="classifier">ndarray (…, n_directions)</span></dt><dd><p>The value of the odf on each point of <cite>sphere</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="bingham-fiber-density">
<h3>bingham_fiber_density<a class="headerlink" href="#bingham-fiber-density" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.bingham.bingham_fiber_density">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.bingham.</span></span><span class="sig-name descname"><span class="pre">bingham_fiber_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bingham_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdivide</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#bingham_fiber_density"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.bingham_fiber_density" title="Link to this definition">#</a></dt>
<dd><p>Compute fiber density for each lobe for a given Bingham ODF.
Measured in the unit 1/mm^3.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bingham_params</strong><span class="classifier">ndarray (…., nl, 12)</span></dt><dd><p>ndarray containing the model parameters of Bingham’s fitted to ODFs in
the following order:
- Maximum value of the Bingham function (f0, index 0);
- Concentration parameters k1 and k2 (indexes 1 and 2);
- Elements of Bingham’s main direction (indexes 3-5);
- Elements of Bingham’s dispersion major axis (indexes 6-8);
- Elements of Bingham’s dispersion minor axis (indexes 9-11).</p>
</dd>
<dt><strong>subdivide: int &gt;= 0, optional</strong></dt><dd><p>Number of times the unit icosahedron used for integration
should be subdivided. The higher this value the more precise the
approximation will be, at the cost of longer execution times. The
default results in a sphere of 10242 points.</p>
</dd>
<dt><strong>mask: ndarray, optional</strong></dt><dd><p>Map marking the coordinates in the data that should be analyzed.
Default (None) means all voxels in the volume will be analyzed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>fd: ndarray (…., nl)</dt><dd><p>Fiber density for each Bingham function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Fiber density (fd) is given by the surface integral of the
Bingham function <a class="footnote-reference brackets" href="#footcite-riffert2014" id="id22" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="bingham-fiber-spread">
<h3>bingham_fiber_spread<a class="headerlink" href="#bingham-fiber-spread" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.bingham.bingham_fiber_spread">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.bingham.</span></span><span class="sig-name descname"><span class="pre">bingham_fiber_spread</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#bingham_fiber_spread"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.bingham_fiber_spread" title="Link to this definition">#</a></dt>
<dd><p>Compute fiber spread for each lobe for a given Bingham volume.
Measured in radians.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f0: ndarray</strong></dt><dd><p>Peak amplitude (f0) of each Bingham function.</p>
</dd>
<dt><strong>fd: ndarray</strong></dt><dd><p>Fiber density (fd) of each Bingham function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>fs: list of floats</dt><dd><p>Fiber spread (fs) of each each Bingham function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Fiber spread (fs) is defined as fs = fd/f0 and characterizes the spread of
the lobe, i.e. the higher the fs, the wider the lobe <a class="footnote-reference brackets" href="#footcite-riffert2014" id="id23" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="k2odi">
<h3>k2odi<a class="headerlink" href="#k2odi" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.bingham.k2odi">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.bingham.</span></span><span class="sig-name descname"><span class="pre">k2odi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#k2odi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.k2odi" title="Link to this definition">#</a></dt>
<dd><p>Convert the Bingham/Watson concentration parameter k to the orientation
dispersion index (ODI).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: ndarray</strong></dt><dd><p>Watson/Bingham concentration parameter</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ODI: float or ndarray</dt><dd><p>Orientation Dispersion Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Orientation Dispersion Index for Watson/Bingham functions are defined as
<a class="footnote-reference brackets" href="#footcite-netohenriques2018" id="id24" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-zhang2012" id="id25" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[ODI = \frac{2}{pi} \arctan{( \frac{1}{k})}\]</div>
<p class="rubric">References</p>
<div class="docutils container" id="id26">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-zhang2012" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id25">1</a>,<a role="doc-backlink" href="#id28">2</a>)</span>
<p>Hui Zhang, Torben Schneider, Claudia A. Wheeler-Kingshott, and Daniel C. Alexander. Noddi: practical in vivo neurite orientation dispersion and density imaging of the human brain. <em>NeuroImage</em>, 61(4):1000–1016, 2012. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2012.03.072">https://doi.org/10.1016/j.neuroimage.2012.03.072</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2012.03.072">doi:10.1016/j.neuroimage.2012.03.072</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="odi2k">
<h3>odi2k<a class="headerlink" href="#odi2k" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.bingham.odi2k">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.bingham.</span></span><span class="sig-name descname"><span class="pre">odi2k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#odi2k"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.odi2k" title="Link to this definition">#</a></dt>
<dd><p>Convert the orientation dispersion index (ODI) to the Bingham/Watson
concentration parameter k.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ODI: ndarray</strong></dt><dd><p>Orientation Dispersion Index</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>k: float or ndarray</dt><dd><p>Watson/Bingham concentration parameter</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Orientation Dispersion Index for Watson/Bingham functions are defined as
<a class="footnote-reference brackets" href="#footcite-netohenriques2018" id="id27" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-zhang2012" id="id28" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[ODI = \frac{2}{pi} \arctan ( \frac{1}{k} )\]</div>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="weighted-voxel-metric">
<h3>weighted_voxel_metric<a class="headerlink" href="#weighted-voxel-metric" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.bingham.weighted_voxel_metric">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.bingham.</span></span><span class="sig-name descname"><span class="pre">weighted_voxel_metric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bmetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bfd</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#weighted_voxel_metric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.weighted_voxel_metric" title="Link to this definition">#</a></dt>
<dd><p>Compute density-weighted scalar maps for metrics of Bingham functions
fitted to multiple ODF lobes. The metric is computed as the
weighted average of a given metric across the multiple ODF lobes
(weights are defined by the Bingham fiber density estimates).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bmetric: ndarray(…, nl)</strong></dt><dd><p>Any metric with values for nl ODF lobes.</p>
</dd>
<dt><strong>bfd: ndarray(…, nl)</strong></dt><dd><p>Bingham’s fiber density estimates for the nl ODF lobes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>wmetric: ndarray(…)</dt><dd><p>Weight-averaged Bingham metric</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="sf-to-bingham">
<h3>sf_to_bingham<a class="headerlink" href="#sf-to-bingham" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.bingham.sf_to_bingham">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.bingham.</span></span><span class="sig-name descname"><span class="pre">sf_to_bingham</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_search_angle</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npeaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_sep_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rel_th</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#sf_to_bingham"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.sf_to_bingham" title="Link to this definition">#</a></dt>
<dd><p>Fit the Bingham function from an image volume of ODFs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>odf: ndarray (Nx, Ny, Nz, Ndirs)</strong></dt><dd><p>Orientation Distribution Function sampled on the vertices of a sphere.</p>
</dd>
<dt><strong>sphere: `Sphere` class instance</strong></dt><dd><p>The Sphere providing the odf’s discrete directions.</p>
</dd>
<dt><strong>max_search_angle: float.</strong></dt><dd><p>Maximum angle between a peak and its neighbour directions
for fitting the Bingham distribution.</p>
</dd>
<dt><strong>mask: ndarray, optional</strong></dt><dd><p>Map marking the coordinates in the data that should be analyzed.</p>
</dd>
<dt><strong>npeak: int, optional</strong></dt><dd><p>Maximum number of peaks found.</p>
</dd>
<dt><strong>min_sep_angle: float, optional</strong></dt><dd><p>Minimum separation angle between two peaks for peak extraction.</p>
</dd>
<dt><strong>rel_th: float, optional</strong></dt><dd><p>Relative threshold used for peak extraction.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>BinghamMetrics: class instance</dt><dd><p>Class instance containing metrics computed from Bingham functions
fitted to ODF lobes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="sh-to-bingham">
<h3>sh_to_bingham<a class="headerlink" href="#sh-to-bingham" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.bingham.sh_to_bingham">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.bingham.</span></span><span class="sig-name descname"><span class="pre">sh_to_bingham</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_search_angle</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'descoteaux07'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npeaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_sep_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rel_th</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/bingham.html#sh_to_bingham"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.bingham.sh_to_bingham" title="Link to this definition">#</a></dt>
<dd><p>Fit the Bingham function from an image volume of spherical harmonics (SH)
representing ODFs.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>sh</strong><span class="classifier">ndarray</span></dt><dd><p>SH coefficients representing a spherical function.</p>
</dd>
<dt><strong>sphere</strong><span class="classifier"><cite>Sphere</cite> class instance</span></dt><dd><p>The Sphere providing the odf’s discrete directions.</p>
</dd>
<dt><strong>max_search_angle: float.</strong></dt><dd><p>Maximum angle between a peak and its neighbour directions
for fitting the Bingham distribution.</p>
</dd>
<dt><strong>mask: ndarray, optional</strong></dt><dd><p>Map marking the coordinates in the data that should be analyzed.</p>
</dd>
<dt><strong>sh_basis: str, optional</strong></dt><dd><p>SH basis. Either <cite>descoteaux07</cite> or <cite>tournier07</cite>.</p>
</dd>
<dt><strong>legacy: bool, optional</strong></dt><dd><p>Use legacy SH basis definitions.</p>
</dd>
<dt><strong>npeak: int, optional</strong></dt><dd><p>Maximum number of peaks found.</p>
</dd>
<dt><strong>min_sep_angle: float, optional</strong></dt><dd><p>Minimum separation angle between two peaks for peak extraction.</p>
</dd>
<dt><strong>rel_th: float, optional</strong></dt><dd><p>Relative threshold used for peak extraction.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>BinghamMetrics: class instance</dt><dd><p>Class instance containing metrics computed from Bingham functions
fitted to ODF lobes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="cache">
<h3><a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#cache" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.cache.Cache">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.cache.</span></span><span class="sig-name descname"><span class="pre">Cache</span></span><a class="reference internal" href="../_modules/dipy/reconst/cache.html#Cache"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cache.Cache" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cache.Cache.cache_clear" title="dipy.reconst.cache.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cache.Cache.cache_get" title="dipy.reconst.cache.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cache.Cache.cache_set" title="dipy.reconst.cache.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cache.Cache.cache_clear">
<span class="sig-name descname"><span class="pre">cache_clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cache.html#Cache.cache_clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_clear" title="Link to this definition">#</a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cache.Cache.cache_get">
<span class="sig-name descname"><span class="pre">cache_get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cache.html#Cache.cache_get"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_get" title="Link to this definition">#</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tag</strong><span class="classifier">str</span></dt><dd><p>Description of the cached value.</p>
</dd>
<dt><strong>key</strong><span class="classifier">object</span></dt><dd><p>Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong><span class="classifier">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>v</strong><span class="classifier">object</span></dt><dd><p>Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cache.Cache.cache_set">
<span class="sig-name descname"><span class="pre">cache_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cache.html#Cache.cache_set"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_set" title="Link to this definition">#</a></dt>
<dd><p>Store a value in the cache.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tag</strong><span class="classifier">str</span></dt><dd><p>Description of the cached value.</p>
</dd>
<dt><strong>key</strong><span class="classifier">object</span></dt><dd><p>Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong><span class="classifier">object</span></dt><dd><p>Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="coeff-of-determination">
<h3>coeff_of_determination<a class="headerlink" href="#coeff-of-determination" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cross_validation.coeff_of_determination">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cross_validation.</span></span><span class="sig-name descname"><span class="pre">coeff_of_determination</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cross_validation.html#coeff_of_determination"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cross_validation.coeff_of_determination" title="Link to this definition">#</a></dt>
<dd><p>Calculate the coefficient of determination for a model prediction,
relative to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>The data</p>
</dd>
<dt><strong>model</strong><span class="classifier">ndarray</span></dt><dd><p>The predictions of a model for this data. Same shape as the data.</p>
</dd>
<dt><strong>axis: int, optional</strong></dt><dd><p>The axis along which different samples are laid out.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>COD</strong><span class="classifier">ndarray</span></dt><dd><p>The coefficient of determination. This has shape <cite>data.shape[:-1]</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Coefficient_of_determination">https://en.wikipedia.org/wiki/Coefficient_of_determination</a></p>
<p>The coefficient of determination is calculated as:</p>
<div class="math notranslate nohighlight">
\[R^2 = 100 * (1 - \frac{SSE}{SSD})\]</div>
<p>where SSE is the sum of the squared error between the model and the data
(sum of the squared residuals) and SSD is the sum of the squares of the
deviations of the data from the mean of the data (variance * N).</p>
</dd></dl>

</section>
<section id="kfold-xval">
<h3>kfold_xval<a class="headerlink" href="#kfold-xval" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cross_validation.kfold_xval">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cross_validation.</span></span><span class="sig-name descname"><span class="pre">kfold_xval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">folds</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">model_args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">model_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cross_validation.html#kfold_xval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cross_validation.kfold_xval" title="Link to this definition">#</a></dt>
<dd><p>Perform k-fold cross-validation.</p>
<p>It generates out-of-sample predictions for each measurement.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-rokem2014" id="id29" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model</strong><span class="classifier">Model class instance</span></dt><dd><p>The type of the model to use for prediction. The corresponding Fit
object must have a <cite>predict</cite> function implemented One of the following:
<cite>reconst.dti.TensorModel</cite> or
<cite>reconst.csdeconv.ConstrainedSphericalDeconvModel</cite>.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>Diffusion MRI data acquired with the GradientTable of the model. Shape
will typically be <cite>(x, y, z, b)</cite> where <cite>xyz</cite> are spatial dimensions and
b is the number of bvals/bvecs in the GradientTable.</p>
</dd>
<dt><strong>folds</strong><span class="classifier">int</span></dt><dd><p>The number of divisions to apply to the data</p>
</dd>
<dt><strong>model_args</strong><span class="classifier">list</span></dt><dd><p>Additional arguments to the model initialization</p>
</dd>
<dt><strong>model_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional key-word arguments to the model initialization. If contains
the kwarg <cite>mask</cite>, this will be used as a key-word argument to the <cite>fit</cite>
method of the model object, rather than being used in the
initialization of the model object</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function assumes that a prediction API is implemented in the Model
class for which prediction is conducted. That is, the Fit object that gets
generated upon fitting the model needs to have a <cite>predict</cite> method, which
receives a GradientTable class instance as input and produces a predicted
signal as output.</p>
<p>It also assumes that the model object has <cite>bval</cite> and <cite>bvec</cite> attributes
holding b-values and corresponding unit vectors.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="axsymshresponse">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse" title="dipy.reconst.csdeconv.AxSymShResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a><a class="headerlink" href="#axsymshresponse" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.AxSymShResponse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">AxSymShResponse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dwi_response</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#AxSymShResponse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A simple wrapper for response functions represented using only axially
symmetric, even spherical harmonic functions (ie, m == 0 and l is even).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>Signal with no diffusion weighting.</p>
</dd>
<dt><strong>dwi_response</strong><span class="classifier">array</span></dt><dd><p>Response function signal as coefficients to axially symmetric, even
spherical harmonic.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse.basis" title="dipy.reconst.csdeconv.AxSymShResponse.basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">basis</span></code></a>(sphere)</p></td>
<td><p>A basis that maps the response coefficients onto a sphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse.on_sphere" title="dipy.reconst.csdeconv.AxSymShResponse.on_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">on_sphere</span></code></a>(sphere)</p></td>
<td><p>Evaluates the response function on sphere.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.AxSymShResponse.basis">
<span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#AxSymShResponse.basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.basis" title="Link to this definition">#</a></dt>
<dd><p>A basis that maps the response coefficients onto a sphere.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.AxSymShResponse.on_sphere">
<span class="sig-name descname"><span class="pre">on_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#AxSymShResponse.on_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.on_sphere" title="Link to this definition">#</a></dt>
<dd><p>Evaluates the response function on sphere.</p>
</dd></dl>

</dd></dl>

</section>
<section id="constrainedsphericaldeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a><a class="headerlink" href="#constrainedsphericaldeconvmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">ConstrainedSphericalDeconvModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#ConstrainedSphericalDeconvModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(sh_coeff, *[, gtab, S0])</p></td>
<td><p>Compute a signal prediction given spherical harmonic coefficients for the provided GradientTable class instance.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</p></td>
<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeff</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#ConstrainedSphericalDeconvModel.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict" title="Link to this definition">#</a></dt>
<dd><p>Compute a signal prediction given spherical harmonic coefficients
for the provided GradientTable class instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_coeff</strong><span class="classifier">ndarray</span></dt><dd><p>The spherical harmonic representation of the FOD from which to make
the signal prediction.</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>The gradients for which the signal will be predicted. Uses the
model’s gradient table by default.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">ndarray or float</span></dt><dd><p>The non diffusion-weighted signal value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pred_sig</strong><span class="classifier">ndarray</span></dt><dd><p>The predicted signal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="constrainedsdtmodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="dipy.reconst.csdeconv.ConstrainedSDTModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a><a class="headerlink" href="#constrainedsdtmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSDTModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">ConstrainedSDTModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#ConstrainedSDTModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.fit" title="dipy.reconst.csdeconv.ConstrainedSDTModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</p></td>
<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSDTModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="estimate-response">
<h3>estimate_response<a class="headerlink" href="#estimate-response" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.estimate_response">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">estimate_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#estimate_response"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.estimate_response" title="Link to this definition">#</a></dt>
<dd><p>Estimate single fiber response function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>evals</strong><span class="classifier">ndarray</span></dt><dd><p>Eigenvalues.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>non diffusion weighted</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">estimated signal</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="forward-sdt-deconv-mat">
<h3>forward_sdt_deconv_mat<a class="headerlink" href="#forward-sdt-deconv-mat" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.forward_sdt_deconv_mat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">forward_sdt_deconv_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ratio</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_values</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r2_term</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#forward_sdt_deconv_mat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat" title="Link to this definition">#</a></dt>
<dd><p>Build forward sharpening deconvolution transform (SDT) matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ratio</strong><span class="classifier">float</span></dt><dd><p>ratio = <span class="math notranslate nohighlight">\(\frac{\lambda_2}{\lambda_1}\)</span> of the single fiber response
function</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">ndarray (N,)</span></dt><dd><p>The order (<span class="math notranslate nohighlight">\(l\)</span>) of spherical harmonic function associated with each row
of the deconvolution matrix. Only even orders are allowed.</p>
</dd>
<dt><strong>r2_term</strong><span class="classifier">bool</span></dt><dd><p>True if ODF comes from an ODF computed from a model using the <span class="math notranslate nohighlight">\(r^2\)</span>
term in the integral. For example, DSI, GQI, SHORE, CSA, Tensor,
Multi-tensor ODFs. This results in using the proper analytical response
function solution solving from the single-fiber ODF with the r^2 term.
This derivation is not published anywhere but is very similar to
<a class="footnote-reference brackets" href="#footcite-descoteaux2008b" id="id30" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">ndarray (N, N)</span></dt><dd><p>SDT deconvolution matrix</p>
</dd>
<dt><strong>P</strong><span class="classifier">ndarray (N, N)</span></dt><dd><p>Funk-Radon Transform (FRT) matrix</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id31">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-descoteaux2008b" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id30">1</a>,<a role="doc-backlink" href="#id38">2</a>,<a role="doc-backlink" href="#id174">3</a>)</span>
<p>Maxime Descoteaux. <em>High Angular Resolution Diffusion MRI: from Local Estimation to Segmentation and Tractography</em>. PhD thesis, Université Nice Sophia Antipolis, Valbonne, France, 2007. URL: <a class="reference external" href="https://theses.hal.science/tel-00457458">https://theses.hal.science/tel-00457458</a>, <a class="reference external" href="https://doi.org/">doi:</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="csdeconv">
<h3>csdeconv<a class="headerlink" href="#csdeconv" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.csdeconv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">csdeconv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dwsignal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_reg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#csdeconv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.csdeconv" title="Link to this definition">#</a></dt>
<dd><p>Constrained-regularized spherical deconvolution (CSD).</p>
<p>Deconvolves the axially symmetric single fiber response function <cite>r_rh</cite> in
rotational harmonics coefficients from the diffusion weighted signal in
<cite>dwsignal</cite> <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id32" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dwsignal</strong><span class="classifier">array</span></dt><dd><p>Diffusion weighted signals to be deconvolved.</p>
</dd>
<dt><strong>X</strong><span class="classifier">array</span></dt><dd><p>Prediction matrix which estimates diffusion weighted signals from FOD
coefficients.</p>
</dd>
<dt><strong>B_reg</strong><span class="classifier">array (N, B)</span></dt><dd><p>SH basis matrix which maps FOD coefficients to FOD values on the
surface of the sphere. B_reg should be scaled to account for lambda.</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>Threshold controlling the amplitude below which the corresponding fODF
is assumed to be zero.  Ideally, tau should be set to zero. However, to
improve the stability of the algorithm, tau is set to tau*100 % of the
max fODF amplitude (here, 10% by default). This is similar to peak
detection where peaks below 0.1 amplitude are usually considered noise
peaks. Because SDT is based on a q-ball ODF deconvolution, and not
signal deconvolution, using the max instead of mean (as in CSD), is
more stable.</p>
</dd>
<dt><strong>convergence</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations to allow the deconvolution to converge.</p>
</dd>
<dt><strong>P</strong><span class="classifier">ndarray</span></dt><dd><p>This is an optimization to avoid computing <code class="docutils literal notranslate"><span class="pre">dot(X.T,</span> <span class="pre">X)</span></code> many times.
If the same <code class="docutils literal notranslate"><span class="pre">X</span></code> is used many times, <code class="docutils literal notranslate"><span class="pre">P</span></code> can be precomputed and
passed to this function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>fodf_sh</strong><span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)*(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt><dd><p>Spherical harmonics coefficients of the constrained-regularized fiber
ODF.</p>
</dd>
<dt><strong>_num_it</strong><span class="classifier">int</span></dt><dd><p>Number of iterations in the constrained-regularization used for
convergence.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This section describes how the fitting of the SH coefficients is done.
Problem is to minimise per iteration:</p>
<p><span class="math notranslate nohighlight">\(F(f_n) = ||Xf_n - S||^2 + \lambda^2 ||H_{n-1} f_n||^2\)</span></p>
<p>Where <span class="math notranslate nohighlight">\(X\)</span> maps current FOD SH coefficients <span class="math notranslate nohighlight">\(f_n\)</span> to DW signals <span class="math notranslate nohighlight">\(s\)</span> and
<span class="math notranslate nohighlight">\(H_{n-1}\)</span> maps FOD SH coefficients <span class="math notranslate nohighlight">\(f_n\)</span> to amplitudes along set of
negative directions identified in previous iteration, i.e. the matrix
formed by the rows of <span class="math notranslate nohighlight">\(B_{reg}\)</span> for which <span class="math notranslate nohighlight">\(Hf_{n-1}&lt;0\)</span> where <span class="math notranslate nohighlight">\(B_{reg}\)</span>
maps <span class="math notranslate nohighlight">\(f_n\)</span> to FOD amplitude on a sphere.</p>
<p>Solve by differentiating and setting to zero:</p>
<p><span class="math notranslate nohighlight">\(\Rightarrow \frac{\delta F}{\delta f_n} = 2X^T(Xf_n - S) + 2 \lambda^2
H_{n-1}^TH_{n-1}f_n=0\)</span></p>
<p>Or:</p>
<p><span class="math notranslate nohighlight">\((X^TX + \lambda^2 H_{n-1}^TH_{n-1})f_n = X^Ts\)</span></p>
<p>Define <span class="math notranslate nohighlight">\(Q = X^TX + \lambda^2 H_{n-1}^TH_{n-1}\)</span> , which by construction is a
square positive definite symmetric matrix of size <span class="math notranslate nohighlight">\(n_{SH} by n_{SH}\)</span>. If
needed, positive definiteness can be enforced with a small minimum norm
regulariser (helps a lot with poorly conditioned direction sets and/or
superresolution):</p>
<p><span class="math notranslate nohighlight">\(Q = X^TX + (\lambda H_{n-1}^T) (\lambda H_{n-1}) + \mu I\)</span></p>
<p>Solve <span class="math notranslate nohighlight">\(Qf_n = X^Ts\)</span> using Cholesky decomposition:</p>
<p><span class="math notranslate nohighlight">\(Q = LL^T\)</span></p>
<p>where <span class="math notranslate nohighlight">\(L\)</span> is lower triangular. Then problem can be solved by
back-substitution:</p>
<p><span class="math notranslate nohighlight">\(L_y = X^Ts\)</span></p>
<p><span class="math notranslate nohighlight">\(L^Tf_n = y\)</span></p>
<p>To speeds things up further, form <span class="math notranslate nohighlight">\(P = X^TX + \mu I\)</span>, and update to form
<span class="math notranslate nohighlight">\(Q\)</span> by rankn update with <span class="math notranslate nohighlight">\(H_{n-1}\)</span>. The dipy implementation looks like:</p>
<blockquote>
<div><p>form initially <span class="math notranslate nohighlight">\(P = X^T X + \mu I\)</span> and <span class="math notranslate nohighlight">\(\lambda B_{reg}\)</span></p>
<p>for each voxel: form <span class="math notranslate nohighlight">\(z = X^Ts\)</span></p>
<blockquote>
<div><p>estimate <span class="math notranslate nohighlight">\(f_0\)</span> by solving <span class="math notranslate nohighlight">\(Pf_0=z\)</span>. We use a simplified <span class="math notranslate nohighlight">\(l_{max}=4\)</span>
solution here, but it might not make a big difference.</p>
<p>Then iterate until no change in rows of <span class="math notranslate nohighlight">\(H\)</span> used in <span class="math notranslate nohighlight">\(H_n\)</span></p>
<blockquote>
<div><p>form <span class="math notranslate nohighlight">\(H_{n}\)</span> given <span class="math notranslate nohighlight">\(f_{n-1}\)</span></p>
<p>form <span class="math notranslate nohighlight">\(Q = P + (\lambda H_{n-1}^T) (\lambda H_{n-1}\)</span>) (this can
be done by rankn update, but we currently do not use rankn
update).</p>
<p>solve <span class="math notranslate nohighlight">\(Qf_n = z\)</span> using Cholesky decomposition</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>We would like to thank Donald Tournier for his help with describing and
implementing this algorithm.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id33">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-tournier2007" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id32">1</a>,<a role="doc-backlink" href="#id41">2</a>,<a role="doc-backlink" href="#id365">3</a>,<a role="doc-backlink" href="#id366">4</a>,<a role="doc-backlink" href="#id370">5</a>,<a role="doc-backlink" href="#id373">6</a>,<a role="doc-backlink" href="#id374">7</a>,<a role="doc-backlink" href="#id381">8</a>,<a role="doc-backlink" href="#id384">9</a>,<a role="doc-backlink" href="#id387">10</a>,<a role="doc-backlink" href="#id393">11</a>,<a role="doc-backlink" href="#id395">12</a>,<a role="doc-backlink" href="#id399">13</a>,<a role="doc-backlink" href="#id401">14</a>)</span>
<p>Jacques-Donald Tournier, Fernando Calamante, and Alan Connelly. Robust determination of the fibre orientation distribution in diffusion MRI: Non-negativity constrained super-resolved spherical deconvolution. <em>NeuroImage</em>, 35(4):1459–1472, May 2007. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2012.06.005">https://doi.org/10.1016/j.neuroimage.2012.06.005</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2007.02.016">doi:10.1016/j.neuroimage.2007.02.016</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="odf-deconv">
<h3>odf_deconv<a class="headerlink" href="#odf-deconv" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.odf_deconv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">odf_deconv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odf_sh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_reg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r2_term</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#odf_deconv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.odf_deconv" title="Link to this definition">#</a></dt>
<dd><p>ODF constrained-regularized spherical deconvolution using
the Sharpening Deconvolution Transform (SDT).</p>
<p>See <a class="footnote-reference brackets" href="#footcite-tuch2004" id="id34" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-descoteaux2009" id="id35" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a> for further
details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>odf_sh</strong><span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)*(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt><dd><p>ndarray of SH coefficients for the ODF spherical function to be
deconvolved</p>
</dd>
<dt><strong>R</strong><span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>)
SDT matrix in SH basis</p>
</dd>
<dt><strong>B_reg</strong><span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>)
SH basis matrix used for deconvolution</p>
</dd>
<dt><strong>lambda_</strong><span class="classifier">float, optional</span></dt><dd><p>lambda parameter in minimization equation</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float, optional</span></dt><dd><p>threshold (<code class="docutils literal notranslate"><span class="pre">tau</span> <span class="pre">*max(fODF)</span></code>) controlling the amplitude below
which the corresponding fODF is assumed to be zero.</p>
</dd>
<dt><strong>r2_term</strong><span class="classifier">bool, optional</span></dt><dd><p>True if ODF is computed from model that uses the <span class="math notranslate nohighlight">\(r^2\)</span> term in the
integral.  Recall that Tuch’s ODF (used in Q-ball Imaging
<a class="footnote-reference brackets" href="#footcite-tuch2004" id="id36" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a>) and the true normalized ODF definition differ
from a <span class="math notranslate nohighlight">\(r^2\)</span> term in the ODF integral. The original Sharpening
Deconvolution Transform (SDT) technique <a class="footnote-reference brackets" href="#footcite-descoteaux2009" id="id37" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a>
is expecting Tuch’s ODF without the <span class="math notranslate nohighlight">\(r^2\)</span> (see
<a class="footnote-reference brackets" href="#footcite-descoteaux2008b" id="id38" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a> for the mathematical details). Now, this
function supports ODF that have been computed using the <span class="math notranslate nohighlight">\(r^2\)</span> term
because the proper analytical response function has be derived. For
example, models such as DSI, GQI, SHORE, CSA, Tensor, Multi-tensor ODFs,
should now be deconvolved with the r2_term=True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>fodf_sh</strong><span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt><dd><p>Spherical harmonics coefficients of the constrained-regularized fiber
ODF</p>
</dd>
<dt><strong>num_it</strong><span class="classifier">int</span></dt><dd><p>Number of iterations in the constrained-regularization used for
convergence</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id39">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-tuch2004" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id34">1</a>,<a role="doc-backlink" href="#id36">2</a>,<a role="doc-backlink" href="#id43">3</a>)</span>
<p>David S. Tuch. Q-ball imaging. <em>Magnetic Resonance in Medicine</em>, 52(6):1358–1372, 2004. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.20279">https://doi.org/10.1002/mrm.20279</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.20279">doi:10.1002/mrm.20279</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-descoteaux2009" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id35">1</a>,<a role="doc-backlink" href="#id37">2</a>,<a role="doc-backlink" href="#id40">3</a>,<a role="doc-backlink" href="#id44">4</a>)</span>
<p>Maxime Descoteaux, Rachid Deriche, Thomas R. Knösche, and Alfred Anwander. Deterministic and Probabilistic Tractography Based on Complex Fibre Orientation Distributions. <em>IEEE Transactions on Medical Imaging</em>, 28(2):269–286, February 2009. URL: <a class="reference external" href="https://doi.org/10.1109/TMI.2008.2004424">https://doi.org/10.1109/TMI.2008.2004424</a>, <a class="reference external" href="https://doi.org/10.1109/TMI.2008.2004424">doi:10.1109/TMI.2008.2004424</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="odf-sh-to-sharp">
<h3>odf_sh_to_sharp<a class="headerlink" href="#odf-sh-to-sharp" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.odf_sh_to_sharp">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">odf_sh_to_sharp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odfs_sh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r2_term</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#odf_sh_to_sharp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.odf_sh_to_sharp" title="Link to this definition">#</a></dt>
<dd><p>Sharpen odfs using the sharpening deconvolution transform.</p>
<p>This function can be used to sharpen any smooth ODF spherical function. In
theory, this should only be used to sharpen QballModel ODFs, but in
practice, one can play with the deconvolution ratio and sharpen almost any
ODF-like spherical function. The constrained-regularization is stable and
will not only sharpen the ODF peaks but also regularize the noisy peaks.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-descoteaux2009" id="id40" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>odfs_sh</strong><span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)*(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>, )</span></dt><dd><p>array of odfs expressed as spherical harmonics coefficients</p>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>sphere used to build the regularization matrix</p>
</dd>
<dt><strong>basis</strong><span class="classifier">{None, ‘tournier07’, ‘descoteaux07’}, optional</span></dt><dd><p>different spherical harmonic basis:
<code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id41" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> basis,
and <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007
<a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id42" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> basis (<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>ratio</strong><span class="classifier">float, optional</span></dt><dd><p>ratio of the smallest vs the largest eigenvalue of the single prolate
tensor response function (<span class="math notranslate nohighlight">\(\frac{\lambda_2}{\lambda_1}\)</span>)</p>
</dd>
<dt><strong>sh_order_max</strong><span class="classifier">int, optional</span></dt><dd><p>maximal SH order (<span class="math notranslate nohighlight">\(l\)</span>) of the SH representation</p>
</dd>
<dt><strong>lambda_</strong><span class="classifier">float, optional</span></dt><dd><p>lambda parameter (see odfdeconv)</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float, optional</span></dt><dd><p>tau parameter in the L matrix construction (see odfdeconv)</p>
</dd>
<dt><strong>r2_term</strong><span class="classifier">bool, optional</span></dt><dd><p>True if ODF is computed from model that uses the <span class="math notranslate nohighlight">\(r^2\)</span> term in the
integral.  Recall that Tuch’s ODF (used in Q-ball Imaging
<a class="footnote-reference brackets" href="#footcite-tuch2004" id="id43" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a>) and the true normalized ODF definition differ
from a <span class="math notranslate nohighlight">\(r^2\)</span> term in the ODF integral. The original Sharpening
Deconvolution Transform (SDT) technique <a class="footnote-reference brackets" href="#footcite-descoteaux2009" id="id44" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a> is
expecting Tuch’s ODF without the <span class="math notranslate nohighlight">\(r^2\)</span> (see <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id45" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>
for the mathematical details).  Now, this function supports ODF that
have been computed using the <span class="math notranslate nohighlight">\(r^2\)</span> term because the proper analytical
response function has be derived.  For example, models such as DSI,
GQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved
with the r2_term=True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fodf_sh</strong><span class="classifier">ndarray</span></dt><dd><p>sharpened odf expressed as spherical harmonics coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mask-for-response-ssst">
<h3>mask_for_response_ssst<a class="headerlink" href="#mask-for-response-ssst" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.mask_for_response_ssst">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">mask_for_response_ssst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#mask_for_response_ssst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.mask_for_response_ssst" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computation of mask for single-shell single-tissue (ssst) response</dt><dd><p>function using FA.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>diffusion data (4D)</p>
</dd>
<dt><strong>roi_center</strong><span class="classifier">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt><strong>roi_radii</strong><span class="classifier">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>
</dd>
<dt><strong>fa_thr</strong><span class="classifier">float</span></dt><dd><p>FA threshold</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA above the FA threshold.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this, we look for voxels with very
anisotropic configurations. This function aims to accomplish that by
returning a mask of voxels within a ROI, that have a FA value above a
given threshold. For example we can use a ROI (20x20x20) at
the center of the volume and store the signal values for the voxels with
FA values higher than 0.7 (see <a class="footnote-reference brackets" href="#footcite-tournier2004" id="id46" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a>).</p>
<p class="rubric">References</p>
<div class="docutils container" id="id47">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-tournier2004" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id46">1</a>,<a role="doc-backlink" href="#id48">2</a>,<a role="doc-backlink" href="#id375">3</a>)</span>
<p>Jacques-Donald Tournier, Fernando Calamante, David G. Gadian, and Alan Connelly. Direct estimation of the fiber orientation density function from diffusion-weighted MRI data using spherical deconvolution. <em>NeuroImage</em>, 23(3):1176–1185, November 2004. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2004.07.037">https://doi.org/10.1016/j.neuroimage.2004.07.037</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2004.07.037">doi:10.1016/j.neuroimage.2004.07.037</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="response-from-mask-ssst">
<h3>response_from_mask_ssst<a class="headerlink" href="#response-from-mask-ssst" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.response_from_mask_ssst">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">response_from_mask_ssst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#response_from_mask_ssst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.response_from_mask_ssst" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computation of single-shell single-tissue (ssst) response</dt><dd><p>function from a given mask.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>diffusion data</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>mask from where to compute the response function</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response</strong><span class="classifier">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>
</dd>
<dt><strong>ratio</strong><span class="classifier">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this, we look for voxels with very
anisotropic configurations. This information can be obtained by using
csdeconv.mask_for_response_ssst() through a mask of selected voxels
(see <a class="footnote-reference brackets" href="#footcite-tournier2004" id="id48" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a>). The present function uses such a mask to
compute the ssst response function.</p>
<p>For the response we also need to find the average S0 in the ROI. This is
possible using <cite>gtab.b0s_mask()</cite> we can find all the S0 volumes (which
correspond to b-values equal 0) in the dataset.</p>
<p>The <cite>response</cite> consists always of a prolate tensor created by averaging
the highest and second highest eigenvalues in the ROI with FA higher than
threshold. We also include the average S0s.</p>
<p>We also return the <cite>ratio</cite> which is used for the SDT models.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="auto-response-ssst">
<h3>auto_response_ssst<a class="headerlink" href="#auto-response-ssst" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.auto_response_ssst">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">auto_response_ssst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#auto_response_ssst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.auto_response_ssst" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Automatic estimation of single-shell single-tissue (ssst) response</dt><dd><p>function using FA.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>diffusion data</p>
</dd>
<dt><strong>roi_center</strong><span class="classifier">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt><strong>roi_radii</strong><span class="classifier">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>
</dd>
<dt><strong>fa_thr</strong><span class="classifier">float</span></dt><dd><p>FA threshold</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response</strong><span class="classifier">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>
</dd>
<dt><strong>ratio</strong><span class="classifier">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this, we look for voxels with very
anisotropic configurations. We get this information from
csdeconv.mask_for_response_ssst(), which returns a mask of selected voxels
(more details are available in the description of the function).</p>
<p>With the mask, we compute the response function by using
csdeconv.response_from_mask_ssst(), which returns the <cite>response</cite> and the
<cite>ratio</cite> (more details are available in the description of the function).</p>
</dd></dl>

</section>
<section id="recursive-response">
<h3>recursive_response<a class="headerlink" href="#recursive-response" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.recursive_response">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">recursive_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max=8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peak_thr=0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_fa=0.08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_trace=0.0021</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter=8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence=0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_processes=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere=&lt;dipy.core.sphere.HemiSphere</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#recursive_response"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.recursive_response" title="Link to this definition">#</a></dt>
<dd><p>Recursive calibration of response function using peak threshold.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-tax2014" id="id49" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>diffusion data</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray, optional</span></dt><dd><p>mask for recursive calibration, for example a white matter mask. It has
shape <cite>data.shape[0:3]</cite> and dtype=bool. Default: use the entire data
array.</p>
</dd>
<dt><strong>sh_order_max</strong><span class="classifier">int, optional</span></dt><dd><p>maximal spherical harmonics order (l).</p>
</dd>
<dt><strong>peak_thr</strong><span class="classifier">float, optional</span></dt><dd><p>peak threshold, how large the second peak can be relative to the first
peak in order to call it a single fiber population
<a class="footnote-reference brackets" href="#footcite-tax2014" id="id50" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a>.</p>
</dd>
<dt><strong>init_fa</strong><span class="classifier">float, optional</span></dt><dd><p>FA of the initial ‘fat’ response function (tensor).</p>
</dd>
<dt><strong>init_trace</strong><span class="classifier">float, optional</span></dt><dd><p>trace of the initial ‘fat’ response function (tensor).</p>
</dd>
<dt><strong>iter</strong><span class="classifier">int, optional</span></dt><dd><p>maximum number of iterations for calibration.</p>
</dd>
<dt><strong>convergence</strong><span class="classifier">float, optional</span></dt><dd><p>convergence criterion, maximum relative change of SH
coefficients.</p>
</dd>
<dt><strong>parallel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to use parallelization in peak-finding during the calibration
procedure.</p>
</dd>
<dt><strong>num_processes</strong><span class="classifier">int, optional</span></dt><dd><p>If <cite>parallel</cite> is True, the number of subprocesses to use
(default multiprocessing.cpu_count()). If &lt; 0 the maximal number of
cores minus <code class="docutils literal notranslate"><span class="pre">num_processes</span> <span class="pre">+</span> <span class="pre">1</span></code> is used (enter -1 to use as many
cores as possible). 0 raises an error.</p>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere, optional.</span></dt><dd><p>The sphere used for peak finding.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response</strong><span class="classifier">ndarray</span></dt><dd><p>response function in SH coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. Using an FA threshold is not a very robust method.
It is dependent on the dataset (non-informed used subjectivity), and still
depends on the diffusion tensor (FA and first eigenvector),
which has low accuracy at high b-value. This function recursively
calibrates the response function, for more information see
<a class="footnote-reference brackets" href="#footcite-tax2014" id="id51" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id52">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-tax2014" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id49">1</a>,<a role="doc-backlink" href="#id50">2</a>,<a role="doc-backlink" href="#id51">3</a>)</span>
<p>Chantal M.W. Tax, Ben Jeurissen, Sjoerd B. Vos, Max A. Viergever, and Alexander Leemans. Recursive calibration of the fiber response function for spherical deconvolution of diffusion MRI data. <em>NeuroImage</em>, 86:67–80, 2014. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2013.07.067">https://doi.org/10.1016/j.neuroimage.2013.07.067</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2013.07.067">doi:10.1016/j.neuroimage.2013.07.067</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="fa-trace-to-lambdas">
<h3>fa_trace_to_lambdas<a class="headerlink" href="#fa-trace-to-lambdas" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.fa_trace_to_lambdas">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">fa_trace_to_lambdas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0021</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/csdeconv.html#fa_trace_to_lambdas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="correlationtensormodel">
<h3><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorModel" title="dipy.reconst.cti.CorrelationTensorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CorrelationTensorModel</span></code></a><a class="headerlink" href="#correlationtensormodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">CorrelationTensorModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#CorrelationTensorModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Class for the Correlation Tensor Model</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorModel.fit" title="dipy.reconst.cti.CorrelationTensorModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorModel.predict" title="dipy.reconst.cti.CorrelationTensorModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(cti_params, *[, S0])</p></td>
<td><p>Predict a signal for the CTI model class instance given parameters</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cti_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#CorrelationTensorModel.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorModel.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal for the CTI model class instance given parameters</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>cti_params: numpy.ndarray (…, 48)</strong></dt><dd><p>All parameters estimated from the correlation tensor model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
<li><p>Twenty-One elements of the covariance tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>gtab1: dipy.core.gradients.GradientTable</strong></dt><dd><p>A GradientTable class instance for first DDE diffusion epoch</p>
</dd>
<dt><strong>gtab2: dipy.core.gradients.GradientTable</strong></dt><dd><p>A GradientTable class instance for second DDE diffusion epoch</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Predicted signal based on the CTI model</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="correlationtensorfit">
<h3><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit" title="dipy.reconst.cti.CorrelationTensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">CorrelationTensorFit</span></code></a><a class="headerlink" href="#correlationtensorfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">CorrelationTensorFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#CorrelationTensorFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a></p>
<p>Class for fitting the Correlation Tensor Model</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit.K_aniso" title="dipy.reconst.cti.CorrelationTensorFit.K_aniso"><code class="xref py py-obj docutils literal notranslate"><span class="pre">K_aniso</span></code></a></dt><dd><p>Returns the anisotropic Source of Kurtosis ($K_{aniso}$)</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit.K_iso" title="dipy.reconst.cti.CorrelationTensorFit.K_iso"><code class="xref py py-obj docutils literal notranslate"><span class="pre">K_iso</span></code></a></dt><dd><p>Returns the isotropic Source of Kurtosis ($K_{iso}$)</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit.K_micro" title="dipy.reconst.cti.CorrelationTensorFit.K_micro"><code class="xref py py-obj docutils literal notranslate"><span class="pre">K_micro</span></code></a></dt><dd><p>Returns Microscopic Source of Kurtosis.</p>
</dd>
<dt><strong>S0_hat</strong></dt><dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit.ct" title="dipy.reconst.cti.CorrelationTensorFit.ct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ct</span></code></a></dt><dd><p>Returns the 21 independent elements of the covariance tensor as an</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></dt><dd><p>For tracking - return the primary direction in each voxel</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kfa</span></code></dt><dd><p>Return the kurtosis tensor (KFA).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kt</span></code></dt><dd><p>Return the 15 independent elements of the kurtosis tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit.K_total" title="dipy.reconst.cti.CorrelationTensorFit.K_total"><code class="xref py py-obj docutils literal notranslate"><span class="pre">K_total</span></code></a>()</p></td>
<td><p>Returns the total excess kurtosis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code>()</p></td>
<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code>(sphere)</p></td>
<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on the sphere for each voxel in the data</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ak</span></code>(*[, min_kurtosis, max_kurtosis, analytical])</p></td>
<td><p>Compute axial kurtosis (AK) of a diffusion kurtosis tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">akc</span></code>(sphere)</p></td>
<td><p>Calculate the apparent kurtosis coefficient (AKC) in each direction on the sphere for each voxel in the data</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code>()</p></td>
<td><p>Color fractional anisotropy of diffusion tensor</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code>()</p></td>
<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code>()</p></td>
<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">kmax</span></code>(*[, sphere, gtol, mask])</p></td>
<td><p>Compute the maximum value of a single voxel kurtosis tensor</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code>()</p></td>
<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mk</span></code>(*[, min_kurtosis, max_kurtosis, analytical])</p></td>
<td><p>Compute mean kurtosis (MK) from the kurtosis tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mkt</span></code>(*[, min_kurtosis, max_kurtosis])</p></td>
<td><p>Compute mean of the kurtosis tensor (MKT).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code>()</p></td>
<td><p>Tensor mode calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</p></td>
<td><p>The diffusion orientation distribution function (dODF).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit.predict" title="dipy.reconst.cti.CorrelationTensorFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab1, gtab2, *[, S0])</p></td>
<td><p>Given a CTI model fit, predict the signal on the vertices of a gradient table</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code>()</p></td>
<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rk</span></code>(*[, min_kurtosis, max_kurtosis, analytical])</p></td>
<td><p>Compute radial kurtosis (RK) of a diffusion kurtosis tensor.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtk</span></code>(*[, min_kurtosis, max_kurtosis])</p></td>
<td><p>Compute the rescaled radial tensor kurtosis (RTK).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>()</p></td>
<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>lower_triangular</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.K_aniso">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">K_aniso</span></span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.K_aniso" title="Link to this definition">#</a></dt>
<dd><p>Returns the anisotropic Source of Kurtosis (<span class="math notranslate nohighlight">\(K_{aniso}\)</span>)</p>
<p class="rubric">Notes</p>
<p>The <span class="math notranslate nohighlight">\(K_{aniso}\)</span> is defined as <a class="footnote-reference brackets" href="#footcite-netohenriques2020" id="id53" role="doc-noteref"><span class="fn-bracket">[</span>18<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[\[K_{aniso} = \frac{6}{5} \cdot \frac{\langle V_{\lambda}(D_c)
                                  \rangle}{\overline{D}^2}\]\]</div>
<p>where <span class="math notranslate nohighlight">\(K_{aniso}\)</span> is the anisotropic kurtosis,
<span class="math notranslate nohighlight">\(\langle V_{\lambda}(D_c) \rangle\)</span> represents the mean of the variance
of eigenvalues of the diffusion tensor, <span class="math notranslate nohighlight">\(\overline{D}\)</span> is the mean of
the diffusion tensor.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id54">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-netohenriques2020" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id53">18</a><span class="fn-bracket">]</span></span>
<p>Rafael Neto Henriques, Sune N. Jespersen, and Noam Shemesh. Correlation tensor magnetic resonance imaging. <em>NeuroImage</em>, 211:116605, 2020. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2020.116605">https://doi.org/10.1016/j.neuroimage.2020.116605</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2020.116605">doi:10.1016/j.neuroimage.2020.116605</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.K_iso">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">K_iso</span></span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.K_iso" title="Link to this definition">#</a></dt>
<dd><p>Returns the isotropic Source of Kurtosis (<span class="math notranslate nohighlight">\(K_{iso}\)</span>)</p>
<p class="rubric">Notes</p>
<p>The <span class="math notranslate nohighlight">\(K_{iso}\)</span> is defined as :</p>
<div class="math notranslate nohighlight">
\[K_{\text{iso}} = 3 \cdot \frac{V(\overline{D}^c)}{\overline{D}^2}\]</div>
<p>where: <span class="math notranslate nohighlight">\(K_{\text{iso}}\)</span> is the isotropic kurtosis, <span class="math notranslate nohighlight">\(V({\overline{D}^c})\)</span>
represents the variance of the diffusion tensor raised to the power <span class="math notranslate nohighlight">\(c\)</span>,
<span class="math notranslate nohighlight">\(\overline{D}\)</span> is the mean of the diffusion tensor.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.K_micro">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">K_micro</span></span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.K_micro" title="Link to this definition">#</a></dt>
<dd><p>Returns Microscopic Source of Kurtosis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.K_total">
<span class="sig-name descname"><span class="pre">K_total</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#CorrelationTensorFit.K_total"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.K_total" title="Link to this definition">#</a></dt>
<dd><p>Returns the total excess kurtosis.</p>
<p class="rubric">Notes</p>
<p><span class="math notranslate nohighlight">\(K_{total}\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[\[\Psi = \frac{2}{5} \cdot \frac{D_{11}^2 + D_{22}^2 + D_{33}^2
                                 + 2D_{12}^2 + 2D_{13}^2 +
                                 2D_{23}^2{\overline{D}^2} -
                                 \frac{6}{5} \]
\[{\overline{W}} = \frac{1}{5} \cdot (W_{1111} + W_{2222}
                                      + W_{3333} + 2W_{1122}
                                      + 2W_{1133} + 2W_{2233})\
  ]\]</div>
<p>where <span class="math notranslate nohighlight">\(\Psi\)</span> is a variable representing a part of the total
excess kurtosis, <span class="math notranslate nohighlight">\(D_{ij}\)</span> are elements of the diffusion tensor,
<span class="math notranslate nohighlight">\(\overline{D}\)</span> is the mean of the diffusion tensor. <span class="math notranslate nohighlight">\(\overline{W}\)</span>
is the mean kurtosis, <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are elements of the kurtosis
tensor.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.ct">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ct</span></span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.ct" title="Link to this definition">#</a></dt>
<dd><p>Returns the 21 independent elements of the covariance tensor as an
array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#CorrelationTensorFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Given a CTI model fit, predict the signal on the vertices of a
gradient table</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab1: dipy.core.gradients.GradientTable</strong></dt><dd><p>A GradientTable class instance for first DDE diffusion epoch</p>
</dd>
<dt><strong>gtab2: dipy.core.gradients.GradientTable</strong></dt><dd><p>A GradientTable class instance for second DDE diffusion epoch</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Predicted signal based on the CTI model</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="from-qte-to-cti">
<h3>from_qte_to_cti<a class="headerlink" href="#from-qte-to-cti" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.from_qte_to_cti">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">from_qte_to_cti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#from_qte_to_cti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.from_qte_to_cti" title="Link to this definition">#</a></dt>
<dd><p>Rescales the qte C elements to the C elements used in CTI.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>C: array(…, 21)</strong></dt><dd><p>Twenty-one elements of the covariance tensor in voigt notation plus
some extra scaling factors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ccti: array(…, 21)</dt><dd><p>Covariance Tensor Elements with no hidden factors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="multi-gaussian-k-from-c">
<h3>multi_gaussian_k_from_c<a class="headerlink" href="#multi-gaussian-k-from-c" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.multi_gaussian_k_from_c">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">multi_gaussian_k_from_c</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ccti</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MD</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#multi_gaussian_k_from_c"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.multi_gaussian_k_from_c" title="Link to this definition">#</a></dt>
<dd><p>Computes the multiple Gaussian diffusion kurtosis tensor from the
covariance tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ccti: array(…, 21)</strong></dt><dd><p>Covariance Tensor Elements with no hidden factors.</p>
</dd>
<dt><strong>MD</strong><span class="classifier">ndarray</span></dt><dd><p>Mean Diffusivity (MD) of a diffusion tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>K: array (…, 15)</dt><dd><p>Fifteen elements of the kurtosis tensor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="split-cti-params">
<h3>split_cti_params<a class="headerlink" href="#split-cti-params" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.split_cti_params">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">split_cti_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cti_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#split_cti_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.split_cti_params" title="Link to this definition">#</a></dt>
<dd><p>Splits CTI params into DTI, DKI, CTI portions.</p>
<p>Extract the diffusion tensor eigenvalues, the diffusion tensor
eigenvector matrix, and the 21 independent elements of the covariance
tensor, and the 15 independent elements of the kurtosis tensor from the
model parameters estimated from the CTI model</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>cti_params: numpy.ndarray (…, 48)</strong></dt><dd><p>All parameters estimated from the correlation tensor model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
<li><p>Twenty-One elements of the covariance tensor</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array (…, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt><strong>evecs</strong><span class="classifier">array (…, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. evecs[:,j] is associated with
evals[j])</p>
</dd>
<dt><strong>kt</strong><span class="classifier">array (…, 15)</span></dt><dd><p>Fifteen elements of the kurtosis tensor</p>
</dd>
<dt>ct: array(…, 21)</dt><dd><p>Twenty-one elements of the covariance tensor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="cti-prediction">
<h3>cti_prediction<a class="headerlink" href="#cti-prediction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.cti_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">cti_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cti_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#cti_prediction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.cti_prediction" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal given correlation tensor imaging parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>cti_params: numpy.ndarray (…, 48)</strong></dt><dd><p>All parameters estimated from the correlation tensor model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
<li><p>Twenty-One elements of the covariance tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>gtab1: dipy.core.gradients.GradientTable</strong></dt><dd><p>A GradientTable class instance for first DDE diffusion epoch</p>
</dd>
<dt><strong>gtab2: dipy.core.gradients.GradientTable</strong></dt><dd><p>A GradientTable class instance for second DDE diffusion epoch</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">ndarray</span></dt><dd><p>Simulated signal based on the CTI model</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="params-to-cti-params">
<h3>params_to_cti_params<a class="headerlink" href="#params-to-cti-params" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.params_to_cti_params">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">params_to_cti_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#params_to_cti_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.params_to_cti_params" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="ls-fit-cti">
<h3>ls_fit_cti<a class="headerlink" href="#ls-fit-cti" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.ls_fit_cti">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">ls_fit_cti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_design_matrix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/cti.html#ls_fit_cti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.cti.ls_fit_cti" title="Link to this definition">#</a></dt>
<dd><p>Compute the diffusion kurtosis and covariance tensors using an
ordinary or weighted linear least squares approach</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g, 43)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array (g)</span></dt><dd><p>Data or response variables holding the data.</p>
</dd>
<dt><strong>inverse_design_matrix</strong><span class="classifier">array (43, g)</span></dt><dd><p>Inverse of the design matrix.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>Parameter indicating whether weights are used.</p>
</dd>
<dt><strong>min_diffusivity</strong><span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than <cite>min_diffusivity</cite>
are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>cti_params</strong><span class="classifier">array (48)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model for all N
voxels. Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor eigenvalues.</p></li>
<li><dl class="simple">
<dt>Three blocks of three elements, containing the first second and</dt><dd><p>third coordinates of the diffusion tensor eigenvectors.</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor.</p></li>
<li><p>Twenty One elements of the covariance tensor.</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="diffusionkurtosismodel">
<h3><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="dipy.reconst.dki.DiffusionKurtosisModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a><a class="headerlink" href="#diffusionkurtosismodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">DiffusionKurtosisModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Class for the Diffusion Kurtosis Model</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel.fit" title="dipy.reconst.dki.DiffusionKurtosisModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method of the DKI model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel.iterative_fit" title="dipy.reconst.dki.DiffusionKurtosisModel.iterative_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iterative_fit</span></code></a>(data_thres, *[, mask, ...])</p></td>
<td><p>Iteratively Reweighted fitting for the DKI model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel.multi_fit" title="dipy.reconst.dki.DiffusionKurtosisModel.multi_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel.predict" title="dipy.reconst.dki.DiffusionKurtosisModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(dki_params, *[, S0])</p></td>
<td><p>Predict a signal for this DKI model class instance given parameters</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method of the DKI model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>The measured signal.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[-1]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel.iterative_fit">
<span class="sig-name descname"><span class="pre">iterative_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_thres</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter=4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_method=&lt;function</span> <span class="pre">weights_method_wls_m_est&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisModel.iterative_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.iterative_fit" title="Link to this definition">#</a></dt>
<dd><p>Iteratively Reweighted fitting for the DKI model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>data_thres</strong><span class="classifier">array</span></dt><dd><p>The measured signal.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[-1]</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of times to iterate.</p>
</dd>
<dt><strong>weights_method</strong><span class="classifier">callable, optional</span></dt><dd><p>A function with args and returns as follows:</p>
<dl class="simple">
<dt>(weights, robust) =</dt><dd><dl class="simple">
<dt>weights_method(data, pred_sig,</dt><dd><p>design_matrix, leverages,
idx, num_iter,
robust)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>On the first iteration, (C)WLS fit is performed. Subsequent iterations
will be weighted according to weights_method.  Outlier rejection should
be handled within weights_method by setting the corresponding weights
to zero (if weights_method implements outlier rejection).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel.multi_fit">
<span class="sig-name descname"><span class="pre">multi_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.multi_fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisModel.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal for this DKI model class instance given parameters</p>
<p>See <a class="footnote-reference brackets" href="#footcite-jensen2005" id="id55" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id56" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id57">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-jensen2005" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id55">1</a>,<a role="doc-backlink" href="#id60">2</a>,<a role="doc-backlink" href="#id71">3</a>,<a role="doc-backlink" href="#id78">4</a>,<a role="doc-backlink" href="#id81">5</a>,<a role="doc-backlink" href="#id84">6</a>,<a role="doc-backlink" href="#id97">7</a>,<a role="doc-backlink" href="#id102">8</a>,<a role="doc-backlink" href="#id105">9</a>,<a role="doc-backlink" href="#id109">10</a>,<a role="doc-backlink" href="#id117">11</a>,<a role="doc-backlink" href="#id124">12</a>,<a role="doc-backlink" href="#id131">13</a>,<a role="doc-backlink" href="#id139">14</a>)</span>
<p>Jens H. Jensen, Joseph A. Helpern, Anita Ramani, Hanzhang Lu, and Kyle Kaczynski. Diffusional kurtosis imaging: The quantification of non-gaussian water diffusion by means of magnetic resonance imaging. <em>Magnetic Resonance in Medicine</em>, 53(6):1432–1440, 2005. URL: <a class="reference external" href="https://onlinelibrary.wiley.com/doi/abs/10.1002/mrm.20508">https://onlinelibrary.wiley.com/doi/abs/10.1002/mrm.20508</a>, <a class="reference external" href="https://doi.org/https://doi.org/10.1002/mrm.20508">doi:https://doi.org/10.1002/mrm.20508</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-netohenriques2021a" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id56">1</a>,<a role="doc-backlink" href="#id59">2</a>,<a role="doc-backlink" href="#id62">3</a>,<a role="doc-backlink" href="#id67">4</a>,<a role="doc-backlink" href="#id70">5</a>,<a role="doc-backlink" href="#id73">6</a>,<a role="doc-backlink" href="#id82">7</a>,<a role="doc-backlink" href="#id86">8</a>,<a role="doc-backlink" href="#id87">9</a>,<a role="doc-backlink" href="#id99">10</a>,<a role="doc-backlink" href="#id101">11</a>,<a role="doc-backlink" href="#id104">12</a>,<a role="doc-backlink" href="#id108">13</a>,<a role="doc-backlink" href="#id111">14</a>,<a role="doc-backlink" href="#id114">15</a>,<a role="doc-backlink" href="#id116">16</a>,<a role="doc-backlink" href="#id119">17</a>,<a role="doc-backlink" href="#id120">18</a>,<a role="doc-backlink" href="#id123">19</a>,<a role="doc-backlink" href="#id126">20</a>,<a role="doc-backlink" href="#id128">21</a>,<a role="doc-backlink" href="#id129">22</a>,<a role="doc-backlink" href="#id136">23</a>,<a role="doc-backlink" href="#id140">24</a>)</span>
<p>Rafael Neto Henriques, Marta M. Correia, Maurizio Marrale, Elizabeth Huber, John Kruper, Serge Koudoro, Jason D. Yeatman, Eleftherios Garyfallidis, and Ariel Rokem. Diffusional Kurtosis Imaging in the Diffusion Imaging in Python Project. <em>Frontiers in Human Neuroscience</em>, July 2021. Sec. Brain Imaging and Stimulation. Advanced Diffusion MRI for Brain Microstructure: Methodology, Consistency, and Application. URL: <a class="reference external" href="https://doi.org/10.3389/fnhum.2021.675433">https://doi.org/10.3389/fnhum.2021.675433</a>, <a class="reference external" href="https://doi.org/10.3389/fnhum.2021.675433">doi:10.3389/fnhum.2021.675433</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="diffusionkurtosisfit">
<h3><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a><a class="headerlink" href="#diffusionkurtosisfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">DiffusionKurtosisFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a></p>
<p>Class for fitting the Diffusion Kurtosis Model</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S0_hat</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></dt><dd><p>For tracking - return the primary direction in each voxel</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.kfa" title="dipy.reconst.dki.DiffusionKurtosisFit.kfa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kfa</span></code></a></dt><dd><p>Return the kurtosis tensor (KFA).</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.kt" title="dipy.reconst.dki.DiffusionKurtosisFit.kt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kt</span></code></a></dt><dd><p>Return the 15 independent elements of the kurtosis tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code>()</p></td>
<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code>(sphere)</p></td>
<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on the sphere for each voxel in the data</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.ak" title="dipy.reconst.dki.DiffusionKurtosisFit.ak"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ak</span></code></a>(*[, min_kurtosis, max_kurtosis, analytical])</p></td>
<td><p>Compute axial kurtosis (AK) of a diffusion kurtosis tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.akc" title="dipy.reconst.dki.DiffusionKurtosisFit.akc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">akc</span></code></a>(sphere)</p></td>
<td><p>Calculate the apparent kurtosis coefficient (AKC) in each direction on the sphere for each voxel in the data</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code>()</p></td>
<td><p>Color fractional anisotropy of diffusion tensor</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code>()</p></td>
<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code>()</p></td>
<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.kmax" title="dipy.reconst.dki.DiffusionKurtosisFit.kmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kmax</span></code></a>(*[, sphere, gtol, mask])</p></td>
<td><p>Compute the maximum value of a single voxel kurtosis tensor</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code>()</p></td>
<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.mk" title="dipy.reconst.dki.DiffusionKurtosisFit.mk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mk</span></code></a>(*[, min_kurtosis, max_kurtosis, analytical])</p></td>
<td><p>Compute mean kurtosis (MK) from the kurtosis tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.mkt" title="dipy.reconst.dki.DiffusionKurtosisFit.mkt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mkt</span></code></a>(*[, min_kurtosis, max_kurtosis])</p></td>
<td><p>Compute mean of the kurtosis tensor (MKT).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code>()</p></td>
<td><p>Tensor mode calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</p></td>
<td><p>The diffusion orientation distribution function (dODF).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.predict" title="dipy.reconst.dki.DiffusionKurtosisFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab, *[, S0])</p></td>
<td><p>Given a DKI model fit, predict the signal on the vertices of a gradient table</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code>()</p></td>
<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.rk" title="dipy.reconst.dki.DiffusionKurtosisFit.rk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rk</span></code></a>(*[, min_kurtosis, max_kurtosis, analytical])</p></td>
<td><p>Compute radial kurtosis (RK) of a diffusion kurtosis tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.rtk" title="dipy.reconst.dki.DiffusionKurtosisFit.rtk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtk</span></code></a>(*[, min_kurtosis, max_kurtosis])</p></td>
<td><p>Compute the rescaled radial tensor kurtosis (RTK).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>()</p></td>
<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>lower_triangular</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.ak">
<span class="sig-name descname"><span class="pre">ak</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisFit.ak"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.ak" title="Link to this definition">#</a></dt>
<dd><p>Compute axial kurtosis (AK) of a diffusion kurtosis tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id58" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id59" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores
<a class="footnote-reference brackets" href="#footcite-jensen2005" id="id60" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>.</p>
</dd>
<dt><strong>analytical</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, AK is calculated from rotated diffusion kurtosis tensor,
otherwise it will be computed from the apparent diffusion kurtosis
values along the principal axis of the diffusion tensor
(see notes).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ak</strong><span class="classifier">array</span></dt><dd><p>Calculated AK.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>AK is defined as the directional kurtosis parallel to the fiber’s main
direction e1 <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id61" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id62" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>.
You can compute AK using to approaches:</p>
<ol class="arabic simple">
<li><p>AK is calculated from rotated diffusion kurtosis tensor, i.e.:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[AK = \hat{W}_{1111}
\frac{(\lambda_{1}+\lambda_{2}+\lambda_{3})^2}{(9 \lambda_{1}^2)}\]</div>
<ol class="arabic simple" start="2">
<li><p>AK can be sampled from the principal axis of the diffusion tensor:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[AK = K(\mathbf{e}_1)\]</div>
<p>Although both approaches leads to an exact calculation of AK, the
first approach will be referred to as the analytical method while the
second approach will be referred to as the numerical method based on
their analogy to the estimation strategies for MK and RK.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id63">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-tabesh2011" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id58">1</a>,<a role="doc-backlink" href="#id61">2</a>,<a role="doc-backlink" href="#id69">3</a>,<a role="doc-backlink" href="#id72">4</a>,<a role="doc-backlink" href="#id75">5</a>,<a role="doc-backlink" href="#id83">6</a>,<a role="doc-backlink" href="#id85">7</a>,<a role="doc-backlink" href="#id88">8</a>,<a role="doc-backlink" href="#id107">9</a>,<a role="doc-backlink" href="#id110">10</a>,<a role="doc-backlink" href="#id113">11</a>,<a role="doc-backlink" href="#id115">12</a>,<a role="doc-backlink" href="#id118">13</a>,<a role="doc-backlink" href="#id121">14</a>,<a role="doc-backlink" href="#id122">15</a>,<a role="doc-backlink" href="#id125">16</a>,<a role="doc-backlink" href="#id127">17</a>)</span>
<p>Ali Tabesh, Jens H. Jensen, Babak A. Ardekani, and Joseph A. Helpern. Estimation of tensors and tensor-derived measures in diffusional kurtosis imaging. <em>Magnetic Resonance in Medicine</em>, 65(3):823–836, 2011. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.22655">https://doi.org/10.1002/mrm.22655</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.22655">doi:10.1002/mrm.22655</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.akc">
<span class="sig-name descname"><span class="pre">akc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisFit.akc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.akc" title="Link to this definition">#</a></dt>
<dd><p>Calculate the apparent kurtosis coefficient (AKC) in each
direction on the sphere for each voxel in the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere class instance</span></dt><dd><p>Sphere providing sample directions to compute the apparent kurtosis
coefficient.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>akc</strong><span class="classifier">ndarray</span></dt><dd><p>The estimates of the apparent kurtosis coefficient in every
direction on the input sphere</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For each sphere direction with coordinates <span class="math notranslate nohighlight">\((n_{1}, n_{2}, n_{3})\)</span>, the
calculation of AKC is done using formula:</p>
<div class="math notranslate nohighlight">
\[AKC(n)=\frac{MD^{2}}{ADC(n)^{2}}\sum_{i=1}^{3}\sum_{j=1}^{3}
\sum_{k=1}^{3}\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\]</div>
<p>where <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the kurtosis tensor, MD the mean
diffusivity and ADC the apparent diffusion coefficient computed as:</p>
<div class="math notranslate nohighlight">
\[ADC(n)=\sum_{i=1}^{3}\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\]</div>
<p>where <span class="math notranslate nohighlight">\(D_{ij}\)</span> are the elements of the diffusion tensor.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.kfa">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kfa</span></span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.kfa" title="Link to this definition">#</a></dt>
<dd><p>Return the kurtosis tensor (KFA).</p>
<p>See <a class="footnote-reference brackets" href="#footcite-glenn2015" id="id64" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">Notes</p>
<p>The KFA is defined as <a class="footnote-reference brackets" href="#footcite-glenn2015" id="id65" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[KFA \equiv
\frac{||\mathbf{W} - MKT \mathbf{I}^{(4)}||_F}{||\mathbf{W}||_F}\]</div>
<p>where <span class="math notranslate nohighlight">\(W\)</span> is the kurtosis tensor, MKT the kurtosis tensor mean, <span class="math notranslate nohighlight">\(I^{(4)}\)</span>
is the fully symmetric rank 2 isotropic tensor and <span class="math notranslate nohighlight">\(||...||_F\)</span> is the
tensor’s Frobenius norm <a class="footnote-reference brackets" href="#footcite-glenn2015" id="id66" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.kmax">
<span class="sig-name descname"><span class="pre">kmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisFit.kmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.kmax" title="Link to this definition">#</a></dt>
<dd><p>Compute the maximum value of a single voxel kurtosis tensor</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id67" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for further details about the
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of
the maximum value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong><span class="classifier">float, optional</span></dt><dd><p>This input is to refine kurtosis maximum under the precision of the
directions sampled on the sphere class instance. The gradient of
the convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken
from the initial sampled directions of the given sphere object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_value</strong><span class="classifier">float</span></dt><dd><p>kurtosis tensor maximum value</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id68">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-glenn2015" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id64">1</a>,<a role="doc-backlink" href="#id65">2</a>,<a role="doc-backlink" href="#id66">3</a>,<a role="doc-backlink" href="#id135">4</a>,<a role="doc-backlink" href="#id137">5</a>,<a role="doc-backlink" href="#id138">6</a>)</span>
<p>G. Russell Glenn, Joseph A. Helpern, Ali Tabesh, and Jens H. Jensen. Quantitative assessment of diffusional kurtosis anisotropy. <em>NMR in Biomedicine</em>, 28(4):448–459, 2015. URL: <a class="reference external" href="https://doi.org/10.1002/nbm.3271">https://doi.org/10.1002/nbm.3271</a>, <a class="reference external" href="https://doi.org/10.1002/nbm.3271">doi:10.1002/nbm.3271</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.kt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kt</span></span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.kt" title="Link to this definition">#</a></dt>
<dd><p>Return the 15 independent elements of the kurtosis tensor as an array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.mk">
<span class="sig-name descname"><span class="pre">mk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisFit.mk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.mk" title="Link to this definition">#</a></dt>
<dd><p>Compute mean kurtosis (MK) from the kurtosis tensor.</p>
<p>See Tabesh <em>et al.</em><a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id69" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id70" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores
<a class="footnote-reference brackets" href="#footcite-jensen2005" id="id71" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>.</p>
</dd>
<dt><strong>analytical</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, MK is calculated using its analytical solution, otherwise
an exact numerical estimator is used (see Notes).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mk</strong><span class="classifier">array</span></dt><dd><p>Calculated MK.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The MK is defined as the average of directional kurtosis coefficients
across all spatial directions, which can be formulated by the following
surface integral <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id72" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id73" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[MK \equiv \frac{1}{4\pi} \int d\Omega_\mathbf{n} K(\mathbf{n})\]</div>
<p>This integral can be numerically solved by averaging directional
kurtosis values sampled for directions of a spherical t-design
<a class="footnote-reference brackets" href="#footcite-hardin1996" id="id74" role="doc-noteref"><span class="fn-bracket">[</span>23<span class="fn-bracket">]</span></a>.</p>
<p>Alternatively, MK can be solved from the analytical solution derived by
Tabesh <em>et al.</em><a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id75" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>. This solution is given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}MK=F_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{1111}+
   F_1(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{2222}+
   F_1(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{3333}+ \\
   F_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}+
   F_2(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{1133}+
   F_2(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{1122}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{W}_{ijkl}\)</span> are the components of the <span class="math notranslate nohighlight">\(W\)</span> tensor in the
coordinates system defined by the eigenvectors of the diffusion tensor
<span class="math notranslate nohighlight">\(\mathbf{D}\)</span> and</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}F_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{18(\lambda_1-\lambda_2)(\lambda_1-\lambda_3)}
[\frac{\sqrt{\lambda_2\lambda_3}}{\lambda_1}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{3\lambda_1^2-\lambda_1\lambda_2-\lambda_2\lambda_3-
\lambda_1\lambda_3}
{3\lambda_1 \sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-1 ]\end{split}\\\begin{split}F_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{3(\lambda_2-\lambda_3)^2}
[\frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{2\lambda_1-\lambda_2-\lambda_3}{3\sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-2]\end{split}\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(R_f\)</span> and <span class="math notranslate nohighlight">\(R_d\)</span> are the Carlson’s elliptic integrals.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id76">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-hardin1996" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>23<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id74">1</a>,<a role="doc-backlink" href="#id112">2</a>)</span>
<p>Ronald H. Hardin and Neil J. A. Sloane. Mclaren’s improved snub cube and other new spherical designs in three dimensions. <em>Discrete &amp; Computational Geometry</em>, 15(4):429–441, 1996. URL: <a class="reference external" href="https://doi.org/10.1007/BF02711518">https://doi.org/10.1007/BF02711518</a>, <a class="reference external" href="https://doi.org/10.1007/BF02711518">doi:10.1007/BF02711518</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.mkt">
<span class="sig-name descname"><span class="pre">mkt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisFit.mkt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.mkt" title="Link to this definition">#</a></dt>
<dd><p>Compute mean of the kurtosis tensor (MKT).</p>
<p>See <a class="footnote-reference brackets" href="#footcite-hansen2013" id="id77" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores
<a class="footnote-reference brackets" href="#footcite-jensen2005" id="id78" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mkt</strong><span class="classifier">array</span></dt><dd><p>Calculated mean kurtosis tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The MKT is defined as <a class="footnote-reference brackets" href="#footcite-hansen2013" id="id79" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[MKT \equiv \frac{1}{4\pi} \int d
\Omega_{\mathnbf{n}} n_i n_j n_k n_l W_{ijkl}\]</div>
<p>which can be directly computed from the trace of the kurtosis tensor:</p>
<div class="math notranslate nohighlight">
\[MKT = \frac{1}{5} Tr(\mathbf{W}) = \frac{1}{5}
(W_{1111} + W_{2222} + W_{3333} + 2W_{1122} + 2W_{1133} + 2W_{2233})\]</div>
<p class="rubric">References</p>
<div class="docutils container" id="id80">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-hansen2013" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id77">1</a>,<a role="doc-backlink" href="#id79">2</a>,<a role="doc-backlink" href="#id130">3</a>,<a role="doc-backlink" href="#id132">4</a>,<a role="doc-backlink" href="#id133">5</a>,<a role="doc-backlink" href="#id134">6</a>)</span>
<p>Brian Hansen, Torben E. Lund, Ryan Sangill, and Sune Nørhøj Jespersen. Experimentally and computationally fast method for estimation of a mean kurtosis. <em>Magnetic Resonance in Medicine</em>, 69(6):1754–1760, 2013. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.24743">https://doi.org/10.1002/mrm.24743</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.24743">doi:10.1002/mrm.24743</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Given a DKI model fit, predict the signal on the vertices of a
gradient table</p>
<p>See <a class="footnote-reference brackets" href="#footcite-jensen2005" id="id81" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id82" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S(n,b)=S_{0}e^{-bD(n)+\frac{1}{6}b^{2}D(n)^{2}K(n)}\]</div>
<p><span class="math notranslate nohighlight">\(\mathbf{D(n)}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{K(n)}\)</span> can be computed from the DT and KT
using the following equations:</p>
<div class="math notranslate nohighlight">
\[D(n)=\sum_{i=1}^{3}\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[K(n)=\frac{MD^{2}}{D(n)^{2}}\sum_{i=1}^{3}\sum_{j=1}^{3}
\sum_{k=1}^{3}\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\]</div>
<p>where <span class="math notranslate nohighlight">\(D_{ij}\)</span> and <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the second-order DT
and the fourth-order KT tensors, respectively, and <span class="math notranslate nohighlight">\(MD\)</span> is the mean
diffusivity.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.rk">
<span class="sig-name descname"><span class="pre">rk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisFit.rk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.rk" title="Link to this definition">#</a></dt>
<dd><p>Compute radial kurtosis (RK) of a diffusion kurtosis tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id83" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,
radial kurtosis values that are smaller than <cite>min_kurtosis</cite> are
replaced with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis
limit for regions that consist of water confined to spherical pores
<a class="footnote-reference brackets" href="#footcite-jensen2005" id="id84" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,
radial kurtosis values that are larger than <cite>max_kurtosis</cite> are
replaced with <cite>max_kurtosis</cite>.</p>
</dd>
<dt><strong>analytical</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, RK is calculated using its analytical solution, otherwise
an exact numerical estimator is used (see Notes).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rk</strong><span class="classifier">array</span></dt><dd><p>Calculated RK.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>RK is defined as the average of the directional kurtosis perpendicular
to the fiber’s main direction e1 <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id85" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id86" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[RK \equiv \frac{1}{2\pi} \int d\Omega _\mathbf{\theta}
    K(\mathbf{\theta}) \delta (\mathbf{\theta}\cdot \mathbf{e}_1)\]</div>
<p>This equation can be numerically computed by averaging apparent
directional kurtosis samples for directions perpendicular to e1
<a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id87" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>.</p>
<p>Otherwise, RK can be calculated from its analytical solution
<a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id88" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[K_{\bot} = G_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2222} +
           G_1(\lambda_1,\lambda_3,\lambda_2)\hat{W}_{3333} +
           G_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[G_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{18\lambda_2(\lambda_2-
\lambda_3)} \left (2\lambda_2 +
\frac{\lambda_3^2-3\lambda_2\lambda_3}{\sqrt{\lambda_2\lambda_3}}
\right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[ G_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{(\lambda_2-\lambda_3)^2}
\left ( \frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}-
2\right )\]</div>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.rtk">
<span class="sig-name descname"><span class="pre">rtk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#DiffusionKurtosisFit.rtk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.rtk" title="Link to this definition">#</a></dt>
<dd><p>Compute the rescaled radial tensor kurtosis (RTK).</p>
<p>See <a class="footnote-reference brackets" href="#footcite-hansen2016b" id="id89" role="doc-noteref"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,
radial kurtosis values that are smaller than <cite>min_kurtosis</cite> are
replaced with <cite>min_kurtosis</cite>.</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,
radial kurtosis values that are larger than <cite>max_kurtosis</cite> are
replaced with <cite>max_kurtosis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rtk</strong><span class="classifier">array</span></dt><dd><p>Calculated escaled radial tensor kurtosis (RTK).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Rescaled radial tensor kurtosis (RTK) is defined as
<a class="footnote-reference brackets" href="#footcite-hansen2016b" id="id90" role="doc-noteref"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>RKT = frac{3}{8}frac{MD^2}{RD^2} (W_{2222}+ W_{3333}+2*W_{2233})</p>
<p>where W is the kurtosis tensor rotated to a coordinate system in
which the 3 orthonormal eigenvectors of DT are the base coordinate,
MD is the mean diffusivity, and RD is the radial diffusivity.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id91">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-hansen2016b" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id89">1</a>,<a role="doc-backlink" href="#id90">2</a>)</span>
<p>Brian Hansen, Noam Shemesh, and Sune Nørhøj Jespersen. Fast imaging of mean, axial and radial diffusion kurtosis. <em>NeuroImage</em>, 142:381–393, November 2016. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.08.022">https://doi.org/10.1016/j.neuroimage.2016.08.022</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.08.022">doi:10.1016/j.neuroimage.2016.08.022</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="carlson-rf">
<h3>carlson_rf<a class="headerlink" href="#carlson-rf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.carlson_rf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">carlson_rf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0003</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#carlson_rf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.carlson_rf" title="Link to this definition">#</a></dt>
<dd><p>Compute the Carlson’s incomplete elliptic integral of the first kind.</p>
<p>Carlson’s incomplete elliptic integral of the first kind is defined as
<a class="footnote-reference brackets" href="#footcite-carlson1995" id="id92" role="doc-noteref"><span class="fn-bracket">[</span>26<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[R_F = \frac{1}{2} \int_{0}^{\infty} \left [(t+x)(t+y)(t+z)  \right ]
^{-\frac{1}{2}}dt\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>First independent variable of the integral.</p>
</dd>
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>Second independent variable of the integral.</p>
</dd>
<dt><strong>z</strong><span class="classifier">ndarray</span></dt><dd><p>Third independent variable of the integral.</p>
</dd>
<dt><strong>errtol</strong><span class="classifier">float</span></dt><dd><p>Error tolerance. Integral is computed with relative error less in
magnitude than the defined value</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>RF</strong><span class="classifier">ndarray</span></dt><dd><p>Value of the incomplete first order elliptic integral</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>x, y, and z have to be nonnegative and at most one of them is zero.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id93">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-carlson1995" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>26<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id92">1</a>,<a role="doc-backlink" href="#id94">2</a>)</span>
<p>Billie C. Carlson. Numerical computation of real or complex elliptic integrals. <em>Numerical Algorithms</em>, 10(1):13–26, 1995. URL: <a class="reference external" href="https://doi.org/10.1007/BF02198293">https://doi.org/10.1007/BF02198293</a>, <a class="reference external" href="https://doi.org/10.1007/BF02198293">doi:10.1007/BF02198293</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="carlson-rd">
<h3>carlson_rd<a class="headerlink" href="#carlson-rd" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.carlson_rd">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">carlson_rd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#carlson_rd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.carlson_rd" title="Link to this definition">#</a></dt>
<dd><p>Compute the Carlson’s incomplete elliptic integral of the second kind.</p>
<p>Carlson’s incomplete elliptic integral of the second kind is defined as
<a class="footnote-reference brackets" href="#footcite-carlson1995" id="id94" role="doc-noteref"><span class="fn-bracket">[</span>26<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[R_D = \frac{3}{2} \int_{0}^{\infty} (t+x)^{-\frac{1}{2}}
(t+y)^{-\frac{1}{2}}(t+z)  ^{-\frac{3}{2}}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>First independent variable of the integral.</p>
</dd>
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>Second independent variable of the integral.</p>
</dd>
<dt><strong>z</strong><span class="classifier">ndarray</span></dt><dd><p>Third independent variable of the integral.</p>
</dd>
<dt><strong>errtol</strong><span class="classifier">float</span></dt><dd><p>Error tolerance. Integral is computed with relative error less in
magnitude than the defined value</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>RD</strong><span class="classifier">ndarray</span></dt><dd><p>Value of the incomplete second order elliptic integral</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>x, y, and z have to be nonnegative and at most x or y is zero.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="directional-diffusion">
<h3>directional_diffusion<a class="headerlink" href="#directional-diffusion" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.directional_diffusion">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">directional_diffusion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#directional_diffusion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.directional_diffusion" title="Link to this definition">#</a></dt>
<dd><p>Compute apparent diffusion coefficient (adc).</p>
<p>Calculate the apparent diffusion coefficient (adc) in each direction of
a sphere for a single voxel Neto Henriques <em>et al.</em><a class="footnote-reference brackets" href="#footcite-netohenriques2015" id="id95" role="doc-noteref"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>
</dd>
<dt><strong>V</strong><span class="classifier">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt><strong>min_diffusivity</strong><span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>. Default = 0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>adc</strong><span class="classifier">ndarray (g,)</span></dt><dd><p>Apparent diffusion coefficient (ADC) in all g directions of a sphere
for a single voxel.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id96">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-netohenriques2015" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id95">1</a>,<a role="doc-backlink" href="#id98">2</a>,<a role="doc-backlink" href="#id100">3</a>,<a role="doc-backlink" href="#id103">4</a>,<a role="doc-backlink" href="#id106">5</a>)</span>
<p>Rafael Neto Henriques, Marta Morgado Correia, Rita Gouveia Nunes, and Hugo Alexandre Ferreira. Exploring the 3D geometry of the diffusion kurtosis tensor—Impact on the development of robust tractography procedures and novel biomarkers. <em>NeuroImage</em>, 111:85–99, 2015. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2015.02.004">https://doi.org/10.1016/j.neuroimage.2015.02.004</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2015.02.004">doi:10.1016/j.neuroimage.2015.02.004</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="directional-diffusion-variance">
<h3>directional_diffusion_variance<a class="headerlink" href="#directional-diffusion-variance" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.directional_diffusion_variance">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">directional_diffusion_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#directional_diffusion_variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.directional_diffusion_variance" title="Link to this definition">#</a></dt>
<dd><p>Calculate the apparent diffusion variance (adv) in each direction of a
sphere for a single voxel</p>
<p>See <a class="footnote-reference brackets" href="#footcite-jensen2005" id="id97" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-netohenriques2015" id="id98" role="doc-noteref"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></a>, and
<a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id99" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>kt</strong><span class="classifier">array (15,)</span></dt><dd><p>elements of the kurtosis tensor of the voxel.</p>
</dd>
<dt><strong>V</strong><span class="classifier">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>adv</strong><span class="classifier">ndarray (g,)</span></dt><dd><p>Apparent diffusion variance (adv) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="directional-kurtosis">
<h3>directional_kurtosis<a class="headerlink" href="#directional-kurtosis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.directional_kurtosis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">directional_kurtosis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">md</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#directional_kurtosis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.directional_kurtosis" title="Link to this definition">#</a></dt>
<dd><p>Calculate the apparent kurtosis coefficient (akc) in each direction of
a sphere for a single voxel.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2015" id="id100" role="doc-noteref"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id101" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>
</dd>
<dt><strong>md</strong><span class="classifier">float</span></dt><dd><p>mean diffusivity of the voxel</p>
</dd>
<dt><strong>kt</strong><span class="classifier">array (15,)</span></dt><dd><p>elements of the kurtosis tensor of the voxel.</p>
</dd>
<dt><strong>V</strong><span class="classifier">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt><strong>min_diffusivity</strong><span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>. Default = 0</p>
</dd>
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>Because high-amplitude negative values of kurtosis are not physically
and biologicaly pluasible, and these cause artefacts in
kurtosis-based measures, directional kurtosis values smaller than
<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>.
(theoretical kurtosis limit for regions that consist of water confined
to spherical pores <a class="footnote-reference brackets" href="#footcite-jensen2005" id="id102" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
<dt><strong>adc</strong><span class="classifier">ndarray(g,), optional</span></dt><dd><p>Apparent diffusion coefficient (ADC) in all g directions of a sphere
for a single voxel.</p>
</dd>
<dt><strong>adv</strong><span class="classifier">ndarray(g,), optional</span></dt><dd><p>Apparent diffusion variance (advc) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>akc</strong><span class="classifier">ndarray (g,)</span></dt><dd><p>Apparent kurtosis coefficient (AKC) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="apparent-kurtosis-coef">
<h3>apparent_kurtosis_coef<a class="headerlink" href="#apparent-kurtosis-coef" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.apparent_kurtosis_coef">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">apparent_kurtosis_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#apparent_kurtosis_coef"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.apparent_kurtosis_coef" title="Link to this definition">#</a></dt>
<dd><p>Calculate the apparent kurtosis coefficient (AKC) in each direction
of a sphere.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2015" id="id103" role="doc-noteref"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id104" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvectors respectively</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>sphere</strong><span class="classifier">a Sphere class instance</span></dt><dd><p>The AKC will be calculated for each of the vertices in the sphere</p>
</dd>
<dt><strong>min_diffusivity</strong><span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>.</p>
</dd>
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>Because high-amplitude negative values of kurtosis are not physically
and biologicaly pluasible, and these cause artefacts in
kurtosis-based measures, directional kurtosis values smaller than
<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7
(theoretical kurtosis limit for regions that consist of water confined
to spherical pores <a class="footnote-reference brackets" href="#footcite-jensen2005" id="id105" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>akc</strong><span class="classifier">ndarray (x, y, z, g) or (n, g)</span></dt><dd><p>Apparent kurtosis coefficient (AKC) for all g directions of a sphere.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For each sphere direction with coordinates <span class="math notranslate nohighlight">\((n_{1}, n_{2}, n_{3})\)</span>, the
calculation of AKC is done using formula <a class="footnote-reference brackets" href="#footcite-netohenriques2015" id="id106" role="doc-noteref"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[AKC(n)=\frac{MD^{2}}{ADC(n)^{2}}\sum_{i=1}^{3}\sum_{j=1}^{3}
\sum_{k=1}^{3}\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\]</div>
<p>where <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the kurtosis tensor, MD the mean
diffusivity and ADC the apparent diffusion coefficient computed as:</p>
<div class="math notranslate nohighlight">
\[ADC(n)=\sum_{i=1}^{3}\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\]</div>
<p>where <span class="math notranslate nohighlight">\(D_{ij}\)</span> are the elements of the diffusion tensor.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mean-kurtosis">
<h3>mean_kurtosis<a class="headerlink" href="#mean-kurtosis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.mean_kurtosis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">mean_kurtosis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#mean_kurtosis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.mean_kurtosis" title="Link to this definition">#</a></dt>
<dd><p>Compute mean kurtosis (MK) from the kurtosis tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id107" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id108" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores
<a class="footnote-reference brackets" href="#footcite-jensen2005" id="id109" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>.</p>
</dd>
<dt><strong>analytical</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, MK is calculated using its analytical solution, otherwise an
exact numerical estimator is used (see Notes).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mk</strong><span class="classifier">array</span></dt><dd><p>Calculated MK.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The MK is defined as the average of directional kurtosis coefficients
across all spatial directions, which can be formulated by the following
surface integral <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id110" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id111" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[MK \equiv \frac{1}{4\pi} \int d\Omega_\mathbf{n} K(\mathbf{n})\]</div>
<p>This integral can be numerically solved by averaging directional
kurtosis values sampled for directions of a spherical t-design
<a class="footnote-reference brackets" href="#footcite-hardin1996" id="id112" role="doc-noteref"><span class="fn-bracket">[</span>23<span class="fn-bracket">]</span></a>.</p>
<p>Alternatively, MK can be solved from the analytical solution derived by
<a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id113" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id114" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>. This solution is
given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}MK=F_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{1111}+
   F_1(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{2222}+
   F_1(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{3333}+ \\
   F_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}+
   F_2(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{1133}+
   F_2(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{1122}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{W}_{ijkl}\)</span> are the components of the <span class="math notranslate nohighlight">\(W\)</span> tensor in the
coordinates system defined by the eigenvectors of the diffusion tensor
<span class="math notranslate nohighlight">\(\mathbf{D}\)</span> and</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}F_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{18(\lambda_1-\lambda_2)(\lambda_1-\lambda_3)}
[\frac{\sqrt{\lambda_2\lambda_3}}{\lambda_1}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{3\lambda_1^2-\lambda_1\lambda_2-\lambda_2\lambda_3-
\lambda_1\lambda_3}
{3\lambda_1 \sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-1 ]\end{split}\\\begin{split}F_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{3(\lambda_2-\lambda_3)^2}
[\frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{2\lambda_1-\lambda_2-\lambda_3}{3\sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-2]\end{split}\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(R_f\)</span> and <span class="math notranslate nohighlight">\(R_d\)</span> are the Carlson’s elliptic integrals.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="radial-kurtosis">
<h3>radial_kurtosis<a class="headerlink" href="#radial-kurtosis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.radial_kurtosis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">radial_kurtosis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#radial_kurtosis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.radial_kurtosis" title="Link to this definition">#</a></dt>
<dd><p>Compute radial kurtosis (RK) of a diffusion kurtosis tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id115" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id116" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, radial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores
<a class="footnote-reference brackets" href="#footcite-jensen2005" id="id117" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, radial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>.</p>
</dd>
<dt><strong>analytical</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, RK is calculated using its analytical solution, otherwise an
exact numerical estimator is used (see Notes). Default is set to True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rk</strong><span class="classifier">array</span></dt><dd><p>Calculated RK.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>RK is defined as the average of the directional kurtosis perpendicular
to the fiber’s main direction e1 <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id118" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id119" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[RK \equiv \frac{1}{2\pi} \int d\Omega _\mathbf{\theta} K(\mathbf{\theta})
          \delta (\mathbf{\theta}\cdot \mathbf{e}_1)\]</div>
<p>This equation can be numerically computed by averaging apparent
directional kurtosis samples for directions perpendicular to e1
<a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id120" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>.</p>
<p>Otherwise, RK can be calculated from its analytical solution
<a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id121" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[K_{\bot} = G_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2222} +
           G_1(\lambda_1,\lambda_3,\lambda_2)\hat{W}_{3333} +
           G_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[G_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{18\lambda_2(\lambda_2-
\lambda_3)} \left (2\lambda_2 +
\frac{\lambda_3^2-3\lambda_2\lambda_3}{\sqrt{\lambda_2\lambda_3}}
\right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[G_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{(\lambda_2-\lambda_3)^2}
\left ( \frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}-2\right )\]</div>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="axial-kurtosis">
<h3>axial_kurtosis<a class="headerlink" href="#axial-kurtosis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.axial_kurtosis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">axial_kurtosis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#axial_kurtosis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.axial_kurtosis" title="Link to this definition">#</a></dt>
<dd><p>Compute axial kurtosis (AK) from the kurtosis tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id122" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id123" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for further
details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores
<a class="footnote-reference brackets" href="#footcite-jensen2005" id="id124" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>.</p>
</dd>
<dt><strong>analytical</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, AK is calculated from rotated diffusion kurtosis tensor,
otherwise it will be computed from the apparent diffusion kurtosis
values along the principal axis of the diffusion tensor (see notes).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ak</strong><span class="classifier">array</span></dt><dd><p>Calculated AK.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>AK is defined as the directional kurtosis parallel to the fiber’s main
direction e1 <a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id125" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id126" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>. You
can compute AK using to approaches:</p>
<ol class="arabic simple">
<li><p>AK is calculated from rotated diffusion kurtosis tensor
<a class="footnote-reference brackets" href="#footcite-tabesh2011" id="id127" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a>, i.e.:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[AK = \hat{W}_{1111}
    \frac{(\lambda_{1}+\lambda_{2}+\lambda_{3})^2}{(9 \lambda_{1}^2)}\]</div>
<ol class="arabic simple" start="2">
<li><p>AK can be sampled from the principal axis of the diffusion tensor
<a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id128" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[AK = K(\mathbf{e}_1)\]</div>
<p>Although both approaches leads to an exact calculation of AK, the first
approach will be referred to as the analytical method while the second
approach will be referred to as the numerical method based on their analogy
to the estimation strategies for MK and RK.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="kurtosis-maximum">
<h3>kurtosis_maximum<a class="headerlink" href="#kurtosis-maximum" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.kurtosis_maximum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">kurtosis_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#kurtosis_maximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.kurtosis_maximum" title="Link to this definition">#</a></dt>
<dd><p>Compute kurtosis maximum value.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id129" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eingenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of the
maximal value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong><span class="classifier">float, optional</span></dt><dd><p>This input is to refine kurtosis maximum under the precision of the
directions sampled on the sphere class instance. The gradient of the
convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken from
the initial sampled directions of the given sphere object</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_value</strong><span class="classifier">float</span></dt><dd><p>kurtosis tensor maximum value</p>
</dd>
<dt><strong>max_dir</strong><span class="classifier">array (3,)</span></dt><dd><p>Cartesian coordinates of the direction of the maximal kurtosis value</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mean-kurtosis-tensor">
<h3>mean_kurtosis_tensor<a class="headerlink" href="#mean-kurtosis-tensor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.mean_kurtosis_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">mean_kurtosis_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#mean_kurtosis_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.mean_kurtosis_tensor" title="Link to this definition">#</a></dt>
<dd><p>Compute mean of the kurtosis tensor (MKT).</p>
<p>See <a class="footnote-reference brackets" href="#footcite-hansen2013" id="id130" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores
<a class="footnote-reference brackets" href="#footcite-jensen2005" id="id131" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a>).</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mkt</strong><span class="classifier">array</span></dt><dd><p>Calculated mean kurtosis tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The MKT is defined as <a class="footnote-reference brackets" href="#footcite-hansen2013" id="id132" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[MKT \equiv \frac{1}{4\pi} \int d
\Omega_{\mathnbf{n}} n_i n_j n_k n_l W_{ijkl}\]</div>
<p>which can be directly computed from the trace of the kurtosis tensor:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>MKT = frac{1}{5} Tr(mathbf{W}) = frac{1}{5}
(W_{1111} + W_{2222} + W_{3333} + 2W_{1122} + 2W_{1133} + 2W_{2233})</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="radial-tensor-kurtosis">
<h3>radial_tensor_kurtosis<a class="headerlink" href="#radial-tensor-kurtosis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.radial_tensor_kurtosis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">radial_tensor_kurtosis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#radial_tensor_kurtosis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.radial_tensor_kurtosis" title="Link to this definition">#</a></dt>
<dd><p>Compute the rescaled radial tensor kurtosis (RTK).</p>
<p>See <a class="footnote-reference brackets" href="#footcite-hansen2013" id="id133" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>min_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, radial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>.</p>
</dd>
<dt><strong>max_kurtosis</strong><span class="classifier">float, optional</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, radial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rtk</strong><span class="classifier">array</span></dt><dd><p>Calculated rescaled radial tensor kurtosis (RTK).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Rescaled radial tensor kurtosis (RTK) is defined as
<a class="footnote-reference brackets" href="#footcite-hansen2013" id="id134" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>RKT = frac{3}{8} frac{MD^2}{RD^2} (W_{2222} + W_{3333} + 2*W_{2233})</p>
<p>where W is the kurtosis tensor rotated to a coordinate system in which the
3 orthonormal eigenvectors of DT are the base coordinate, MD is the mean
diffusivity, and RD is the radial diffusivity.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="kurtosis-fractional-anisotropy">
<h3>kurtosis_fractional_anisotropy<a class="headerlink" href="#kurtosis-fractional-anisotropy" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.kurtosis_fractional_anisotropy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">kurtosis_fractional_anisotropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#kurtosis_fractional_anisotropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.kurtosis_fractional_anisotropy" title="Link to this definition">#</a></dt>
<dd><p>Compute the anisotropy of the kurtosis tensor (KFA).</p>
<p>See <a class="footnote-reference brackets" href="#footcite-glenn2015" id="id135" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id136" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for further
details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>kfa</strong><span class="classifier">array</span></dt><dd><p>Calculated mean kurtosis tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The KFA is defined as <a class="footnote-reference brackets" href="#footcite-glenn2015" id="id137" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[KFA \equiv
\frac{||\mathbf{W} - MKT \mathbf{I}^{(4)}||_F}{||\mathbf{W}||_F}\]</div>
<p>where <span class="math notranslate nohighlight">\(W\)</span> is the kurtosis tensor, MKT the kurtosis tensor mean, <span class="math notranslate nohighlight">\(I^{(4)}\)</span> is
the fully symmetric rank 2 isotropic tensor and <span class="math notranslate nohighlight">\(||...||_F\)</span> is the tensor’s
Frobenius norm <a class="footnote-reference brackets" href="#footcite-glenn2015" id="id138" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="dki-prediction">
<h3>dki_prediction<a class="headerlink" href="#dki-prediction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.dki_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">dki_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#dki_prediction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.dki_prediction" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal given diffusion kurtosis imaging parameters</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S=S_{0}e^{-bD+\frac{1}{6}b^{2}D^{2}K}\]</div>
<p>See <a class="footnote-reference brackets" href="#footcite-jensen2005" id="id139" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2021a" id="id140" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pred_sig</strong><span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated signal based on the DKI model.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="params-to-dki-params">
<h3>params_to_dki_params<a class="headerlink" href="#params-to-dki-params" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.params_to_dki_params">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">params_to_dki_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#params_to_dki_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.params_to_dki_params" title="Link to this definition">#</a></dt>
<dd><p>Convert the 21 unique elements of the diffusion and kurtosis tensors
to the parameter format adopted in DIPY</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>results</strong><span class="classifier">array (21)</span></dt><dd><p>Unique elements of the diffusion and kurtosis tensors in the following
order: 1) six unique lower triangular DT elements; and 2) Fifteen
unique elements of the kurtosis tensor.</p>
</dd>
<dt><strong>min_diffusivity</strong><span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>dki_params</strong><span class="classifier">array (27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model for all N
voxels. Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor eigenvalues.</p></li>
<li><p>Three blocks of three elements, containing the first second and
third coordinates of the diffusion tensor eigenvectors.</p></li>
<li><p>Fifteen elements of the kurtosis tensor.</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="ls-fit-dki">
<h3>ls_fit_dki<a class="headerlink" href="#ls-fit-dki" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.ls_fit_dki">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">ls_fit_dki</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_design_matrix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_lower_triangular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_leverages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#ls_fit_dki"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.ls_fit_dki" title="Link to this definition">#</a></dt>
<dd><p>Compute the diffusion and kurtosis tensors using an ordinary or
weighted linear least squares approach.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-veraart2013" id="id141" role="doc-noteref"><span class="fn-bracket">[</span>28<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g, 22)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array (g)</span></dt><dd><p>Data or response variables holding the data.</p>
</dd>
<dt><strong>inverse_design_matrix</strong><span class="classifier">array (22, g)</span></dt><dd><p>Inverse of the design matrix.</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array ([X, Y, Z, …], g), optional</span></dt><dd><p>Weights to apply for fitting. These weights must correspond to the
squared residuals such that <span class="math notranslate nohighlight">\(S = \sum_i w_i r_i^2\)</span>. If not provided,
weights are estimated as the squared predicted signal from an initial
OLS fit.</p>
</dd>
<dt><strong>min_diffusivity</strong><span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
<dt><strong>return_lower_triangular</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the coefficients of the fit.</p>
</dd>
<dt><strong>return_leverages</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the fitting leverages.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>dki_params</strong><span class="classifier">array (27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model for all N
voxels. Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor eigenvalues.</p></li>
<li><p>Three blocks of three elements, containing the first second and
third coordinates of the diffusion tensor eigenvectors.</p></li>
<li><p>Fifteen elements of the kurtosis tensor.</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>leverages</strong><span class="classifier">array (g)</span></dt><dd><p>Leverages of the fitting problem (if return_leverages is True)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id142">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-veraart2013" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id141">28</a><span class="fn-bracket">]</span></span>
<p>Jelle Veraart, Jan Sijbers, Stefan Sunaert, Alexander Leemans, and Ben Jeurissen. Weighted linear least squares estimation of diffusion MRI parameters: Strengths, limitations, and pitfalls. <em>NeuroImage</em>, 81:335–346, 2013. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2013.05.028">https://doi.org/10.1016/j.neuroimage.2013.05.028</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2013.05.028">doi:10.1016/j.neuroimage.2013.05.028</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="cls-fit-dki">
<h3>cls_fit_dki<a class="headerlink" href="#cls-fit-dki" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.cls_fit_dki">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">cls_fit_dki</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sdp</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_lower_triangular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_leverages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#cls_fit_dki"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.cls_fit_dki" title="Link to this definition">#</a></dt>
<dd><p>Compute the diffusion and kurtosis tensors using a constrained
ordinary or weighted linear least squares approach.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-delahaije2020" id="id143" role="doc-noteref"><span class="fn-bracket">[</span>29<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g, 22)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array (g)</span></dt><dd><p>Data or response variables holding the data.</p>
</dd>
<dt><strong>inverse_design_matrix</strong><span class="classifier">array (22, g)</span></dt><dd><p>Inverse of the design matrix.</p>
</dd>
<dt><strong>sdp</strong><span class="classifier">PositiveDefiniteLeastSquares instance</span></dt><dd><p>A CVXPY representation of a regularized least squares optimization
problem.</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array ([X, Y, Z, …], g), optional</span></dt><dd><p>Weights to apply for fitting. These weights must correspond to the
squared residuals such that <span class="math notranslate nohighlight">\(S = \sum_i w_i r_i^2\)</span>. If not provided,
weights are estimated as the squared predicted signal from an initial
OLS fit.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>Parameter indicating whether weights are used.</p>
</dd>
<dt><strong>min_diffusivity</strong><span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
<dt><strong>return_lower_triangular</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the coefficients of the fit.</p>
</dd>
<dt><strong>return_leverages</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the fitting leverages.</p>
</dd>
<dt><strong>cvxpy_solver</strong><span class="classifier">str, optional</span></dt><dd><p>cvxpy solver name. Optionally optimize the positivity constraint with a
particular cvxpy solver. See <a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a> for details.
Default: None (cvxpy chooses its own solver).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>dki_params</strong><span class="classifier">array (27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model for all N
voxels. Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor eigenvalues.</p></li>
<li><p>Three blocks of three elements, containing the first second and
third coordinates of the diffusion tensor eigenvectors.</p></li>
<li><p>Fifteen elements of the kurtosis tensor.</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>leverages</strong><span class="classifier">array (g)</span></dt><dd><p>Leverages of the fitting problem (if return_leverages is True)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id144">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-delahaije2020" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id143">29</a><span class="fn-bracket">]</span></span>
<p>Tom Dela Haije, Evren Özarslan, and Aasa Feragen. Enforcing necessary non-negativity constraints for common diffusion MRI models using sum of squares programming. <em>NeuroImage</em>, 209:116405, 2020. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2019.116405">https://doi.org/10.1016/j.neuroimage.2019.116405</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2019.116405">doi:10.1016/j.neuroimage.2019.116405</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="wrotate">
<h3>Wrotate<a class="headerlink" href="#wrotate" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.Wrotate">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">Wrotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Basis</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#Wrotate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.Wrotate" title="Link to this definition">#</a></dt>
<dd><p>Rotate a kurtosis tensor from the standard Cartesian coordinate system
to another coordinate system basis</p>
<p>See <a class="footnote-reference brackets" href="#footcite-hui2008" id="id145" role="doc-noteref"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>kt</strong><span class="classifier">(15,)</span></dt><dd><p>Vector with the 15 independent elements of the kurtosis tensor</p>
</dd>
<dt><strong>Basis</strong><span class="classifier">array (3, 3)</span></dt><dd><p>Vectors of the basis column-wise oriented</p>
</dd>
<dt><strong>inds</strong><span class="classifier">array(m, 4), optional</span></dt><dd><p>Array of vectors containing the four indexes of m specific elements of
the rotated kurtosis tensor. If not specified all 15 elements of the
rotated kurtosis tensor are computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Wrot</strong><span class="classifier">array (m,) or (15,)</span></dt><dd><p>Vector with the m independent elements of the rotated kurtosis tensor.
If ‘indices’ is not specified all 15 elements of the rotated kurtosis
tensor are computed.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The kurtosis tensor elements are assumed to be ordered as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}KT =
\begin{pmatrix}
    W_{xxxx} &amp; W_{yyyy} &amp; W_{zzzz} &amp; W_{xxxy} &amp; W_{xxxz} \\
    W_{xyyy} &amp; W_{yyyz} &amp; W_{xzzz} &amp; W_{yzzz} &amp; W_{xxyy} \\
    W_{xxzz} &amp; W_{yyzz} &amp; W_{xxyz} &amp; W_{xyyz} &amp; W_{xyzz}
\end{pmatrix}\end{split}\]</div>
<p class="rubric">References</p>
<div class="docutils container" id="id146">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-hui2008" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id145">1</a>,<a role="doc-backlink" href="#id147">2</a>)</span>
<p>Edward S. Hui, Matthew M. Cheung, Liqun Qi, and Ed X. Wu. Towards better MR characterization of neural tissues using directional diffusion kurtosis analysis. <em>NeuroImage</em>, 42(1):122–134, 2008. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2008.04.237">https://doi.org/10.1016/j.neuroimage.2008.04.237</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2008.04.237">doi:10.1016/j.neuroimage.2008.04.237</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="wrotate-element">
<h3>Wrotate_element<a class="headerlink" href="#wrotate-element" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.Wrotate_element">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">Wrotate_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#Wrotate_element"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.Wrotate_element" title="Link to this definition">#</a></dt>
<dd><p>Compute the specified index element of a kurtosis tensor rotated
to the coordinate system basis B</p>
<p>See <a class="footnote-reference brackets" href="#footcite-hui2008" id="id147" role="doc-noteref"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>kt</strong><span class="classifier">ndarray (x, y, z, 15) or (n, 15)</span></dt><dd><p>Array containing the 15 independent elements of the kurtosis tensor</p>
</dd>
<dt><strong>indi</strong><span class="classifier">int</span></dt><dd><p>Rotated kurtosis tensor element index i (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt><strong>indj</strong><span class="classifier">int</span></dt><dd><p>Rotated kurtosis tensor element index j (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt><strong>indk</strong><span class="classifier">int</span></dt><dd><p>Rotated kurtosis tensor element index k (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt><strong>indl: int</strong></dt><dd><p>Rotated kurtosis tensor element index l (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt><strong>B: array (x, y, z, 3, 3) or (n, 15)</strong></dt><dd><p>Vectors of the basis column-wise oriented</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Wre</strong><span class="classifier">float</span></dt><dd><p>rotated kurtosis tensor element of index ind_i, ind_j, ind_k, ind_l</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is assumed that initial kurtosis tensor elements are defined on the
Cartesian coordinate system.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="wcons">
<h3>Wcons<a class="headerlink" href="#wcons" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.Wcons">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">Wcons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_elements</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#Wcons"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.Wcons" title="Link to this definition">#</a></dt>
<dd><p>Construct the full 4D kurtosis tensors from its 15 independent
elements</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k_elements</strong><span class="classifier">(15,)</span></dt><dd><p>elements of the kurtosis tensor in the following order:</p>
</dd>
<dt><strong>.. math::</strong></dt><dd></dd>
<dt><strong>KT =</strong></dt><dd></dd>
<dt><strong>begin{pmatrix}</strong></dt><dd><p>W_{xxxx} &amp; W_{yyyy} &amp; W_{zzzz} &amp; W_{xxxy} &amp; W_{xxxz} \
W_{xyyy} &amp; W_{yyyz} &amp; W_{xzzz} &amp; W_{yzzz} &amp; W_{xxyy} \
W_{xxzz} &amp; W_{yyzz} &amp; W_{xxyz} &amp; W_{xyyz} &amp; W_{xyzz}</p>
</dd>
<dt><strong>end{pmatrix}</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">array(3, 3, 3, 3)</span></dt><dd><p>Full 4D kurtosis tensor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="split-dki-param">
<h3>split_dki_param<a class="headerlink" href="#split-dki-param" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.split_dki_param">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">split_dki_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki.html#split_dki_param"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki.split_dki_param" title="Link to this definition">#</a></dt>
<dd><p>Extract the diffusion tensor eigenvalues, the diffusion tensor
eigenvector matrix, and the 15 independent elements of the kurtosis tensor
from the model parameters estimated from the DKI model</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigvals</strong><span class="classifier">array (x, y, z, 3) or (n, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt><strong>eigvecs</strong><span class="classifier">array (x, y, z, 3, 3) or (n, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
<dt><strong>kt</strong><span class="classifier">array (x, y, z, 15) or (n, 15)</span></dt><dd><p>Fifteen elements of the kurtosis tensor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="kurtosismicrostructuremodel">
<h3><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a><a class="headerlink" href="#kurtosismicrostructuremodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructureModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">KurtosisMicrostructureModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki_micro.html#KurtosisMicrostructureModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="dipy.reconst.dki.DiffusionKurtosisModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a></p>
<p>Class for the Diffusion Kurtosis Microstructural Model</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask, sphere, gtol, awf_only])</p></td>
<td><p>Fit method of the Diffusion Kurtosis Microstructural Model</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">iterative_fit</span></code>(data_thres, *[, mask, ...])</p></td>
<td><p>Iteratively Reweighted fitting for the DKI model.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_fit</span></code>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(params, *[, S0])</p></td>
<td><p>Predict a signal for the DKI microstructural model class instance given parameters.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">awf_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki_micro.html#KurtosisMicrostructureModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method of the Diffusion Kurtosis Microstructural Model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>An 4D matrix containing the diffusion-weighted data.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[-1]</p>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of
the maximal value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong><span class="classifier">float, optional</span></dt><dd><p>This input is to refine kurtosis maxima under the precision of the
directions sampled on the sphere class instance. The gradient of
the convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken
from the initial sampled directions of the given sphere object</p>
</dd>
<dt><strong>awf_only</strong><span class="classifier">bool, optiomal</span></dt><dd><p>If set to true only the axonal volume fraction is computed from
the kurtosis tensor. Default = False</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki_micro.html#KurtosisMicrostructureModel.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal for the DKI microstructural model class instance
given parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>params</strong><span class="classifier">ndarray (x, y, z, 40) or (n, 40)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis
microstructural model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
<li><p>Six elements of the hindered diffusion tensor</p></li>
<li><p>Six elements of the restricted diffusion tensor</p></li>
<li><p>Axonal water fraction</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In the original article of DKI microstructural model
<a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id148" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>, the hindered and restricted tensors were
defined as the intra-cellular and extra-cellular diffusion compartments
respectively.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id149">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-fieremans2011" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id148">1</a>,<a role="doc-backlink" href="#id150">2</a>,<a role="doc-backlink" href="#id151">3</a>,<a role="doc-backlink" href="#id152">4</a>,<a role="doc-backlink" href="#id153">5</a>,<a role="doc-backlink" href="#id154">6</a>,<a role="doc-backlink" href="#id155">7</a>,<a role="doc-backlink" href="#id156">8</a>,<a role="doc-backlink" href="#id157">9</a>,<a role="doc-backlink" href="#id158">10</a>,<a role="doc-backlink" href="#id159">11</a>,<a role="doc-backlink" href="#id160">12</a>,<a role="doc-backlink" href="#id161">13</a>,<a role="doc-backlink" href="#id162">14</a>)</span>
<p>Els Fieremans, Jens H. Jensen, and Joseph A. Helpern. White matter characterization with diffusional kurtosis imaging. <em>NeuroImage</em>, 58(1):177–188, 2011. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2011.06.006">https://doi.org/10.1016/j.neuroimage.2011.06.006</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2011.06.006">doi:10.1016/j.neuroimage.2011.06.006</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="kurtosismicrostructuralfit">
<h3><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a><a class="headerlink" href="#kurtosismicrostructuralfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">KurtosisMicrostructuralFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki_micro.html#KurtosisMicrostructuralFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a></p>
<p>Class for fitting the Diffusion Kurtosis Microstructural Model</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S0_hat</strong></dt><dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">awf</span></code></a></dt><dd><p>Returns the volume fraction of the restricted diffusion compartment also known as axonal water fraction.</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axonal_diffusivity</span></code></a></dt><dd><p>Returns the axonal diffusivity defined as the restricted diffusion tensor trace.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></dt><dd><p>For tracking - return the primary direction in each voxel</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hindered_ad</span></code></a></dt><dd><p>Returns the axial diffusivity of the hindered compartment.</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hindered_evals</span></code></a></dt><dd><p>Returns the eigenvalues of the hindered diffusion compartment.</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hindered_rd</span></code></a></dt><dd><p>Returns the radial diffusivity of the hindered compartment.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kfa</span></code></dt><dd><p>Return the kurtosis tensor (KFA).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kt</span></code></dt><dd><p>Return the 15 independent elements of the kurtosis tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">restricted_evals</span></code></a></dt><dd><p>Returns the eigenvalues of the restricted diffusion compartment.</p>
</dd>
<dt><strong>shape</strong></dt><dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.tortuosity" title="dipy.reconst.dki_micro.tortuosity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tortuosity</span></code></a></dt><dd><p>Returns the tortuosity of the hindered diffusion which is defined by ADe / RDe, where ADe and RDe are the axial and radial diffusivities of the hindered compartment.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code>()</p></td>
<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code>(sphere)</p></td>
<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on the sphere for each voxel in the data</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ak</span></code>(*[, min_kurtosis, max_kurtosis, analytical])</p></td>
<td><p>Compute axial kurtosis (AK) of a diffusion kurtosis tensor.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">akc</span></code>(sphere)</p></td>
<td><p>Calculate the apparent kurtosis coefficient (AKC) in each direction on the sphere for each voxel in the data</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code>()</p></td>
<td><p>Color fractional anisotropy of diffusion tensor</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code>()</p></td>
<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code>()</p></td>
<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">kmax</span></code>(*[, sphere, gtol, mask])</p></td>
<td><p>Compute the maximum value of a single voxel kurtosis tensor</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code>()</p></td>
<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mk</span></code>(*[, min_kurtosis, max_kurtosis, analytical])</p></td>
<td><p>Compute mean kurtosis (MK) from the kurtosis tensor.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mkt</span></code>(*[, min_kurtosis, max_kurtosis])</p></td>
<td><p>Compute mean of the kurtosis tensor (MKT).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code>()</p></td>
<td><p>Tensor mode calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</p></td>
<td><p>The diffusion orientation distribution function (dODF).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab, *[, S0])</p></td>
<td><p>Given a DKI microstructural model fit, predict the signal on the vertices of a gradient table</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code>()</p></td>
<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rk</span></code>(*[, min_kurtosis, max_kurtosis, analytical])</p></td>
<td><p>Compute radial kurtosis (RK) of a diffusion kurtosis tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtk</span></code>(*[, min_kurtosis, max_kurtosis])</p></td>
<td><p>Compute the rescaled radial tensor kurtosis (RTK).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>()</p></td>
<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>lower_triangular</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">awf</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf" title="Link to this definition">#</a></dt>
<dd><p>Returns the volume fraction of the restricted diffusion compartment
also known as axonal water fraction.</p>
<p class="rubric">Notes</p>
<p>The volume fraction of the restricted diffusion compartment can be seen
as the volume fraction of the intra-cellular compartment
<a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id150" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">axonal_diffusivity</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity" title="Link to this definition">#</a></dt>
<dd><p>Returns the axonal diffusivity defined as the restricted diffusion
tensor trace.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id151" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hindered_ad</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad" title="Link to this definition">#</a></dt>
<dd><p>Returns the axial diffusivity of the hindered compartment.</p>
<p class="rubric">Notes</p>
<p>The hindered diffusion tensor can be seen as the tissue’s
extra-cellular diffusion compartment <a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id152" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hindered_evals</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals" title="Link to this definition">#</a></dt>
<dd><p>Returns the eigenvalues of the hindered diffusion compartment.</p>
<p class="rubric">Notes</p>
<p>The hindered diffusion tensor can be seen as the tissue’s
extra-cellular diffusion compartment <a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id153" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hindered_rd</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd" title="Link to this definition">#</a></dt>
<dd><p>Returns the radial diffusivity of the hindered compartment.</p>
<p class="rubric">Notes</p>
<p>The hindered diffusion tensor can be seen as the tissue’s
extra-cellular diffusion compartment <a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id154" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki_micro.html#KurtosisMicrostructuralFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Given a DKI microstructural model fit, predict the signal on the
vertices of a gradient table</p>
<dl class="simple">
<dt>gtab<span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt>S0<span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S(\theta, b) = S_0 * [f * e^{-b ADC_{r}} + (1-f) * e^{-b ADC_{h}]\]</div>
<p>where <span class="math notranslate nohighlight">\(ADC_{r}\)</span> and <span class="math notranslate nohighlight">\(ADC_{h}\)</span> are the apparent diffusion coefficients
of the diffusion hindered and restricted compartment for a given
direction <span class="math notranslate nohighlight">\(\theta\)</span>, <span class="math notranslate nohighlight">\(b\)</span> is the b value provided in the GradientTable
input for that direction, <span class="math notranslate nohighlight">\(f\)</span> is the volume fraction of the restricted
diffusion compartment (also known as the axonal water fraction).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">restricted_evals</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals" title="Link to this definition">#</a></dt>
<dd><p>Returns the eigenvalues of the restricted diffusion compartment.</p>
<p class="rubric">Notes</p>
<p>The restricted diffusion tensor can be seen as the tissue’s
intra-cellular diffusion compartment <a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id155" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tortuosity</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity" title="Link to this definition">#</a></dt>
<dd><p>Returns the tortuosity of the hindered diffusion which is defined
by ADe / RDe, where ADe and RDe are the axial and radial diffusivities
of the hindered compartment.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id156" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">Notes</p>
<p>The hindered diffusion tensor can be seen as the tissue’s
extra-cellular diffusion compartment <a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id157" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</dd></dl>

</section>
<section id="axonal-water-fraction">
<h3>axonal_water_fraction<a class="headerlink" href="#axonal-water-fraction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.axonal_water_fraction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">axonal_water_fraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki_micro.html#axonal_water_fraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki_micro.axonal_water_fraction" title="Link to this definition">#</a></dt>
<dd><p>Computes the axonal water fraction from DKI.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id158" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of the
maximal value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong><span class="classifier">float, optional</span></dt><dd><p>This input is to refine kurtosis maxima under the precision of the
directions sampled on the sphere class instance. The gradient of the
convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken from
the initial sampled directions of the given sphere object</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>awf</strong><span class="classifier">ndarray (x, y, z) or (n)</span></dt><dd><p>Axonal Water Fraction</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="diffusion-components">
<h3>diffusion_components<a class="headerlink" href="#diffusion-components" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.diffusion_components">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">diffusion_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">awf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki_micro.html#diffusion_components"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki_micro.diffusion_components" title="Link to this definition">#</a></dt>
<dd><p>Extracts the restricted and hindered diffusion tensors of well aligned
fibers from diffusion kurtosis imaging parameters.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id159" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dki_params</strong><span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions to sample the restricted and
hindered cellular diffusion tensors. For more details see
<a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id160" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
</dd>
<dt><strong>awf</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Array containing values of the axonal water fraction that has the shape
dki_params.shape[:-1]. If not given this will be automatically computed
using <a class="reference internal" href="#dipy.reconst.dki_micro.axonal_water_fraction" title="dipy.reconst.dki_micro.axonal_water_fraction"><code class="xref py py-func docutils literal notranslate"><span class="pre">axonal_water_fraction()</span></code></a> with function’s default precision.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>edt</strong><span class="classifier">ndarray (x, y, z, 6) or (n, 6)</span></dt><dd><p>Parameters of the hindered diffusion tensor.</p>
</dd>
<dt><strong>idt</strong><span class="classifier">ndarray (x, y, z, 6) or (n, 6)</span></dt><dd><p>Parameters of the restricted diffusion tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In the original article of DKI microstructural model
<a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id161" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>, the hindered and restricted tensors were
defined as the intra-cellular and extra-cellular diffusion compartments
respectively.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="dkimicro-prediction">
<h3>dkimicro_prediction<a class="headerlink" href="#dkimicro-prediction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.dkimicro_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">dkimicro_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki_micro.html#dkimicro_prediction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki_micro.dkimicro_prediction" title="Link to this definition">#</a></dt>
<dd><p>Signal prediction given the DKI microstructure model parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>params</strong><span class="classifier">ndarray (x, y, z, 40) or (n, 40)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis microstructure
model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
<li><p>Six elements of the hindered diffusion tensor</p></li>
<li><p>Six elements of the restricted diffusion tensor</p></li>
<li><p>Axonal water fraction</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated signal based on the DKI microstructure model</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic">
<li><p>The predicted signal is given by:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="p">(</span>\<span class="n">theta</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">S_0</span> <span class="o">*</span> <span class="p">[</span><span class="n">f</span> <span class="o">*</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span><span class="n">b</span> <span class="n">ADC_</span><span class="p">{</span><span class="n">r</span><span class="p">}}</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span><span class="n">b</span> <span class="n">ADC_</span><span class="p">{</span><span class="n">h</span><span class="p">}]</span>
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(ADC_{r}\)</span> and <span class="math notranslate nohighlight">\(ADC_{h}\)</span> are the apparent diffusion coefficients of
the diffusion hindered and restricted compartment for a given direction
<span class="math notranslate nohighlight">\(\theta\)</span>, <span class="math notranslate nohighlight">\(b\)</span> is the b value provided in the GradientTable input for that
direction, <span class="math notranslate nohighlight">\(f\)</span> is the volume fraction of the restricted diffusion
compartment (also known as the axonal water fraction).</p>
</li>
<li><p>In the original article of DKI microstructural model
<a class="footnote-reference brackets" href="#footcite-fieremans2011" id="id162" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>, the hindered and restricted tensors were
defined as the intra-cellular and extra-cellular diffusion compartments
respectively.</p></li>
</ol>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="tortuosity">
<h3>tortuosity<a class="headerlink" href="#tortuosity" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.tortuosity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">tortuosity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hindered_ad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hindered_rd</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dki_micro.html#tortuosity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dki_micro.tortuosity" title="Link to this definition">#</a></dt>
<dd><p>Computes the tortuosity of the hindered diffusion compartment given
its axial and radial diffusivities</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hindered_ad: ndarray</strong></dt><dd><p>Array containing the values of the hindered axial diffusivity.</p>
</dd>
<dt><strong>hindered_rd: ndarray</strong></dt><dd><p>Array containing the values of the hindered radial diffusivity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Tortuosity of the hindered diffusion compartment</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="diffusionspectrummodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a><a class="headerlink" href="#diffusionspectrummodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">DiffusionSpectrumModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qgrid_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">17</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel.fit" title="dipy.reconst.dsi.DiffusionSpectrumModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="diffusionspectrumfit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a><a class="headerlink" href="#diffusionspectrumfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">DiffusionSpectrumFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete" title="dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd_discrete</span></code></a>(*[, normalized])</p></td>
<td><p>Calculates the mean squared displacement on the discrete propagator</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.odf" title="dipy.reconst.dsi.DiffusionSpectrumFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</p></td>
<td><p>Calculates the real discrete odf for a given discrete sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.pdf" title="dipy.reconst.dsi.DiffusionSpectrumFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>(*[, normalized])</p></td>
<td><p>Applies the 3D FFT in the q-space grid to generate the diffusion propagator</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf" title="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_pdf</span></code></a>(*[, normalized])</p></td>
<td><p>Calculates the return to origin probability from the propagator, which is the propagator evaluated at zero.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal" title="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_signal</span></code></a>(*[, filtering])</p></td>
<td><p>Calculates the return to origin probability (rtop) from the signal rtop equals to the sum of all signal values</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete">
<span class="sig-name descname"><span class="pre">msd_discrete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumFit.msd_discrete"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete" title="Link to this definition">#</a></dt>
<dd><p>Calculates the mean squared displacement on the discrete propagator</p>
<div class="math notranslate nohighlight">
MSD:{DSI}=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\int_{-\infty}^{\infty} P(\hat{\mathbf{r}}) \cdot \hat{\mathbf{r}}^{2} \ dr_x \ dr_y \ dr_z</div><p>where <span class="math notranslate nohighlight">\(\hat{\mathbf{r}}\)</span> is a point in the 3D Propagator space
(see <a class="footnote-reference brackets" href="#footcite-wu2007" id="id163" role="doc-noteref"><span class="fn-bracket">[</span>32<span class="fn-bracket">]</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>normalized</strong><span class="classifier">boolean, optional</span></dt><dd><p>Whether to normalize the propagator by its sum in order to obtain a
pdf.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>msd</strong><span class="classifier">float</span></dt><dd><p>the mean square displacement</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id164">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-wu2007" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>32<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id163">1</a>,<a role="doc-backlink" href="#id416">2</a>,<a role="doc-backlink" href="#id417">3</a>)</span>
<p>Yu-Chien Wu and Andrew L. Alexander. Hybrid diffusion imaging. <em>NeuroImage</em>, 36(3):617–629, 2007. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2007.02.050">https://doi.org/10.1016/j.neuroimage.2007.02.050</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2007.02.050">doi:10.1016/j.neuroimage.2007.02.050</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.odf" title="Link to this definition">#</a></dt>
<dd><p>Calculates the real discrete odf for a given discrete sphere</p>
<div class="math notranslate nohighlight">
\[\psi_{DSI}(\hat{\mathbf{u}})=\int_{0}^{\infty}P(r\hat{\mathbf{u}})r^{2}dr\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\mathbf{u}}\)</span> is the unit vector which corresponds to a
sphere point.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumFit.pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.pdf" title="Link to this definition">#</a></dt>
<dd><p>Applies the 3D FFT in the q-space grid to generate
the diffusion propagator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf">
<span class="sig-name descname"><span class="pre">rtop_pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumFit.rtop_pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf" title="Link to this definition">#</a></dt>
<dd><p>Calculates the return to origin probability from the propagator,
which is the propagator evaluated at zero.</p>
<p>rtop = P(0)</p>
<p>See <a class="footnote-reference brackets" href="#footcite-descoteaux2011" id="id165" role="doc-noteref"><span class="fn-bracket">[</span>33<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-tuch2002" id="id166" role="doc-noteref"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></a> and
<a class="footnote-reference brackets" href="#footcite-wu2008" id="id167" role="doc-noteref"><span class="fn-bracket">[</span>35<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>normalized</strong><span class="classifier">boolean, optional</span></dt><dd><p>Whether to normalize the propagator by its sum in order to obtain a
pdf.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rtop</strong><span class="classifier">float</span></dt><dd><p>the return to origin probability</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id168">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-descoteaux2011" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id165">33</a><span class="fn-bracket">]</span></span>
<p>Maxime Descoteaux, Rachid Deriche, Denis Le Bihan, Jean-François Mangin, and Cyril Poupon. Multiple q-shell diffusion propagator imaging. <em>Medical Image Analysis</em>, 15(4):603–621, 2011. Special section on IPMI 2009. URL: <a class="reference external" href="https://doi.org/10.1016/j.media.2010.07.001">https://doi.org/10.1016/j.media.2010.07.001</a>, <a class="reference external" href="https://doi.org/10.1016/j.media.2010.07.001">doi:10.1016/j.media.2010.07.001</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-tuch2002" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id166">34</a><span class="fn-bracket">]</span></span>
<p>David S. Tuch. <em>Diffusion MRI of Complex Tissue Structure</em>. PhD thesis, Massachusetts Institute of Technology, Cambridge, USA, 2002. URL: <a class="reference external" href="http://hdl.handle.net/1721.1/8348">http://hdl.handle.net/1721.1/8348</a>, <a class="reference external" href="https://doi.org/">doi:</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-wu2008" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id167">35</a><span class="fn-bracket">]</span></span>
<p>Yu-Chien Wu, Aaron S. Field, and Andrew L. Alexander. Computation of Diffusion Function Measures in $q$-Space Using Magnetic Resonance Hybrid Diffusion Imaging. <em>IEEE Transactions on Medical Imaging</em>, 27(6):858–865, 2008. <a class="reference external" href="https://doi.org/10.1109/TMI.2008.922696">doi:10.1109/TMI.2008.922696</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal">
<span class="sig-name descname"><span class="pre">rtop_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumFit.rtop_signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal" title="Link to this definition">#</a></dt>
<dd><p>Calculates the return to origin probability (rtop) from the signal
rtop equals to the sum of all signal values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filtering</strong><span class="classifier">boolean, optional</span></dt><dd><p>Whether to perform Hanning filtering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rtop</strong><span class="classifier">float</span></dt><dd><p>the return to origin probability</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="diffusionspectrumdeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a><a class="headerlink" href="#diffusionspectrumdeconvmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">DiffusionSpectrumDeconvModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qgrid_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">35</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">13.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumDeconvModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="diffusionspectrumdeconvfit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a><a class="headerlink" href="#diffusionspectrumdeconvfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">DiffusionSpectrumDeconvFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumDeconvFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd_discrete</span></code>(*[, normalized])</p></td>
<td><p>Calculates the mean squared displacement on the discrete propagator</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</p></td>
<td><p>Calculates the real discrete odf for a given discrete sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>()</p></td>
<td><p>Applies the 3D FFT in the q-space grid to generate the DSI diffusion propagator, remove the background noise with a hard threshold and then deconvolve the propagator with the Lucy-Richardson deconvolution algorithm</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_pdf</span></code>(*[, normalized])</p></td>
<td><p>Calculates the return to origin probability from the propagator, which is the propagator evaluated at zero.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_signal</span></code>(*[, filtering])</p></td>
<td><p>Calculates the return to origin probability (rtop) from the signal rtop equals to the sum of all signal values</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#DiffusionSpectrumDeconvFit.pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf" title="Link to this definition">#</a></dt>
<dd><p>Applies the 3D FFT in the q-space grid to generate
the DSI diffusion propagator, remove the background noise with a
hard threshold and then deconvolve the propagator with the
Lucy-Richardson deconvolution algorithm</p>
</dd></dl>

</dd></dl>

</section>
<section id="create-qspace">
<h3>create_qspace<a class="headerlink" href="#create-qspace" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.create_qspace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">create_qspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#create_qspace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.create_qspace" title="Link to this definition">#</a></dt>
<dd><p>create the 3D grid which holds the signal values (q-space)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>origin</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>center of qspace</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qgrid</strong><span class="classifier">ndarray</span></dt><dd><p>qspace coordinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="create-qtable">
<h3>create_qtable<a class="headerlink" href="#create-qtable" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.create_qtable">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">create_qtable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#create_qtable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.create_qtable" title="Link to this definition">#</a></dt>
<dd><p>create a normalized version of gradients</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>origin</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>center of qspace</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qtable</strong><span class="classifier">ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="hanning-filter">
<h3>hanning_filter<a class="headerlink" href="#hanning-filter" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.hanning_filter">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">hanning_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#hanning_filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.hanning_filter" title="Link to this definition">#</a></dt>
<dd><p>create a hanning window</p>
<p>The signal is premultiplied by a Hanning window before
Fourier transform in order to ensure a smooth attenuation
of the signal at high q values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>filter_width</strong><span class="classifier">int</span></dt><dd><p>Strength of the Hanning filter.</p>
</dd>
<dt><strong>origin</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>center of qspace</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filter</strong><span class="classifier">(N,) ndarray</span></dt><dd><p>where N is the number of non-b0 gradient directions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="pdf-interp-coords">
<h3>pdf_interp_coords<a class="headerlink" href="#pdf-interp-coords" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.pdf_interp_coords">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">pdf_interp_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rradius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#pdf_interp_coords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.pdf_interp_coords" title="Link to this definition">#</a></dt>
<dd><p>Precompute coordinates for ODF calculation from the PDF</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">object,</span></dt><dd><p>Sphere</p>
</dd>
<dt><strong>rradius</strong><span class="classifier">array, shape (N,)</span></dt><dd><p>line interpolation points</p>
</dd>
<dt><strong>origin</strong><span class="classifier">array, shape (3,)</span></dt><dd><p>center of the grid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="pdf-odf">
<h3>pdf_odf<a class="headerlink" href="#pdf-odf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.pdf_odf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">pdf_odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Pr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rradius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_coords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#pdf_odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.pdf_odf" title="Link to this definition">#</a></dt>
<dd><p>Calculates the real ODF from the diffusion propagator(PDF) Pr</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Pr</strong><span class="classifier">array, shape (X, X, X)</span></dt><dd><p>probability density function</p>
</dd>
<dt><strong>rradius</strong><span class="classifier">array, shape (N,)</span></dt><dd><p>interpolation range on the radius</p>
</dd>
<dt><strong>interp_coords</strong><span class="classifier">array, shape (3, M, N)</span></dt><dd><p>coordinates in the pdf for interpolating the odf</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="half-to-full-qspace">
<h3>half_to_full_qspace<a class="headerlink" href="#half-to-full-qspace" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.half_to_full_qspace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">half_to_full_qspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#half_to_full_qspace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.half_to_full_qspace" title="Link to this definition">#</a></dt>
<dd><p>Half to full Cartesian grid mapping</p>
<p>Useful when dMRI data are provided in one qspace hemisphere as
DiffusionSpectrum expects data to be in full qspace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (X, Y, Z, W)</span></dt><dd><p>where (X, Y, Z) volume size and W number of gradient directions</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>container for b-values and b-vectors (gradient directions)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_data</strong><span class="classifier">array, shape (X, Y, Z, 2 * W -1)</span></dt><dd><p>DWI data across the full Cartesian space.</p>
</dd>
<dt><strong>new_gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We assume here that only on b0 is provided with the initial data. If that
is not the case then you will need to write your own preparation function
before providing the gradients and the data to the DiffusionSpectrumModel
class.</p>
</dd></dl>

</section>
<section id="project-hemisph-bvecs">
<h3>project_hemisph_bvecs<a class="headerlink" href="#project-hemisph-bvecs" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.project_hemisph_bvecs">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">project_hemisph_bvecs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#project_hemisph_bvecs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.project_hemisph_bvecs" title="Link to this definition">#</a></dt>
<dd><p>Project any near identical bvecs to the other hemisphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">object,</span></dt><dd><p>GradientTable</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Useful only when working with some types of dsi data.</p>
</dd></dl>

</section>
<section id="threshold-propagator">
<h3>threshold_propagator<a class="headerlink" href="#threshold-propagator" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.threshold_propagator">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">threshold_propagator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_snr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#threshold_propagator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.threshold_propagator" title="Link to this definition">#</a></dt>
<dd><p>Applies hard threshold on the propagator to remove background noise for the
deconvolution.</p>
</dd></dl>

</section>
<section id="gen-psf">
<h3>gen_PSF<a class="headerlink" href="#gen-psf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.gen_PSF">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">gen_PSF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qgrid_sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">siz_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">siz_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">siz_z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#gen_PSF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.gen_PSF" title="Link to this definition">#</a></dt>
<dd><p>Generate a PSF for DSI Deconvolution by taking the ifft of the binary
q-space sampling mask and truncating it to keep only the center.</p>
</dd></dl>

</section>
<section id="lr-deconv">
<h3>LR_deconv<a class="headerlink" href="#lr-deconv" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.LR_deconv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">LR_deconv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dsi.html#LR_deconv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dsi.LR_deconv" title="Link to this definition">#</a></dt>
<dd><p>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>prop</strong><span class="classifier">3-D ndarray of dtype float</span></dt><dd><p>The 3D volume to be deconvolve</p>
</dd>
<dt><strong>psf</strong><span class="classifier">3-D ndarray of dtype float</span></dt><dd><p>The filter that will be used for the deconvolution.</p>
</dd>
<dt><strong>numit</strong><span class="classifier">int</span></dt><dd><p>Number of Lucy-Richardson iteration to perform.</p>
</dd>
<dt><strong>acc_factor</strong><span class="classifier">float</span></dt><dd><p>Exponential acceleration factor as in <a class="footnote-reference brackets" href="#footcite-biggs1997" id="id169" role="doc-noteref"><span class="fn-bracket">[</span>36<span class="fn-bracket">]</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id170">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-biggs1997" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id169">36</a><span class="fn-bracket">]</span></span>
<p>David S. C. Biggs and Mark Andrews. Acceleration of iterative image restoration algorithms. <em>Applied Optics</em>, 36(8):1766–1775, March 1997. URL: <a class="reference external" href="https://doi.org/10.1364/AO.36.001766">https://doi.org/10.1364/AO.36.001766</a>, <a class="reference external" href="https://doi.org/10.1364/AO.36.001766">doi:10.1364/AO.36.001766</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="tensormodel">
<h3><a class="reference internal" href="#dipy.reconst.dti.TensorModel" title="dipy.reconst.dti.TensorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorModel</span></code></a><a class="headerlink" href="#tensormodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">TensorModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Diffusion Tensor</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorModel.fit" title="dipy.reconst.dti.TensorModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method of the DTI model class</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorModel.predict" title="dipy.reconst.dti.TensorModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(dti_params, *[, S0])</p></td>
<td><p>Predict a signal for this TensorModel class instance given parameters.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method of the DTI model class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>The measured signal from one voxel.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dti_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorModel.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorModel.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal for this TensorModel class instance given parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dti_params</strong><span class="classifier">ndarray</span></dt><dd><p>The last dimension should have 12 tensor parameters: 3
eigenvalues, followed by the 3 eigenvectors</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="tensorfit">
<h3><a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a><a class="headerlink" href="#tensorfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">TensorFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S0_hat</strong></dt><dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.dti.TensorFit.directions" title="dipy.reconst.dti.TensorFit.directions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></a></dt><dd><p>For tracking - return the primary direction in each voxel</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dti.TensorFit.evals" title="dipy.reconst.dti.TensorFit.evals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></a></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dti.TensorFit.evecs" title="dipy.reconst.dti.TensorFit.evecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></a></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dti.TensorFit.quadratic_form" title="dipy.reconst.dti.TensorFit.quadratic_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></a></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.ad" title="dipy.reconst.dti.TensorFit.ad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code></a>()</p></td>
<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.adc" title="dipy.reconst.dti.TensorFit.adc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code></a>(sphere)</p></td>
<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on the sphere for each voxel in the data</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.color_fa" title="dipy.reconst.dti.TensorFit.color_fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code></a>()</p></td>
<td><p>Color fractional anisotropy of diffusion tensor</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.fa" title="dipy.reconst.dti.TensorFit.fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code></a>()</p></td>
<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.ga" title="dipy.reconst.dti.TensorFit.ga"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code></a>()</p></td>
<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.linearity" title="dipy.reconst.dti.TensorFit.linearity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code></a>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.md" title="dipy.reconst.dti.TensorFit.md"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code></a>()</p></td>
<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.mode" title="dipy.reconst.dti.TensorFit.mode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code></a>()</p></td>
<td><p>Tensor mode calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.odf" title="dipy.reconst.dti.TensorFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</p></td>
<td><p>The diffusion orientation distribution function (dODF).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.planarity" title="dipy.reconst.dti.TensorFit.planarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code></a>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.predict" title="dipy.reconst.dti.TensorFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab, *[, S0, step])</p></td>
<td><p>Given a model fit, predict the signal on the vertices of a sphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.rd" title="dipy.reconst.dti.TensorFit.rd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code></a>()</p></td>
<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.sphericity" title="dipy.reconst.dti.TensorFit.sphericity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code></a>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit.trace" title="dipy.reconst.dti.TensorFit.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>()</p></td>
<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>lower_triangular</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.S0_hat">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">S0_hat</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.S0_hat" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.ad">
<span class="sig-name descname"><span class="pre">ad</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.ad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.ad" title="Link to this definition">#</a></dt>
<dd><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ad</strong><span class="classifier">array (V, 1)</span></dt><dd><p>Calculated AD.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>AD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[AD = \lambda_1\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.adc">
<span class="sig-name descname"><span class="pre">adc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.adc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.adc" title="Link to this definition">#</a></dt>
<dd><p>Calculate the apparent diffusion coefficient (ADC) in each direction on
the sphere for each voxel in the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere class instance</span></dt><dd><p>Sphere providing sample directions to compute the apparent diffusion
coefficient.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>adc</strong><span class="classifier">ndarray</span></dt><dd><p>The estimates of the apparent diffusion coefficient in every
direction on the input sphere</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The calculation of ADC, relies on the following relationship:</p>
<div class="math notranslate nohighlight">
\[ADC = \vec{b} Q \vec{b}^T\]</div>
<p>Where Q is the quadratic form of the tensor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.color_fa">
<span class="sig-name descname"><span class="pre">color_fa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.color_fa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.color_fa" title="Link to this definition">#</a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.directions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">directions</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.directions" title="Link to this definition">#</a></dt>
<dd><p>For tracking - return the primary direction in each voxel</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.evals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">evals</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.evals" title="Link to this definition">#</a></dt>
<dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.evecs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">evecs</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.evecs" title="Link to this definition">#</a></dt>
<dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.fa">
<span class="sig-name descname"><span class="pre">fa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.fa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.fa" title="Link to this definition">#</a></dt>
<dd><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.ga">
<span class="sig-name descname"><span class="pre">ga</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.ga"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.ga" title="Link to this definition">#</a></dt>
<dd><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.linearity">
<span class="sig-name descname"><span class="pre">linearity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.linearity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.linearity" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>linearity</strong><span class="classifier">array</span></dt><dd><p>Calculated linearity of the diffusion tensor
<a class="footnote-reference brackets" href="#footcite-westin1997" id="id171" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Linearity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Linearity =
\frac{\lambda_1-\lambda_2}{\lambda_1+\lambda_2+\lambda_3}\]</div>
<p class="rubric">References</p>
<div class="docutils container" id="id172">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-westin1997" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id171">1</a>,<a role="doc-backlink" href="#id176">2</a>,<a role="doc-backlink" href="#id177">3</a>,<a role="doc-backlink" href="#id195">4</a>,<a role="doc-backlink" href="#id196">5</a>,<a role="doc-backlink" href="#id197">6</a>)</span>
<p>Carl-Fredrik Westin, Sharon Peled, Hákon Gudbjartsson, Ron Kikinis, and Ferenc Jolesz. Geometrical diffusion measures for MRI from tensor basis analysis. In <em>5th Scientific Meeting and Exhibition</em>, volume. Vancouver, Canada, 1997. International Society for Magnetic Resonance in Medicine (ISMRM).</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.lower_triangular">
<span class="sig-name descname"><span class="pre">lower_triangular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.lower_triangular"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.lower_triangular" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.md">
<span class="sig-name descname"><span class="pre">md</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.md"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.md" title="Link to this definition">#</a></dt>
<dd><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>md</strong><span class="classifier">array (V, 1)</span></dt><dd><p>Calculated MD.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>MD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[MD = \frac{\lambda_1+\lambda_2+\lambda_3}{3}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.mode">
<span class="sig-name descname"><span class="pre">mode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.mode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.mode" title="Link to this definition">#</a></dt>
<dd><p>Tensor mode calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.odf" title="Link to this definition">#</a></dt>
<dd><p>The diffusion orientation distribution function (dODF). This is an
estimate of the diffusion distance in each direction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere class instance.</span></dt><dd><p>The dODF is calculated in the vertices of this input.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>odf</strong><span class="classifier">ndarray</span></dt><dd><p>The diffusion distance in every direction of the sphere in every
voxel in the input data.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is based on equation 3 in <a class="footnote-reference brackets" href="#footcite-aganj2010" id="id173" role="doc-noteref"><span class="fn-bracket">[</span>38<span class="fn-bracket">]</span></a>. To re-derive it
from scratch, follow steps in <a class="footnote-reference brackets" href="#footcite-descoteaux2008b" id="id174" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>, Section 7.9
Equation 7.24 but with an <span class="math notranslate nohighlight">\(r^2\)</span> term in the integral.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id175">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-aganj2010" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id173">38</a><span class="fn-bracket">]</span></span>
<p>Iman Aganj, Christophe Lenglet, Guillermo Sapiro, Essa Yacoub, Kamil Ugurbil, and Noam Harel. Reconstruction of the orientation distribution function in single- and multiple-shell q-ball imaging within constant solid angle. <em>Magnetic Resonance in Medicine</em>, 64(2):554–566, 2010. URL: <a class="reference external" href="https://onlinelibrary.wiley.com/doi/abs/10.1002/mrm.22365">https://onlinelibrary.wiley.com/doi/abs/10.1002/mrm.22365</a>, <a class="reference external" href="https://doi.org/https://doi.org/10.1002/mrm.22365">doi:https://doi.org/10.1002/mrm.22365</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.planarity">
<span class="sig-name descname"><span class="pre">planarity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.planarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.planarity" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphericity</strong><span class="classifier">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor
<a class="footnote-reference brackets" href="#footcite-westin1997" id="id176" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Sphericity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Sphericity =
\frac{2 (\lambda_2 - \lambda_3)}{\lambda_1+\lambda_2+\lambda_3}\]</div>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Given a model fit, predict the signal on the vertices of a sphere</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>This encodes the directions for which a prediction is made</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float array, optional</span></dt><dd><p>The mean non-diffusion weighted signal in each voxel. Default:
The fitted S0 value in all voxels if it was fitted. Otherwise 1 in
all voxels.</p>
</dd>
<dt><strong>step</strong><span class="classifier">int, optional</span></dt><dd><p>The chunk size as a number of voxels. Optional parameter with
default value 10,000.</p>
<p>In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. This parameter sets the number of
voxels that will be fit at once in each iteration. A larger step
value should speed things up, but it will also take up more memory.
It is advisable to keep an eye on memory consumption as this value
is increased.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S(\theta, b) = S_0 * e^{-b ADC}\]</div>
<p>Where:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ADC</span> <span class="o">=</span> \<span class="n">theta</span> <span class="n">Q</span> \<span class="n">theta</span><span class="o">^</span><span class="n">T</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(\theta\)</span> is a unit vector pointing at any direction on the sphere for
which a signal is to be predicted and <span class="math notranslate nohighlight">\(b\)</span> is the b value provided in
the GradientTable input for that direction</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.quadratic_form">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">quadratic_form</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.quadratic_form" title="Link to this definition">#</a></dt>
<dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.rd">
<span class="sig-name descname"><span class="pre">rd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.rd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.rd" title="Link to this definition">#</a></dt>
<dd><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rd</strong><span class="classifier">array (V, 1)</span></dt><dd><p>Calculated RD.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>RD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[RD = \frac{\lambda_2 + \lambda_3}{2}\]</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.shape" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.sphericity">
<span class="sig-name descname"><span class="pre">sphericity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.sphericity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.sphericity" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphericity</strong><span class="classifier">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor
<a class="footnote-reference brackets" href="#footcite-westin1997" id="id177" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Sphericity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Sphericity = \frac{3 \lambda_3}{\lambda_1+\lambda_2+\lambda_3}\]</div>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.trace">
<span class="sig-name descname"><span class="pre">trace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#TensorFit.trace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.TensorFit.trace" title="Link to this definition">#</a></dt>
<dd><p>Trace of the tensor calculated from cached eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trace</strong><span class="classifier">array (V, 1)</span></dt><dd><p>Calculated trace.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The trace is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[trace = \lambda_1 + \lambda_2 + \lambda_3\]</div>
</dd></dl>

</dd></dl>

</section>
<section id="fractional-anisotropy">
<h3>fractional_anisotropy<a class="headerlink" href="#fractional-anisotropy" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.fractional_anisotropy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">fractional_anisotropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#fractional_anisotropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.fractional_anisotropy" title="Link to this definition">#</a></dt>
<dd><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fa</strong><span class="classifier">array</span></dt><dd><p>Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>FA is calculated using the following equation:</p>
<div class="math notranslate nohighlight">
\[FA = \sqrt{\frac{1}{2}\frac{(\lambda_1-\lambda_2)^2+(\lambda_1-
            \lambda_3)^2+(\lambda_2-\lambda_3)^2}{\lambda_1^2+
            \lambda_2^2+\lambda_3^2}}\]</div>
</dd></dl>

</section>
<section id="geodesic-anisotropy">
<h3>geodesic_anisotropy<a class="headerlink" href="#geodesic-anisotropy" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.geodesic_anisotropy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">geodesic_anisotropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#geodesic_anisotropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.geodesic_anisotropy" title="Link to this definition">#</a></dt>
<dd><p>Geodesic anisotropy (GA) of a diffusion tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ga</strong><span class="classifier">array</span></dt><dd><p>Calculated GA. In the range 0 to +infinity</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>GA is calculated using the following equation given in
<a class="footnote-reference brackets" href="#footcite-batchelor2005" id="id178" role="doc-noteref"><span class="fn-bracket">[</span>39<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[GA = \sqrt{\sum_{i=1}^3
\log^2{\left ( \lambda_i/&lt;\mathbf{D}&gt; \right )}},
\quad \textrm{where} \quad &lt;\mathbf{D}&gt; =
(\lambda_1\lambda_2\lambda_3)^{1/3}\]</div>
<p>Note that the notation, <span class="math notranslate nohighlight">\(&lt;D&gt;\)</span>, is often used as the mean diffusivity (MD)
of the diffusion tensor and can lead to confusions in the literature
(see <a class="footnote-reference brackets" href="#footcite-batchelor2005" id="id179" role="doc-noteref"><span class="fn-bracket">[</span>39<span class="fn-bracket">]</span></a> versus <a class="footnote-reference brackets" href="#footcite-correia2011b" id="id180" role="doc-noteref"><span class="fn-bracket">[</span>40<span class="fn-bracket">]</span></a> versus
<a class="footnote-reference brackets" href="#footcite-lee2008" id="id181" role="doc-noteref"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></a> for example). <a class="footnote-reference brackets" href="#footcite-correia2011b" id="id182" role="doc-noteref"><span class="fn-bracket">[</span>40<span class="fn-bracket">]</span></a> defines
geodesic anisotropy (GA) with <span class="math notranslate nohighlight">\(&lt;D&gt;\)</span> as the MD in the denominator of the
sum. This is wrong. The original paper <a class="footnote-reference brackets" href="#footcite-batchelor2005" id="id183" role="doc-noteref"><span class="fn-bracket">[</span>39<span class="fn-bracket">]</span></a> defines
GA with  <span class="math notranslate nohighlight">\(&lt;D&gt; = det(D)^{1/3}\)</span>, as the isotropic part of the distance. This
might be an explanation for the confusion. The isotropic part of the
diffusion tensor in Euclidean space is the MD whereas the isotropic part of
the tensor in log-Euclidean space is <span class="math notranslate nohighlight">\(det(D)^{1/3}\)</span>. The Appendix of
<a class="footnote-reference brackets" href="#footcite-batchelor2005" id="id184" role="doc-noteref"><span class="fn-bracket">[</span>39<span class="fn-bracket">]</span></a> and log-Euclidean derivations from
<a class="footnote-reference brackets" href="#footcite-lee2008" id="id185" role="doc-noteref"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></a> are clear on this. Hence, all that to say that
<span class="math notranslate nohighlight">\(&lt;D&gt; = det(D)^{1/3}\)</span> here for the GA definition and not MD.</p>
<p>See also <a class="footnote-reference brackets" href="#footcite-arsigny2006" id="id186" role="doc-noteref"><span class="fn-bracket">[</span>42<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id187">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-batchelor2005" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>39<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id178">1</a>,<a role="doc-backlink" href="#id179">2</a>,<a role="doc-backlink" href="#id183">3</a>,<a role="doc-backlink" href="#id184">4</a>)</span>
<p>Phillipp G. Batchelor, Maher Moakher, David Atkinson, Fernando Calamante, and Alan Connelly. A rigorous framework for diffusion tensor calculus. <em>Magnetic Resonance in Medicine</em>, 53(1):221–225, 2005. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.20334">https://doi.org/10.1002/mrm.20334</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.20334">doi:10.1002/mrm.20334</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-correia2011b" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>40<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id180">1</a>,<a role="doc-backlink" href="#id182">2</a>)</span>
<p>Marta Morgado Correia, Virginia F. J. Newcombe, and Guy B. Williams. Contrast-to-noise ratios for indices of anisotropy obtained from diffusion MRI: A study with standard clinical b-values at 3T. <em>NeuroImage</em>, 57(3):1103–1115, August 2011. Special Issue: Educational Neuroscience. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2011.03.004">https://doi.org/10.1016/j.neuroimage.2011.03.004</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2011.03.004">doi:10.1016/j.neuroimage.2011.03.004</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-lee2008" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id181">1</a>,<a role="doc-backlink" href="#id185">2</a>)</span>
<p>Agatha D. Lee, Natasha Lepore, Marina Barysheva, Yi-Yu Chou, Caroline Brun, Sarah K. Madsen, Katie L. McMahon, Greig I. de Zubicaray, Matthew Meredith, Margaret J. Wright, Arthur W. Toga, and Paul M. Thompson. Comparison of fractional and geodesic anisotropy in diffusion tensor images of 90 monozygotic and dizygotic twins. In <em>2008 5th IEEE International Symposium on Biomedical Imaging: From Nano to Macro</em>, volume, 943–946. May 2008. <a class="reference external" href="https://doi.org/10.1109/ISBI.2008.4541153">doi:10.1109/ISBI.2008.4541153</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-arsigny2006" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id186">42</a><span class="fn-bracket">]</span></span>
<p>Vincent Arsigny, Pierre Fillard, Xavier Pennec, and Nicholas Ayache. Log-Euclidean metrics for fast and simple calculus on diffusion tensors. <em>Magnetic Resonance in Medicine</em>, 56(2):411–421, 2006. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.20965">https://doi.org/10.1002/mrm.20965</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.20965">doi:10.1002/mrm.20965</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="mean-diffusivity">
<h3>mean_diffusivity<a class="headerlink" href="#mean-diffusivity" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.mean_diffusivity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">mean_diffusivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#mean_diffusivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.mean_diffusivity" title="Link to this definition">#</a></dt>
<dd><p>Mean Diffusivity (MD) of a diffusion tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>md</strong><span class="classifier">array</span></dt><dd><p>Calculated MD.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>MD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[MD = \frac{\lambda_1 + \lambda_2 + \lambda_3}{3}\]</div>
</dd></dl>

</section>
<section id="axial-diffusivity">
<h3>axial_diffusivity<a class="headerlink" href="#axial-diffusivity" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.axial_diffusivity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">axial_diffusivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#axial_diffusivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.axial_diffusivity" title="Link to this definition">#</a></dt>
<dd><p>Axial Diffusivity (AD) of a diffusion tensor.
Also called parallel diffusivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ad</strong><span class="classifier">array</span></dt><dd><p>Calculated AD.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>AD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[AD = \lambda_1\]</div>
</dd></dl>

</section>
<section id="radial-diffusivity">
<h3>radial_diffusivity<a class="headerlink" href="#radial-diffusivity" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.radial_diffusivity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">radial_diffusivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#radial_diffusivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.radial_diffusivity" title="Link to this definition">#</a></dt>
<dd><p>Radial Diffusivity (RD) of a diffusion tensor.
Also called perpendicular diffusivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rd</strong><span class="classifier">array</span></dt><dd><p>Calculated RD.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>RD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[RD = \frac{\lambda_2 + \lambda_3}{2}\]</div>
</dd></dl>

</section>
<section id="trace">
<h3>trace<a class="headerlink" href="#trace" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.trace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#trace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.trace" title="Link to this definition">#</a></dt>
<dd><p>Trace of a diffusion tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>trace</strong><span class="classifier">array</span></dt><dd><p>Calculated trace of the diffusion tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Trace is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Trace = \lambda_1 + \lambda_2 + \lambda_3\]</div>
</dd></dl>

</section>
<section id="color-fa">
<h3>color_fa<a class="headerlink" href="#color-fa" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.color_fa">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">color_fa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evecs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#color_fa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.color_fa" title="Link to this definition">#</a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fa</strong><span class="classifier">array-like</span></dt><dd><p>Array of the fractional anisotropy (can be 1D, 2D or 3D)</p>
</dd>
<dt><strong>evecs</strong><span class="classifier">array-like</span></dt><dd><p>eigen vectors from the tensor model</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">Array with 3 channels for each color as the last dimension.</span></dt><dd><p>Colormap of the FA with red for the x value, y for the green
value and z for the blue value.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is computed from the clipped FA between 0 and 1 using the following
formula</p>
<div class="math notranslate nohighlight">
\[rgb = abs(max(\vec{e})) \times fa\]</div>
</dd></dl>

</section>
<section id="determinant">
<h3>determinant<a class="headerlink" href="#determinant" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.determinant">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">determinant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#determinant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.determinant" title="Link to this definition">#</a></dt>
<dd><p>The determinant of a tensor, given in quadratic form</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_form</strong><span class="classifier">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>det</strong><span class="classifier">array</span></dt><dd><p>The determinant of the tensor in each spatial coordinate</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="isotropic">
<h3>isotropic<a class="headerlink" href="#isotropic" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.isotropic">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">isotropic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#isotropic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.isotropic" title="Link to this definition">#</a></dt>
<dd><p>Calculate the isotropic part of the tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ennis2006" id="id188" role="doc-noteref"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_form</strong><span class="classifier">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>A_hat: ndarray</dt><dd><p>The isotropic part of the tensor in each spatial coordinate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The isotropic part of a tensor is defined as (equations 3-5 of
<a class="footnote-reference brackets" href="#footcite-ennis2006" id="id189" role="doc-noteref"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></a>):</p>
<div class="math notranslate nohighlight">
\[\bar{A} = \frac{1}{2} tr(A) I\]</div>
<p class="rubric">References</p>
<div class="docutils container" id="id190">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-ennis2006" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id188">1</a>,<a role="doc-backlink" href="#id189">2</a>,<a role="doc-backlink" href="#id191">3</a>,<a role="doc-backlink" href="#id192">4</a>,<a role="doc-backlink" href="#id193">5</a>,<a role="doc-backlink" href="#id194">6</a>)</span>
<p>Daniel B. Ennis and Gordon Kindlmann. Orthogonal tensor invariants and the analysis of diffusion tensor magnetic resonance images. <em>Magnetic Resonance in Medicine</em>, 55(1):136–146, 2006. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.20741">https://doi.org/10.1002/mrm.20741</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.20741">doi:10.1002/mrm.20741</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="deviatoric">
<h3>deviatoric<a class="headerlink" href="#deviatoric" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.deviatoric">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">deviatoric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#deviatoric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.deviatoric" title="Link to this definition">#</a></dt>
<dd><p>Calculate the deviatoric (anisotropic) part of the tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ennis2006" id="id191" role="doc-noteref"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_form</strong><span class="classifier">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A_squiggle</strong><span class="classifier">ndarray</span></dt><dd><p>The deviatoric part of the tensor in each spatial coordinate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The deviatoric part of the tensor is defined as (equations 3-5 in
<a class="footnote-reference brackets" href="#footcite-ennis2006" id="id192" role="doc-noteref"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></a>):</p>
<div class="math notranslate nohighlight">
\[\widetilde{A} = A - \bar{A}\]</div>
<p>Where <span class="math notranslate nohighlight">\(A\)</span> is the tensor quadratic form and <span class="math notranslate nohighlight">\(\bar{A}\)</span> is the anisotropic
part of the tensor.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="norm">
<h3>norm<a class="headerlink" href="#norm" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.norm">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.norm" title="Link to this definition">#</a></dt>
<dd><p>Calculate the Frobenius norm of a tensor quadratic form</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_form: ndarray</strong></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">ndarray</span></dt><dd><p>The Frobenius norm of the 3,3 tensor q_form in each spatial
coordinate.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.linalg.norm</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The Frobenius norm is defined as:</p>
<div class="math notranslate nohighlight">
\[||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}\]</div>
</dd></dl>

</section>
<section id="mode">
<h3>mode<a class="headerlink" href="#mode" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.mode">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#mode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.mode" title="Link to this definition">#</a></dt>
<dd><p>Mode (MO) of a diffusion tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ennis2006" id="id193" role="doc-noteref"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_form</strong><span class="classifier">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mode</strong><span class="classifier">array</span></dt><dd><p>Calculated tensor mode in each spatial coordinate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Mode ranges between -1 (planar anisotropy) and +1 (linear anisotropy)
with 0 representing isotropy. Mode is calculated with the following
equation (equation 9 in <a class="footnote-reference brackets" href="#footcite-ennis2006" id="id194" role="doc-noteref"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></a>):</p>
<div class="math notranslate nohighlight">
\[Mode = 3*\sqrt{6}*det(\widetilde{A}/norm(\widetilde{A}))\]</div>
<p>Where <span class="math notranslate nohighlight">\(\widetilde{A}\)</span> is the deviatoric part of the tensor quadratic form.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="linearity">
<h3>linearity<a class="headerlink" href="#linearity" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.linearity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">linearity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#linearity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.linearity" title="Link to this definition">#</a></dt>
<dd><p>The linearity of the tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-westin1997" id="id195" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>linearity</strong><span class="classifier">array</span></dt><dd><p>Calculated linearity of the diffusion tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Linearity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Linearity = \frac{\lambda_1-\lambda_2}{\lambda_1+\lambda_2+\lambda_3}\]</div>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="planarity">
<h3>planarity<a class="headerlink" href="#planarity" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.planarity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">planarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#planarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.planarity" title="Link to this definition">#</a></dt>
<dd><p>The planarity of the tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-westin1997" id="id196" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>linearity</strong><span class="classifier">array</span></dt><dd><p>Calculated linearity of the diffusion tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Planarity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Planarity =
\frac{2 (\lambda_2-\lambda_3)}{\lambda_1+\lambda_2+\lambda_3}\]</div>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="sphericity">
<h3>sphericity<a class="headerlink" href="#sphericity" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.sphericity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">sphericity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#sphericity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.sphericity" title="Link to this definition">#</a></dt>
<dd><p>The sphericity of the tensor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-westin1997" id="id197" role="doc-noteref"><span class="fn-bracket">[</span>37<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evals</strong><span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sphericity</strong><span class="classifier">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Sphericity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Sphericity = \frac{3 \lambda_3)}{\lambda_1+\lambda_2+\lambda_3}\]</div>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="apparent-diffusion-coef">
<h3>apparent_diffusion_coef<a class="headerlink" href="#apparent-diffusion-coef" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.apparent_diffusion_coef">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">apparent_diffusion_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#apparent_diffusion_coef"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.apparent_diffusion_coef" title="Link to this definition">#</a></dt>
<dd><p>Calculate the apparent diffusion coefficient (ADC) in each direction of a
sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_form</strong><span class="classifier">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (…, 3, 3)</p>
</dd>
<dt><strong>sphere</strong><span class="classifier">a Sphere class instance</span></dt><dd><p>The ADC will be calculated for each of the vertices in the sphere</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The calculation of ADC, relies on the following relationship:</p>
<div class="math notranslate nohighlight">
\[ADC = \vec{b} Q \vec{b}^T\]</div>
<p>Where Q is the quadratic form of the tensor.</p>
</dd></dl>

</section>
<section id="tensor-prediction">
<h3>tensor_prediction<a class="headerlink" href="#tensor-prediction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.tensor_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">tensor_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dti_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#tensor_prediction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.tensor_prediction" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal given tensor parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dti_params</strong><span class="classifier">ndarray</span></dt><dd><p>Tensor parameters. The last dimension should have 12 tensor
parameters: 3 eigenvalues, followed by the 3 corresponding
eigenvectors.</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S(\theta, b) = S_0 * e^{-b ADC}\]</div>
<p>where <span class="math notranslate nohighlight">\(ADC = \theta Q \theta^T\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span> is a unit vector pointing at any
direction on the sphere for which a signal is to be predicted, <span class="math notranslate nohighlight">\(b\)</span> is the b
value provided in the GradientTable input for that direction, <span class="math notranslate nohighlight">\(Q\)</span> is the
quadratic form of the tensor determined by the input parameters.</p>
</dd></dl>

</section>
<section id="iter-fit-tensor">
<h3>iter_fit_tensor<a class="headerlink" href="#iter-fit-tensor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.iter_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">iter_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#iter_fit_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.iter_fit_tensor" title="Link to this definition">#</a></dt>
<dd><p>Wrap a fit_tensor func and iterate over chunks of data with given length</p>
<p>Splits data into a number of chunks of specified size and iterates the
decorated fit_tensor function over them. This is useful to counteract the
temporary but significant memory usage increase in fit_tensor functions
that use vectorized operations and need to store large temporary arrays for
their vectorized operations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>step</strong><span class="classifier">int, optional</span></dt><dd><p>The chunk size as a number of voxels. Optional parameter with default
value 10,000.</p>
<p>In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. This parameter sets the number of
voxels that will be fit at once in each iteration. A larger step value
should speed things up, but it will also take up more memory. It is
advisable to keep an eye on memory consumption as this value is
increased.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="wls-fit-tensor">
<h3>wls_fit_tensor<a class="headerlink" href="#wls-fit-tensor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.wls_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">wls_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_lower_triangular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_leverages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#wls_fit_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.wls_fit_tensor" title="Link to this definition">#</a></dt>
<dd><p>Computes weighted least squares (WLS) fit to calculate self-diffusion
tensor using a linear regression model.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-chung2006" id="id198" role="doc-noteref"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array ([X, Y, Z, …], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array ([X, Y, Z, …], g), optional</span></dt><dd><p>Weights to apply for fitting. These weights must correspond to the
squared residuals such that <span class="math notranslate nohighlight">\(S = \sum_i w_i r_i^2\)</span>.
If not provided, weights are estimated as the squared predicted signal
from an initial OLS fit <a class="footnote-reference brackets" href="#footcite-chung2006" id="id199" role="doc-noteref"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></a>.</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>return_lower_triangular</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the coefficients of the fit.</p>
</dd>
<dt><strong>return_leverages</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the fitting leverages.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigvals</strong><span class="classifier">array (…, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt><strong>eigvecs</strong><span class="classifier">array (…, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
<dt><strong>leverages</strong><span class="classifier">array (g)</span></dt><dd><p>Leverages of the fitting problem (if return_leverages is True)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>In Chung, et al. 2006, the regression of the WLS fit needed an unbiased
preliminary estimate of the weights and therefore the ordinary least
squares (OLS) estimates were used. A “two pass” method was implemented:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>calculate OLS estimates of the data</p></li>
<li><p>apply the OLS estimates as weights to the WLS fit of the data</p></li>
</ol>
</div></blockquote>
<p>This ensured heteroscedasticity could be properly modeled for various
types of bootstrap resampling (namely residual bootstrap).</p>
<div class="math notranslate nohighlight">
\[\begin{split}y = \mathrm{data} \\
X = \mathrm{design matrix} \\
\hat{\beta}_\mathrm{WLS} =
\mathrm{desired regression coefficients (e.g. tensor)}\\
\\
\hat{\beta}_\mathrm{WLS} = (X^T W X)^{-1} X^T W y \\
\\
W = \mathrm{diag}((X \hat{\beta}_\mathrm{OLS})^2),
\mathrm{where} \hat{\beta}_\mathrm{OLS} = (X^T X)^{-1} X^T y\end{split}\]</div>
<p class="rubric">References</p>
<div class="docutils container" id="id200">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-chung2006" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id198">1</a>,<a role="doc-backlink" href="#id199">2</a>,<a role="doc-backlink" href="#id201">3</a>)</span>
<p>SungWon Chung, Ying Lu, and Roland G. Henry. Comparison of bootstrap approaches for estimation of uncertainties of DTI parameters. <em>NeuroImage</em>, 33(2):531–541, 2006. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2006.07.001">https://doi.org/10.1016/j.neuroimage.2006.07.001</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2006.07.001">doi:10.1016/j.neuroimage.2006.07.001</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="ols-fit-tensor">
<h3>ols_fit_tensor<a class="headerlink" href="#ols-fit-tensor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.ols_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">ols_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_lower_triangular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_leverages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#ols_fit_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.ols_fit_tensor" title="Link to this definition">#</a></dt>
<dd><p>Computes ordinary least squares (OLS) fit to calculate self-diffusion
tensor using a linear regression model.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-chung2006" id="id201" role="doc-noteref"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array ([X, Y, Z, …], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>return_lower_triangular</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the coefficients of the fit.</p>
</dd>
<dt><strong>return_leverages</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the fitting leverages.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigvals</strong><span class="classifier">array (…, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt><strong>eigvecs</strong><span class="classifier">array (…, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
<dt><strong>leverages</strong><span class="classifier">array (g)</span></dt><dd><p>Leverages of the fitting problem (if return_leverages is True)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">WLS_fit_tensor</span></code>, <a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a>, <a class="reference internal" href="#dipy.reconst.dti.design_matrix" title="dipy.reconst.dti.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}y = \mathrm{data} \\
X = \mathrm{design matrix} \\\end{split}\\\hat{\beta}_\mathrm{OLS} = (X^T X)^{-1} X^T y\end{aligned}\end{align} \]</div>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="nlls-fit-tensor">
<h3>nlls_fit_tensor<a class="headerlink" href="#nlls-fit-tensor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.nlls_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">nlls_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fail_is_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_lower_triangular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_leverages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#nlls_fit_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.nlls_fit_tensor" title="Link to this definition">#</a></dt>
<dd><p>Fit the cumulant expansion params (e.g. DTI, DKI) using non-linear
least-squares.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g, Npar)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients. First six parameters of design matrix should correspond
to the six unique diffusion tensor elements in the lower triangular
order (Dxx, Dxy, Dyy, Dxz, Dyz, Dzz), while last parameter to -log(S0)</p>
</dd>
<dt><strong>data</strong><span class="classifier">array ([X, Y, Z, …], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array ([X, Y, Z, …], g), optional</span></dt><dd><p>Weights to apply for fitting. These weights must correspond to the
squared residuals such that <span class="math notranslate nohighlight">\(S = \sum_i w_i r_i^2\)</span>.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">bool, optional</span></dt><dd><p>Use the Jacobian?</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>fail_is_nan</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to set failed NL fitting to NaN (True) or LS (False, default).</p>
</dd>
<dt><strong>return_lower_triangular</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the coefficients of the fit.</p>
</dd>
<dt><strong>return_leverages</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the fitting leverages.</p>
</dd>
<dt><strong>init_params</strong><span class="classifier">array ([X, Y, Z, …], Npar), optional</span></dt><dd><p>Parameters in lower triangular form as initial optimization guess.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>nlls_params: the eigen-values and eigen-vectors of the tensor in each</dt><dd><p>voxel.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="restore-fit-tensor">
<h3>restore_fit_tensor<a class="headerlink" href="#restore-fit-tensor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.restore_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">restore_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fail_is_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#restore_fit_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.restore_fit_tensor" title="Link to this definition">#</a></dt>
<dd><p>Compute a robust tensor fit using the RESTORE algorithm.</p>
<p>Note that the RESTORE algorithm defined in <a class="footnote-reference brackets" href="#footcite-chang2005" id="id202" role="doc-noteref"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></a> does not define
Geman–McClure M-estimator weights as claimed (instead, Cauchy M-estimator
weights are defined), but this function does define correct Geman–McClure
M-estimator weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array of shape (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array of shape ([X, Y, Z, n_directions], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>An estimate of the variance. <a class="footnote-reference brackets" href="#footcite-chang2005" id="id203" role="doc-noteref"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></a> recommend to use
1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).
If not provided, will be estimated per voxel as:
sigma = 1.4826 * sqrt(N / (N - p)) * MAD(residuals)
as in <a class="footnote-reference brackets" href="#footcite-chang2012" id="id204" role="doc-noteref"><span class="fn-bracket">[</span>46<span class="fn-bracket">]</span></a> but with the additional correction factor
1.4826 required to link standard deviation to MAD.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to use the Jacobian of the tensor to speed the non-linear
optimization procedure used to fit the tensor parameters (see also
<a class="reference internal" href="#dipy.reconst.dti.nlls_fit_tensor" title="dipy.reconst.dti.nlls_fit_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">nlls_fit_tensor()</span></code></a>).</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>fail_is_nan</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to set failed NL fitting to NaN (True) or LS (False).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>restore_params</strong><span class="classifier">an estimate of the tensor parameters in each voxel.</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id205">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-chang2005" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id202">1</a>,<a role="doc-backlink" href="#id203">2</a>,<a role="doc-backlink" href="#id217">3</a>,<a role="doc-backlink" href="#id218">4</a>)</span>
<p>Lin-Ching Chang, Derek K. Jones, and Carlo Pierpaoli. RESTORE: Robust estimation of tensors by outlier rejection. <em>Magnetic Resonance in Medicine</em>, 53(5):1088–1095, 2005. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.20426">https://doi.org/10.1002/mrm.20426</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.20426">doi:10.1002/mrm.20426</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-chang2012" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id204">46</a><span class="fn-bracket">]</span></span>
<p>Lin-Ching Chang, Lindsay Walker, and Carlo Pierpaoli. Informed RESTORE: A method for robust estimation of diffusion tensor from low redundancy datasets in the presence of physiological noise artifacts. <em>Magnetic Resonance in Medicine</em>, 68(5):1654–1663, 2012. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.24173">https://doi.org/10.1002/mrm.24173</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.24173">doi:10.1002/mrm.24173</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="iterative-fit-tensor">
<h3>iterative_fit_tensor<a class="headerlink" href="#iterative-fit-tensor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.iterative_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">iterative_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#iterative_fit_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.iterative_fit_tensor" title="Link to this definition">#</a></dt>
<dd><p>Iteratively Reweighted fitting for the DTI/DKI model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>design_matrix</strong><span class="classifier">ndarray of shape (g, …)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray of shape ([X, Y, Z, n_directions], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">bool, optional</span></dt><dd><p>Use the Jacobian for NLLS fitting (does nothing for WLS fitting).</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>fit_type</strong><span class="classifier">str, optional</span></dt><dd><p>Whether to use NLLS or WLS fitting scheme.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of times to iterate.</p>
</dd>
<dt><strong>weights_method</strong><span class="classifier">callable, optional</span></dt><dd><p>A function with args and returns as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">robust</span><span class="p">)</span> <span class="o">=</span> <span class="n">weights_method</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pred_sig</span><span class="p">,</span> <span class="n">design_matrix</span><span class="p">,</span>
                                   <span class="n">leverages</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">robust</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Take care to supply an appropriate weights_method for the fit_type.
It is possible to use NLLS fitting with weights designed for WLS fitting,
but this is a user error.</p>
</dd></dl>

</section>
<section id="robust-fit-tensor-wls">
<h3>robust_fit_tensor_wls<a class="headerlink" href="#robust-fit-tensor-wls" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.robust_fit_tensor_wls">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">robust_fit_tensor_wls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#robust_fit_tensor_wls"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.robust_fit_tensor_wls" title="Link to this definition">#</a></dt>
<dd><p>Iteratively Reweighted fitting for WLS for the DTI/DKI model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">ndarray of shape (g, …)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray of shape ([X, Y, Z, n_directions], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of times to iterate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a convenience function that does:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iterative_fit_tensor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">fit_type</span><span class="o">=</span><span class="s2">&quot;WLS&quot;</span><span class="p">,</span>
                     <span class="n">weights_method</span><span class="o">=</span><span class="n">weights_method_wls</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="robust-fit-tensor-nlls">
<h3>robust_fit_tensor_nlls<a class="headerlink" href="#robust-fit-tensor-nlls" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.robust_fit_tensor_nlls">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">robust_fit_tensor_nlls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#robust_fit_tensor_nlls"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.robust_fit_tensor_nlls" title="Link to this definition">#</a></dt>
<dd><p>Iteratively Reweighted fitting for NLLS for the DTI/DKI model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">ndarray of shape (g, …)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray of shape ([X, Y, Z, n_directions], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">bool, optional</span></dt><dd><p>Use the Jacobian?</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of times to iterate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a convenience function that does:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iterative_fit_tensor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">fit_type</span><span class="o">=</span><span class="s2">&quot;NLLS&quot;</span><span class="p">,</span>
<span class="n">weights_method</span><span class="o">=</span><span class="n">weights_method_nlls</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="from-lower-triangular">
<h3>from_lower_triangular<a class="headerlink" href="#from-lower-triangular" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.from_lower_triangular">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">from_lower_triangular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#from_lower_triangular"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.from_lower_triangular" title="Link to this definition">#</a></dt>
<dd><p>Returns a tensor given the six unique tensor elements</p>
<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,
Dyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are
ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>D</strong><span class="classifier">array_like, (…, &gt;6)</span></dt><dd><p>Unique elements of the tensors</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">ndarray (…, 3, 3)</span></dt><dd><p>3 by 3 tensors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="lower-triangular">
<h3>lower_triangular<a class="headerlink" href="#lower-triangular" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.lower_triangular">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">lower_triangular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#lower_triangular"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.lower_triangular" title="Link to this definition">#</a></dt>
<dd><p>Returns the six lower triangular values of the tensor ordered as
(Dxx, Dxy, Dyy, Dxz, Dyz, Dzz) and a dummy variable if b0 is not None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">array_like (…, 3, 3)</span></dt><dd><p>a collection of 3, 3 diffusion tensors</p>
</dd>
<dt><strong>b0</strong><span class="classifier">float, optional</span></dt><dd><p>if b0 is not none log(b0) is returned as the dummy variable</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>D</strong><span class="classifier">ndarray</span></dt><dd><p>If b0 is none, then the shape will be (…, 6) otherwise (…, 7)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="decompose-tensor">
<h3>decompose_tensor<a class="headerlink" href="#decompose-tensor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.decompose_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">decompose_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#decompose_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.decompose_tensor" title="Link to this definition">#</a></dt>
<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>
<p>Computes tensor eigen decomposition to calculate eigenvalues and
eigenvectors (Basser et al., 1994a).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">array (…, 3, 3)</span></dt><dd><p>Hermitian matrix representing a diffusion tensor.</p>
</dd>
<dt><strong>min_diffusivity</strong><span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigvals</strong><span class="classifier">array (…, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor. Negative
eigenvalues are replaced by zero. Sorted from largest to smallest.</p>
</dd>
<dt><strong>eigvecs</strong><span class="classifier">array (…, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[…, :, j] is associated with
eigvals[…, j])</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="design-matrix">
<h3>design_matrix<a class="headerlink" href="#design-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#design_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.design_matrix" title="Link to this definition">#</a></dt>
<dd><p>Constructs design matrix for DTI weighted least squares or
least squares fitting. (Basser et al., 1994a)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">A GradientTable class instance</span></dt><dd></dd>
<dt><strong>dtype</strong><span class="classifier">str, optional</span></dt><dd><p>Parameter to control the dtype of returned designed matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g,7)</span></dt><dd><p>Design matrix or B matrix assuming Gaussian distributed tensor model
design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="quantize-evecs">
<h3>quantize_evecs<a class="headerlink" href="#quantize-evecs" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.quantize_evecs">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">quantize_evecs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evecs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#quantize_evecs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.quantize_evecs" title="Link to this definition">#</a></dt>
<dd><p>Find the closest orientation of an evenly distributed sphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evecs</strong><span class="classifier">ndarray</span></dt><dd><p>Eigenvectors.</p>
</dd>
<dt><strong>odf_vertices</strong><span class="classifier">ndarray, optional</span></dt><dd><p>If None, then set vertices from symmetric362 sphere.  Otherwise use
passed ndarray as vertices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>IN</strong><span class="classifier">ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="eig-from-lo-tri">
<h3>eig_from_lo_tri<a class="headerlink" href="#eig-from-lo-tri" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.eig_from_lo_tri">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">eig_from_lo_tri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/dti.html#eig_from_lo_tri"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.dti.eig_from_lo_tri" title="Link to this definition">#</a></dt>
<dd><p>Calculates tensor eigenvalues/eigenvectors from an array containing the
lower diagonal form of the six unique tensor elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array_like (…, 6)</span></dt><dd><p>diffusion tensors elements stored in lower triangular order</p>
</dd>
<dt><strong>min_diffusivity</strong><span class="classifier">float, optional</span></dt><dd><p>See decompose_tensor()</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dti_params</strong><span class="classifier">array (…, 12)</span></dt><dd><p>Eigen-values and eigen-vectors of the same array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="forecastmodel">
<h3><a class="reference internal" href="#dipy.reconst.forecast.ForecastModel" title="dipy.reconst.forecast.ForecastModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastModel</span></code></a><a class="headerlink" href="#forecastmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">ForecastModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_lb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dec_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CSD'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_csd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#ForecastModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.ForecastModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>Fiber ORientation Estimated using Continuous Axially Symmetric Tensors
(FORECAST).</p>
<p>FORECAST <a class="footnote-reference brackets" href="#footcite-anderson2005" id="id206" role="doc-noteref"><span class="fn-bracket">[</span>47<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-kaden2016a" id="id207" role="doc-noteref"><span class="fn-bracket">[</span>48<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-zucchelli2017" id="id208" role="doc-noteref"><span class="fn-bracket">[</span>49<span class="fn-bracket">]</span></a> is a Spherical Deconvolution reconstruction
model for multi-shell diffusion data which enables the calculation of a
voxel adaptive response function using the Spherical Mean Technique (SMT)
<a class="footnote-reference brackets" href="#footcite-kaden2016a" id="id209" role="doc-noteref"><span class="fn-bracket">[</span>48<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-zucchelli2017" id="id210" role="doc-noteref"><span class="fn-bracket">[</span>49<span class="fn-bracket">]</span></a>.</p>
<p>With FORECAST it is possible to calculate crossing invariant parallel
diffusivity, perpendicular diffusivity, mean diffusivity, and fractional
anisotropy <a class="footnote-reference brackets" href="#footcite-kaden2016a" id="id211" role="doc-noteref"><span class="fn-bracket">[</span>48<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.ForecastModel.fit" title="dipy.reconst.forecast.ForecastModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">Notes</p>
<p>The implementation of FORECAST may require CVXPY (<a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a>).</p>
<p class="rubric">References</p>
<div class="docutils container" id="id212">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-anderson2005" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id206">47</a><span class="fn-bracket">]</span></span>
<p>Adam W. Anderson. Measurement of fiber orientation distributions using high angular resolution diffusion imaging. <em>Magnetic Resonance in Medicine</em>, 54(5):1194–1206, 2005. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.20667">https://doi.org/10.1002/mrm.20667</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.20667">doi:10.1002/mrm.20667</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-kaden2016a" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>48<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id207">1</a>,<a role="doc-backlink" href="#id209">2</a>,<a role="doc-backlink" href="#id211">3</a>)</span>
<p>Enrico Kaden, Frithjof Kruggel, and Daniel C. Alexander. Quantitative mapping of the per-axon diffusion coefficients in brain white matter. <em>Magnetic Resonance in Medicine</em>, 75(4):1752–1763, April 2016. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.25734">https://doi.org/10.1002/mrm.25734</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.25734">doi:10.1002/mrm.25734</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-zucchelli2017" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>49<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id208">1</a>,<a role="doc-backlink" href="#id210">2</a>)</span>
<p>Mauro Zucchelli, Maxime Descoteaux, and Gloria Menegaz. A generalized SMT-based framework for Diffusion MRI microstructural model estimation. In Enrico Kaden, Francesco Grussu, Lipeng Ning, Chantal M. W. Tax, and Jelle Veraart, editors, <em>Computational Diffusion MRI</em>, 51–63. Cham, 2018. Springer International Publishing.</p>
</aside>
</aside>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="forecastfit">
<h3><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit" title="dipy.reconst.forecast.ForecastFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastFit</span></code></a><a class="headerlink" href="#forecastfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">ForecastFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_par</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_perp</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#ForecastFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.dpar" title="dipy.reconst.forecast.ForecastFit.dpar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dpar</span></code></a></dt><dd><p>The parallel diffusivity</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.dperp" title="dipy.reconst.forecast.ForecastFit.dperp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dperp</span></code></a></dt><dd><p>The perpendicular diffusivity</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.sh_coeff" title="dipy.reconst.forecast.ForecastFit.sh_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_coeff</span></code></a></dt><dd><p>The FORECAST SH coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.fractional_anisotropy" title="dipy.reconst.forecast.ForecastFit.fractional_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractional_anisotropy</span></code></a>()</p></td>
<td><p>Calculates the fractional anisotropy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.mean_diffusivity" title="dipy.reconst.forecast.ForecastFit.mean_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_diffusivity</span></code></a>()</p></td>
<td><p>Calculates the mean diffusivity.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.odf" title="dipy.reconst.forecast.ForecastFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere, *[, clip_negative])</p></td>
<td><p>Calculates the fODF for a given discrete sphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.predict" title="dipy.reconst.forecast.ForecastFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(*[, gtab, S0])</p></td>
<td><p>Calculates the fODF for a given discrete sphere.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.dpar">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dpar</span></span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.dpar" title="Link to this definition">#</a></dt>
<dd><p>The parallel diffusivity</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.dperp">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dperp</span></span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.dperp" title="Link to this definition">#</a></dt>
<dd><p>The perpendicular diffusivity</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.fractional_anisotropy">
<span class="sig-name descname"><span class="pre">fractional_anisotropy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#ForecastFit.fractional_anisotropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.fractional_anisotropy" title="Link to this definition">#</a></dt>
<dd><p>Calculates the fractional anisotropy.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.mean_diffusivity">
<span class="sig-name descname"><span class="pre">mean_diffusivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#ForecastFit.mean_diffusivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.mean_diffusivity" title="Link to this definition">#</a></dt>
<dd><p>Calculates the mean diffusivity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#ForecastFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.odf" title="Link to this definition">#</a></dt>
<dd><p>Calculates the fODF for a given discrete sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere,</span></dt><dd><p>the odf sphere</p>
</dd>
<dt><strong>clip_negative</strong><span class="classifier">boolean, optional</span></dt><dd><p>if True clip the negative odf values to 0, default True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#ForecastFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Calculates the fODF for a given discrete sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable, optional</span></dt><dd><p>gradient directions and bvalues container class.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float, optional</span></dt><dd><p>the signal at b-value=0</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.sh_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sh_coeff</span></span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.sh_coeff" title="Link to this definition">#</a></dt>
<dd><p>The FORECAST SH coefficients</p>
</dd></dl>

</dd></dl>

</section>
<section id="find-signal-means">
<h3>find_signal_means<a class="headerlink" href="#find-signal-means" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.find_signal_means">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">find_signal_means</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b_unique</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb_matrix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#find_signal_means"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.find_signal_means" title="Link to this definition">#</a></dt>
<dd><p>Calculate the mean signal for each shell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>b_unique</strong><span class="classifier">1d ndarray,</span></dt><dd><p>unique b-values in a vector excluding zero</p>
</dd>
<dt><strong>data_norm</strong><span class="classifier">1d ndarray,</span></dt><dd><p>normalized diffusion signal</p>
</dd>
<dt><strong>bvals</strong><span class="classifier">1d ndarray,</span></dt><dd><p>the b-values</p>
</dd>
<dt><strong>rho</strong><span class="classifier">2d ndarray,</span></dt><dd><p>SH basis matrix for fitting the signal on each shell</p>
</dd>
<dt><strong>lb_matrix</strong><span class="classifier">2d ndarray,</span></dt><dd><p>Laplace-Beltrami regularization matrix</p>
</dd>
<dt><strong>w</strong><span class="classifier">float,</span></dt><dd><p>weight for the Laplace-Beltrami regularization</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>means</strong><span class="classifier">1d ndarray</span></dt><dd><p>the average of the signal for each b-values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="forecast-error-func">
<h3>forecast_error_func<a class="headerlink" href="#forecast-error-func" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.forecast_error_func">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">forecast_error_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_unique</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#forecast_error_func"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.forecast_error_func" title="Link to this definition">#</a></dt>
<dd><p>Calculates the difference between the mean signal calculated using
the parameter vector x and the average signal E using FORECAST and SMT</p>
</dd></dl>

</section>
<section id="psi-l">
<h3>psi_l<a class="headerlink" href="#psi-l" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.psi_l">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">psi_l</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#psi_l"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.psi_l" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="forecast-matrix">
<h3>forecast_matrix<a class="headerlink" href="#forecast-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.forecast_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">forecast_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_par</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_perp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvals</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#forecast_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.forecast_matrix" title="Link to this definition">#</a></dt>
<dd><p>Compute the FORECAST radial matrix</p>
</dd></dl>

</section>
<section id="rho-matrix">
<h3>rho_matrix<a class="headerlink" href="#rho-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.rho_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">rho_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vecs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#rho_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.rho_matrix" title="Link to this definition">#</a></dt>
<dd><p>Compute the SH matrix <span class="math notranslate nohighlight">\(\rho\)</span></p>
</dd></dl>

</section>
<section id="lb-forecast">
<h3>lb_forecast<a class="headerlink" href="#lb-forecast" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.lb_forecast">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">lb_forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/forecast.html#lb_forecast"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.forecast.lb_forecast" title="Link to this definition">#</a></dt>
<dd><p>Returns the Laplace-Beltrami regularization matrix for FORECAST</p>
</dd></dl>

</section>
<section id="freewatertensormodel">
<h3><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel" title="dipy.reconst.fwdti.FreeWaterTensorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a><a class="headerlink" href="#freewatertensormodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">FreeWaterTensorModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'NLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#FreeWaterTensorModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Class for the Free Water Elimination Diffusion Tensor Model</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel.fit" title="dipy.reconst.fwdti.FreeWaterTensorModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel.predict" title="dipy.reconst.fwdti.FreeWaterTensorModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(fwdti_params, *[, S0])</p></td>
<td><p>Predict a signal for this TensorModel class instance given parameters.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwdti_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#FreeWaterTensorModel.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal for this TensorModel class instance given
parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fwdti_params</strong><span class="classifier">(…, 13) ndarray</span></dt><dd><p>The last dimension should have 13 parameters: the 12 tensor
parameters (3 eigenvalues, followed by the 3 corresponding
eigenvectors) and the free water volume fraction.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated signal based on the free water DTI model</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="freewatertensorfit">
<h3><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit" title="dipy.reconst.fwdti.FreeWaterTensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a><a class="headerlink" href="#freewatertensorfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">FreeWaterTensorFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#FreeWaterTensorFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a></p>
<p>Class for fitting the Free Water Tensor Model</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S0_hat</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></dt><dd><p>For tracking - return the primary direction in each voxel</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit.f" title="dipy.reconst.fwdti.FreeWaterTensorFit.f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f</span></code></a></dt><dd><p>Returns the free water diffusion volume fraction f</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code>()</p></td>
<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code>(sphere)</p></td>
<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on the sphere for each voxel in the data</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code>()</p></td>
<td><p>Color fractional anisotropy of diffusion tensor</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code>()</p></td>
<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code>()</p></td>
<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code>()</p></td>
<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code>()</p></td>
<td><p>Tensor mode calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</p></td>
<td><p>The diffusion orientation distribution function (dODF).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit.predict" title="dipy.reconst.fwdti.FreeWaterTensorFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab, *[, S0])</p></td>
<td><p>Given a free water tensor model fit, predict the signal on the vertices of a gradient table</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code>()</p></td>
<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code>()</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>()</p></td>
<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>lower_triangular</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorFit.f">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">f</span></span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit.f" title="Link to this definition">#</a></dt>
<dd><p>Returns the free water diffusion volume fraction f</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#FreeWaterTensorFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Given a free water tensor model fit, predict the signal on the
vertices of a gradient table</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float array</span></dt><dd><p>The mean non-diffusion weighted signal in each voxel. Default: 1 in
all voxels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated signal based on the free water DTI model</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="fwdti-prediction">
<h3>fwdti_prediction<a class="headerlink" href="#fwdti-prediction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.fwdti_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">fwdti_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#fwdti_prediction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.fwdti_prediction" title="Link to this definition">#</a></dt>
<dd><p>Signal prediction given the free water DTI model parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(…, 13) ndarray</span></dt><dd><p>Model parameters. The last dimension should have the 12 tensor
parameters (3 eigenvalues, followed by the 3 corresponding
eigenvectors) and the volume fraction of the free water compartment.</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
<dt><strong>Diso</strong><span class="classifier">float, optional</span></dt><dd><p>Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
units of diffusion.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated signal based on the free water DTI model</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:
<span class="math notranslate nohighlight">\(S(\theta, b) = S_0 * [(1-f) * e^{-b ADC} + f * e^{-b D_{iso}]\)</span>, where
<span class="math notranslate nohighlight">\(ADC = \theta Q \theta^T\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span> is a unit vector pointing at any
direction on the sphere for which a signal is to be predicted, <span class="math notranslate nohighlight">\(b\)</span> is the b
value provided in the GradientTable input for that direction, <span class="math notranslate nohighlight">\(Q\)</span> is the
quadratic form of the tensor determined by the input parameters, <span class="math notranslate nohighlight">\(f\)</span> is the
free water diffusion compartment, <span class="math notranslate nohighlight">\(D_{iso}\)</span> is the free water diffusivity
which is equal to $3 * 10^{-3} mm^{2}s^{-1} <a class="footnote-reference brackets" href="#footcite-netohenriques2017" id="id213" role="doc-noteref"><span class="fn-bracket">[</span>50<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id214">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-netohenriques2017" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>50<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id213">1</a>,<a role="doc-backlink" href="#id216">2</a>)</span>
<p>Rafael Neto Henriques, Ariel Rokem, Eleftherios Garyfallidis, Samuel St-Jean, Eric Thomas Peterson, and Marta Morgado Correia. [Re] Optimization of a free water elimination two-compartment model for diffusion tensor imaging. bioRxiv, 2017. <a class="reference external" href="https://doi.org/https://doi.org/10.1101/108795">doi:https://doi.org/10.1101/108795</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="wls-iter">
<h3>wls_iter<a class="headerlink" href="#wls-iter" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.wls_iter">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">wls_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mdreg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0027</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">piterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#wls_iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.wls_iter" title="Link to this definition">#</a></dt>
<dd><p>Applies weighted linear least squares fit of the water free elimination
model to single voxel signals.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>sig</strong><span class="classifier">array (g, )</span></dt><dd><p>Diffusion-weighted signal for a single voxel data.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>Non diffusion weighted signal (i.e. signal for b-value=0).</p>
</dd>
<dt><strong>Diso</strong><span class="classifier">float, optional</span></dt><dd><p>Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
units of diffusion.</p>
</dd>
<dt><strong>mdreg</strong><span class="classifier">float, optimal</span></dt><dd><p>DTI’s mean diffusivity regularization threshold. If standard DTI
diffusion tensor’s mean diffusivity is almost near the free water
diffusion value, the diffusion signal is assumed to be only free water
diffusion (i.e. volume fraction will be set to 1 and tissue’s diffusion
parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
(corresponding to 90% of the free water diffusion value).</p>
</dd>
<dt><strong>min_signal</strong><span class="classifier">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive
number. Default: minimal signal in the data provided to <cite>fit</cite>.</p>
</dd>
<dt><strong>piterations</strong><span class="classifier">inter, optional</span></dt><dd><p>Number of iterations used to refine the precision of f. Default is set
to 3 corresponding to a precision of 0.01.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>fw_params</strong><span class="classifier">ndarray</span></dt><dd><p>All parameters estimated from the free water tensor model. Parameters
are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>The volume fraction of the free water compartment</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="id215">
<h3>wls_fit_tensor<a class="headerlink" href="#id215" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.wls_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">wls_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">piterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mdreg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0027</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#wls_fit_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.wls_fit_tensor" title="Link to this definition">#</a></dt>
<dd><p>Computes weighted least squares (WLS) fit to calculate self-diffusion
tensor using a linear regression model.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2017" id="id216" role="doc-noteref"><span class="fn-bracket">[</span>50<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table containing diffusion acquisition parameters.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray ([X, Y, Z, …], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>Diso</strong><span class="classifier">float, optional</span></dt><dd><p>Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
units of diffusion.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should
be analyzed that has the shape data.shape[:-1]</p>
</dd>
<dt><strong>min_signal</strong><span class="classifier">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive
number.</p>
</dd>
<dt><strong>piterations</strong><span class="classifier">inter, optional</span></dt><dd><p>Number of iterations used to refine the precision of f. Default is set
to 3 corresponding to a precision of 0.01.</p>
</dd>
<dt><strong>mdreg</strong><span class="classifier">float, optimal</span></dt><dd><p>DTI’s mean diffusivity regularization threshold. If standard DTI
diffusion tensor’s mean diffusivity is almost near the free water
diffusion value, the diffusion signal is assumed to be only free water
diffusion (i.e. volume fraction will be set to 1 and tissue’s diffusion
parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
(corresponding to 90% of the free water diffusion value).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>fw_params</strong><span class="classifier">ndarray (x, y, z, 13)</span></dt><dd><p>Matrix containing in the last dimension the free water model parameters
in the following order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>The volume fraction of the free water compartment.</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="nls-iter">
<h3>nls_iter<a class="headerlink" href="#nls-iter" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.nls_iter">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">nls_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mdreg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0027</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#nls_iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.nls_iter" title="Link to this definition">#</a></dt>
<dd><p>Applies non linear least squares fit of the water free elimination
model to single voxel signals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>sig</strong><span class="classifier">array (g, )</span></dt><dd><p>Diffusion-weighted signal for a single voxel data.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>Non diffusion weighted signal (i.e. signal for b-value=0).</p>
</dd>
<dt><strong>Diso</strong><span class="classifier">float, optional</span></dt><dd><p>Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
units of diffusion.</p>
</dd>
<dt><strong>mdreg</strong><span class="classifier">float, optimal</span></dt><dd><p>DTI’s mean diffusivity regularization threshold. If standard DTI
diffusion tensor’s mean diffusivity is almost near the free water
diffusion value, the diffusion signal is assumed to be only free water
diffusion (i.e. volume fraction will be set to 1 and tissue’s diffusion
parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
(corresponding to 90% of the free water diffusion value).</p>
</dd>
<dt><strong>min_signal</strong><span class="classifier">float, optional</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive
number.</p>
</dd>
<dt><strong>cholesky</strong><span class="classifier">bool, optional</span></dt><dd><p>If true it uses Cholesky decomposition to ensure that diffusion tensor
is positive define.</p>
</dd>
<dt><strong>f_transform</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, the water volume fractions is converted during the convergence
procedure to ft = arcsin(2*f - 1) + pi/2, insuring f estimates between
0 and 1.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">bool, optional</span></dt><dd><p>True to use the Jacobian.</p>
</dd>
<dt><strong>weighting: str, optional</strong></dt><dd><p>the weighting scheme to use in considering the
squared-error. Default behavior is to use uniform weighting. Other
options: ‘sigma’ ‘gmm’</p>
</dd>
<dt><strong>sigma: float, optional</strong></dt><dd><p>If the ‘sigma’ weighting scheme is used, a value of sigma needs to be
provided here. According to Chang <em>et al.</em><a class="footnote-reference brackets" href="#footcite-chang2005" id="id217" role="doc-noteref"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></a>, a good value to use
is 1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>All parameters estimated from the free water tensor model.</dt><dd></dd>
<dt>Parameters are ordered as follows:</dt><dd><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>The volume fraction of the free water compartment.</p></li>
</ol>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="nls-fit-tensor">
<h3>nls_fit_tensor<a class="headerlink" href="#nls-fit-tensor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.nls_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">nls_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mdreg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0027</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#nls_fit_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.nls_fit_tensor" title="Link to this definition">#</a></dt>
<dd><p>Fit the water elimination tensor model using the non-linear least-squares.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table containing diffusion acquisition parameters.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray ([X, Y, Z, …], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should
be analyzed that has the shape data.shape[:-1]</p>
</dd>
<dt><strong>Diso</strong><span class="classifier">float, optional</span></dt><dd><p>Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
units of diffusion.</p>
</dd>
<dt><strong>mdreg</strong><span class="classifier">float, optimal</span></dt><dd><p>DTI’s mean diffusivity regularization threshold. If standard DTI
diffusion tensor’s mean diffusivity is almost near the free water
diffusion value, the diffusion signal is assumed to be only free water
diffusion (i.e. volume fraction will be set to 1 and tissue’s diffusion
parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
(corresponding to 90% of the free water diffusion value).</p>
</dd>
<dt><strong>min_signal</strong><span class="classifier">float, optional</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive
number.</p>
</dd>
<dt><strong>f_transform</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, the water volume fractions is converted during the convergence
procedure to ft = arcsin(2*f - 1) + pi/2, insuring f estimates between
0 and 1.</p>
</dd>
<dt><strong>cholesky</strong><span class="classifier">bool, optional</span></dt><dd><p>If true it uses Cholesky decomposition to ensure that diffusion tensor
is positive define.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">bool, optional</span></dt><dd><p>True to use the Jacobian.</p>
</dd>
<dt><strong>weighting: str, optional</strong></dt><dd><p>the weighting scheme to use in considering the
squared-error. Default behavior is to use uniform weighting. Other
options: ‘sigma’ ‘gmm’</p>
</dd>
<dt><strong>sigma: float, optional</strong></dt><dd><p>If the ‘sigma’ weighting scheme is used, a value of sigma needs to be
provided here. According to Chang <em>et al.</em><a class="footnote-reference brackets" href="#footcite-chang2005" id="id218" role="doc-noteref"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></a>, a good value to use
is 1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>fw_params</strong><span class="classifier">ndarray (x, y, z, 13)</span></dt><dd><p>Matrix containing in the dimension the free water model parameters in
the following order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>The volume fraction of the free water compartment</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="lower-triangular-to-cholesky">
<h3>lower_triangular_to_cholesky<a class="headerlink" href="#lower-triangular-to-cholesky" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.lower_triangular_to_cholesky">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">lower_triangular_to_cholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor_elements</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#lower_triangular_to_cholesky"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.lower_triangular_to_cholesky" title="Link to this definition">#</a></dt>
<dd><p>Performs Cholesky decomposition of the diffusion tensor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor_elements</strong><span class="classifier">array (6,)</span></dt><dd><p>Array containing the six elements of diffusion tensor’s lower
triangular.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cholesky_elements</strong><span class="classifier">array (6,)</span></dt><dd><p>Array containing the six Cholesky’s decomposition elements
(R0, R1, R2, R3, R4, R5) <a class="footnote-reference brackets" href="#footcite-koay2006b" id="id219" role="doc-noteref"><span class="fn-bracket">[</span>51<span class="fn-bracket">]</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id220">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-koay2006b" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>51<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id219">1</a>,<a role="doc-backlink" href="#id221">2</a>)</span>
<p>Cheng Guan Koay, John D. Carew, Andrew L. Alexander, Peter J. Basser, and M. Elizabeth Meyerand. Investigation of anomalous estimates of tensor-derived quantities in diffusion tensor imaging. <em>Magnetic Resonance in Medicine</em>, 55(4):930–936, April 2006. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.20832">https://doi.org/10.1002/mrm.20832</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.20832">doi:10.1002/mrm.20832</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="cholesky-to-lower-triangular">
<h3>cholesky_to_lower_triangular<a class="headerlink" href="#cholesky-to-lower-triangular" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.cholesky_to_lower_triangular">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">cholesky_to_lower_triangular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/fwdti.html#cholesky_to_lower_triangular"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.fwdti.cholesky_to_lower_triangular" title="Link to this definition">#</a></dt>
<dd><p>Convert Cholesky decomposition elements to the diffusion tensor elements</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>R</strong><span class="classifier">array (6,)</span></dt><dd><p>Array containing the six Cholesky’s decomposition elements
(R0, R1, R2, R3, R4, R5) <a class="footnote-reference brackets" href="#footcite-koay2006b" id="id221" role="doc-noteref"><span class="fn-bracket">[</span>51<span class="fn-bracket">]</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor_elements</strong><span class="classifier">array (6,)</span></dt><dd><p>Array containing the six elements of diffusion tensor’s lower
triangular.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="generalizedqsamplingmodel">
<h3><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="dipy.reconst.gqi.GeneralizedQSamplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a><a class="headerlink" href="#generalizedqsamplingmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">GeneralizedQSamplingModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gqi2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#GeneralizedQSamplingModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.fit" title="dipy.reconst.gqi.GeneralizedQSamplingModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="generalizedqsamplingfit">
<h3><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="dipy.reconst.gqi.GeneralizedQSamplingFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a><a class="headerlink" href="#generalizedqsamplingfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">GeneralizedQSamplingFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#GeneralizedQSamplingFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.odf" title="dipy.reconst.gqi.GeneralizedQSamplingFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</p></td>
<td><p>Calculates the discrete ODF for a given discrete sphere.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#GeneralizedQSamplingFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.odf" title="Link to this definition">#</a></dt>
<dd><p>Calculates the discrete ODF for a given discrete sphere.</p>
</dd></dl>

</dd></dl>

</section>
<section id="normalize-qa">
<h3>normalize_qa<a class="headerlink" href="#normalize-qa" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.normalize_qa">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">normalize_qa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qa</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_qa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#normalize_qa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.normalize_qa" title="Link to this definition">#</a></dt>
<dd><p>Normalize quantitative anisotropy.</p>
<p>Used mostly with GQI rather than GQI2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qa</strong><span class="classifier">array, shape (X, Y, Z, N)</span></dt><dd><p>where N is the maximum number of peaks stored</p>
</dd>
<dt><strong>max_qa</strong><span class="classifier">float,</span></dt><dd><p>maximum qa value. Usually found in the CSF (corticospinal fluid).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nqa</strong><span class="classifier">array, shape (x, Y, Z, N)</span></dt><dd><p>normalized quantitative anisotropy</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Normalized quantitative anisotropy has the very useful property
to be very small near gray matter and background areas. Therefore,
it can be used to mask out white matter areas.</p>
</dd></dl>

</section>
<section id="squared-radial-component">
<h3>squared_radial_component<a class="headerlink" href="#squared-radial-component" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.squared_radial_component">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">squared_radial_component</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#squared_radial_component"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.squared_radial_component" title="Link to this definition">#</a></dt>
<dd><p>Part of the GQI2 integral</p>
<p>Eq.8 in the referenced paper by Yeh <em>et al.</em><a class="footnote-reference brackets" href="#footcite-yeh2010" id="id222" role="doc-noteref"><span class="fn-bracket">[</span>52<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id223">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-yeh2010" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id222">52</a><span class="fn-bracket">]</span></span>
<p>Fang-Cheng Yeh, Van Jay Wedeen, and Wen-Yih Isaac Tseng. Generalized $q$-Sampling Imaging. <em>IEEE Transactions on Medical Imaging</em>, 29(9):1626–1635, 2010. URL: <a class="reference external" href="https://doi.org/10.1109/TMI.2010.2045126">https://doi.org/10.1109/TMI.2010.2045126</a>, <a class="reference external" href="https://doi.org/10.1109/TMI.2010.2045126">doi:10.1109/TMI.2010.2045126</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="npa">
<h3>npa<a class="headerlink" href="#npa" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.npa">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">npa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#npa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.npa" title="Link to this definition">#</a></dt>
<dd><p>non-parametric anisotropy</p>
<p>Nimmo-Smith et al.  ISMRM 2011</p>
</dd></dl>

</section>
<section id="equatorial-zone-vertices">
<h3>equatorial_zone_vertices<a class="headerlink" href="#equatorial-zone-vertices" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.equatorial_zone_vertices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">equatorial_zone_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#equatorial_zone_vertices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.equatorial_zone_vertices" title="Link to this definition">#</a></dt>
<dd><p>finds the ‘vertices’ in the equatorial zone conjugate
to ‘pole’ with width half ‘width’ degrees</p>
</dd></dl>

</section>
<section id="polar-zone-vertices">
<h3>polar_zone_vertices<a class="headerlink" href="#polar-zone-vertices" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.polar_zone_vertices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">polar_zone_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#polar_zone_vertices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.polar_zone_vertices" title="Link to this definition">#</a></dt>
<dd><p>finds the ‘vertices’ in the equatorial band around
the ‘pole’ of radius ‘width’ degrees</p>
</dd></dl>

</section>
<section id="upper-hemi-map">
<h3>upper_hemi_map<a class="headerlink" href="#upper-hemi-map" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.upper_hemi_map">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">upper_hemi_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#upper_hemi_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.upper_hemi_map" title="Link to this definition">#</a></dt>
<dd><p>maps a 3-vector into the z-upper hemisphere</p>
</dd></dl>

</section>
<section id="equatorial-maximum">
<h3>equatorial_maximum<a class="headerlink" href="#equatorial-maximum" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.equatorial_maximum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">equatorial_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#equatorial_maximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.equatorial_maximum" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="patch-vertices">
<h3>patch_vertices<a class="headerlink" href="#patch-vertices" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.patch_vertices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">patch_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#patch_vertices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.patch_vertices" title="Link to this definition">#</a></dt>
<dd><p>find ‘vertices’ within the cone of ‘width’ degrees around ‘pole’</p>
</dd></dl>

</section>
<section id="patch-maximum">
<h3>patch_maximum<a class="headerlink" href="#patch-maximum" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.patch_maximum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">patch_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#patch_maximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.patch_maximum" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="odf-sum">
<h3>odf_sum<a class="headerlink" href="#odf-sum" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.odf_sum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">odf_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#odf_sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.odf_sum" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="patch-sum">
<h3>patch_sum<a class="headerlink" href="#patch-sum" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.patch_sum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">patch_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#patch_sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.patch_sum" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="triple-odf-maxima">
<h3>triple_odf_maxima<a class="headerlink" href="#triple-odf-maxima" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.triple_odf_maxima">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">triple_odf_maxima</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/gqi.html#triple_odf_maxima"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.gqi.triple_odf_maxima" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="ivimmodeltrr">
<h3><a class="reference internal" href="#dipy.reconst.ivim.IvimModelTRR" title="dipy.reconst.ivim.IvimModelTRR"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimModelTRR</span></code></a><a class="headerlink" href="#ivimmodeltrr" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">IvimModelTRR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_b_D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">400.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_b_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1000.0,</span> <span class="pre">0.1,</span> <span class="pre">0.001,</span> <span class="pre">0.0001)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ftol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelTRR"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Ivim model</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star" title="dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_f_D_star</span></code></a>(params_f_D_star, data, S0, D)</p></td>
<td><p>Estimate f and D_star using the values of all the other parameters obtained from a linear fit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit" title="dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_linear_fit</span></code></a>(data, split_b, *[, ...])</p></td>
<td><p>Estimate a linear fit by taking log of data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelTRR.fit" title="dipy.reconst.ivim.IvimModelTRR.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelTRR.predict" title="dipy.reconst.ivim.IvimModelTRR.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(ivim_params, gtab, *[, S0])</p></td>
<td><p>Predict a signal for this IvimModel class instance given parameters.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star">
<span class="sig-name descname"><span class="pre">estimate_f_D_star</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params_f_D_star</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelTRR.estimate_f_D_star"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star" title="Link to this definition">#</a></dt>
<dd><p>Estimate f and D_star using the values of all the other parameters
obtained from a linear fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params_f_D_star: array</strong></dt><dd><p>An array containing the value of f and D_star.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>Array containing the actual signal values.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>The parameters S0 obtained from a linear fit.</p>
</dd>
<dt><strong>D</strong><span class="classifier">float</span></dt><dd><p>The parameters D obtained from a linear fit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">float</span></dt><dd><p>Perfusion fraction estimated from the fit.</p>
</dd>
<dt>D_star</dt><dd><p>The value of D_star estimated from the fit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit">
<span class="sig-name descname"><span class="pre">estimate_linear_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">less_than</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelTRR.estimate_linear_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit" title="Link to this definition">#</a></dt>
<dd><p>Estimate a linear fit by taking log of data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>An array containing the data to be fit</p>
</dd>
<dt><strong>split_b</strong><span class="classifier">float</span></dt><dd><p>The b value to split the data</p>
</dd>
<dt><strong>less_than</strong><span class="classifier">bool</span></dt><dd><p>If True, splitting occurs for bvalues less than split_b</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>The estimated S0 value. (intercept)</p>
</dd>
<dt><strong>D</strong><span class="classifier">float</span></dt><dd><p>The estimated value of D.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ivim_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelTRR.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal for this IvimModel class instance given parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ivim_params</strong><span class="classifier">array</span></dt><dd><p>The ivim parameters as an array [S0, f, D_star and D]</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float, optional</span></dt><dd><p>This has been added just for consistency with the existing
API. Unlike other models, IVIM predicts S0 and this is over written
by the S0 value in params.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ivim_signal</strong><span class="classifier">array</span></dt><dd><p>The predicted IVIM signal using given parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="ivimmodelvp">
<h3><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP" title="dipy.reconst.ivim.IvimModelVP"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimModelVP</span></code></a><a class="headerlink" href="#ivimmodelvp" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">IvimModelVP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelVP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP.cvx_fit" title="dipy.reconst.ivim.IvimModelVP.cvx_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cvx_fit</span></code></a>(signal, phi)</p></td>
<td><p>Performs the constrained search for the linear parameters <cite>f</cite> after the estimation of <cite>x</cite> is done.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP.fit" title="dipy.reconst.ivim.IvimModelVP.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one" title="dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ivim_mix_cost_one</span></code></a>(phi, signal)</p></td>
<td><p>Constructs the objective for the :func: <cite>stoc_search_cost</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP.nlls_cost" title="dipy.reconst.ivim.IvimModelVP.nlls_cost"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlls_cost</span></code></a>(x_f, signal)</p></td>
<td><p>Cost function for the least square problem.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP.phi" title="dipy.reconst.ivim.IvimModelVP.phi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phi</span></code></a>(x)</p></td>
<td><p>Creates a structure for the combining the diffusion and pseudo- diffusion by multiplying with the bvals and then exponentiating each of the two components for fitting as per the IVIM- two compartment model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP.stoc_search_cost" title="dipy.reconst.ivim.IvimModelVP.stoc_search_cost"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stoc_search_cost</span></code></a>(x, signal)</p></td>
<td><p>Cost function for differential evolution algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f" title="dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">x_and_f_to_x_f</span></code></a>(x, f)</p></td>
<td><p>Combines the array of parameters 'x' and 'f' into x_f for performing NLLS on the final stage of optimization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f" title="dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">x_f_to_x_and_f</span></code></a>(x_f)</p></td>
<td><p>Splits the array of parameters in x_f to 'x' and 'f' for performing a search on the both of them independently using the Trust Region Method.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.cvx_fit">
<span class="sig-name descname"><span class="pre">cvx_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelVP.cvx_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.cvx_fit" title="Link to this definition">#</a></dt>
<dd><p>Performs the constrained search for the linear parameters <cite>f</cite> after
the estimation of <cite>x</cite> is done. Estimation of the linear parameters <cite>f</cite>
is a constrained linear least-squares optimization problem solved by
using a convex optimizer from cvxpy. The IVIM equation contains two
parameters that depend on the same volume fraction. Both are estimated
as separately in the convex optimizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">array</span></dt><dd><p>Returns an array calculated from :func: <cite>phi</cite>.</p>
</dd>
<dt><strong>signal</strong><span class="classifier">array</span></dt><dd><p>The signal values measured for this model.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>f1, f2 (volume fractions)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>cost function for differential evolution algorithm:</p>
<div class="math notranslate nohighlight">
\[minimize(norm((signal)- (phi*f)))\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one">
<span class="sig-name descname"><span class="pre">ivim_mix_cost_one</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelVP.ivim_mix_cost_one"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one" title="Link to this definition">#</a></dt>
<dd><p>Constructs the objective for the :func: <cite>stoc_search_cost</cite>.</p>
<p>First calculates the Moore-Penrose inverse of the input <cite>phi</cite> and takes
a dot product with the measured signal. The result obtained is again
multiplied with <cite>phi</cite> to complete the projection of the variable into
a transformed space. (see <a class="footnote-reference brackets" href="#footcite-fadnavis2019" id="id224" role="doc-noteref"><span class="fn-bracket">[</span>53<span class="fn-bracket">]</span></a> and
<a class="footnote-reference brackets" href="#footcite-farooq2016" id="id225" role="doc-noteref"><span class="fn-bracket">[</span>54<span class="fn-bracket">]</span></a> for thorough discussion on Variable Projections
and relevant cost functions).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">array</span></dt><dd><p>Returns an array calculated from :func: <cite>Phi</cite>.</p>
</dd>
<dt><strong>signal</strong><span class="classifier">array</span></dt><dd><p>The signal values measured for this model.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>(signal -  S)^T(signal -  S)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>to make cost function for Differential Evolution algorithm:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">signal</span> <span class="o">-</span>  <span class="n">S</span><span class="p">)</span><span class="o">^</span><span class="n">T</span><span class="p">(</span><span class="n">signal</span> <span class="o">-</span>  <span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<div class="docutils container" id="id226">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-fadnavis2019" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id224">53</a><span class="fn-bracket">]</span></span>
<p>Shreyas Fadnavis, Marco Reisert, Hamza Farooq, Maryam Afzali, Cheng Hu, Bago Amirbekian, and Eleftherios Garyfallidis. MicroLearn: Framework for machine learning, reconstruction, optimization and microstructure modeling. In <em>ISMRM 27th Annual Meeting &amp; Exhibition SMRT 28th Annual Meeting</em>. Montréal, Canada, 2019. International Society for Magnetic Resonance in Medicine (ISMRM).</p>
</aside>
<aside class="footnote brackets" id="footcite-farooq2016" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id225">54</a><span class="fn-bracket">]</span></span>
<p>Hamza Farooq, Junqian Xu, Jung Who Nam, Daniel F. Keefe, Essa Yacoub, Tryphon Georgiou, and Christophe Lenglet. Microstructure imaging of crossing (mix) white matter fibers from diffusion mri. <em>Scientific Reports</em>, 6(1):38927, December 2016. URL: <a class="reference external" href="https://doi.org/10.1038/srep38927">https://doi.org/10.1038/srep38927</a>, <a class="reference external" href="https://doi.org/10.1038/srep38927">doi:10.1038/srep38927</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.nlls_cost">
<span class="sig-name descname"><span class="pre">nlls_cost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelVP.nlls_cost"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.nlls_cost" title="Link to this definition">#</a></dt>
<dd><p>Cost function for the least square problem. The cost function is used
in the Least Squares function of SciPy in :func: <cite>fit</cite>. It guarantees
that stopping point of the algorithm is at least a stationary point
with reduction in the number of iterations required by the
differential evolution optimizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x_f</strong><span class="classifier">array</span></dt><dd><p>Contains the parameters ‘x’ and ‘f’ combines in the same array.</p>
</dd>
<dt><strong>signal</strong><span class="classifier">array</span></dt><dd><p>The signal values measured for this model.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>sum{(signal -  phi*f)^2}</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>cost function for the least square problem.</p>
<div class="math notranslate nohighlight">
\[sum{(signal -  phi*f)^2}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.phi">
<span class="sig-name descname"><span class="pre">phi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelVP.phi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.phi" title="Link to this definition">#</a></dt>
<dd><p>Creates a structure for the combining the diffusion and pseudo-
diffusion by multiplying with the bvals and then exponentiating each of
the two components for fitting as per the IVIM- two compartment model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array</span></dt><dd><p>input from the Differential Evolution optimizer.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>exp_phi1</strong><span class="classifier">array</span></dt><dd><p>Combined array of parameters perfusion/pseudo-diffusion
and diffusion parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.stoc_search_cost">
<span class="sig-name descname"><span class="pre">stoc_search_cost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelVP.stoc_search_cost"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.stoc_search_cost" title="Link to this definition">#</a></dt>
<dd><p>Cost function for differential evolution algorithm. Performs a
stochastic search for the non-linear parameters ‘x’. The objective
function is calculated in the :func: <cite>ivim_mix_cost_one</cite>. The function
constructs the parameters using :func: <cite>phi</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array</span></dt><dd><p>input from the Differential Evolution optimizer.</p>
</dd>
<dt><strong>signal</strong><span class="classifier">array</span></dt><dd><p>The signal values measured for this model.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="field-list simple">
<dt class="field-odd">func<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>ivim_mix_cost_one</cite>
..</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f">
<span class="sig-name descname"><span class="pre">x_and_f_to_x_f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelVP.x_and_f_to_x_f"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f" title="Link to this definition">#</a></dt>
<dd><p>Combines the array of parameters ‘x’ and ‘f’ into x_f for performing
NLLS on the final stage of optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x, f</strong><span class="classifier">array</span></dt><dd><p>Split parameters into two separate arrays</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x_f</strong><span class="classifier">array</span></dt><dd><p>Combined array of parameters ‘x’ and ‘f’ parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f">
<span class="sig-name descname"><span class="pre">x_f_to_x_and_f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimModelVP.x_f_to_x_and_f"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f" title="Link to this definition">#</a></dt>
<dd><p>Splits the array of parameters in x_f to ‘x’ and ‘f’ for performing
a search on the both of them independently using the Trust Region
Method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x_f</strong><span class="classifier">array</span></dt><dd><p>Combined array of parameters ‘x’ and ‘f’ parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x, f</strong><span class="classifier">array</span></dt><dd><p>Split parameters into two separate arrays</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="ivimfit">
<h3><a class="reference internal" href="#dipy.reconst.ivim.IvimFit" title="dipy.reconst.ivim.IvimFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimFit</span></code></a><a class="headerlink" href="#ivimfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">IvimFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>D</strong></dt><dd></dd>
<dt><strong>D_star</strong></dt><dd></dd>
<dt><strong>S0_predicted</strong></dt><dd></dd>
<dt><strong>perfusion_fraction</strong></dt><dd></dd>
<dt><strong>shape</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimFit.predict" title="dipy.reconst.ivim.IvimFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab, *[, S0])</p></td>
<td><p>Given a model fit, predict the signal.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.D">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">D</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.D" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.D_star">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">D_star</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.D_star" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.S0_predicted">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">S0_predicted</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.S0_predicted" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.perfusion_fraction">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">perfusion_fraction</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.perfusion_fraction" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#IvimFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Given a model fit, predict the signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>S0 value here is not necessary and will not be used to predict the
signal. It has been added to conform to the structure of the
predict method in multi_voxel which requires a keyword argument S0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>signal</strong><span class="classifier">array</span></dt><dd><p>The signal values predicted for this model using its parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.shape" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="ivim-prediction">
<h3>ivim_prediction<a class="headerlink" href="#ivim-prediction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.ivim.ivim_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">ivim_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#ivim_prediction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.ivim_prediction" title="Link to this definition">#</a></dt>
<dd><p>The Intravoxel incoherent motion (IVIM) model function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">array</span></dt><dd><p>An array of IVIM parameters - [S0, f, D_star, D].</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float, optional</span></dt><dd><p>This has been added just for consistency with the existing
API. Unlike other models, IVIM predicts S0 and this is over written
by the S0 value in params.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">array</span></dt><dd><p>An array containing the IVIM signal estimated using given parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="f-d-star-prediction">
<h3>f_D_star_prediction<a class="headerlink" href="#f-d-star-prediction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.ivim.f_D_star_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">f_D_star_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#f_D_star_prediction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.f_D_star_prediction" title="Link to this definition">#</a></dt>
<dd><p>Function used to predict IVIM signal when S0 and D are known
by considering f and D_star as the unknown parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">array</span></dt><dd><p>The value of f and D_star.</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>The parameters S0 obtained from a linear fit.</p>
</dd>
<dt><strong>D</strong><span class="classifier">float</span></dt><dd><p>The parameters D obtained from a linear fit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">array</span></dt><dd><p>An array containing the IVIM signal estimated using given parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="f-d-star-error">
<h3>f_D_star_error<a class="headerlink" href="#f-d-star-error" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.ivim.f_D_star_error">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">f_D_star_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#f_D_star_error"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.f_D_star_error" title="Link to this definition">#</a></dt>
<dd><p>Error function used to fit f and D_star keeping S0 and D fixed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">array</span></dt><dd><p>The value of f and D_star.</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>
</dd>
<dt><strong>signal</strong><span class="classifier">array</span></dt><dd><p>Array containing the actual signal values.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float</span></dt><dd><p>The parameters S0 obtained from a linear fit.</p>
</dd>
<dt><strong>D</strong><span class="classifier">float</span></dt><dd><p>The parameters D obtained from a linear fit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residual</strong><span class="classifier">array</span></dt><dd><p>An array containing the difference of actual and estimated signal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="ivim-model-selector">
<h3>ivim_model_selector<a class="headerlink" href="#ivim-model-selector" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.ivim.ivim_model_selector">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">ivim_model_selector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trr'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/ivim.html#ivim_model_selector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.ivim.ivim_model_selector" title="Link to this definition">#</a></dt>
<dd><p>Selector function to switch between the 2-stage Trust-Region Reflective
based NLLS fitting method (also containing the linear fit): <cite>trr</cite> and the
Variable Projections based fitting method: <cite>varpro</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fit_method</strong><span class="classifier">string, optional</span></dt><dd><p>The value fit_method can either be ‘trr’ or ‘varpro’.
default : trr</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="mapmrimodel">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.MapmriModel" title="dipy.reconst.mapmri.MapmriModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriModel</span></code></a><a class="headerlink" href="#mapmrimodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">MapmriModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positivity_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'adaptive'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anisotropic_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bval_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dti_scale_estimation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0007</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>Mean Apparent Propagator MRI (MAPMRI) of the diffusion signal.</p>
<p>The main idea in MAPMRI footcite:p:<cite>Ozarslan2013</cite> is to model the diffusion
signal as a linear combination of the continuous functions presented in
footcite:p:<cite>Ozarslan2008</cite> but extending it in three dimensions.</p>
<p>The main difference with the SHORE proposed in footcite:p:<cite>Merlet2013</cite> is
that MAPMRI 3D extension is provided using a set of three basis functions
for the radial part, one for the signal along x, one for y and one for z,
while footcite:p:<cite>Merlet2013</cite> uses one basis function to model the radial
part and real Spherical Harmonics to model the angular part.</p>
<p>From the MAPMRI coefficients is possible to use the analytical formulae
to estimate the ODF.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-avram2015" id="id227" role="doc-noteref"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></a> for additional tissue microstructure insights
provided by MAPMRI.</p>
<p>See also footcite:p:<cite>Fick2016b</cite>, footcite:p:<cite>Cheng2012</cite>,
footcite:p:<cite>Hosseinbor2013</cite>, footcite:p:<cite>Craven1979</cite>, and
footcite:p:<cite>DelaHaije2020</cite> for additional insight into to the model.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriModel.fit" title="dipy.reconst.mapmri.MapmriModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">References</p>
<div class="docutils container" id="id228">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-avram2015" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id227">1</a>,<a role="doc-backlink" href="#id232">2</a>,<a role="doc-backlink" href="#id235">3</a>,<a role="doc-backlink" href="#id237">4</a>)</span>
<p>Alexandru V. Avram, Joelle E Sarlls, Alan S Barnett, Evren Özarslan, Cibu Thomas, M. Okan Irfanoglu, Elizabeth Hutchinson, Carlo Pierpaoli, and Peter J. Basser. Clinical feasibility of using mean apparent propagator (MAP) MRI to characterize brain tissue microstructure. <em>NeuroImage</em>, 111:159–169, 2015. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2015.01.007">https://doi.org/10.1016/j.neuroimage.2015.01.007</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2015.01.007">doi:10.1016/j.neuroimage.2015.01.007</a>.</p>
</aside>
</aside>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="mapmrifit">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit" title="dipy.reconst.mapmri.MapmriFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriFit</span></code></a><a class="headerlink" href="#mapmrifit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">MapmriFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapmri_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lopt</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errorcode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.mapmri_R" title="dipy.reconst.mapmri.MapmriFit.mapmri_R"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_R</span></code></a></dt><dd><p>The MAPMRI rotation matrix</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.mapmri_coeff" title="dipy.reconst.mapmri.MapmriFit.mapmri_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_coeff</span></code></a></dt><dd><p>The MAPMRI coefficients</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.mapmri_mu" title="dipy.reconst.mapmri.MapmriFit.mapmri_mu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_mu</span></code></a></dt><dd><p>The MAPMRI scale factors</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.fitted_signal" title="dipy.reconst.mapmri.MapmriFit.fitted_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fitted_signal</span></code></a>(*[, gtab])</p></td>
<td><p>Recovers the fitted signal for the given gradient table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.msd" title="dipy.reconst.mapmri.MapmriFit.msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd</span></code></a>()</p></td>
<td><p>Calculates the analytical Mean Squared Displacement (MSD).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.ng" title="dipy.reconst.mapmri.MapmriFit.ng"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ng</span></code></a>()</p></td>
<td><p>Calculates the analytical non-Gaussiannity (NG).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.ng_parallel" title="dipy.reconst.mapmri.MapmriFit.ng_parallel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ng_parallel</span></code></a>()</p></td>
<td><p>Calculates the analytical parallel non-Gaussiannity (NG).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.ng_perpendicular" title="dipy.reconst.mapmri.MapmriFit.ng_perpendicular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ng_perpendicular</span></code></a>()</p></td>
<td><p>Calculates the analytical perpendicular non-Gaussiannity (NG)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal" title="dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm_of_laplacian_signal</span></code></a>()</p></td>
<td><p>Calculates the norm of the laplacian of the fitted signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.odf" title="dipy.reconst.mapmri.MapmriFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere, *[, s])</p></td>
<td><p>Calculates the analytical Orientation Distribution Function (ODF) from the signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.odf_sh" title="dipy.reconst.mapmri.MapmriFit.odf_sh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sh</span></code></a>(*[, s])</p></td>
<td><p>Calculates the real analytical odf for a given discrete sphere.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.pdf" title="dipy.reconst.mapmri.MapmriFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>(r_points)</p></td>
<td><p>Diffusion propagator on a given set of real points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.predict" title="dipy.reconst.mapmri.MapmriFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(qvals_or_gtab, *[, S0])</p></td>
<td><p>Recovers the reconstructed signal for any qvalue array or gradient table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.qiv" title="dipy.reconst.mapmri.MapmriFit.qiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qiv</span></code></a>()</p></td>
<td><p>Calculates the analytical Q-space Inverse Variance (QIV).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.rtap" title="dipy.reconst.mapmri.MapmriFit.rtap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtap</span></code></a>()</p></td>
<td><p>Calculates the analytical return to the axis probability (RTAP).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.rtop" title="dipy.reconst.mapmri.MapmriFit.rtop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop</span></code></a>()</p></td>
<td><p>Calculates the analytical return to the origin probability (RTOP).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.rtpp" title="dipy.reconst.mapmri.MapmriFit.rtpp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtpp</span></code></a>()</p></td>
<td><p>Calculates the analytical return to the plane probability (RTPP).</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.fitted_signal">
<span class="sig-name descname"><span class="pre">fitted_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.fitted_signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.fitted_signal" title="Link to this definition">#</a></dt>
<dd><p>Recovers the fitted signal for the given gradient table. If no
gradient table is given it recovers the signal for the gtab of the model
object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.mapmri_R">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mapmri_R</span></span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.mapmri_R" title="Link to this definition">#</a></dt>
<dd><p>The MAPMRI rotation matrix</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.mapmri_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mapmri_coeff</span></span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.mapmri_coeff" title="Link to this definition">#</a></dt>
<dd><p>The MAPMRI coefficients</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.mapmri_mu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mapmri_mu</span></span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.mapmri_mu" title="Link to this definition">#</a></dt>
<dd><p>The MAPMRI scale factors</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.msd">
<span class="sig-name descname"><span class="pre">msd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.msd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.msd" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical Mean Squared Displacement (MSD).</p>
<p>It is defined as the Laplacian of the origin of the estimated signal
<a class="footnote-reference brackets" href="#footcite-cheng2012" id="id229" role="doc-noteref"><span class="fn-bracket">[</span>56<span class="fn-bracket">]</span></a>. The analytical formula for the MAP-MRI basis
was derived in <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id230" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C13, D1).</p>
<p class="rubric">References</p>
<div class="docutils container" id="id231">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-cheng2012" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>56<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id229">1</a>,<a role="doc-backlink" href="#id310">2</a>)</span>
<p>Jian Cheng. <em>Estimation and Processing of Ensemble Average Propagator and Its Features in Diffusion MRI</em>. PhD thesis, Université Nice Sophia Antipolis, Valbonne, France, 2012. URL:, <a class="reference external" href="https://doi.org/">doi:</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-fick2016b" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id230">1</a>,<a role="doc-backlink" href="#id239">2</a>,<a role="doc-backlink" href="#id242">3</a>,<a role="doc-backlink" href="#id244">4</a>,<a role="doc-backlink" href="#id247">5</a>,<a role="doc-backlink" href="#id249">6</a>,<a role="doc-backlink" href="#id251">7</a>,<a role="doc-backlink" href="#id266">8</a>,<a role="doc-backlink" href="#id269">9</a>,<a role="doc-backlink" href="#id270">10</a>,<a role="doc-backlink" href="#id271">11</a>,<a role="doc-backlink" href="#id273">12</a>,<a role="doc-backlink" href="#id274">13</a>,<a role="doc-backlink" href="#id275">14</a>,<a role="doc-backlink" href="#id276">15</a>,<a role="doc-backlink" href="#id277">16</a>,<a role="doc-backlink" href="#id278">17</a>,<a role="doc-backlink" href="#id281">18</a>,<a role="doc-backlink" href="#id311">19</a>,<a role="doc-backlink" href="#id313">20</a>,<a role="doc-backlink" href="#id315">21</a>,<a role="doc-backlink" href="#id319">22</a>,<a role="doc-backlink" href="#id322">23</a>,<a role="doc-backlink" href="#id326">24</a>,<a role="doc-backlink" href="#id329">25</a>,<a role="doc-backlink" href="#id332">26</a>)</span>
<p>Rutger H. J. Fick, Demian Wassermann, Emmanuel Caruyer, and Rachid Deriche. MAPL: Tissue microstructure estimation using Laplacian-regularized MAP-MRI and its application to HCP data. <em>NeuroImage</em>, 134:365–385, July 2016. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.03.046">https://doi.org/10.1016/j.neuroimage.2016.03.046</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.03.046">doi:10.1016/j.neuroimage.2016.03.046</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.ng">
<span class="sig-name descname"><span class="pre">ng</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.ng"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.ng" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical non-Gaussiannity (NG).</p>
<p>For the NG to be meaningful the mapmri scale factors must be estimated
only on data representing Gaussian diffusion of spins, i.e., bvals
smaller than about 2000 s/mm^2 <a class="footnote-reference brackets" href="#footcite-avram2015" id="id232" role="doc-noteref"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></a>.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id233" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> for a definition of the metric.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id234">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-ozarslan2013" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id233">1</a>,<a role="doc-backlink" href="#id236">2</a>,<a role="doc-backlink" href="#id238">3</a>,<a role="doc-backlink" href="#id240">4</a>,<a role="doc-backlink" href="#id241">5</a>,<a role="doc-backlink" href="#id246">6</a>,<a role="doc-backlink" href="#id248">7</a>,<a role="doc-backlink" href="#id250">8</a>,<a role="doc-backlink" href="#id252">9</a>,<a role="doc-backlink" href="#id253">10</a>,<a role="doc-backlink" href="#id254">11</a>,<a role="doc-backlink" href="#id255">12</a>,<a role="doc-backlink" href="#id256">13</a>,<a role="doc-backlink" href="#id257">14</a>,<a role="doc-backlink" href="#id258">15</a>,<a role="doc-backlink" href="#id259">16</a>,<a role="doc-backlink" href="#id260">17</a>,<a role="doc-backlink" href="#id261">18</a>,<a role="doc-backlink" href="#id262">19</a>,<a role="doc-backlink" href="#id263">20</a>,<a role="doc-backlink" href="#id264">21</a>,<a role="doc-backlink" href="#id265">22</a>,<a role="doc-backlink" href="#id267">23</a>,<a role="doc-backlink" href="#id268">24</a>,<a role="doc-backlink" href="#id272">25</a>,<a role="doc-backlink" href="#id306">26</a>,<a role="doc-backlink" href="#id316">27</a>,<a role="doc-backlink" href="#id318">28</a>,<a role="doc-backlink" href="#id325">29</a>,<a role="doc-backlink" href="#id328">30</a>,<a role="doc-backlink" href="#id331">31</a>,<a role="doc-backlink" href="#id414">32</a>,<a role="doc-backlink" href="#id418">33</a>,<a role="doc-backlink" href="#id419">34</a>)</span>
<p>Evren Özarslan, Cheng Guan Koay, Timothy M. Shepherd, Michal E. Komlosh, M. Okan İrfanoǧlu, Carlo Pierpaoli, and Peter J. Basser. Mean apparent propagator (MAP) MRI: A novel diffusion imaging method for mapping tissue microstructure. <em>NeuroImage</em>, 78:16–32, 2013. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2013.04.016">https://doi.org/10.1016/j.neuroimage.2013.04.016</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2013.04.016">doi:10.1016/j.neuroimage.2013.04.016</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.ng_parallel">
<span class="sig-name descname"><span class="pre">ng_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.ng_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.ng_parallel" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical parallel non-Gaussiannity (NG).</p>
<p>For the NG to be meaningful the mapmri scale factors must be estimated
only on data representing Gaussian diffusion of spins, i.e., bvals
smaller than about 2000 s/mm^2 <a class="footnote-reference brackets" href="#footcite-avram2015" id="id235" role="doc-noteref"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></a>.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id236" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> for a definition of the metric.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.ng_perpendicular">
<span class="sig-name descname"><span class="pre">ng_perpendicular</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.ng_perpendicular"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.ng_perpendicular" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical perpendicular non-Gaussiannity (NG)</p>
<p>For the NG to be meaningful the mapmri scale factors must be estimated
only on data representing Gaussian diffusion of spins, i.e.,  bvals
smaller than about 2000 s/mm^2 <a class="footnote-reference brackets" href="#footcite-avram2015" id="id237" role="doc-noteref"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></a>.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id238" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> for a definition of the metric.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal">
<span class="sig-name descname"><span class="pre">norm_of_laplacian_signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.norm_of_laplacian_signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal" title="Link to this definition">#</a></dt>
<dd><p>Calculates the norm of the laplacian of the fitted signal.</p>
<p>This information could be useful to assess if the extrapolation of the
fitted signal contains spurious oscillations. A high laplacian may
indicate that these are present, and any q-space indices that use
integrals of the signal may be corrupted (e.g. RTOP, RTAP, RTPP, QIV).</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id239" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> for a definition of the metric.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.odf" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical Orientation Distribution Function (ODF)
from the signal.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id240" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. (32).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>A Sphere instance with vertices, edges and faces attributes.</p>
</dd>
<dt><strong>s</strong><span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.odf_sh">
<span class="sig-name descname"><span class="pre">odf_sh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.odf_sh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.odf_sh" title="Link to this definition">#</a></dt>
<dd><p>Calculates the real analytical odf for a given discrete sphere.</p>
<p>Computes the design matrix of the ODF for the given sphere vertices
and radial moment <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id241" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (32). The radial moment
s acts as a sharpening method. The analytical equation for the spherical
ODF basis  is given in <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id242" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C8).</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_points</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.pdf" title="Link to this definition">#</a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qvals_or_gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Recovers the reconstructed signal for any qvalue array or gradient
table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.qiv">
<span class="sig-name descname"><span class="pre">qiv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.qiv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.qiv" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical Q-space Inverse Variance (QIV).</p>
<p>It is defined as the inverse of the Laplacian of the origin of the
estimated propagator <a class="footnote-reference brackets" href="#footcite-hosseinbor2013" id="id243" role="doc-noteref"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></a> eq. (22). The
analytical formula for the MAP-MRI basis was derived in
<a class="footnote-reference brackets" href="#footcite-fick2016b" id="id244" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C14, D2).</p>
<p class="rubric">References</p>
<div class="docutils container" id="id245">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-hosseinbor2013" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id243">1</a>,<a role="doc-backlink" href="#id321">2</a>)</span>
<p>A. Pasha Hosseinbor, Moo K. Chung, Yu-Chien Wu, and Andrew L. Alexander. Bessel Fourier Orientation Reconstruction (BFOR): An analytical diffusion propagator reconstruction for hybrid diffusion imaging and computation of q-space indices. <em>NeuroImage</em>, 64:650–670, 2013. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2012.08.072">https://doi.org/10.1016/j.neuroimage.2012.08.072</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2012.08.072">doi:10.1016/j.neuroimage.2012.08.072</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.rtap">
<span class="sig-name descname"><span class="pre">rtap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.rtap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.rtap" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the axis probability (RTAP).</p>
<p>RTAP is defined in <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id246" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (40, 44a). The
analytical formula for the isotropic MAP-MRI basis was derived in
<a class="footnote-reference brackets" href="#footcite-fick2016b" id="id247" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C11).</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.rtop">
<span class="sig-name descname"><span class="pre">rtop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.rtop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.rtop" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the origin probability (RTOP).</p>
<p>RTOP is defined in <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id248" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (36, 43). The
analytical formula for the isotropic MAP-MRI basis was derived in
<a class="footnote-reference brackets" href="#footcite-fick2016b" id="id249" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C11).</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.rtpp">
<span class="sig-name descname"><span class="pre">rtpp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#MapmriFit.rtpp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.rtpp" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the plane probability (RTPP).</p>
<p>RTPP is defined in <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id250" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (42). The analytical
formula for the isotropic MAP-MRI basis was derived in
<a class="footnote-reference brackets" href="#footcite-fick2016b" id="id251" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C11).</p>
<p class="rubric">References</p>
</dd></dl>

</dd></dl>

</section>
<section id="isotropic-scale-factor">
<h3>isotropic_scale_factor<a class="headerlink" href="#isotropic-scale-factor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.isotropic_scale_factor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">isotropic_scale_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu_squared</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#isotropic_scale_factor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.isotropic_scale_factor" title="Link to this definition">#</a></dt>
<dd><p>Estimated isotropic scaling factor.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id252" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. (49).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mu_squared</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>squared scale factors of mapmri basis in x, y, z</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u0</strong><span class="classifier">float</span></dt><dd><p>closest isotropic scale factor for the isotropic basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-index-matrix">
<h3>mapmri_index_matrix<a class="headerlink" href="#mapmri-index-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_index_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_index_matrix" title="Link to this definition">#</a></dt>
<dd><p>Calculates the indices for the MAPMRI basis in x, y and z.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id253" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> for a definition of MAPMRI.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int</span></dt><dd><p>radial order of MAPMRI basis</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>index_matrix</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>ordering of the basis in x, y, z</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="b-mat">
<h3>b_mat<a class="headerlink" href="#b-mat" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.b_mat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">b_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#b_mat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.b_mat" title="Link to this definition">#</a></dt>
<dd><p>Calculates the B coefficients from</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id254" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. (27).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index_matrix</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>ordering of the basis in x, y, z</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>B</strong><span class="classifier">array, shape (N,)</span></dt><dd><p>B coefficients for the basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="b-mat-isotropic">
<h3>b_mat_isotropic<a class="headerlink" href="#b-mat-isotropic" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.b_mat_isotropic">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">b_mat_isotropic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#b_mat_isotropic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.b_mat_isotropic" title="Link to this definition">#</a></dt>
<dd><p>Calculates the isotropic B coefficients.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id255" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Fig 8.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index_matrix</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>ordering of the isotropic basis in j, l, m</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>B</strong><span class="classifier">array, shape (N,)</span></dt><dd><p>B coefficients for the isotropic basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-phi-1d">
<h3>mapmri_phi_1d<a class="headerlink" href="#mapmri-phi-1d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_phi_1d">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_phi_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_phi_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_phi_1d" title="Link to this definition">#</a></dt>
<dd><p>One dimensional MAPMRI basis function.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id256" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. (4).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">unsigned int</span></dt><dd><p>order of the basis</p>
</dd>
<dt><strong>q</strong><span class="classifier">array, shape (N,)</span></dt><dd><p>points in the q-space in which evaluate the basis</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float</span></dt><dd><p>scale factor of the basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-phi-matrix">
<h3>mapmri_phi_matrix<a class="headerlink" href="#mapmri-phi-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_phi_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_phi_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_gradients</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_phi_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_phi_matrix" title="Link to this definition">#</a></dt>
<dd><p>Compute the MAPMRI phi matrix for the signal.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id257" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (23).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>
</dd>
<dt><strong>q_gradients</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>points in the q-space in which evaluate the basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-psi-1d">
<h3>mapmri_psi_1d<a class="headerlink" href="#mapmri-psi-1d" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_psi_1d">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_psi_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_psi_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_psi_1d" title="Link to this definition">#</a></dt>
<dd><p>One dimensional MAPMRI propagator basis function.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id258" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. (10).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">unsigned int</span></dt><dd><p>order of the basis</p>
</dd>
<dt><strong>x</strong><span class="classifier">array, shape (N,)</span></dt><dd><p>points in the r-space in which evaluate the basis</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float</span></dt><dd><p>scale factor of the basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-psi-matrix">
<h3>mapmri_psi_matrix<a class="headerlink" href="#mapmri-psi-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_psi_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_psi_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgrad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_psi_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_psi_matrix" title="Link to this definition">#</a></dt>
<dd><p>Compute the MAPMRI psi matrix for the propagator.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id259" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (22).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>
</dd>
<dt><strong>rgrad</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>points in the r-space in which evaluate the EAP</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-odf-matrix">
<h3>mapmri_odf_matrix<a class="headerlink" href="#mapmri-odf-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_odf_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_odf_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_odf_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_odf_matrix" title="Link to this definition">#</a></dt>
<dd><p>Compute the MAPMRI ODF matrix.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id260" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. (33).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>
</dd>
<dt><strong>s</strong><span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
<dt><strong>vertices</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>points of the sphere shell in the r-space in which evaluate the ODF</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-phi-matrix">
<h3>mapmri_isotropic_phi_matrix<a class="headerlink" href="#mapmri-isotropic-phi-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_phi_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_phi_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_phi_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix" title="Link to this definition">#</a></dt>
<dd><p>Three dimensional isotropic MAPMRI signal basis function</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id261" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. (61).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>radial order of the mapmri basis.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float,</span></dt><dd><p>positive isotropic scale factor of the basis</p>
</dd>
<dt><strong>q</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>points in the q-space in which evaluate the basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-radial-signal-basis">
<h3>mapmri_isotropic_radial_signal_basis<a class="headerlink" href="#mapmri-isotropic-radial-signal-basis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_radial_signal_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_radial_signal_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis" title="Link to this definition">#</a></dt>
<dd><p>Radial part of the isotropic 1D-SHORE signal basis.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id262" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (61).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">unsigned int,</span></dt><dd><p>a positive integer related to the radial order</p>
</dd>
<dt><strong>l_value</strong><span class="classifier">unsigned int,</span></dt><dd><p>the spherical harmonic order (l)</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the basis</p>
</dd>
<dt><strong>qval</strong><span class="classifier">float,</span></dt><dd><p>points in the q-space in which evaluate the basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-m-mu-independent">
<h3>mapmri_isotropic_M_mu_independent<a class="headerlink" href="#mapmri-isotropic-m-mu-independent" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_M_mu_independent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_M_mu_independent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent" title="Link to this definition">#</a></dt>
<dd><p>Computed the mu independent part of the signal design matrix.</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-m-mu-dependent">
<h3>mapmri_isotropic_M_mu_dependent<a class="headerlink" href="#mapmri-isotropic-m-mu-dependent" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_M_mu_dependent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_M_mu_dependent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent" title="Link to this definition">#</a></dt>
<dd><p>Computed the mu dependent part of the signal design matrix.</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-psi-matrix">
<h3>mapmri_isotropic_psi_matrix<a class="headerlink" href="#mapmri-isotropic-psi-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_psi_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_psi_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgrad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_psi_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix" title="Link to this definition">#</a></dt>
<dd><p>Three dimensional isotropic MAPMRI propagator basis function.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id263" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. (61).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>radial order of the mapmri basis.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float,</span></dt><dd><p>positive isotropic scale factor of the basis</p>
</dd>
<dt><strong>rgrad</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>points in the r-space in which evaluate the basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-radial-pdf-basis">
<h3>mapmri_isotropic_radial_pdf_basis<a class="headerlink" href="#mapmri-isotropic-radial-pdf-basis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_radial_pdf_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_radial_pdf_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis" title="Link to this definition">#</a></dt>
<dd><p>Radial part of the isotropic 1D-SHORE propagator basis.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id264" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (61).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">unsigned int,</span></dt><dd><p>a positive integer related to the radial order</p>
</dd>
<dt><strong>l_value</strong><span class="classifier">unsigned int,</span></dt><dd><p>the spherical harmonic order (l)</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the basis</p>
</dd>
<dt><strong>r</strong><span class="classifier">float,</span></dt><dd><p>points in the r-space in which evaluate the basis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-k-mu-independent">
<h3>mapmri_isotropic_K_mu_independent<a class="headerlink" href="#mapmri-isotropic-k-mu-independent" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_K_mu_independent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgrad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_K_mu_independent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent" title="Link to this definition">#</a></dt>
<dd><p>Computes mu independent part of K. Same trick as with M.</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-k-mu-dependent">
<h3>mapmri_isotropic_K_mu_dependent<a class="headerlink" href="#mapmri-isotropic-k-mu-dependent" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_K_mu_dependent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgrad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_K_mu_dependent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent" title="Link to this definition">#</a></dt>
<dd><p>Computes mu dependent part of M. Same trick as with M.</p>
</dd></dl>

</section>
<section id="binomialfloat">
<h3>binomialfloat<a class="headerlink" href="#binomialfloat" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.binomialfloat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">binomialfloat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#binomialfloat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.binomialfloat" title="Link to this definition">#</a></dt>
<dd><p>Custom Binomial function</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-odf-matrix">
<h3>mapmri_isotropic_odf_matrix<a class="headerlink" href="#mapmri-isotropic-odf-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_odf_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_odf_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_odf_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix" title="Link to this definition">#</a></dt>
<dd><p>Compute the isotropic MAPMRI ODF matrix.</p>
<p>The computation follows <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id265" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. 32, but it is done
for the isotropic propagator in footcite:p:<cite>Ozarslan2013</cite> eq. (60).
Analytical derivation in <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id266" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C8).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
<dt><strong>s</strong><span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
<dt><strong>vertices</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>points of the sphere shell in the r-space in which evaluate the ODF</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>odf_mat</strong><span class="classifier">Matrix, shape (N_vertices, N_mapmri_coef)</span></dt><dd><p>ODF design matrix to discrete sphere function</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-odf-sh-matrix">
<h3>mapmri_isotropic_odf_sh_matrix<a class="headerlink" href="#mapmri-isotropic-odf-sh-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_odf_sh_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_odf_sh_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix" title="Link to this definition">#</a></dt>
<dd><p>Compute the isotropic MAPMRI ODF matrix.</p>
<p>The computation follows <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id267" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. 32, but it is done
for the isotropic propagator in <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id268" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (60). Here
we do not compute the sphere function but the spherical harmonics by only
integrating the radial part of the propagator. We use the same derivation of
the ODF in the isotropic implementation as in <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id269" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq.
(C8).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
<dt><strong>s</strong><span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>odf_sh_mat</strong><span class="classifier">Matrix, shape (N_sh_coef, N_mapmri_coef)</span></dt><dd><p>ODF design matrix to spherical harmonics</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-laplacian-reg-matrix">
<h3>mapmri_isotropic_laplacian_reg_matrix<a class="headerlink" href="#mapmri-isotropic-laplacian-reg-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_laplacian_reg_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_laplacian_reg_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix" title="Link to this definition">#</a></dt>
<dd><p>Computes the Laplacian regularization matrix for MAP-MRI’s isotropic
implementation.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id270" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C7).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>LR</strong><span class="classifier">Matrix, shape (N_coef, N_coef)</span></dt><dd><p>Laplacian regularization matrix</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-laplacian-reg-matrix-from-index-matrix">
<h3>mapmri_isotropic_laplacian_reg_matrix_from_index_matrix<a class="headerlink" href="#mapmri-isotropic-laplacian-reg-matrix-from-index-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_laplacian_reg_matrix_from_index_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix" title="Link to this definition">#</a></dt>
<dd><p>Computes the Laplacian regularization matrix for MAP-MRI’s isotropic
implementation.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id271" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C7).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind_mat</strong><span class="classifier">matrix (N_coef, 3),</span></dt><dd><p>Basis order matrix</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>LR</strong><span class="classifier">Matrix, shape (N_coef, N_coef)</span></dt><dd><p>Laplacian regularization matrix</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-index-matrix">
<h3>mapmri_isotropic_index_matrix<a class="headerlink" href="#mapmri-isotropic-index-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_isotropic_index_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_index_matrix" title="Link to this definition">#</a></dt>
<dd><p>Calculates the indices for the isotropic MAPMRI basis.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id272" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Fig 8.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int</span></dt><dd><p>radial order of isotropic MAPMRI basis</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>index_matrix</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>ordering of the basis in x, y, z</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="create-rspace">
<h3>create_rspace<a class="headerlink" href="#create-rspace" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.create_rspace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">create_rspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_max</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#create_rspace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.create_rspace" title="Link to this definition">#</a></dt>
<dd><p>Create the real space table, that contains the points in which
to compute the pdf.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gridsize</strong><span class="classifier">unsigned int</span></dt><dd><p>dimension of the propagator grid</p>
</dd>
<dt><strong>radius_max</strong><span class="classifier">float</span></dt><dd><p>maximal radius in which compute the propagator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tab</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>real space points in which calculates the pdf</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="delta">
<h3>delta<a class="headerlink" href="#delta" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.delta">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">delta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#delta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.delta" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="map-laplace-u">
<h3>map_laplace_u<a class="headerlink" href="#map-laplace-u" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.map_laplace_u">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">map_laplace_u</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#map_laplace_u"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.map_laplace_u" title="Link to this definition">#</a></dt>
<dd><p>S(n, m) static matrix for Laplacian regularization.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id273" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (13).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n, m</strong><span class="classifier">unsigned int</span></dt><dd><p>basis order of the MAP-MRI basis in different directions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>U</strong><span class="classifier">float,</span></dt><dd><p>Analytical integral of <span class="math notranslate nohighlight">\(\phi_n(q) * \phi_m(q)\)</span></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="map-laplace-t">
<h3>map_laplace_t<a class="headerlink" href="#map-laplace-t" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.map_laplace_t">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">map_laplace_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#map_laplace_t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.map_laplace_t" title="Link to this definition">#</a></dt>
<dd><p>L(m, n) static matrix for Laplacian regularization.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id274" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (12).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n, m</strong><span class="classifier">unsigned int</span></dt><dd><p>basis order of the MAP-MRI basis in different directions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Analytical integral of <span class="math notranslate nohighlight">\(\phi_n(q) * \phi_m''(q)\)</span></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="map-laplace-s">
<h3>map_laplace_s<a class="headerlink" href="#map-laplace-s" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.map_laplace_s">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">map_laplace_s</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#map_laplace_s"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.map_laplace_s" title="Link to this definition">#</a></dt>
<dd><p>R(m,n) static matrix for Laplacian regularization.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id275" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (11).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n, m</strong><span class="classifier">unsigned int</span></dt><dd><p>basis order of the MAP-MRI basis in different directions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">float</span></dt><dd><p>Analytical integral of <span class="math notranslate nohighlight">\(\phi_n''(q) * \phi_m''(q)\)</span></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-stu-reg-matrices">
<h3>mapmri_STU_reg_matrices<a class="headerlink" href="#mapmri-stu-reg-matrices" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_STU_reg_matrices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_STU_reg_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_STU_reg_matrices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_STU_reg_matrices" title="Link to this definition">#</a></dt>
<dd><p>Generate the static portions of the Laplacian regularization matrix.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id276" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (11, 12, 13).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S, T, U</strong><span class="classifier">Matrices, shape (N_coef,N_coef)</span></dt><dd><p>Regularization submatrices</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="mapmri-laplacian-reg-matrix">
<h3>mapmri_laplacian_reg_matrix<a class="headerlink" href="#mapmri-laplacian-reg-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_laplacian_reg_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_laplacian_reg_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#mapmri_laplacian_reg_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix" title="Link to this definition">#</a></dt>
<dd><p>Put the Laplacian regularization matrix together.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id277" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (10).</p>
<p>The static parts in S, T and U are multiplied and divided by the
voxel-specific scale factors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind_mat</strong><span class="classifier">matrix (N_coef, 3),</span></dt><dd><p>Basis order matrix</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>
</dd>
<dt><strong>S, T, U</strong><span class="classifier">matrices, shape (N_coef,N_coef)</span></dt><dd><p>Regularization submatrices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>LR</strong><span class="classifier">matrix (N_coef, N_coef),</span></dt><dd><p>Voxel-specific Laplacian regularization matrix</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="generalized-crossvalidation-array">
<h3>generalized_crossvalidation_array<a class="headerlink" href="#generalized-crossvalidation-array" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.generalized_crossvalidation_array">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">generalized_crossvalidation_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LR</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#generalized_crossvalidation_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.generalized_crossvalidation_array" title="Link to this definition">#</a></dt>
<dd><p>Generalized Cross Validation Function.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id278" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (15).</p>
<p>Here weights_array is a numpy array with all values that should be
considered in the GCV. It will run through the weights until the cost
function starts to increase, then stop and take the last value as the
optimum weight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array (N),</span></dt><dd><p>Basis order matrix</p>
</dd>
<dt><strong>M</strong><span class="classifier">matrix, shape (N, Ncoef)</span></dt><dd><p>mapmri observation matrix</p>
</dd>
<dt><strong>LR</strong><span class="classifier">matrix, shape (N_coef, N_coef)</span></dt><dd><p>regularization matrix</p>
</dd>
<dt><strong>weights_array</strong><span class="classifier">array (N_of_weights)</span></dt><dd><p>array of optional regularization weights</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="generalized-crossvalidation">
<h3>generalized_crossvalidation<a class="headerlink" href="#generalized-crossvalidation" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.generalized_crossvalidation">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">generalized_crossvalidation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LR</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gcv_startpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#generalized_crossvalidation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.generalized_crossvalidation" title="Link to this definition">#</a></dt>
<dd><p>Generalized Cross Validation Function.</p>
<p>Finds optimal regularization weight based on generalized cross-validation.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-craven1979" id="id279" role="doc-noteref"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></a> eq. (15).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array (N),</span></dt><dd><p>data array</p>
</dd>
<dt><strong>M</strong><span class="classifier">matrix, shape (N, Ncoef)</span></dt><dd><p>mapmri observation matrix</p>
</dd>
<dt><strong>LR</strong><span class="classifier">matrix, shape (N_coef, N_coef)</span></dt><dd><p>regularization matrix</p>
</dd>
<dt><strong>gcv_startpoint</strong><span class="classifier">float</span></dt><dd><p>startpoint for the gcv optimization</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>optimal_lambda</strong><span class="classifier">float,</span></dt><dd><p>optimal regularization weight</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id280">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-craven1979" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id279">1</a>,<a role="doc-backlink" href="#id307">2</a>,<a role="doc-backlink" href="#id346">3</a>,<a role="doc-backlink" href="#id348">4</a>)</span>
<p>Peter Craven and Grace Wahba. Smoothing Noisy Data with Spline Functions - Estimating the Correct Degree of Smoothing by the Method of Generalized Cross-Validation. <em>Numerische Mathematik</em>, 31(4):377–403, 1979. <a class="reference external" href="https://doi.org/">doi:</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="gcv-cost-function">
<h3>gcv_cost_function<a class="headerlink" href="#gcv-cost-function" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.gcv_cost_function">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">gcv_cost_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mapmri.html#gcv_cost_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mapmri.gcv_cost_function" title="Link to this definition">#</a></dt>
<dd><p>The GCV cost function that is iterated.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id281" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="multishellresponse">
<h3><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellResponse" title="dipy.reconst.mcsd.MultiShellResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiShellResponse</span></code></a><a class="headerlink" href="#multishellresponse" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellResponse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">MultiShellResponse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shells</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#MultiShellResponse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellResponse" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>iso</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellResponse.iso">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iso</span></span><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellResponse.iso" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="multishelldeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellDeconvModel" title="dipy.reconst.mcsd.MultiShellDeconvModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiShellDeconvModel</span></code></a><a class="headerlink" href="#multishelldeconvmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellDeconvModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">MultiShellDeconvModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_sphere=&lt;dipy.core.sphere.HemiSphere</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max=8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iso=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#MultiShellDeconvModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellDeconvModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellDeconvModel.fit" title="dipy.reconst.mcsd.MultiShellDeconvModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellDeconvModel.predict" title="dipy.reconst.mcsd.MultiShellDeconvModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(params, *[, gtab, S0])</p></td>
<td><p>Compute a signal prediction given spherical harmonic coefficients for the provided GradientTable class instance.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</p></td>
<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellDeconvModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellDeconvModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellDeconvModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#MultiShellDeconvModel.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellDeconvModel.predict" title="Link to this definition">#</a></dt>
<dd><p>Compute a signal prediction given spherical harmonic coefficients
for the provided GradientTable class instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">ndarray</span></dt><dd><p>The spherical harmonic representation of the FOD from which to make
the signal prediction.</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>The gradients for which the signal will be predicted. Use the
model’s gradient table by default.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">ndarray or float</span></dt><dd><p>The non diffusion-weighted signal value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="msdeconvfit">
<h3><a class="reference internal" href="#dipy.reconst.mcsd.MSDeconvFit" title="dipy.reconst.mcsd.MSDeconvFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MSDeconvFit</span></code></a><a class="headerlink" href="#msdeconvfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MSDeconvFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">MSDeconvFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#MSDeconvFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.MSDeconvFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>all_shm_coeff</strong></dt><dd></dd>
<dt><strong>shape</strong></dt><dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.mcsd.MSDeconvFit.shm_coeff" title="dipy.reconst.mcsd.MSDeconvFit.shm_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm_coeff</span></code></a></dt><dd><p>The spherical harmonic coefficients of the odf</p>
</dd>
<dt><strong>volume_fractions</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</p></td>
<td><p>Samples the odf function on the points of a sphere</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code>(*[, gtab, S0])</p></td>
<td><p>Predict the diffusion signal from the model coefficients.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>gfa</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MSDeconvFit.all_shm_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_shm_coeff</span></span><a class="headerlink" href="#dipy.reconst.mcsd.MSDeconvFit.all_shm_coeff" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MSDeconvFit.shm_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shm_coeff</span></span><a class="headerlink" href="#dipy.reconst.mcsd.MSDeconvFit.shm_coeff" title="Link to this definition">#</a></dt>
<dd><p>The spherical harmonic coefficients of the odf</p>
<p>Make this a property for now, if there is a use case for modifying
the coefficients we can add a setter or expose the coefficients more
directly</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MSDeconvFit.volume_fractions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">volume_fractions</span></span><a class="headerlink" href="#dipy.reconst.mcsd.MSDeconvFit.volume_fractions" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="qpfitter">
<h3><a class="reference internal" href="#dipy.reconst.mcsd.QpFitter" title="dipy.reconst.mcsd.QpFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">QpFitter</span></code></a><a class="headerlink" href="#qpfitter" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.QpFitter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">QpFitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#QpFitter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.QpFitter" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(signal)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
</tbody>
</table>
</div>
</dd></dl>

</section>
<section id="multi-tissue-basis">
<h3>multi_tissue_basis<a class="headerlink" href="#multi-tissue-basis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.multi_tissue_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">multi_tissue_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iso_comp</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#multi_tissue_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.multi_tissue_basis" title="Link to this definition">#</a></dt>
<dd><p>Builds a basis for multi-shell multi-tissue CSD model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>sh_order_max</strong><span class="classifier">int</span></dt><dd><p>Maximal spherical harmonics order (l).</p>
</dd>
<dt><strong>iso_comp: int</strong></dt><dd><p>Number of tissue compartments for running the MSMT-CSD. Minimum
number of compartments required is 2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>B</strong><span class="classifier">ndarray</span></dt><dd><p>Matrix of the spherical harmonics model used to fit the data</p>
</dd>
<dt><strong>m_values</strong><span class="classifier">int <code class="docutils literal notranslate"><span class="pre">|m_value|</span> <span class="pre">&lt;=</span> <span class="pre">l_value</span></code></span></dt><dd><p>The phase factor (<span class="math notranslate nohighlight">\(m\)</span>) of the harmonic.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">int <code class="docutils literal notranslate"><span class="pre">l_value</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt><dd><p>The order (<span class="math notranslate nohighlight">\(l\)</span>) of the harmonic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="solve-qp">
<h3>solve_qp<a class="headerlink" href="#solve-qp" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.solve_qp">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">solve_qp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#solve_qp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.solve_qp" title="Link to this definition">#</a></dt>
<dd><p>Helper function to set up and solve the Quadratic Program (QP) in CVXPY.
A QP problem has the following form:
minimize      1/2 x’ P x + Q’ x
subject to    G x &lt;= H</p>
<p>Here the QP solver is based on CVXPY and uses OSQP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>P</strong><span class="classifier">ndarray</span></dt><dd><p>n x n matrix for the primal QP objective function.</p>
</dd>
<dt><strong>Q</strong><span class="classifier">ndarray</span></dt><dd><p>n x 1 matrix for the primal QP objective function.</p>
</dd>
<dt><strong>G</strong><span class="classifier">ndarray</span></dt><dd><p>m x n matrix for the inequality constraint.</p>
</dd>
<dt><strong>H</strong><span class="classifier">ndarray</span></dt><dd><p>m x 1 matrix for the inequality constraint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array</span></dt><dd><p>Optimal solution to the QP problem.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="multi-shell-fiber-response">
<h3>multi_shell_fiber_response<a class="headerlink" href="#multi-shell-fiber-response" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.multi_shell_fiber_response">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">multi_shell_fiber_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_rf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_rf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_rf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">btens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#multi_shell_fiber_response"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.multi_shell_fiber_response" title="Link to this definition">#</a></dt>
<dd><p>Fiber response function estimation for multi-shell data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>sh_order_max</strong><span class="classifier">int</span></dt><dd><p>Maximum spherical harmonics order (l).</p>
</dd>
<dt><strong>bvals</strong><span class="classifier">ndarray</span></dt><dd><p>Array containing the b-values. Must be unique b-values, like outputted
by <cite>dipy.core.gradients.unique_bvals_tolerance</cite>.</p>
</dd>
<dt><strong>wm_rf</strong><span class="classifier">(N-1, 4) ndarray</span></dt><dd><p>Response function of the WM tissue, for each bvals,
where N is the number of unique b-values including the b0.</p>
</dd>
<dt><strong>gm_rf</strong><span class="classifier">(N-1, 4) ndarray</span></dt><dd><p>Response function of the GM tissue, for each bvals.</p>
</dd>
<dt><strong>csf_rf</strong><span class="classifier">(N-1, 4) ndarray</span></dt><dd><p>Response function of the CSF tissue, for each bvals.</p>
</dd>
<dt><strong>sphere</strong><span class="classifier"><cite>dipy.core.Sphere</cite> instance, optional</span></dt><dd><p>Sphere where the signal will be evaluated.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">int, optional</span></dt><dd><p>Tolerance gap for b-values clustering.</p>
</dd>
<dt><strong>btens</strong><span class="classifier">can be any of two options, optional</span></dt><dd><ol class="arabic simple">
<li><p>an array of strings of shape (N,) specifying
encoding tensor shape associated with all unique b-values
separately. N corresponds to the number of unique b-values,
including the b0. Options for elements in array: ‘LTE’,
‘PTE’, ‘STE’, ‘CTE’ corresponding to linear, planar, spherical, and
“cigar-shaped” tensor encoding.</p></li>
<li><p>an array of shape (N,3,3) specifying the b-tensor of each unique
b-values exactly. N corresponds to the number of unique b-values,
including the b0.</p></li>
</ol>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>MultiShellResponse</dt><dd><p>MultiShellResponse object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="mask-for-response-msmt">
<h3>mask_for_response_msmt<a class="headerlink" href="#mask-for-response-msmt" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.mask_for_response_msmt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">mask_for_response_msmt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_md_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0007</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_md_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.002</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#mask_for_response_msmt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.mask_for_response_msmt" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computation of masks for multi-shell multi-tissue (msmt) response</dt><dd><p>function using FA and MD.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>diffusion data (4D)</p>
</dd>
<dt><strong>roi_center</strong><span class="classifier">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt><strong>roi_radii</strong><span class="classifier">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>
</dd>
<dt><strong>wm_fa_thr</strong><span class="classifier">float</span></dt><dd><p>FA threshold for WM.</p>
</dd>
<dt><strong>gm_fa_thr</strong><span class="classifier">float</span></dt><dd><p>FA threshold for GM.</p>
</dd>
<dt><strong>csf_fa_thr</strong><span class="classifier">float</span></dt><dd><p>FA threshold for CSF.</p>
</dd>
<dt><strong>gm_md_thr</strong><span class="classifier">float</span></dt><dd><p>MD threshold for GM.</p>
</dd>
<dt><strong>csf_md_thr</strong><span class="classifier">float</span></dt><dd><p>MD threshold for CSF.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask_wm</strong><span class="classifier">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA above the FA threshold
for WM.</p>
</dd>
<dt><strong>mask_gm</strong><span class="classifier">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA below the FA threshold
for GM and with MD below the MD threshold for GM.</p>
</dd>
<dt><strong>mask_csf</strong><span class="classifier">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA below the FA threshold
for CSF and with MD below the MD threshold for CSF.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In msmt-CSD there is an important pre-processing step: the estimation of
every tissue’s response function. In order to do this, we look for voxels
corresponding to WM, GM and CSF. This function aims to accomplish that by
returning a mask of voxels within a ROI and who respect some threshold
constraints, for each tissue. More precisely, the WM mask must have a FA
value above a given threshold. The GM mask and CSF mask must have a FA
below given thresholds and a MD below other thresholds. To get the FA and
MD, we need to fit a Tensor model to the datasets.</p>
</dd></dl>

</section>
<section id="response-from-mask-msmt">
<h3>response_from_mask_msmt<a class="headerlink" href="#response-from-mask-msmt" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.response_from_mask_msmt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">response_from_mask_msmt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_wm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_gm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_csf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#response_from_mask_msmt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.response_from_mask_msmt" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computation of multi-shell multi-tissue (msmt) response</dt><dd><p>functions from given tissues masks.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>diffusion data</p>
</dd>
<dt><strong>mask_wm</strong><span class="classifier">ndarray</span></dt><dd><p>mask from where to compute the WM response function.</p>
</dd>
<dt><strong>mask_gm</strong><span class="classifier">ndarray</span></dt><dd><p>mask from where to compute the GM response function.</p>
</dd>
<dt><strong>mask_csf</strong><span class="classifier">ndarray</span></dt><dd><p>mask from where to compute the CSF response function.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">int</span></dt><dd><p>tolerance gap for b-values clustering. (Default = 20)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response_wm</strong><span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for WM for each unique bvalues (except b0).</p>
</dd>
<dt><strong>response_gm</strong><span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for GM for each unique bvalues (except b0).</p>
</dd>
<dt><strong>response_csf</strong><span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for CSF for each unique bvalues (except b0).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In msmt-CSD there is an important pre-processing step: the estimation of
every tissue’s response function. In order to do this, we look for voxels
corresponding to WM, GM and CSF. This information can be obtained by using
mcsd.mask_for_response_msmt() through masks of selected voxels. The present
function uses such masks to compute the msmt response functions.</p>
<p>For the responses, we base our approach on the function
csdeconv.response_from_mask_ssst(), with the added layers of multishell and
multi-tissue (see the ssst function for more information about the
computation of the ssst response function). This means that for each tissue
we use the previously found masks and loop on them. For each mask, we loop
on the b-values (clustered using the tolerance gap) to get many responses
and then average them to get one response per tissue.</p>
</dd></dl>

</section>
<section id="auto-response-msmt">
<h3>auto_response_msmt<a class="headerlink" href="#auto-response-msmt" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.auto_response_msmt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">auto_response_msmt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_md_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_md_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0032</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/mcsd.html#auto_response_msmt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.mcsd.auto_response_msmt" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Automatic estimation of multi-shell multi-tissue (msmt) response</dt><dd><p>functions using FA and MD.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>diffusion data</p>
</dd>
<dt><strong>tol</strong><span class="classifier">int, optional</span></dt><dd><p>Tolerance gap for b-values clustering.</p>
</dd>
<dt><strong>roi_center</strong><span class="classifier">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt><strong>roi_radii</strong><span class="classifier">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>
</dd>
<dt><strong>wm_fa_thr</strong><span class="classifier">float</span></dt><dd><p>FA threshold for WM.</p>
</dd>
<dt><strong>gm_fa_thr</strong><span class="classifier">float</span></dt><dd><p>FA threshold for GM.</p>
</dd>
<dt><strong>csf_fa_thr</strong><span class="classifier">float</span></dt><dd><p>FA threshold for CSF.</p>
</dd>
<dt><strong>gm_md_thr</strong><span class="classifier">float</span></dt><dd><p>MD threshold for GM.</p>
</dd>
<dt><strong>csf_md_thr</strong><span class="classifier">float</span></dt><dd><p>MD threshold for CSF.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response_wm</strong><span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for WM for each unique bvalues (except b0).</p>
</dd>
<dt><strong>response_gm</strong><span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for GM for each unique bvalues (except b0).</p>
</dd>
<dt><strong>response_csf</strong><span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for CSF for each unique bvalues (except b0).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In msmt-CSD there is an important pre-processing step: the estimation of
every tissue’s response function. In order to do this, we look for voxels
corresponding to WM, GM and CSF. We get this information from
mcsd.mask_for_response_msmt(), which returns masks of selected voxels
(more details are available in the description of the function).</p>
<p>With the masks, we compute the response functions by using
mcsd.response_from_mask_msmt(), which returns the <cite>response</cite> for each
tissue (more details are available in the description of the function).</p>
</dd></dl>

</section>
<section id="meandiffusionkurtosismodel">
<h3><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel" title="dipy.reconst.msdki.MeanDiffusionKurtosisModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel</span></code></a><a class="headerlink" href="#meandiffusionkurtosismodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">MeanDiffusionKurtosisModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bmag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Mean signal Diffusion Kurtosis Model</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit" title="dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method of the MSDKI model class</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict" title="dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(msdki_params, *[, S0])</p></td>
<td><p>Predict a signal for this MeanDiffusionKurtosisModel class instance given parameters.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method of the MSDKI model class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">ndarray ([X, Y, Z, …], g)</span></dt><dd><p>ndarray containing the data signals in its last dimension.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msdki_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisModel.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict a signal for this MeanDiffusionKurtosisModel class instance
given parameters.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2018" id="id282" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> for further details about the
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>msdki_params</strong><span class="classifier">ndarray</span></dt><dd><p>The parameters of the mean signal diffusion kurtosis model</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated mean signal based on the mean signal diffusion kurtosis
model</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>The predicted signal is given by:</dt><dd><p><span class="math notranslate nohighlight">\(MS(b) = S_0 * exp(-bD + 1/6 b^{2} D^{2} K)\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(K\)</span> are
the mean signal diffusivity and mean signal kurtosis.</p>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</dd></dl>

</section>
<section id="meandiffusionkurtosisfit">
<h3><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit</span></code></a><a class="headerlink" href="#meandiffusionkurtosisfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">MeanDiffusionKurtosisFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S0_hat</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd</span></code></a>()</p></td>
<td><p>Mean signal diffusivity (MSD) calculated from the mean signal Diffusion Kurtosis Model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msk</span></code></a>()</p></td>
<td><p>Mean signal kurtosis (MSK) calculated from the mean signal Diffusion Kurtosis Model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab, *[, S0])</p></td>
<td><p>Given a mean signal diffusion kurtosis model fit, predict the signal on the vertices of a sphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smt2di</span></code></a>()</p></td>
<td><p>Computes the intrinsic diffusivity from the mean signal diffusional kurtosis parameters assuming the 2-compartmental spherical mean technique model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smt2f</span></code></a>()</p></td>
<td><p>Computes the axonal water fraction from the mean signal kurtosis assuming the 2-compartmental spherical mean technique model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smt2uFA</span></code></a>()</p></td>
<td><p>Computes the microscopic fractional anisotropy from the mean signal diffusional kurtosis parameters assuming the 2-compartmental spherical mean technique model.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.S0_hat">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">S0_hat</span></span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.S0_hat" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd">
<span class="sig-name descname"><span class="pre">msd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisFit.msd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd" title="Link to this definition">#</a></dt>
<dd><p>Mean signal diffusivity (MSD) calculated from the mean signal
Diffusion Kurtosis Model.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2018" id="id283" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> for further details about the
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>msd</strong><span class="classifier">ndarray</span></dt><dd><p>Calculated signal mean diffusivity.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk">
<span class="sig-name descname"><span class="pre">msk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisFit.msk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk" title="Link to this definition">#</a></dt>
<dd><p>Mean signal kurtosis (MSK) calculated from the mean signal
Diffusion Kurtosis Model.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2018" id="id284" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> for further details about the
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>msk</strong><span class="classifier">ndarray</span></dt><dd><p>Calculated signal mean kurtosis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Given a mean signal diffusion kurtosis model fit, predict the signal
on the vertices of a sphere</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2018" id="id285" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> for further details about the
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>This encodes the directions for which a prediction is made</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float array</span></dt><dd><p>The mean non-diffusion weighted signal in each voxel. Default:
The fitted S0 value in all voxels if it was fitted. Otherwise 1 in
all voxels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated mean signal based on the mean signal kurtosis model</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:
<span class="math notranslate nohighlight">\(MS(b) = S_0 * exp(-bD + 1/6 b^{2} D^{2} K)\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(k\)</span> are the
mean signal diffusivity and mean signal kurtosis.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di">
<span class="sig-name descname"><span class="pre">smt2di</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisFit.smt2di"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di" title="Link to this definition">#</a></dt>
<dd><p>Computes the intrinsic diffusivity from the mean signal diffusional
kurtosis parameters assuming the 2-compartmental spherical mean
technique model.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-kaden2016b" id="id286" role="doc-noteref"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2019" id="id287" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>smt2di</strong><span class="classifier">ndarray</span></dt><dd><p>Intrinsic diffusivity computed by converting MSDKI to SMT2.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Computes the intrinsic diffusivity using equation 16 of
<a class="footnote-reference brackets" href="#footcite-netohenriques2019" id="id288" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id289">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-kaden2016b" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id286">1</a>,<a role="doc-backlink" href="#id290">2</a>,<a role="doc-backlink" href="#id293">3</a>,<a role="doc-backlink" href="#id297">4</a>)</span>
<p>Enrico Kaden, Nathaniel D. Kelm, Robert P. Carson, Mark D. Does, and Daniel C. Alexander. Multi-compartment microscopic diffusion imaging. <em>NeuroImage</em>, 139:346–359, October 2016. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.06.002">https://doi.org/10.1016/j.neuroimage.2016.06.002</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.06.002">doi:10.1016/j.neuroimage.2016.06.002</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-netohenriques2019" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id287">1</a>,<a role="doc-backlink" href="#id288">2</a>,<a role="doc-backlink" href="#id291">3</a>,<a role="doc-backlink" href="#id292">4</a>,<a role="doc-backlink" href="#id294">5</a>,<a role="doc-backlink" href="#id295">6</a>,<a role="doc-backlink" href="#id296">7</a>,<a role="doc-backlink" href="#id298">8</a>,<a role="doc-backlink" href="#id299">9</a>)</span>
<p>Rafael Neto Henriques, Sune N. Jespersen, and Noam Shemesh. Microscopic anisotropy misestimation in spherical-mean single diffusion encoding MRI. <em>Magnetic Resonance in Medicine</em>, 81(5):3245–3261, 2019. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.27606">https://doi.org/10.1002/mrm.27606</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.27606">doi:10.1002/mrm.27606</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f">
<span class="sig-name descname"><span class="pre">smt2f</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisFit.smt2f"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f" title="Link to this definition">#</a></dt>
<dd><p>Computes the axonal water fraction from the mean signal kurtosis
assuming the 2-compartmental spherical mean technique model.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-kaden2016b" id="id290" role="doc-noteref"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2019" id="id291" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray</dt><dd><p>Axonal volume fraction calculated from MSK.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Computes the axonal water fraction from the mean signal kurtosis
MSK using equation 17 of <a class="footnote-reference brackets" href="#footcite-netohenriques2019" id="id292" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA">
<span class="sig-name descname"><span class="pre">smt2uFA</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#MeanDiffusionKurtosisFit.smt2uFA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA" title="Link to this definition">#</a></dt>
<dd><p>Computes the microscopic fractional anisotropy from the mean signal
diffusional kurtosis parameters assuming the 2-compartmental spherical
mean technique model.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-kaden2016b" id="id293" role="doc-noteref"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2019" id="id294" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>smt2uFA</strong><span class="classifier">ndarray</span></dt><dd><p>Microscopic fractional anisotropy computed by converting MSDKI to
SMT2.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Computes the intrinsic diffusivity using equation 10 of
<a class="footnote-reference brackets" href="#footcite-netohenriques2019" id="id295" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</dd></dl>

</section>
<section id="mean-signal-bvalue">
<h3>mean_signal_bvalue<a class="headerlink" href="#mean-signal-bvalue" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.mean_signal_bvalue">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">mean_signal_bvalue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bmag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#mean_signal_bvalue"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.mean_signal_bvalue" title="Link to this definition">#</a></dt>
<dd><p>Computes the average signal across different diffusion directions
for each unique b-value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">ndarray ([X, Y, Z, …], g)</span></dt><dd><p>ndarray containing the data signals in its last dimension.</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table containing diffusion acquisition parameters.</p>
</dd>
<dt><strong>bmag</strong><span class="classifier">The order of magnitude that the bvalues have to differ to be</span></dt><dd><p>considered an unique b-value. Default: derive this value from the
maximal b-value provided: <span class="math notranslate nohighlight">\(bmag=log_{10}(max(bvals)) - 1\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>msignal</strong><span class="classifier">ndarray ([X, Y, Z, …, nub])</span></dt><dd><p>Mean signal along all gradient directions for each unique b-value
Note that the last dimension contains the signal means and nub is the
number of unique b-values.</p>
</dd>
<dt><strong>ng</strong><span class="classifier">ndarray(nub)</span></dt><dd><p>Number of gradient directions used to compute the mean signal for
all unique b-values</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function assumes that directions are evenly sampled on the sphere or
on the hemisphere</p>
</dd></dl>

</section>
<section id="msk-from-awf">
<h3>msk_from_awf<a class="headerlink" href="#msk-from-awf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.msk_from_awf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">msk_from_awf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#msk_from_awf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.msk_from_awf" title="Link to this definition">#</a></dt>
<dd><p>Computes mean signal kurtosis from axonal water fraction estimates of the
SMT2 model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray ([X, Y, Z, …])</span></dt><dd><p>ndarray containing the axonal volume fraction estimate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>msk</strong><span class="classifier">ndarray(nub)</span></dt><dd><p>Mean signal kurtosis (msk)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Computes mean signal kurtosis using equations 17 of
<a class="footnote-reference brackets" href="#footcite-netohenriques2019" id="id296" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="awf-from-msk">
<h3>awf_from_msk<a class="headerlink" href="#awf-from-msk" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.awf_from_msk">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">awf_from_msk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#awf_from_msk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.awf_from_msk" title="Link to this definition">#</a></dt>
<dd><p>Computes the axonal water fraction from the mean signal kurtosis
assuming the 2-compartmental spherical mean technique model.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-kaden2016b" id="id297" role="doc-noteref"><span class="fn-bracket">[</span>61<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-netohenriques2019" id="id298" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a> for further
details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>msk</strong><span class="classifier">ndarray ([X, Y, Z, …])</span></dt><dd><p>Mean signal kurtosis (msk)</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be
analyzed that has the same shape of the msdki parameters</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>awf</strong><span class="classifier">ndarray ([X, Y, Z, …])</span></dt><dd><p>ndarray containing the axonal volume fraction estimate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Computes the axonal water fraction from the mean signal kurtosis
MSK using equation 17 of <a class="footnote-reference brackets" href="#footcite-netohenriques2019" id="id299" role="doc-noteref"><span class="fn-bracket">[</span>62<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="msdki-prediction">
<h3>msdki_prediction<a class="headerlink" href="#msdki-prediction" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.msdki_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">msdki_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msdki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#msdki_prediction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.msdki_prediction" title="Link to this definition">#</a></dt>
<dd><p>Predict the mean signal given the parameters of the mean signal DKI, an
GradientTable object and S0 signal.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2018" id="id300" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>msdki_params</strong><span class="classifier">ndarray ([X, Y, Z, …], 2)</span></dt><dd><p>Array containing the mean signal diffusivity and mean signal kurtosis
in its last axis</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>The predicted signal is given by:</dt><dd><p><span class="math notranslate nohighlight">\(MS(b) = S_0 * exp(-bD + 1/6 b^{2} D^{2} K)\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(K\)</span> are the
mean signal diffusivity and mean signal kurtosis.</p>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="wls-fit-msdki">
<h3>wls_fit_msdki<a class="headerlink" href="#wls-fit-msdki" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.wls_fit_msdki">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">wls_fit_msdki</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msignal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ng</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#wls_fit_msdki"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.wls_fit_msdki" title="Link to this definition">#</a></dt>
<dd><p>Fits the mean signal diffusion kurtosis imaging based on a weighted
least square solution.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-netohenriques2018" id="id301" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (nub, 3)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients of the mean signal diffusion kurtosis model. Note that
nub is the number of unique b-values</p>
</dd>
<dt><strong>msignal</strong><span class="classifier">ndarray ([X, Y, Z, …, nub])</span></dt><dd><p>Mean signal along all gradient directions for each unique b-value
Note that the last dimension should contain the signal means and nub
is the number of unique b-values.</p>
</dd>
<dt><strong>ng</strong><span class="classifier">ndarray(nub)</span></dt><dd><p>Number of gradient directions used to compute the mean signal for
all unique b-values</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</dd>
<dt><strong>min_signal</strong><span class="classifier">float, optional</span></dt><dd><p>Voxel with mean signal intensities lower than the min positive signal
are not processed. Default: 0.0001</p>
</dd>
<dt><strong>return_S0_hat</strong><span class="classifier">bool</span></dt><dd><p>If True, also return S0 values for the fit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">array (…, 2)</span></dt><dd><p>Containing the mean signal diffusivity and mean signal kurtosis</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="id302">
<h3>design_matrix<a class="headerlink" href="#id302" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ubvals</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/msdki.html#design_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.msdki.design_matrix" title="Link to this definition">#</a></dt>
<dd><p>Constructs design matrix for the mean signal diffusion kurtosis model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ubvals</strong><span class="classifier">array</span></dt><dd><p>Containing the unique b-values of the data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (nb, 3)</span></dt><dd><p>Design matrix or B matrix for the mean signal diffusion kurtosis
model assuming that parameters are in the following order:
design_matrix[j, :] = (msd, msk, S0)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="multivoxelfit">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="dipy.reconst.multi_voxel.MultiVoxelFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a><a class="headerlink" href="#multivoxelfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.MultiVoxelFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.multi_voxel.</span></span><span class="sig-name descname"><span class="pre">MultiVoxelFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/multi_voxel.html#MultiVoxelFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<p>Holds an array of fits and allows access to their attributes and
methods</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit.predict" title="dipy.reconst.multi_voxel.MultiVoxelFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(*args, **kwargs)</p></td>
<td><p>Predict for the multi-voxel object using each single-object's prediction API, with S0 provided from an array.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.MultiVoxelFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/multi_voxel.html#MultiVoxelFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict for the multi-voxel object using each single-object’s
prediction API, with S0 provided from an array.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.MultiVoxelFit.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.shape" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="callablearray">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.CallableArray" title="dipy.reconst.multi_voxel.CallableArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CallableArray</span></code></a><a class="headerlink" href="#callablearray" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.CallableArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.multi_voxel.</span></span><span class="sig-name descname"><span class="pre">CallableArray</span></span><a class="reference internal" href="../_modules/dipy/reconst/multi_voxel.html#CallableArray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.multi_voxel.CallableArray" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
<p>An array which can be called like a function</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></dt><dd><p>View of the transposed array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base object if memory is from some other object.</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/library/ctypes.html#module-ctypes" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></a></dt><dd><p>An object to simplify the interaction of the array with the ctypes module.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Python buffer object pointing to the start of the array’s data.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></dt><dd><p>Data-type of the array’s elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Information about the memory layout of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></dt><dd><p>A 1-D iterator over the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></dt><dd><p>The imaginary part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></dt><dd><p>Length of one array element in bytes.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></dt><dd><p>Total bytes consumed by the elements of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></dt><dd><p>Number of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></dt><dd><p>The real part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt><dd><p>Tuple of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></dt><dd><p>Tuple of bytes to step in each dimension when traversing an array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(*args, **kwargs)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code>([axis, out, keepdims, where])</p></td>
<td><p>Returns True if all elements evaluate to True.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code>([axis, out, keepdims, where])</p></td>
<td><p>Returns True if any of the elements of <cite>a</cite> evaluate to True.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code>([axis, out, keepdims])</p></td>
<td><p>Return indices of the maximum values along the given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code>([axis, out, keepdims])</p></td>
<td><p>Return indices of the minimum values along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argpartition</span></code>(kth[, axis, kind, order])</p></td>
<td><p>Returns the indices that would partition this array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code>([axis, kind, order])</p></td>
<td><p>Returns the indices that would sort this array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code>(dtype[, order, casting, subok, copy])</p></td>
<td><p>Copy of the array, cast to a specified type.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">byteswap</span></code>([inplace])</p></td>
<td><p>Swap the bytes of the array elements</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code>(choices[, out, mode])</p></td>
<td><p>Use an index array to construct a new array from a set of choices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([min, max, out])</p></td>
<td><p>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code>(condition[, axis, out])</p></td>
<td><p>Return selected slices of this array along given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code>()</p></td>
<td><p>Complex-conjugate all elements.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code>()</p></td>
<td><p>Return the complex conjugate, element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>([order])</p></td>
<td><p>Return a copy of the array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code>([axis, dtype, out])</p></td>
<td><p>Return the cumulative product of the elements along the given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code>([axis, dtype, out])</p></td>
<td><p>Return the cumulative sum of the elements along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code>([offset, axis1, axis2])</p></td>
<td><p>Return specified diagonals.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump</span></code>(file)</p></td>
<td><p>Dump a pickle of the array to the specified file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumps</span></code>()</p></td>
<td><p>Returns the pickle of the array as a string.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill</span></code>(value)</p></td>
<td><p>Fill the array with a scalar value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code>([order])</p></td>
<td><p>Return a copy of the array collapsed into one dimension.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">getfield</span></code>(dtype[, offset])</p></td>
<td><p>Returns a field of the given array as a certain type.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">item</span></code>(*args)</p></td>
<td><p>Copy an element of an array to a standard Python scalar and return it.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemset</span></code>(*args)</p></td>
<td><p>Insert scalar into an array (scalar is cast to array's dtype, if possible)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code>([axis, out, keepdims, initial, where])</p></td>
<td><p>Return the maximum along a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>([axis, dtype, out, keepdims, where])</p></td>
<td><p>Returns the average of the array elements along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code>([axis, out, keepdims, initial, where])</p></td>
<td><p>Return the minimum along a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">newbyteorder</span></code>([new_order])</p></td>
<td><p>Return the array with the same data viewed with a different byte order.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code>()</p></td>
<td><p>Return the indices of the elements that are non-zero.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code>(kth[, axis, kind, order])</p></td>
<td><p>Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code>([axis, dtype, out, keepdims, initial, ...])</p></td>
<td><p>Return the product of the array elements over the given axis</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptp</span></code>([axis, out, keepdims])</p></td>
<td><p>Peak to peak (maximum - minimum) value along a given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code>(indices, values[, mode])</p></td>
<td><p>Set <code class="docutils literal notranslate"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for all <cite>n</cite> in indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code>([order])</p></td>
<td><p>Return a flattened array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code>(repeats[, axis])</p></td>
<td><p>Repeat elements of an array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code>(shape[, order])</p></td>
<td><p>Returns an array containing the same data with a new shape.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code>(new_shape[, refcheck])</p></td>
<td><p>Change shape and size of array in-place.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code>([decimals, out])</p></td>
<td><p>Return <cite>a</cite> with each element rounded to the given number of decimals.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code>(v[, side, sorter])</p></td>
<td><p>Find indices where elements of v should be inserted in a to maintain order.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setfield</span></code>(val, dtype[, offset])</p></td>
<td><p>Put a value into a specified place in a field defined by a data-type.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setflags</span></code>([write, align, uic])</p></td>
<td><p>Set array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY, respectively.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code>([axis, kind, order])</p></td>
<td><p>Sort an array in-place.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code>([axis])</p></td>
<td><p>Remove axes of length one from <cite>a</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code>([axis, dtype, out, ddof, keepdims, where])</p></td>
<td><p>Returns the standard deviation of the array elements along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code>([axis, dtype, out, keepdims, initial, where])</p></td>
<td><p>Return the sum of the array elements over the given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code>(axis1, axis2)</p></td>
<td><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code>(indices[, axis, out, mode])</p></td>
<td><p>Return an array formed from the elements of <cite>a</cite> at the given indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tobytes</span></code>([order])</p></td>
<td><p>Construct Python bytes containing the raw data bytes in the array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tofile</span></code>(fid[, sep, format])</p></td>
<td><p>Write array to a file as text or binary (default).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code>()</p></td>
<td><p>Return the array as an <code class="docutils literal notranslate"><span class="pre">a.ndim</span></code>-levels deep nested list of Python scalars.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tostring</span></code>([order])</p></td>
<td><p>A compatibility alias for <cite>tobytes</cite>, with exactly the same behavior.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>([offset, axis1, axis2, dtype, out])</p></td>
<td><p>Return the sum along diagonals of the array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code>(*axes)</p></td>
<td><p>Returns a view of the array with axes transposed.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>([axis, dtype, out, ddof, keepdims, where])</p></td>
<td><p>Returns the variance of the array elements, along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code>([dtype][, type])</p></td>
<td><p>New view of array with the same data.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>dot</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
</dd></dl>

</section>
<section id="multi-voxel-fit">
<h3>multi_voxel_fit<a class="headerlink" href="#multi-voxel-fit" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.multi_voxel_fit">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.multi_voxel.</span></span><span class="sig-name descname"><span class="pre">multi_voxel_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">single_voxel_fit</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/multi_voxel.html#multi_voxel_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.multi_voxel.multi_voxel_fit" title="Link to this definition">#</a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</section>
<section id="odfmodel">
<h3><a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a><a class="headerlink" href="#odfmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.odf.</span></span><span class="sig-name descname"><span class="pre">OdfModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/odf.html#OdfModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.odf.OdfModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as it’s
first and only argument.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.odf.OdfModel.fit" title="dipy.reconst.odf.OdfModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data)</p></td>
<td><p>To be implemented by specific odf models</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/odf.html#OdfModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.odf.OdfModel.fit" title="Link to this definition">#</a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</section>
<section id="odffit">
<h3><a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a><a class="headerlink" href="#odffit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.odf.</span></span><span class="sig-name descname"><span class="pre">OdfFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/odf.html#OdfFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.odf.OdfFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.odf.OdfFit.odf" title="dipy.reconst.odf.OdfFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</p></td>
<td><p>To be implemented but specific odf models</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/odf.html#OdfFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.odf.OdfFit.odf" title="Link to this definition">#</a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</section>
<section id="gfa">
<h3>gfa<a class="headerlink" href="#gfa" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.odf.gfa">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.odf.</span></span><span class="sig-name descname"><span class="pre">gfa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/odf.html#gfa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.odf.gfa" title="Link to this definition">#</a></dt>
<dd><p>The general fractional anisotropy of a function evaluated
on the unit sphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">ndarray</span></dt><dd><p>Values of data on the unit sphere.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gfa</strong><span class="classifier">ndarray</span></dt><dd><p>GFA evaluated in each entry of the array, along the last dimension.
An <cite>np.nan</cite> is returned for coordinates that contain all-zeros in
<cite>samples</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The GFA is defined as <a class="footnote-reference brackets" href="#footcite-cohenadad2011" id="id303" role="doc-noteref"><span class="fn-bracket">[</span>63<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[\sqrt{\frac{n \sum_i{(\Psi_i - &lt;\Psi&gt;)^2}}{(n-1) \sum{\Psi_i ^ 2}}}\]</div>
<p>Where <span class="math notranslate nohighlight">\(\Psi\)</span> is an orientation distribution function sampled discretely on
the unit sphere and angle brackets denote average over the samples on the
sphere.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id304">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-cohenadad2011" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id303">63</a><span class="fn-bracket">]</span></span>
<p>Julien Cohen-Adad, Maxime Descoteaux, and Lawrence L. Wald. Quality assessment of high angular resolution diffusion imaging data using bootstrap on Q-ball reconstruction. <em>Journal of Magnetic Resonance Imaging</em>, 33(5):1194–1208, 2011. URL: <a class="reference external" href="https://doi.org/10.1002/jmri.22535">https://doi.org/10.1002/jmri.22535</a>, <a class="reference external" href="https://doi.org/10.1002/jmri.22535">doi:10.1002/jmri.22535</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="minmax-normalize">
<h3>minmax_normalize<a class="headerlink" href="#minmax-normalize" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.odf.minmax_normalize">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.odf.</span></span><span class="sig-name descname"><span class="pre">minmax_normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/odf.html#minmax_normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.odf.minmax_normalize" title="Link to this definition">#</a></dt>
<dd><p>Min-max normalization of a function evaluated on the unit sphere</p>
<p>Normalizes samples to <code class="docutils literal notranslate"><span class="pre">(samples</span> <span class="pre">-</span> <span class="pre">min(samples))</span> <span class="pre">/</span> <span class="pre">(max(samples)</span> <span class="pre">-</span>
<span class="pre">min(samples))</span></code> for each unit sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">ndarray (…, N)</span></dt><dd><p>N samples on a unit sphere for each point, stored along the last axis
of the array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndrray (…, N), optional</span></dt><dd><p>An array to store the normalized samples.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray, (…, N)</span></dt><dd><p>Normalized samples.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="qtdmrimodel">
<h3><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriModel" title="dipy.reconst.qtdmri.QtdmriModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a><a class="headerlink" href="#qtdmrimodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">QtdmriModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cartesian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anisotropic_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constrain_q0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bval_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CLARABEL'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>The q:math:<cite>tau</cite>-dMRI model to analytically and continuously represent the
q:math:<cite>tau</cite> diffusion signal attenuation over diffusion sensitization q and
diffusion time <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
<p>The model <a class="footnote-reference brackets" href="#footcite-fick2018" id="id305" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a> can be seen as an extension of the MAP-MRI
basis <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id306" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> towards different diffusion times.</p>
<p>The main idea is to model the diffusion signal over time and space as
a linear combination of continuous functions,</p>
<div class="math notranslate nohighlight">
\hat{E}(\textbf{q},\tau;\textbf{c}) =
\sum_i^{N_{\textbf{q}}}\sum_k^{N_\tau} \textbf{c}_{ik}
\,\Phi_i(\textbf{q})\,T_k(\tau)</div><p>where <span class="math notranslate nohighlight">\(\Phi\)</span> and <span class="math notranslate nohighlight">\(T\)</span> are the spatial and temporal basis functions,
<span class="math notranslate nohighlight">\(N_{\textbf{q}}\)</span> and <span class="math notranslate nohighlight">\(N_\tau\)</span> are the maximum spatial and temporal
order, and <span class="math notranslate nohighlight">\(i,k\)</span> are basis order iterators.</p>
<p>The estimation of the coefficients <span class="math notranslate nohighlight">\(c_i\)</span> can be regularized using
either analytic Laplacian regularization, sparsity regularization using
the l1-norm, or both to do a type of elastic net regularization.</p>
<p>From the coefficients, there exists an analytical formula to estimate
the ODF, RTOP, RTAP, RTPP, QIV and MSD, for any diffusion time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable,</span></dt><dd><p>gradient directions and bvalues container class. The bvalues
should be in the normal s/mm^2. big_delta and small_delta need to be
given in seconds.</p>
</dd>
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer representing the spatial/radial order of the basis.</p>
</dd>
<dt><strong>time_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an integer larger or equal than zero representing the time order
of the basis.</p>
</dd>
<dt><strong>laplacian_regularization</strong><span class="classifier">bool,</span></dt><dd><p>Regularize using the Laplacian of the qt-dMRI basis.</p>
</dd>
<dt><strong>laplacian_weighting: string or scalar,</strong></dt><dd><p>The string ‘GCV’ makes it use generalized cross-validation to find
the regularization weight <a class="footnote-reference brackets" href="#footcite-craven1979" id="id307" role="doc-noteref"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></a>. A scalar sets the
regularization weight to that value.</p>
</dd>
<dt><strong>l1_regularization</strong><span class="classifier">bool,</span></dt><dd><p>Regularize by imposing sparsity in the coefficients using the
l1-norm.</p>
</dd>
<dt><strong>l1_weighting</strong><span class="classifier">‘CV’ or scalar,</span></dt><dd><p>The string ‘CV’ makes it use five-fold cross-validation to find
the regularization weight. A scalar sets the regularization weight
to that value.</p>
</dd>
<dt><strong>cartesian</strong><span class="classifier">bool</span></dt><dd><p>Whether to use the Cartesian or spherical implementation of the
qt-dMRI basis, which we first explored in <a class="footnote-reference brackets" href="#footcite-fick2015" id="id308" role="doc-noteref"><span class="fn-bracket">[</span>65<span class="fn-bracket">]</span></a>.</p>
</dd>
<dt><strong>anisotropic_scaling</strong><span class="classifier">bool</span></dt><dd><p>Whether to use anisotropic scaling or isotropic scaling. This
option can be used to test if the Cartesian implementation is
equivalent with the spherical one when using the same scaling.</p>
</dd>
<dt><strong>normalization</strong><span class="classifier">bool</span></dt><dd><p>Whether to normalize the basis functions such that their inner
product is equal to one. Normalization is only necessary when
imposing sparsity in the spherical basis if cartesian=False.</p>
</dd>
<dt><strong>constrain_q0</strong><span class="classifier">bool</span></dt><dd><p>whether to constrain the q0 point to unity along the tau-space.
This is necessary to ensure that <span class="math notranslate nohighlight">\(E(0,\tau)=1\)</span>.</p>
</dd>
<dt><strong>bval_threshold</strong><span class="classifier">float</span></dt><dd><p>the threshold b-value to be used, such that only data points below
that threshold are used when estimating the scale factors.</p>
</dd>
<dt><strong>eigenvalue_threshold</strong><span class="classifier">float,</span></dt><dd><p>Sets the minimum of the tensor eigenvalues in order to avoid
stability problem.</p>
</dd>
<dt><strong>cvxpy_solver</strong><span class="classifier">str, optional</span></dt><dd><p>cvxpy solver name. Optionally optimize the positivity constraint
with a particular cvxpy solver. See <a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a> for
details.
Default: None (cvxpy chooses its own solver)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriModel.fit" title="dipy.reconst.qtdmri.QtdmriModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">References</p>
<div class="docutils container" id="id309">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-fick2018" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id305">1</a>,<a role="doc-backlink" href="#id312">2</a>,<a role="doc-backlink" href="#id314">3</a>,<a role="doc-backlink" href="#id317">4</a>,<a role="doc-backlink" href="#id320">5</a>,<a role="doc-backlink" href="#id323">6</a>,<a role="doc-backlink" href="#id324">7</a>,<a role="doc-backlink" href="#id327">8</a>,<a role="doc-backlink" href="#id330">9</a>,<a role="doc-backlink" href="#id333">10</a>,<a role="doc-backlink" href="#id334">11</a>,<a role="doc-backlink" href="#id335">12</a>,<a role="doc-backlink" href="#id336">13</a>,<a role="doc-backlink" href="#id337">14</a>,<a role="doc-backlink" href="#id338">15</a>,<a role="doc-backlink" href="#id339">16</a>,<a role="doc-backlink" href="#id340">17</a>,<a role="doc-backlink" href="#id341">18</a>,<a role="doc-backlink" href="#id342">19</a>,<a role="doc-backlink" href="#id343">20</a>,<a role="doc-backlink" href="#id344">21</a>,<a role="doc-backlink" href="#id349">22</a>)</span>
<p>Rutger H. J. Fick, Alexandra Petiet, Mathieu Santin, Anne-Charlotte Philippe, Stephane Lehericy, Rachid Deriche, and Demian Wassermann. Non-parametric graphnet-regularized representation of dMRI in space and time. <em>Medical Image Analysis</em>, 43:37–53, 2018. URL: <a class="reference external" href="https://doi.org/10.1016/j.media.2017.09.002">https://doi.org/10.1016/j.media.2017.09.002</a>, <a class="reference external" href="https://doi.org/10.1016/j.media.2017.09.002">doi:10.1016/j.media.2017.09.002</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-fick2015" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id308">65</a><span class="fn-bracket">]</span></span>
<p>Rutger Fick, Demian Wassermann, Marco Pizzolato, and Rachid Deriche. A Unifying Framework for Spatial and Temporal Diffusion in Diffusion MRI. In Sebastien Ourselin, Daniel C. Alexander, Carl-Fredrik Westin, and M. Jorge Cardoso, editors, <em>Information Processing in Medical Imaging</em>, 167–178. Cham, 2015. Springer International Publishing.</p>
</aside>
</aside>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="qtdmrifit">
<h3><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit" title="dipy.reconst.qtdmri.QtdmriFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a><a class="headerlink" href="#qtdmrifit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">QtdmriFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qtdmri_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_scaling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solution_optimal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.fitted_signal" title="dipy.reconst.qtdmri.QtdmriFit.fitted_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fitted_signal</span></code></a>(*[, gtab])</p></td>
<td><p>Recovers the fitted signal for the given gradient table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.msd" title="dipy.reconst.qtdmri.QtdmriFit.msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd</span></code></a>(tau)</p></td>
<td><p>Calculates the analytical Mean Squared Displacement (MSD) for a given diffusion time tau.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal" title="dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm_of_laplacian_signal</span></code></a>()</p></td>
<td><p>Calculates the norm of the laplacian of the fitted signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.odf" title="dipy.reconst.qtdmri.QtdmriFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere, tau, *[, s])</p></td>
<td><p>Calculates the analytical Orientation Distribution Function (ODF) for a given diffusion time tau from the signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.odf_sh" title="dipy.reconst.qtdmri.QtdmriFit.odf_sh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sh</span></code></a>(tau, *[, s])</p></td>
<td><p>Calculates the real analytical odf for a given discrete sphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.pdf" title="dipy.reconst.qtdmri.QtdmriFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>(rt_points)</p></td>
<td><p>Diffusion propagator on a given set of real points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.predict" title="dipy.reconst.qtdmri.QtdmriFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(qvals_or_gtab, *[, S0])</p></td>
<td><p>Recovers the reconstructed signal for any qvalue array or gradient table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.qiv" title="dipy.reconst.qtdmri.QtdmriFit.qiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qiv</span></code></a>(tau)</p></td>
<td><p>Calculates the analytical Q-space Inverse Variance (QIV) for given diffusion time tau.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef" title="dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_to_mapmri_coef</span></code></a>(tau)</p></td>
<td><p>This function converts the qtdmri coefficients to mapmri coefficients for a given tau.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.rtap" title="dipy.reconst.qtdmri.QtdmriFit.rtap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtap</span></code></a>(tau)</p></td>
<td><p>Calculates the analytical return to the axis probability (RTAP) for a given diffusion time tau.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.rtop" title="dipy.reconst.qtdmri.QtdmriFit.rtop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop</span></code></a>(tau)</p></td>
<td><p>Calculates the analytical return to the origin probability (RTOP) for a given diffusion time tau.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.rtpp" title="dipy.reconst.qtdmri.QtdmriFit.rtpp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtpp</span></code></a>(tau)</p></td>
<td><p>Calculates the analytical return to the plane probability (RTPP) for a given diffusion time tau.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_abs" title="dipy.reconst.qtdmri.QtdmriFit.sparsity_abs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparsity_abs</span></code></a>(*[, threshold])</p></td>
<td><p>As a measure of sparsity, calculates the number of largest coefficients needed to absolute sum up to 99% of the total absolute sum of all coefficients</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_density" title="dipy.reconst.qtdmri.QtdmriFit.sparsity_density"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparsity_density</span></code></a>(*[, threshold])</p></td>
<td><p>As a measure of sparsity, calculates the number of largest coefficients needed to squared sum up to 99% of the total squared sum of all coefficients</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.fitted_signal">
<span class="sig-name descname"><span class="pre">fitted_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.fitted_signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.fitted_signal" title="Link to this definition">#</a></dt>
<dd><p>Recovers the fitted signal for the given gradient table. If no
gradient table is given it recovers the signal for the gtab of the model
object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.msd">
<span class="sig-name descname"><span class="pre">msd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.msd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.msd" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical Mean Squared Displacement (MSD) for a
given diffusion time tau.</p>
<p>It is defined as the Laplacian of the origin of the estimated signal
Cheng<a class="footnote-reference brackets" href="#footcite-cheng2012" id="id310" role="doc-noteref"><span class="fn-bracket">[</span>56<span class="fn-bracket">]</span></a>. The analytical formula for the MAP-MRI basis
was derived in <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id311" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C13, D1). The qtdmri
coefficients are first converted to mapmri coefficients following
<a class="footnote-reference brackets" href="#footcite-fick2018" id="id312" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal">
<span class="sig-name descname"><span class="pre">norm_of_laplacian_signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.norm_of_laplacian_signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal" title="Link to this definition">#</a></dt>
<dd><p>Calculates the norm of the laplacian of the fitted signal.</p>
<p>This information could be useful to assess if the extrapolation of the
fitted signal contains spurious oscillations. A high laplacian norm may
indicate that these are present, and any q-space indices that
use integrals of the signal may be corrupted (e.g. RTOP, RTAP, RTPP,
QIV). In contrast to Fick <em>et al.</em><a class="footnote-reference brackets" href="#footcite-fick2016b" id="id313" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a>, the Laplacian now
describes oscillations in the 4-dimensional qt-signal
<a class="footnote-reference brackets" href="#footcite-fick2018" id="id314" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id315" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> for a definition of the metric.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.odf" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical Orientation Distribution Function (ODF)
for a given diffusion time tau from the signal.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id316" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> Eq. (32). The qtdmri coefficients are
first converted to mapmri coefficients following <a class="footnote-reference brackets" href="#footcite-fick2018" id="id317" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">dipy sphere object</span></dt><dd><p>sphere object with vertice orientations to compute the ODF on.</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
<dt><strong>s</strong><span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.odf_sh">
<span class="sig-name descname"><span class="pre">odf_sh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.odf_sh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.odf_sh" title="Link to this definition">#</a></dt>
<dd><p>Calculates the real analytical odf for a given discrete sphere.</p>
<p>Computes the design matrix of the ODF for the given sphere vertices
and radial moment <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id318" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (32). The radial moment
s acts as a sharpening method. The analytical equation for the spherical
ODF basis is given in <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id319" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C8). The qtdmri
coefficients are first converted to mapmri coefficients following
<a class="footnote-reference brackets" href="#footcite-fick2018" id="id320" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
<dt><strong>s</strong><span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rt_points</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.pdf" title="Link to this definition">#</a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qvals_or_gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Recovers the reconstructed signal for any qvalue array or gradient
table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.qiv">
<span class="sig-name descname"><span class="pre">qiv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.qiv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.qiv" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical Q-space Inverse Variance (QIV) for given
diffusion time tau.</p>
<p>It is defined as the inverse of the Laplacian of the origin of the
estimated propagator <a class="footnote-reference brackets" href="#footcite-hosseinbor2013" id="id321" role="doc-noteref"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></a> eq. (22). The
analytical formula for the MAP-MRI basis was derived in
<a class="footnote-reference brackets" href="#footcite-fick2016b" id="id322" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C14, D2). The qtdmri coefficients are first
converted to mapmri coefficients following Fick <em>et al.</em><a class="footnote-reference brackets" href="#footcite-fick2018" id="id323" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef">
<span class="sig-name descname"><span class="pre">qtdmri_to_mapmri_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.qtdmri_to_mapmri_coef"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef" title="Link to this definition">#</a></dt>
<dd><p>This function converts the qtdmri coefficients to mapmri
coefficients for a given tau.</p>
<p>Defined in <a class="footnote-reference brackets" href="#footcite-fick2018" id="id324" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>, the conversion is performed by a
matrix multiplication that evaluates the time-depenent part of the basis
and multiplies it with the coefficients, after which coefficients with
the same spatial orders are summed up, resulting in mapmri coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.rtap">
<span class="sig-name descname"><span class="pre">rtap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.rtap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.rtap" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the axis probability (RTAP)
for a given diffusion time tau.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id325" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (40, 44a). The analytical formula for
the isotropic MAP-MRI basis was derived in <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id326" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq.
(C11). The qtdmri coefficients are first converted to mapmri
coefficients following <a class="footnote-reference brackets" href="#footcite-fick2018" id="id327" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.rtop">
<span class="sig-name descname"><span class="pre">rtop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.rtop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.rtop" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the origin probability (RTOP)
for a given diffusion time tau.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id328" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (36, 43). The analytical formula for
the isotropic MAP-MRI basis was derived in <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id329" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq.
(C11). The qtdmri coefficients are first converted to mapmri
coefficients following <a class="footnote-reference brackets" href="#footcite-fick2018" id="id330" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.rtpp">
<span class="sig-name descname"><span class="pre">rtpp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.rtpp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.rtpp" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the plane probability (RTPP)
for a given diffusion time tau.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id331" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> eq. (42). The analytical formula for the
isotropic MAP-MRI basis was derived in <a class="footnote-reference brackets" href="#footcite-fick2016b" id="id332" role="doc-noteref"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></a> eq. (C11).
The qtdmri coefficients are first converted to mapmri coefficients
following <a class="footnote-reference brackets" href="#footcite-fick2018" id="id333" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.sparsity_abs">
<span class="sig-name descname"><span class="pre">sparsity_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.sparsity_abs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_abs" title="Link to this definition">#</a></dt>
<dd><p>As a measure of sparsity, calculates the number of largest
coefficients needed to absolute sum up to 99% of the total absolute sum
of all coefficients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.sparsity_density">
<span class="sig-name descname"><span class="pre">sparsity_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#QtdmriFit.sparsity_density"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_density" title="Link to this definition">#</a></dt>
<dd><p>As a measure of sparsity, calculates the number of largest
coefficients needed to squared sum up to 99% of the total squared sum
of all coefficients</p>
</dd></dl>

</dd></dl>

</section>
<section id="qtdmri-to-mapmri-matrix">
<h3>qtdmri_to_mapmri_matrix<a class="headerlink" href="#qtdmri-to-mapmri-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_to_mapmri_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_to_mapmri_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix" title="Link to this definition">#</a></dt>
<dd><p>Generate the matrix that maps the qtdmri coefficients to MAP-MRI
coefficients for the anisotropic case.</p>
<p>The conversion is done by only evaluating the time basis for a diffusion
time tau and summing up coefficients with the same spatial basis orders
<a class="footnote-reference brackets" href="#footcite-fick2018" id="id334" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer representing the spatial/radial order of the basis.</p>
</dd>
<dt><strong>time_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an integer larger or equal than zero representing the time order
of the basis.</p>
</dd>
<dt><strong>ut</strong><span class="classifier">float</span></dt><dd><p>temporal scaling factor</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="qtdmri-isotropic-to-mapmri-matrix">
<h3>qtdmri_isotropic_to_mapmri_matrix<a class="headerlink" href="#qtdmri-isotropic-to-mapmri-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_to_mapmri_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_isotropic_to_mapmri_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix" title="Link to this definition">#</a></dt>
<dd><p>Generate the matrix that maps the spherical qtdmri coefficients to
MAP-MRI coefficients for the isotropic case.</p>
<p>The conversion is done by only evaluating the time basis for a diffusion
time tau and summing up coefficients with the same spatial basis orders
<a class="footnote-reference brackets" href="#footcite-fick2018" id="id335" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer representing the spatial/radial order of the basis.</p>
</dd>
<dt><strong>time_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an integer larger or equal than zero representing the time order
of the basis.</p>
</dd>
<dt><strong>ut</strong><span class="classifier">float</span></dt><dd><p>temporal scaling factor</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="qtdmri-temporal-normalization">
<h3>qtdmri_temporal_normalization<a class="headerlink" href="#qtdmri-temporal-normalization" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_temporal_normalization">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_temporal_normalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ut</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_temporal_normalization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_temporal_normalization" title="Link to this definition">#</a></dt>
<dd><p>Normalization factor for the temporal basis</p>
</dd></dl>

</section>
<section id="qtdmri-mapmri-normalization">
<h3>qtdmri_mapmri_normalization<a class="headerlink" href="#qtdmri-mapmri-normalization" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_mapmri_normalization">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_mapmri_normalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_mapmri_normalization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_mapmri_normalization" title="Link to this definition">#</a></dt>
<dd><p>Normalization factor for Cartesian MAP-MRI basis. The scaling is the
same for every basis function depending only on the spatial scaling
mu.</p>
</dd></dl>

</section>
<section id="qtdmri-mapmri-isotropic-normalization">
<h3>qtdmri_mapmri_isotropic_normalization<a class="headerlink" href="#qtdmri-mapmri-isotropic-normalization" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_mapmri_isotropic_normalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_mapmri_isotropic_normalization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization" title="Link to this definition">#</a></dt>
<dd><p>Normalization factor for Spherical MAP-MRI basis. The normalization
for a basis function with orders [j,l,m] depends only on orders j,l and
the isotropic scale factor.</p>
</dd></dl>

</section>
<section id="qtdmri-signal-matrix">
<h3>qtdmri_signal_matrix<a class="headerlink" href="#qtdmri-signal-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_signal_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_signal_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_signal_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix" title="Link to this definition">#</a></dt>
<dd><p>Constructs the design matrix as a product of 3 separated radial,
angular and temporal design matrices. It precomputes the relevant basis
orders for each one and finally puts them together according to the index
matrix</p>
</dd></dl>

</section>
<section id="qtdmri-eap-matrix">
<h3>qtdmri_eap_matrix<a class="headerlink" href="#qtdmri-eap-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_eap_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_eap_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_eap_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix" title="Link to this definition">#</a></dt>
<dd><p>Constructs the design matrix as a product of 3 separated radial,
angular and temporal design matrices. It precomputes the relevant basis
orders for each one and finally puts them together according to the index
matrix</p>
</dd></dl>

</section>
<section id="qtdmri-isotropic-signal-matrix">
<h3>qtdmri_isotropic_signal_matrix<a class="headerlink" href="#qtdmri-isotropic-signal-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_signal_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_isotropic_signal_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="qtdmri-isotropic-eap-matrix">
<h3>qtdmri_isotropic_eap_matrix<a class="headerlink" href="#qtdmri-isotropic-eap-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_eap_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_isotropic_eap_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix" title="Link to this definition">#</a></dt>
<dd><p>Constructs the design matrix as a product of 3 separated radial,
angular and temporal design matrices. It precomputes the relevant basis
orders for each one and finally puts them together according to the index
matrix</p>
</dd></dl>

</section>
<section id="radial-basis-opt">
<h3>radial_basis_opt<a class="headerlink" href="#radial-basis-opt" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.radial_basis_opt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">radial_basis_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#radial_basis_opt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.radial_basis_opt" title="Link to this definition">#</a></dt>
<dd><p>Spatial basis dependent on spatial scaling factor us</p>
</dd></dl>

</section>
<section id="angular-basis-opt">
<h3>angular_basis_opt<a class="headerlink" href="#angular-basis-opt" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.angular_basis_opt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">angular_basis_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#angular_basis_opt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.angular_basis_opt" title="Link to this definition">#</a></dt>
<dd><p>Angular basis independent of spatial scaling factor us. Though it
includes q, it is independent of the data and can be precomputed.</p>
</dd></dl>

</section>
<section id="radial-basis-eap-opt">
<h3>radial_basis_EAP_opt<a class="headerlink" href="#radial-basis-eap-opt" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.radial_basis_EAP_opt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">radial_basis_EAP_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#radial_basis_EAP_opt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.radial_basis_EAP_opt" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="angular-basis-eap-opt">
<h3>angular_basis_EAP_opt<a class="headerlink" href="#angular-basis-eap-opt" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.angular_basis_EAP_opt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">angular_basis_EAP_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#angular_basis_EAP_opt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.angular_basis_EAP_opt" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="temporal-basis">
<h3>temporal_basis<a class="headerlink" href="#temporal-basis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.temporal_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">temporal_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">o</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#temporal_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.temporal_basis" title="Link to this definition">#</a></dt>
<dd><p>Temporal basis dependent on temporal scaling factor ut</p>
</dd></dl>

</section>
<section id="qtdmri-index-matrix">
<h3>qtdmri_index_matrix<a class="headerlink" href="#qtdmri-index-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_index_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_index_matrix" title="Link to this definition">#</a></dt>
<dd><p>Computes the SHORE basis order indices according to [1].</p>
</dd></dl>

</section>
<section id="qtdmri-isotropic-index-matrix">
<h3>qtdmri_isotropic_index_matrix<a class="headerlink" href="#qtdmri-isotropic-index-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_isotropic_index_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix" title="Link to this definition">#</a></dt>
<dd><p>Computes the SHORE basis order indices according to [1].</p>
</dd></dl>

</section>
<section id="qtdmri-laplacian-reg-matrix">
<h3>qtdmri_laplacian_reg_matrix<a class="headerlink" href="#qtdmri-laplacian-reg-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_laplacian_reg_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S_mat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T_mat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_mat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part1_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part23_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part4_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_laplacian_reg_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix" title="Link to this definition">#</a></dt>
<dd><p>Computes the cartesian qt-dMRI Laplacian regularization matrix.</p>
<p>If given, uses precomputed matrices for temporal and spatial regularization
matrices to speed up computation. Follows the formulation of Appendix B
in <a class="footnote-reference brackets" href="#footcite-fick2018" id="id336" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="qtdmri-isotropic-laplacian-reg-matrix">
<h3>qtdmri_isotropic_laplacian_reg_matrix<a class="headerlink" href="#qtdmri-isotropic-laplacian-reg-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_laplacian_reg_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part1_uq_iso_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part1_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part23_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part4_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_isotropic_laplacian_reg_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix" title="Link to this definition">#</a></dt>
<dd><p>Computes the spherical qt-dMRI Laplacian regularization matrix.</p>
<p>If given, uses precomputed matrices for temporal and spatial regularization
matrices to speed up computation. Follows the formulation of Appendix C
in <a class="footnote-reference brackets" href="#footcite-fick2018" id="id337" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="part23-reg-matrix-q">
<h3>part23_reg_matrix_q<a class="headerlink" href="#part23-reg-matrix-q" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part23_reg_matrix_q">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part23_reg_matrix_q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#part23_reg_matrix_q"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.part23_reg_matrix_q" title="Link to this definition">#</a></dt>
<dd><p>Partial cartesian spatial Laplacian regularization matrix.</p>
<p>The implementation follows the second line of Eq. (B2) in
<a class="footnote-reference brackets" href="#footcite-fick2018" id="id338" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="part23-iso-reg-matrix-q">
<h3>part23_iso_reg_matrix_q<a class="headerlink" href="#part23-iso-reg-matrix-q" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part23_iso_reg_matrix_q">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part23_iso_reg_matrix_q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#part23_iso_reg_matrix_q"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.part23_iso_reg_matrix_q" title="Link to this definition">#</a></dt>
<dd><p>Partial spherical spatial Laplacian regularization matrix.</p>
<p>The implementation follows the equation below Eq. (C4) in
<a class="footnote-reference brackets" href="#footcite-fick2018" id="id339" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="part4-reg-matrix-q">
<h3>part4_reg_matrix_q<a class="headerlink" href="#part4-reg-matrix-q" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part4_reg_matrix_q">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part4_reg_matrix_q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#part4_reg_matrix_q"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.part4_reg_matrix_q" title="Link to this definition">#</a></dt>
<dd><p>Partial cartesian spatial Laplacian regularization matrix.</p>
<p>The implementation follows equation Eq. (B2) in <a class="footnote-reference brackets" href="#footcite-fick2018" id="id340" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="part4-iso-reg-matrix-q">
<h3>part4_iso_reg_matrix_q<a class="headerlink" href="#part4-iso-reg-matrix-q" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part4_iso_reg_matrix_q">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part4_iso_reg_matrix_q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#part4_iso_reg_matrix_q"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.part4_iso_reg_matrix_q" title="Link to this definition">#</a></dt>
<dd><p>Partial spherical spatial Laplacian regularization matrix.</p>
<p>The implementation follows the equation below Eq. (C4) in
<a class="footnote-reference brackets" href="#footcite-fick2018" id="id341" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="part1-reg-matrix-tau">
<h3>part1_reg_matrix_tau<a class="headerlink" href="#part1-reg-matrix-tau" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part1_reg_matrix_tau">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part1_reg_matrix_tau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#part1_reg_matrix_tau"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.part1_reg_matrix_tau" title="Link to this definition">#</a></dt>
<dd><p>Partial temporal Laplacian regularization matrix.</p>
<p>The implementation follows Appendix B in <a class="footnote-reference brackets" href="#footcite-fick2018" id="id342" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="part23-reg-matrix-tau">
<h3>part23_reg_matrix_tau<a class="headerlink" href="#part23-reg-matrix-tau" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part23_reg_matrix_tau">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part23_reg_matrix_tau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#part23_reg_matrix_tau"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.part23_reg_matrix_tau" title="Link to this definition">#</a></dt>
<dd><p>Partial temporal Laplacian regularization matrix.</p>
<p>The implementation follows Appendix B in <a class="footnote-reference brackets" href="#footcite-fick2018" id="id343" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="part4-reg-matrix-tau">
<h3>part4_reg_matrix_tau<a class="headerlink" href="#part4-reg-matrix-tau" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part4_reg_matrix_tau">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part4_reg_matrix_tau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#part4_reg_matrix_tau"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.part4_reg_matrix_tau" title="Link to this definition">#</a></dt>
<dd><p>Partial temporal Laplacian regularization matrix.</p>
<p>The implementation follows Appendix B in <a class="footnote-reference brackets" href="#footcite-fick2018" id="id344" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="h">
<h3>H<a class="headerlink" href="#h" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.H">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#H"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.H" title="Link to this definition">#</a></dt>
<dd><p>Step function of H(x)=1 if x&gt;=0 and zero otherwise. Used for the
temporal laplacian matrix.</p>
</dd></dl>

</section>
<section id="id345">
<h3>generalized_crossvalidation<a class="headerlink" href="#id345" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.generalized_crossvalidation">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">generalized_crossvalidation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LR</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">startpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0005</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#generalized_crossvalidation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.generalized_crossvalidation" title="Link to this definition">#</a></dt>
<dd><p>Generalized Cross Validation Function.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-craven1979" id="id346" role="doc-noteref"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="id347">
<h3>GCV_cost_function<a class="headerlink" href="#id347" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.GCV_cost_function">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">GCV_cost_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arguments</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#GCV_cost_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.GCV_cost_function" title="Link to this definition">#</a></dt>
<dd><p>Generalized Cross Validation Function that is iterated.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-craven1979" id="id348" role="doc-noteref"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="qtdmri-isotropic-scaling">
<h3>qtdmri_isotropic_scaling<a class="headerlink" href="#qtdmri-isotropic-scaling" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_scaling">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_isotropic_scaling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_scaling" title="Link to this definition">#</a></dt>
<dd><p>Constructs design matrix for fitting an exponential to the
diffusion time points.</p>
</dd></dl>

</section>
<section id="qtdmri-anisotropic-scaling">
<h3>qtdmri_anisotropic_scaling<a class="headerlink" href="#qtdmri-anisotropic-scaling" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_anisotropic_scaling">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_anisotropic_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_anisotropic_scaling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling" title="Link to this definition">#</a></dt>
<dd><p>Constructs design matrix for fitting an exponential to the
diffusion time points.</p>
</dd></dl>

</section>
<section id="design-matrix-spatial">
<h3>design_matrix_spatial<a class="headerlink" href="#design-matrix-spatial" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.design_matrix_spatial">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">design_matrix_spatial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bvecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qvals</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#design_matrix_spatial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.design_matrix_spatial" title="Link to this definition">#</a></dt>
<dd><p>Constructs design matrix for DTI weighted least squares or
least squares fitting. (Basser et al., 1994a)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bvecs</strong><span class="classifier">array (N x 3)</span></dt><dd><p>unit b-vectors of the acquisition.</p>
</dd>
<dt><strong>qvals</strong><span class="classifier">array (N,)</span></dt><dd><p>corresponding q-values in 1/mm</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>design_matrix</strong><span class="classifier">array (g,7)</span></dt><dd><p>Design matrix or B matrix assuming Gaussian distributed tensor model
design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="create-rt-space-grid">
<h3>create_rt_space_grid<a class="headerlink" href="#create-rt-space-grid" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.create_rt_space_grid">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">create_rt_space_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_size_r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radius_r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_size_tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_radius_tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radius_tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#create_rt_space_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.create_rt_space_grid" title="Link to this definition">#</a></dt>
<dd><p>Generates EAP grid (for potential positivity constraint).</p>
</dd></dl>

</section>
<section id="qtdmri-number-of-coefficients">
<h3>qtdmri_number_of_coefficients<a class="headerlink" href="#qtdmri-number-of-coefficients" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_number_of_coefficients">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_number_of_coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#qtdmri_number_of_coefficients"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_number_of_coefficients" title="Link to this definition">#</a></dt>
<dd><p>Computes the total number of coefficients of the qtdmri basis given a
radial and temporal order.</p>
<p>See  equation given below Eq (9) in Fick <em>et al.</em><a class="footnote-reference brackets" href="#footcite-fick2018" id="id349" role="doc-noteref"><span class="fn-bracket">[</span>64<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="l1-crossvalidation">
<h3>l1_crossvalidation<a class="headerlink" href="#l1-crossvalidation" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.l1_crossvalidation">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">l1_crossvalidation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b0s_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#l1_crossvalidation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.l1_crossvalidation" title="Link to this definition">#</a></dt>
<dd><p>cross-validation function to find the optimal weight of alpha for
sparsity regularization</p>
</dd></dl>

</section>
<section id="elastic-crossvalidation">
<h3>elastic_crossvalidation<a class="headerlink" href="#elastic-crossvalidation" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.elastic_crossvalidation">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">elastic_crossvalidation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b0s_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lopt</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#elastic_crossvalidation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.elastic_crossvalidation" title="Link to this definition">#</a></dt>
<dd><p>cross-validation function to find the optimal weight of alpha for
sparsity regularization when also Laplacian regularization is used.</p>
</dd></dl>

</section>
<section id="visualise-gradient-table-g-delta-rainbow">
<h3>visualise_gradient_table_G_Delta_rainbow<a class="headerlink" href="#visualise-gradient-table-g-delta-rainbow" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">visualise_gradient_table_G_Delta_rainbow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">big_delta_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">big_delta_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bval_isolines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0,</span> <span class="pre">250,</span> <span class="pre">1000,</span> <span class="pre">2500,</span> <span class="pre">5000,</span> <span class="pre">7500,</span> <span class="pre">10000,</span> <span class="pre">14000])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_shading</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.6</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qtdmri.html#visualise_gradient_table_G_Delta_rainbow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow" title="Link to this definition">#</a></dt>
<dd><p>This function visualizes a q-tau acquisition scheme as a function of
gradient strength and pulse separation (big_delta). It represents every
measurements at its G and big_delta position regardless of b-vector, with a
background of b-value isolines for reference. It assumes there is only one
unique pulse length (small_delta) in the acquisition scheme.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable object</span></dt><dd><p>constructed gradient table with big_delta and small_delta given as
inputs.</p>
</dd>
<dt><strong>big_delta_start</strong><span class="classifier">float,</span></dt><dd><p>optional minimum big_delta that is plotted in seconds</p>
</dd>
<dt><strong>big_delta_end</strong><span class="classifier">float,</span></dt><dd><p>optional maximum big_delta that is plotted in seconds</p>
</dd>
<dt><strong>G_start</strong><span class="classifier">float,</span></dt><dd><p>optional minimum gradient strength that is plotted in T/m</p>
</dd>
<dt><strong>G_end</strong><span class="classifier">float,</span></dt><dd><p>optional maximum gradient strength that is plotted in T/m</p>
</dd>
<dt><strong>bval_isolines</strong><span class="classifier">array,</span></dt><dd><p>optional array of bvalue isolines that are plotted in the background</p>
</dd>
<dt><strong>alpha_shading</strong><span class="classifier">float between [0-1]</span></dt><dd><p>optional shading of the bvalue colors in the background</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="qtimodel">
<h3><a class="reference internal" href="#dipy.reconst.qti.QtiModel" title="dipy.reconst.qti.QtiModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtiModel</span></code></a><a class="headerlink" href="#qtimodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">QtiModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SCS'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiModel.fit" title="dipy.reconst.qti.QtiModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit QTI to data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiModel.predict" title="dipy.reconst.qti.QtiModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(params)</p></td>
<td><p>Generate signals from this model class instance and given parameters.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit QTI to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array of shape (…, number of acquisitions).</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>Array with the same shape as the data array of a single acquisition.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qtifit</strong><span class="classifier">dipy.reconst.qti.QtiFit</span></dt><dd><p>The fitted model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiModel.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiModel.predict" title="Link to this definition">#</a></dt>
<dd><p>Generate signals from this model class instance and given parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array of shape (…, 28) containing the model parameters. Element 0
is the natural logarithm of the signal without diffusion-weighting,
elements 1-6 are the diffusion tensor elements in Voigt notation,
and elements 7-27 are the covariance tensor elements in Voigt
notation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Signals.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="qtifit">
<h3><a class="reference internal" href="#dipy.reconst.qti.QtiFit" title="dipy.reconst.qti.QtiFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtiFit</span></code></a><a class="headerlink" href="#qtifit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">QtiFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.S0_hat" title="dipy.reconst.qti.QtiFit.S0_hat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">S0_hat</span></code></a>()</p></td>
<td><p>Estimated signal without diffusion-weighting.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.c_c" title="dipy.reconst.qti.QtiFit.c_c"><code class="xref py py-obj docutils literal notranslate"><span class="pre">c_c</span></code></a>()</p></td>
<td><p>Microscopic orientation coherence.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.c_m" title="dipy.reconst.qti.QtiFit.c_m"><code class="xref py py-obj docutils literal notranslate"><span class="pre">c_m</span></code></a>()</p></td>
<td><p>Normalized macroscopic anisotropy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.c_md" title="dipy.reconst.qti.QtiFit.c_md"><code class="xref py py-obj docutils literal notranslate"><span class="pre">c_md</span></code></a>()</p></td>
<td><p>Normalized variance of mean diffusivities.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.c_mu" title="dipy.reconst.qti.QtiFit.c_mu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">c_mu</span></code></a>()</p></td>
<td><p>Normalized microscopic anisotropy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.d_sq" title="dipy.reconst.qti.QtiFit.d_sq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">d_sq</span></code></a>()</p></td>
<td><p>Diffusion tensor's outer product with itself.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.fa" title="dipy.reconst.qti.QtiFit.fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code></a>()</p></td>
<td><p>Fractional anisotropy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.k_bulk" title="dipy.reconst.qti.QtiFit.k_bulk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">k_bulk</span></code></a>()</p></td>
<td><p>Bulk kurtosis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.k_mu" title="dipy.reconst.qti.QtiFit.k_mu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">k_mu</span></code></a>()</p></td>
<td><p>Microscopic kurtosis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.k_shear" title="dipy.reconst.qti.QtiFit.k_shear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">k_shear</span></code></a>()</p></td>
<td><p>Shear kurtosis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.md" title="dipy.reconst.qti.QtiFit.md"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code></a>()</p></td>
<td><p>Mean diffusivity.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.mean_d_sq" title="dipy.reconst.qti.QtiFit.mean_d_sq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_d_sq</span></code></a>()</p></td>
<td><p>Average of microscopic diffusion tensors' outer products with themselves.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.mk" title="dipy.reconst.qti.QtiFit.mk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mk</span></code></a>()</p></td>
<td><p>Mean kurtosis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.predict" title="dipy.reconst.qti.QtiFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab)</p></td>
<td><p>Generate signals from this model fit and a given gradient table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.ufa" title="dipy.reconst.qti.QtiFit.ufa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ufa</span></code></a>()</p></td>
<td><p>Microscopic fractional anisotropy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.v_iso" title="dipy.reconst.qti.QtiFit.v_iso"><code class="xref py py-obj docutils literal notranslate"><span class="pre">v_iso</span></code></a>()</p></td>
<td><p>Total isotropic variance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.v_md" title="dipy.reconst.qti.QtiFit.v_md"><code class="xref py py-obj docutils literal notranslate"><span class="pre">v_md</span></code></a>()</p></td>
<td><p>Variance of microscopic mean diffusivities.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit.v_shear" title="dipy.reconst.qti.QtiFit.v_shear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">v_shear</span></code></a>()</p></td>
<td><p>Shear variance.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.S0_hat">
<span class="sig-name descname"><span class="pre">S0_hat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.S0_hat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.S0_hat" title="Link to this definition">#</a></dt>
<dd><p>Estimated signal without diffusion-weighting.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S0</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.c_c">
<span class="sig-name descname"><span class="pre">c_c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.c_c"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.c_c" title="Link to this definition">#</a></dt>
<dd><p>Microscopic orientation coherence.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c_c</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Microscopic orientation coherence is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C_c = \frac{C_\text{M}}{C_\mu}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.c_m">
<span class="sig-name descname"><span class="pre">c_m</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.c_m"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.c_m" title="Link to this definition">#</a></dt>
<dd><p>Normalized macroscopic anisotropy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c_m</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Normalized macroscopic anisotropy is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C_\text{M} = \frac{3}{2} \frac{\langle \mathbf{D} \rangle
\otimes \langle \mathbf{D} \rangle :
\mathbb{E}_\text{shear}}
{\langle \mathbf{D} \rangle \otimes \langle \mathbf{D}
\rangle :
\mathbb{E}_\text{iso}}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.c_md">
<span class="sig-name descname"><span class="pre">c_md</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.c_md"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.c_md" title="Link to this definition">#</a></dt>
<dd><p>Normalized variance of mean diffusivities.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c_md</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Normalized variance of microscopic mean diffusivities is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C_\text{MD} = \frac{\mathbb{C} : \mathbb{E}_\text{bulk}}
{\langle \mathbf{D} \otimes \mathbf{D} \rangle :
\mathbb{E}_\text{bulk}}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.c_mu">
<span class="sig-name descname"><span class="pre">c_mu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.c_mu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.c_mu" title="Link to this definition">#</a></dt>
<dd><p>Normalized microscopic anisotropy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c_mu</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Normalized microscopic anisotropy is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C_\mu = \frac{3}{2} \frac{\langle \mathbf{D} \otimes
\mathbf{D}
\rangle : \mathbb{E}_\text{shear}}{\langle \mathbf{D}
\otimes
\mathbf{D} \rangle : \mathbb{E}_\text{iso}}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.d_sq">
<span class="sig-name descname"><span class="pre">d_sq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.d_sq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.d_sq" title="Link to this definition">#</a></dt>
<dd><p>Diffusion tensor’s outer product with itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>d_sq</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.fa">
<span class="sig-name descname"><span class="pre">fa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.fa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.fa" title="Link to this definition">#</a></dt>
<dd><p>Fractional anisotropy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fa</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Fractional anisotropy is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\text{FA} = \sqrt{C_\text{M}}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.k_bulk">
<span class="sig-name descname"><span class="pre">k_bulk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.k_bulk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.k_bulk" title="Link to this definition">#</a></dt>
<dd><p>Bulk kurtosis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k_bulk</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Bulk kurtosis is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[K_\text{bulk} = 3 \frac{\mathbb{C} :
\mathbb{E}_\text{bulk}}
{\langle \mathbf{D} \rangle \otimes \langle \mathbf{D}
\rangle : \mathbb{E}_\text{bulk}}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.k_mu">
<span class="sig-name descname"><span class="pre">k_mu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.k_mu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.k_mu" title="Link to this definition">#</a></dt>
<dd><p>Microscopic kurtosis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k_mu</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Microscopic kurtosis is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[K_\mu = \frac{6}{5} \frac{\langle \mathbf{D} \otimes
\mathbf{D}
\rangle : \mathbb{E}_\text{shear}}{\langle \mathbf{D}
\rangle
\otimes \langle \mathbf{D} \rangle :
\mathbb{E}_\text{bulk}}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.k_shear">
<span class="sig-name descname"><span class="pre">k_shear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.k_shear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.k_shear" title="Link to this definition">#</a></dt>
<dd><p>Shear kurtosis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k_shear</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Shear kurtosis is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[K_\text{shear} = \frac{6}{5} \frac{\mathbb{C} :
\mathbb{E}_\text{shear}}{\langle \mathbf{D} \rangle
\otimes
\langle \mathbf{D} \rangle : \mathbb{E}_\text{bulk}}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.md">
<span class="sig-name descname"><span class="pre">md</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.md"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.md" title="Link to this definition">#</a></dt>
<dd><p>Mean diffusivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>md</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Mean diffusivity is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\text{MD} = \langle \mathbf{D} \rangle :
\mathbf{E}_\text{iso}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.mean_d_sq">
<span class="sig-name descname"><span class="pre">mean_d_sq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.mean_d_sq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.mean_d_sq" title="Link to this definition">#</a></dt>
<dd><p>Average of microscopic diffusion tensors’ outer products with
themselves.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mean_d_sq</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Average of microscopic diffusion tensors’ outer products with
themselves is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\langle \mathbf{D} \otimes \mathbf{D} \rangle =
\mathbb{C} +
\langle \mathbf{D} \rangle \otimes \langle \mathbf{D}
\rangle\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.mk">
<span class="sig-name descname"><span class="pre">mk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.mk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.mk" title="Link to this definition">#</a></dt>
<dd><p>Mean kurtosis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mk</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Mean kurtosis is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\text{MK} = K_\text{bulk} + K_\text{shear}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Generate signals from this model fit and a given gradient table.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">dipy.core.gradients.GradientTable</span></dt><dd><p>Gradient table with b-tensors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Signals.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.ufa">
<span class="sig-name descname"><span class="pre">ufa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.ufa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.ufa" title="Link to this definition">#</a></dt>
<dd><p>Microscopic fractional anisotropy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ufa</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Microscopic fractional anisotropy is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mu\text{FA} = \sqrt{C_\mu}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.v_iso">
<span class="sig-name descname"><span class="pre">v_iso</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.v_iso"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.v_iso" title="Link to this definition">#</a></dt>
<dd><p>Total isotropic variance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v_iso</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Total isotropic variance is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[V_\text{iso} = \mathbb{C} : \mathbb{E}_\text{iso}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.v_md">
<span class="sig-name descname"><span class="pre">v_md</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.v_md"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.v_md" title="Link to this definition">#</a></dt>
<dd><p>Variance of microscopic mean diffusivities.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v_md</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Variance of microscopic mean diffusivities is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[V_\text{MD} = \mathbb{C} : \mathbb{E}_\text{bulk}\]</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.v_shear">
<span class="sig-name descname"><span class="pre">v_shear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#QtiFit.v_shear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.QtiFit.v_shear" title="Link to this definition">#</a></dt>
<dd><p>Shear variance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v_shear</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Shear variance is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[V_\text{shear} = \mathbb{C} : \mathbb{E}_\text{shear}\]</div>
</div></blockquote>
</dd></dl>

</dd></dl>

</section>
<section id="from-3x3-to-6x1">
<h3>from_3x3_to_6x1<a class="headerlink" href="#from-3x3-to-6x1" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.from_3x3_to_6x1">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">from_3x3_to_6x1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#from_3x3_to_6x1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.from_3x3_to_6x1" title="Link to this definition">#</a></dt>
<dd><p>Convert symmetric 3 x 3 matrices into 6 x 1 vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>T</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (…, 3, 3).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>V</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Converted vectors of size (…, 6, 1).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{V} = \begin{bmatrix}
T_{11} &amp; T_{22} &amp; T_{33} &amp;
\sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12}
\end{bmatrix}^T\]</div>
</div></blockquote>
</dd></dl>

</section>
<section id="from-6x1-to-3x3">
<h3>from_6x1_to_3x3<a class="headerlink" href="#from-6x1-to-3x3" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.from_6x1_to_3x3">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">from_6x1_to_3x3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#from_6x1_to_3x3"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.from_6x1_to_3x3" title="Link to this definition">#</a></dt>
<dd><p>Convert 6 x 1 vectors into symmetric 3 x 3 matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>V</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (…, 6, 1).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Converted matrices of size (…, 3, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{V} = \begin{bmatrix}
T_{11} &amp; T_{22} &amp; T_{33} &amp;
\sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12}
\end{bmatrix}^T\]</div>
</div></blockquote>
</dd></dl>

</section>
<section id="from-6x6-to-21x1">
<h3>from_6x6_to_21x1<a class="headerlink" href="#from-6x6-to-21x1" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.from_6x6_to_21x1">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">from_6x6_to_21x1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#from_6x6_to_21x1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.from_6x6_to_21x1" title="Link to this definition">#</a></dt>
<dd><p>Convert symmetric 6 x 6 matrices into 21 x 1 vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>T</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (…, 6, 6).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>V</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Converted vectors of size (…, 21, 1).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{matrix}
\mathbf{V} = &amp; \big[
T_{11} &amp; T_{22} &amp; T_{33} \
&amp; \sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12} \
&amp; \sqrt{2} T_{14} &amp; \sqrt{2} T_{15} &amp; \sqrt{2} T_{16} \
&amp; \sqrt{2} T_{24} &amp; \sqrt{2} T_{25} &amp; \sqrt{2} T_{26} \
&amp; \sqrt{2} T_{34} &amp; \sqrt{2} T_{35} &amp; \sqrt{2} T_{36} \
&amp; T_{44} &amp; T_{55} &amp; T_{66} \
&amp; \sqrt{2} T_{45} &amp; \sqrt{2} T_{56} &amp; \sqrt{2} T_{46} \big]^T
\end{matrix}\]</div>
</div></blockquote>
</dd></dl>

</section>
<section id="from-21x1-to-6x6">
<h3>from_21x1_to_6x6<a class="headerlink" href="#from-21x1-to-6x6" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.from_21x1_to_6x6">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">from_21x1_to_6x6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#from_21x1_to_6x6"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.from_21x1_to_6x6" title="Link to this definition">#</a></dt>
<dd><p>Convert 21 x 1 vectors into symmetric 6 x 6 matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>V</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (…, 21, 1).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Converted matrices of size (…, 6, 6).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{matrix}
\mathbf{V} = &amp; \big[
T_{11} &amp; T_{22} &amp; T_{33} \
&amp; \sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12} \
&amp; \sqrt{2} T_{14} &amp; \sqrt{2} T_{15} &amp; \sqrt{2} T_{16} \
&amp; \sqrt{2} T_{24} &amp; \sqrt{2} T_{25} &amp; \sqrt{2} T_{26} \
&amp; \sqrt{2} T_{34} &amp; \sqrt{2} T_{35} &amp; \sqrt{2} T_{36} \
&amp; T_{44} &amp; T_{55} &amp; T_{66} \
&amp; \sqrt{2} T_{45} &amp; \sqrt{2} T_{56} &amp; \sqrt{2} T_{46} \big]^T
\end{matrix}\]</div>
</div></blockquote>
</dd></dl>

</section>
<section id="cvxpy-1x6-to-3x3">
<h3>cvxpy_1x6_to_3x3<a class="headerlink" href="#cvxpy-1x6-to-3x3" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.cvxpy_1x6_to_3x3">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">cvxpy_1x6_to_3x3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#cvxpy_1x6_to_3x3"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.cvxpy_1x6_to_3x3" title="Link to this definition">#</a></dt>
<dd><p>Convert a 1 x 6 vector into a symmetric 3 x 3 matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>V</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (1, 6).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">cvxpy.bmat</span></dt><dd><p>Converted matrix of size (3, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{V} = \begin{bmatrix}
T_{11} &amp; T_{22} &amp; T_{33} &amp;
\sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12}
\end{bmatrix}^T\]</div>
</div></blockquote>
</dd></dl>

</section>
<section id="cvxpy-1x21-to-6x6">
<h3>cvxpy_1x21_to_6x6<a class="headerlink" href="#cvxpy-1x21-to-6x6" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.cvxpy_1x21_to_6x6">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">cvxpy_1x21_to_6x6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#cvxpy_1x21_to_6x6"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.cvxpy_1x21_to_6x6" title="Link to this definition">#</a></dt>
<dd><p>Convert 1 x 21 vector into a symmetric 6 x 6 matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>V</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (1, 21).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">cvxpy.bmat</span></dt><dd><p>Converted matrices of size (6, 6).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{matrix}
\mathbf{V} = &amp; \big[
T_{11} &amp; T_{22} &amp; T_{33} \
&amp; \sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12} \
&amp; \sqrt{2} T_{14} &amp; \sqrt{2} T_{15} &amp; \sqrt{2} T_{16} \
&amp; \sqrt{2} T_{24} &amp; \sqrt{2} T_{25} &amp; \sqrt{2} T_{26} \
&amp; \sqrt{2} T_{34} &amp; \sqrt{2} T_{35} &amp; \sqrt{2} T_{36} \
&amp; T_{44} &amp; T_{55} &amp; T_{66} \
&amp; \sqrt{2} T_{45} &amp; \sqrt{2} T_{56} &amp; \sqrt{2} T_{46} \big]^T
\end{matrix}\]</div>
</div></blockquote>
</dd></dl>

</section>
<section id="dtd-covariance">
<h3>dtd_covariance<a class="headerlink" href="#dtd-covariance" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.dtd_covariance">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">dtd_covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DTD</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#dtd_covariance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.dtd_covariance" title="Link to this definition">#</a></dt>
<dd><p>Calculate covariance of a diffusion tensor distribution (DTD).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>DTD</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Diffusion tensor distribution of shape (number of tensors, 3, 3) or
(number of tensors, 6, 1).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Covariance tensor of shape (6, 6).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The covariance tensor is calculated according to the following equation and
converted into a rank-2 tensor <a class="footnote-reference brackets" href="#footcite-westin2016" id="id350" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbb{C} = \langle \mathbf{D} \otimes \mathbf{D} \rangle -
\langle \mathbf{D} \rangle \otimes \langle \mathbf{D}
\rangle\]</div>
</div></blockquote>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="qti-signal">
<h3>qti_signal<a class="headerlink" href="#qti-signal" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.qti_signal">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">qti_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#qti_signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.qti_signal" title="Link to this definition">#</a></dt>
<dd><p>Generate signals using the covariance tensor signal representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">dipy.core.gradients.GradientTable</span></dt><dd><p>Gradient table with b-tensors.</p>
</dd>
<dt><strong>D</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Diffusion tensors of shape (…, 3, 3), (…, 6, 1), or (…, 6).</p>
</dd>
<dt><strong>C</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Covariance tensors of shape (…, 6, 6), (…, 21, 1), or (…, 21).</p>
</dd>
<dt><strong>S0</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>Signal magnitudes without diffusion-weighting. Must be a single number
or an array of same shape as D and C without the last two dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Simulated signals.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The signal is generated according to</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[S = S_0 \exp \left(- \mathbf{b} : \langle \mathbf{D} \rangle
+ \frac{1}{2}(\mathbf{b} \otimes \mathbf{b}) : \mathbb{C}
\right)\]</div>
</div></blockquote>
</dd></dl>

</section>
<section id="id351">
<h3>design_matrix<a class="headerlink" href="#id351" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">btens</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/qti.html#design_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.qti.design_matrix" title="Link to this definition">#</a></dt>
<dd><p>Calculate the design matrix from the b-tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>btens</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of b-tensors of shape (number of acquisitions, 3, 3).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>X</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Design matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The design matrix is generated according to</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[X = \begin{pmatrix} 1 &amp; -\mathbf{b}_1^T &amp; \frac{1}{2}(
\mathbf{b}_1
\otimes\mathbf{b}_1)^T \ \vdots &amp; \vdots &amp; \vdots \ 1 &amp;
-\mathbf{b}_n^T &amp; \frac{1}{2}(\mathbf{b}_n\otimes
\mathbf{b}_n)^T
\end{pmatrix}\]</div>
</div></blockquote>
</dd></dl>

</section>
<section id="rumbasdmodel">
<h3><a class="reference internal" href="#dipy.reconst.rumba.RumbaSDModel" title="dipy.reconst.rumba.RumbaSDModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">RumbaSDModel</span></code></a><a class="headerlink" href="#rumbasdmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaSDModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">RumbaSDModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0017,</span> <span class="pre">0.0002,</span> <span class="pre">0.0002)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0008</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">600</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recon_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'smf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_coils</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxelwise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#RumbaSDModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.RumbaSDModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data)</p></td>
<td><p>To be implemented by specific odf models</p></td>
</tr>
</tbody>
</table>
</div>
</dd></dl>

</section>
<section id="rumbafit">
<h3><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit" title="dipy.reconst.rumba.RumbaFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">RumbaFit</span></code></a><a class="headerlink" href="#rumbafit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">RumbaFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#RumbaFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit.combined_odf_iso" title="dipy.reconst.rumba.RumbaFit.combined_odf_iso"><code class="xref py py-obj docutils literal notranslate"><span class="pre">combined_odf_iso</span></code></a>()</p></td>
<td><p>Constructs fODF combined with isotropic volume fraction at discrete vertices on model sphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit.f_csf" title="dipy.reconst.rumba.RumbaFit.f_csf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_csf</span></code></a>()</p></td>
<td><p>Constructs CSF volume fraction for each voxel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit.f_gm" title="dipy.reconst.rumba.RumbaFit.f_gm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_gm</span></code></a>()</p></td>
<td><p>Constructs GM volume fraction for each voxel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit.f_iso" title="dipy.reconst.rumba.RumbaFit.f_iso"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_iso</span></code></a>()</p></td>
<td><p>Constructs isotropic volume fraction for each voxel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit.f_wm" title="dipy.reconst.rumba.RumbaFit.f_wm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_wm</span></code></a>()</p></td>
<td><p>Constructs white matter volume fraction for each voxel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit.odf" title="dipy.reconst.rumba.RumbaFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(*[, sphere])</p></td>
<td><p>Constructs fODF at discrete vertices on model sphere for each voxel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit.predict" title="dipy.reconst.rumba.RumbaFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(*[, gtab, S0])</p></td>
<td><p>Compute signal prediction on model gradient table given given fODF and GM/CSF volume fractions for each voxel.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.combined_odf_iso">
<span class="sig-name descname"><span class="pre">combined_odf_iso</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#RumbaFit.combined_odf_iso"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.combined_odf_iso" title="Link to this definition">#</a></dt>
<dd><p>Constructs fODF combined with isotropic volume fraction at discrete
vertices on model sphere.</p>
<p>Distributes isotropic compartments evenly along each fODF direction.
Sums to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>combined</strong><span class="classifier">ndarray ([x, y, z], M-2)</span></dt><dd><p>fODF combined with isotropic volume fraction.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.f_csf">
<span class="sig-name descname"><span class="pre">f_csf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#RumbaFit.f_csf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.f_csf" title="Link to this definition">#</a></dt>
<dd><p>Constructs CSF volume fraction for each voxel.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f_csf</strong><span class="classifier">ndarray ([x, y, z])</span></dt><dd><p>CSF volume fraction.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.f_gm">
<span class="sig-name descname"><span class="pre">f_gm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#RumbaFit.f_gm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.f_gm" title="Link to this definition">#</a></dt>
<dd><p>Constructs GM volume fraction for each voxel.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f_gm</strong><span class="classifier">ndarray ([x, y, z])</span></dt><dd><p>GM volume fraction.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.f_iso">
<span class="sig-name descname"><span class="pre">f_iso</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#RumbaFit.f_iso"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.f_iso" title="Link to this definition">#</a></dt>
<dd><p>Constructs isotropic volume fraction for each voxel.</p>
<p>Equivalent to sum of GM and CSF volume fractions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f_iso</strong><span class="classifier">ndarray ([x, y, z])</span></dt><dd><p>Isotropic volume fraction.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.f_wm">
<span class="sig-name descname"><span class="pre">f_wm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#RumbaFit.f_wm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.f_wm" title="Link to this definition">#</a></dt>
<dd><p>Constructs white matter volume fraction for each voxel.</p>
<p>Equivalent to sum of fODF.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f_wm</strong><span class="classifier">ndarray ([x, y, z])</span></dt><dd><p>White matter volume fraction.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#RumbaFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.odf" title="Link to this definition">#</a></dt>
<dd><p>Constructs fODF at discrete vertices on model sphere for each voxel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere, optional</span></dt><dd><p>Sphere on which to construct fODF. If specified, must be the same
sphere used by the <cite>RumbaSDModel</cite> model. Default: None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>odf</strong><span class="classifier">ndarray ([x, y, z], M-2)</span></dt><dd><p>fODF computed at each vertex on model sphere.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#RumbaFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Compute signal prediction on model gradient table given given fODF
and GM/CSF volume fractions for each voxel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable, optional</span></dt><dd><p>The gradients for which the signal will be predicted. Use the
model’s gradient table if <cite>None</cite>. Default: None</p>
</dd>
<dt><strong>S0</strong><span class="classifier">ndarray ([x, y, z]) or float, optional</span></dt><dd><p>The non diffusion-weighted signal value for each voxel. If a float,
the same value is used for each voxel. If <cite>None</cite>, 1 is used for
each voxel. Default: None</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pred_sig</strong><span class="classifier">ndarray ([x, y, z], N)</span></dt><dd><p>The predicted signal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="rumba-deconv">
<h3>rumba_deconv<a class="headerlink" href="#rumba-deconv" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.rumba.rumba_deconv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">rumba_deconv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">600</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recon_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'smf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_coils</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#rumba_deconv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.rumba_deconv" title="Link to this definition">#</a></dt>
<dd><p>Fit fODF and GM/CSF volume fractions for a voxel using RUMBA-SD.</p>
<p>Deconvolves the kernel from the diffusion-weighted signal by computing a
maximum likelihood estimation of the fODF
<a class="footnote-reference brackets" href="#footcite-canalesrodriguez2015" id="id352" role="doc-noteref"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></a>. Minimizes the negative log-likelihood of
the data under Rician or Noncentral Chi noise distributions by adapting the
iterative technique developed in Richardson-Lucy deconvolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">1d ndarray (N,)</span></dt><dd><p>Signal values for a single voxel.</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">2d ndarray (N, M)</span></dt><dd><p>Deconvolution kernel mapping volume fractions of the M compartments to
N-length signal. Last two columns should be for GM and CSF.</p>
</dd>
<dt><strong>n_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of iterations for fODF estimation. Must be a positive int.
Default: 600</p>
</dd>
<dt><strong>recon_type</strong><span class="classifier">{‘smf’, ‘sos’}, optional</span></dt><dd><p>MRI reconstruction method: spatial matched filter (SMF) or
sum-of-squares (SoS). SMF reconstruction generates Rician noise while
SoS reconstruction generates Noncentral Chi noise. Default: ‘smf’</p>
</dd>
<dt><strong>n_coils</strong><span class="classifier">int, optional</span></dt><dd><p>Number of coils in MRI scanner – only relevant in SoS reconstruction.
Must be a positive int. Default: 1</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fit_vec</strong><span class="classifier">1d ndarray (M,)</span></dt><dd><p>Vector containing fODF and GM/CSF volume fractions. First M-2
components are fODF while last two are GM and CSF respectively.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The diffusion MRI signal measured at a given voxel is a sum of
contributions from each intra-voxel compartment, including parallel white
matter (WM) fiber populations in a given orientation as well as effects
from GM and CSF. The equation governing these  contributions is:</p>
<p><span class="math notranslate nohighlight">\(S_i = S_0\left(\sum_{j=1}^{M}f_j\exp(-b_i\textbf{v}_i^T\textbf{D}_j
\textbf{v}_i) + f_{GM}\exp(-b_iD_{GM})+f_{CSF}\exp(-b_iD_{CSF})\right)\)</span></p>
<p>Where <span class="math notranslate nohighlight">\(S_i\)</span> is the resultant signal along the diffusion-sensitizing
gradient unit vector <span class="math notranslate nohighlight">\(\textbf{v_i}; i = 1, ..., N\)</span> with a b-value of <span class="math notranslate nohighlight">\(b_i\)</span>.
<span class="math notranslate nohighlight">\(f_j; j = 1, ..., M\)</span> is the volume fraction of the <span class="math notranslate nohighlight">\(j^{th}\)</span> fiber
population with an anisotropic diffusion tensor <span class="math notranslate nohighlight">\(\textbf{D_j}\)</span>.</p>
<p><span class="math notranslate nohighlight">\(f_{GM}\)</span> and <span class="math notranslate nohighlight">\(f_{CSF}\)</span> are the volume fractions and <span class="math notranslate nohighlight">\(D_{GM}\)</span> and <span class="math notranslate nohighlight">\(D_{CSF}\)</span>
are the mean diffusivities of GM and CSF respectively.</p>
<p>This equation is linear in <span class="math notranslate nohighlight">\(f_j, f_{GM}, f_{CSF}\)</span> and can be simplified to
a single matrix multiplication:</p>
<p><span class="math notranslate nohighlight">\(\textbf{S} = \textbf{Hf}\)</span></p>
<p>Where <span class="math notranslate nohighlight">\(\textbf{S}\)</span> is the signal vector at a certain voxel, <span class="math notranslate nohighlight">\(\textbf{H}\)</span> is
the deconvolution kernel, and <span class="math notranslate nohighlight">\(\textbf{f}\)</span> is the vector of volume
fractions for each compartment.</p>
<p>Modern MRI scanners produce noise following a Rician or Noncentral Chi
distribution, depending on their signal reconstruction technique
<cite>footcite:p:`Constantinides1997</cite>. Using this linear model, it can be shown
that the likelihood of a signal under a Noncentral Chi noise model is:</p>
<p><span class="math notranslate nohighlight">\(P(\textbf{S}|\textbf{H}, \textbf{f}, \sigma^2, n) = \prod_{i=1}^{N}\left(
\frac{S_i}{\bar{S_i}}\right)^n\exp\left\{-\frac{1}{2\sigma^2}\left[
S_i^2 + \bar{S}_i^2\right]\right\}I_{n-1}\left(\frac{S_i\bar{S}_i}
{\sigma^2}\right)u(S_i)\)</span></p>
<p>Where <span class="math notranslate nohighlight">\(S_i\)</span> and <span class="math notranslate nohighlight">\(\bar{S}_i = \textbf{Hf}\)</span> are the measured and expected
signals respectively, and <span class="math notranslate nohighlight">\(n\)</span> is the number of coils in the scanner, and
<span class="math notranslate nohighlight">\(I_{n-1}\)</span> is the modified Bessel function of first kind of order <span class="math notranslate nohighlight">\(n-1\)</span>.
This gives the likelihood under a Rician distribution when <span class="math notranslate nohighlight">\(n\)</span> is set to 1.</p>
<p>By taking the negative log of this with respect to <span class="math notranslate nohighlight">\(\textbf{f}\)</span> and setting
the derivative to 0, the <span class="math notranslate nohighlight">\(\textbf{f}\)</span> maximizing likelihood is found to be:</p>
<p><span class="math notranslate nohighlight">\(\textbf{f} = \textbf{f} \circ \frac{\textbf{H}^T\left[\textbf{S}\circ
\frac{I_n(\textbf{S}\circ \textbf{Hf}/\sigma^2)} {I_{n-1}(\textbf{S}
\circ\textbf{Hf}\sigma^2)} \right ]} {\textbf{H}^T\textbf{Hf}}\)</span></p>
<p>The solution can be found using an iterative scheme, just as in the
Richardson-Lucy algorithm:</p>
<p><span class="math notranslate nohighlight">\(\textbf{f}^{k+1} = \textbf{f}^k \circ \frac{\textbf{H}^T\left[\textbf{S}
\circ\frac{I_n(\textbf{S}\circ\textbf{Hf}^k/\sigma^2)} {I_{n-1}(\textbf{S}
\circ\textbf{Hf}^k/\sigma^2)} \right ]} {\textbf{H}^T\textbf{Hf}^k}\)</span></p>
<p>In order to apply this, a reasonable estimate of <span class="math notranslate nohighlight">\(\sigma^2\)</span> is required.
To find this, a separate iterative scheme is found using the derivative
of the negative log with respect to <span class="math notranslate nohighlight">\(\sigma^2\)</span>, and is run in parallel.
This is shown here:</p>
<p><span class="math notranslate nohighlight">\(\alpha^{k+1} = \frac{1}{nN}\left\{ \frac{\textbf{S}^T\textbf{S} +
\textbf{f}^T\textbf{H}^T\textbf{Hf}}{2} - \textbf{1}^T_N\left[(\textbf{S}
\circ\textbf{Hf})\circ\frac{I_n(\textbf{S}\circ\textbf{Hf}/\alpha^k)}
{I_{n-1}(\textbf{S}\circ\textbf{Hf}/\alpha^k)} \right ]\right \}\)</span></p>
<p>For more details, see <a class="footnote-reference brackets" href="#footcite-canalesrodriguez2015" id="id353" role="doc-noteref"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id354">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-canalesrodriguez2015" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id352">1</a>,<a role="doc-backlink" href="#id353">2</a>,<a role="doc-backlink" href="#id357">3</a>)</span>
<p>Erick J. Canales-Rodríguez, Alessandro Daducci, Stamatios N. Sotiropoulos, Emmanuel Caruyer, Santiago Aja-Fernández, Joaquim Radua, Jesús M. Yurramendi Mendizabal, Yasser Iturria-Medina, Lester Melie-García, Yasser Alemán-Gómez, Jean-Philippe Thiran, Salvador Sarró, Edith Pomarol-Clotet, and Raymond Salvador. Spherical Deconvolution of Multichannel Diffusion MRI Data with Non-Gaussian Noise Models and Spatial Regularization. <em>PLOS ONE</em>, 10(10):e0138910, 2015. URL: <a class="reference external" href="https://doi.org/10.1371/journal.pone.0138910">https://doi.org/10.1371/journal.pone.0138910</a>, <a class="reference external" href="https://doi.org/10.1371/journal.pone.0138910">doi:10.1371/journal.pone.0138910</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="mbessel-ratio">
<h3>mbessel_ratio<a class="headerlink" href="#mbessel-ratio" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.rumba.mbessel_ratio">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">mbessel_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#mbessel_ratio"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.mbessel_ratio" title="Link to this definition">#</a></dt>
<dd><p>Fast computation of modified Bessel function ratio (first kind).</p>
<p>Computes:</p>
<p><span class="math notranslate nohighlight">\(I_{n}(x) / I_{n-1}(x)\)</span></p>
<p>using Perron’s continued fraction equation where <span class="math notranslate nohighlight">\(I_n\)</span> is the modified
Bessel function of first kind, order <span class="math notranslate nohighlight">\(n\)</span> <a class="footnote-reference brackets" href="#footcite-gautschi1978" id="id355" role="doc-noteref"><span class="fn-bracket">[</span>67<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Order of Bessel function in numerator (denominator is of order n-1).
Must be a positive int.</p>
</dd>
<dt><strong>x</strong><span class="classifier">float or ndarray</span></dt><dd><p>Value or array of values with which to compute ratio.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">float or ndarray</span></dt><dd><p>Result of ratio computation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id356">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-gautschi1978" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id355">67</a><span class="fn-bracket">]</span></span>
<p>Walter Gautschi and Josef Slavik. On the computation of modified Bessel function ratios. <em>Mathematics of Computation</em>, 32(143):865–875, 1978. <a class="reference external" href="https://doi.org/10.1090/S0025-5718-1978-0470267-9">doi:10.1090/S0025-5718-1978-0470267-9</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="generate-kernel">
<h3>generate_kernel<a class="headerlink" href="#generate-kernel" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.rumba.generate_kernel">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">generate_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_response</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#generate_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.generate_kernel" title="Link to this definition">#</a></dt>
<dd><p>Generate deconvolution kernel</p>
<p>Compute kernel mapping orientation densities of white matter fiber
populations (along each vertex of the sphere) and isotropic volume
fractions to a diffusion weighted signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Gradient table.</p>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>Sphere with which to sample discrete fiber orientations in order to
construct kernel</p>
</dd>
<dt><strong>wm_response</strong><span class="classifier">1d ndarray or 2d ndarray or AxSymShResponse, optional</span></dt><dd><p>Tensor eigenvalues as a (3,) ndarray, multishell eigenvalues as
a (len(unique_bvals_tolerance(gtab.bvals))-1, 3) ndarray in
order of smallest to largest b-value, or an AxSymShResponse.</p>
</dd>
<dt><strong>gm_response</strong><span class="classifier">float, optional</span></dt><dd><p>Mean diffusivity for GM compartment. If <cite>None</cite>, then grey
matter compartment set to all zeros.</p>
</dd>
<dt><strong>csf_response</strong><span class="classifier">float, optional</span></dt><dd><p>Mean diffusivity for CSF compartment. If <cite>None</cite>, then CSF
compartment set to all zeros.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>kernel</strong><span class="classifier">2d ndarray (N, M)</span></dt><dd><p>Computed kernel; can be multiplied with a vector consisting of volume
fractions for each of M-2 fiber populations as well as GM and CSF
fractions to produce a diffusion weighted signal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="rumba-deconv-global">
<h3>rumba_deconv_global<a class="headerlink" href="#rumba-deconv-global" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.rumba.rumba_deconv_global">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">rumba_deconv_global</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">600</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recon_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'smf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_coils</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/rumba.html#rumba_deconv_global"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.rumba.rumba_deconv_global" title="Link to this definition">#</a></dt>
<dd><p>Fit fODF for all voxels simultaneously using RUMBA-SD.</p>
<p>Deconvolves the kernel from the diffusion-weighted signal at each voxel by
computing a maximum likelihood estimation of the fODF
<a class="footnote-reference brackets" href="#footcite-canalesrodriguez2015" id="id357" role="doc-noteref"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></a>. Global fitting also permits the use of
total variation regularization (RUMBA-SD + TV). The spatial dependence
introduced by TV promotes smoother solutions (i.e. prevents oscillations),
while still allowing for sharp discontinuities <a class="footnote-reference brackets" href="#footcite-rudin1992" id="id358" role="doc-noteref"><span class="fn-bracket">[</span>68<span class="fn-bracket">]</span></a>. This
promotes smoothness and continuity along individual tracts while preventing
smoothing of adjacent tracts.</p>
<p>Generally, global_fit will proceed more quickly than the voxelwise fit
provided that the computer has adequate RAM (&gt;= 16 GB should be more than
sufficient).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">4d ndarray (x, y, z, N)</span></dt><dd><p>Signal values for entire brain. None of the volume dimensions x, y, z
can be 1 if TV regularization is required.</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">2d ndarray (N, M)</span></dt><dd><p>Deconvolution kernel mapping volume fractions of the M compartments to
N-length signal. Last two columns should be for GM and CSF.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">3d ndarray(x, y, z)</span></dt><dd><p>Binary mask specifying voxels of interest with 1; fODF will only be
fit at these voxels (0 elsewhere).</p>
</dd>
<dt><strong>n_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of iterations for fODF estimation. Must be a positive int.</p>
</dd>
<dt><strong>recon_type</strong><span class="classifier">{‘smf’, ‘sos’}, optional</span></dt><dd><p>MRI reconstruction method: spatial matched filter (SMF) or
sum-of-squares (SoS). SMF reconstruction generates Rician noise while
SoS reconstruction generates Noncentral Chi noise.</p>
</dd>
<dt><strong>n_coils</strong><span class="classifier">int, optional</span></dt><dd><p>Number of coils in MRI scanner – only relevant in SoS reconstruction.
Must be a positive int.</p>
</dd>
<dt><strong>use_tv</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, applies total variation regularization. This requires a brain
volume with no singleton dimensions.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, logs updates on estimated signal-to-noise ratio after each
iteration.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fit_array</strong><span class="classifier">4d ndarray (x, y, z, M)</span></dt><dd><p>fODF and GM/CSF volume fractions computed for each voxel. First M-2
components are fODF, while last two are GM and CSf respectively.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>TV modifies our cost function as follows:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>J(textbf{f}) = -log{P(textbf{S}|textbf{H}, textbf{f}, sigma^2, n)})+
alpha_{TV}TV(textbf{f})</p>
<p>where the first term is the negative log likelihood described in the notes
of <cite>rumba_deconv</cite>, and the second term is the TV energy, or the sum of
gradient absolute values for the fODF across the entire brain. This results
in a new multiplicative factor in the iterative scheme, now becoming:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>textbf{f}^{k+1} = textbf{f}^k circ frac{textbf{H}^Tleft[textbf{S}
circfrac{I_n(textbf{S}circtextbf{Hf}^k/sigma^2)} {I_{n-1}(textbf{S}
circtextbf{Hf}^k/sigma^2)} right ]} {textbf{H}^Ttextbf{Hf}^k}circ
textbf{R}^k</p>
<p>where <span class="math notranslate nohighlight">\(\textbf{R}^k\)</span> is computed voxelwise by:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>(textbf{R}^k)_j = frac{1}{1 - alpha_{TV}divleft(frac{triangledown[
textbf{f}^k_{3D}]_j}{lverttriangledown[textbf{f}^k_{3D}]_j rvert}
right)biggrrvert_{x, y, z}}</p>
<p>Here, <span class="math notranslate nohighlight">\(\triangledown\)</span> is the symbol for the 3D gradient at any voxel.</p>
<p>The regularization strength, <span class="math notranslate nohighlight">\(\alpha_{TV}\)</span> is updated after each iteration
by the discrepancy principle – specifically, it is selected to match the
estimated variance after each iteration <a class="footnote-reference brackets" href="#footcite-chambolle2004" id="id359" role="doc-noteref"><span class="fn-bracket">[</span>69<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id360">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-rudin1992" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id358">68</a><span class="fn-bracket">]</span></span>
<p>Leonid I. Rudin, Stanley Osher, and Emad Fatemi. Nonlinear total variation based noise removal algorithms. <em>Physica D: Nonlinear Phenomena</em>, 60(1):259–268, 1992. URL: <a class="reference external" href="https://doi.org/10.1016/0167-2789(92)90242-F">https://doi.org/10.1016/0167-2789(92)90242-F</a>, <a class="reference external" href="https://doi.org/10.1016/0167-2789(92)90242-F">doi:10.1016/0167-2789(92)90242-F</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-chambolle2004" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id359">69</a><span class="fn-bracket">]</span></span>
<p>Antonin Chambolle. An Algorithm for Total Variation Minimization and Applications. <em>Journal of Mathematical Imaging and Vision</em>, 20(1):89–97, 2004. URL: <a class="reference external" href="https://doi.org/10.1023/B:JMIV.0000011325.36760.1e">https://doi.org/10.1023/B:JMIV.0000011325.36760.1e</a>, <a class="reference external" href="https://doi.org/10.1023/B:JMIV.0000011325.36760.1e">doi:10.1023/B:JMIV.0000011325.36760.1e</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="isotropicmodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a><a class="headerlink" href="#isotropicmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">IsotropicModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#IsotropicModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>A base-class for the representation of isotropic signals.</p>
<p>The default behavior, suitable for single b-value data is to calculate the
mean in each voxel as an estimate of the signal that does not depend on
direction.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel.fit" title="dipy.reconst.sfm.IsotropicModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit an IsotropicModel.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#IsotropicModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit an IsotropicModel.</p>
<p>This boils down to finding the mean diffusion-weighted signal in each
voxel</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>IsotropicFit class instance.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="isotropicfit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a><a class="headerlink" href="#isotropicfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">IsotropicFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#IsotropicFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<p>A fit object for representing the isotropic signal as the mean of the
diffusion-weighted signal.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit.predict" title="dipy.reconst.sfm.IsotropicFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(*[, gtab])</p></td>
<td><p>Predict the isotropic signal.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#IsotropicFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict the isotropic signal.</p>
<p>Based on a gradient table. In this case, the (naive!) prediction will
be the mean of the diffusion-weighted signal in the voxels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance, optional</span></dt><dd><p>Defaults to use the gtab from the IsotropicModel from which this
fit was derived.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="exponentialisotropicmodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="dipy.reconst.sfm.ExponentialIsotropicModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a><a class="headerlink" href="#exponentialisotropicmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">ExponentialIsotropicModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#ExponentialIsotropicModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a></p>
<p>Representing the isotropic signal as a fit to an exponential decay function
with b-values</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel.fit" title="dipy.reconst.sfm.ExponentialIsotropicModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#ExponentialIsotropicModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel.fit" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd></dd>
<dt><strong>mask</strong><span class="classifier">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed. Has the shape <cite>data.shape[:-1]</cite>. Default: None,
which implies that all points should be analyzed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ExponentialIsotropicFit class instance.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="exponentialisotropicfit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="dipy.reconst.sfm.ExponentialIsotropicFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a><a class="headerlink" href="#exponentialisotropicfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">ExponentialIsotropicFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#ExponentialIsotropicFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a></p>
<p>A fit to the ExponentialIsotropicModel object, based on data.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit.predict" title="dipy.reconst.sfm.ExponentialIsotropicFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(*[, gtab])</p></td>
<td><p>Predict the isotropic signal, based on a gradient table.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#ExponentialIsotropicFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict the isotropic signal, based on a gradient table. In this case,
the prediction will be for an exponential decay with the mean
diffusivity derived from the data that was fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance, optional</span></dt><dd><p>Defaults to use the gtab from the IsotropicModel from which this
fit was derived.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="sparsefasciclemodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel" title="dipy.reconst.sfm.SparseFascicleModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a><a class="headerlink" href="#sparsefasciclemodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">SparseFascicleModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0015,</span> <span class="pre">0.0005,</span> <span class="pre">0.0005)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ElasticNet'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#SparseFascicleModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel.design_matrix" title="dipy.reconst.sfm.SparseFascicleModel.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>()</p></td>
<td><p>The design matrix for a SFM.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel.fit" title="dipy.reconst.sfm.SparseFascicleModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask, num_processes, ...])</p></td>
<td><p>Fit the SparseFascicleModel object to data.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleModel.design_matrix">
<span class="sig-name descname"><span class="pre">design_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#SparseFascicleModel.design_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.design_matrix" title="Link to this definition">#</a></dt>
<dd><p>The design matrix for a SFM.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray</dt><dd><p>The design matrix, where each column is a rotated version of the
response function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel_backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'multiprocessing'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#SparseFascicleModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the SparseFascicleModel object to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>The measured signal.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed. Has the shape <cite>data.shape[:-1]</cite>. Default: None,
which implies that all points should be analyzed.</p>
</dd>
<dt><strong>num_processes</strong><span class="classifier">int, optional</span></dt><dd><p>Split the <cite>fit</cite> calculation to a pool of children processes using
joblib. This only applies to 4D <cite>data</cite> arrays. Default is 1,
which does not require joblib and will run <cite>fit</cite> serially.
If &lt; 0 the maximal number of cores minus <code class="docutils literal notranslate"><span class="pre">num_processes</span> <span class="pre">+</span> <span class="pre">1</span></code>
is used (enter -1 to use as many cores as possible).
0 raises an error.</p>
</dd>
<dt><strong>parallel_backend: str, ParallelBackendBase instance or None</strong></dt><dd><p>Specify the parallelization backend implementation.
Supported backends are:</p>
<ul class="simple">
<li><p>“loky” used by default, can induce some
communication and memory overhead when exchanging input and
output data with the worker Python processes.</p></li>
<li><p>“multiprocessing” previous process-based backend based on
<cite>multiprocessing.Pool</cite>. Less robust than <cite>loky</cite>.</p></li>
<li><p>“threading” is a very low-overhead backend but it suffers
from the Python Global Interpreter Lock if the called function
relies a lot on Python objects. “threading” is mostly useful
when the execution bottleneck is a compiled extension that
explicitly releases the GIL (for instance a Cython loop wrapped
in a “with nogil” block or an expensive call to a library such
as NumPy).</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>SparseFascicleFit object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="sparsefasciclefit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit" title="dipy.reconst.sfm.SparseFascicleFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a><a class="headerlink" href="#sparsefasciclefit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">SparseFascicleFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iso</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#SparseFascicleFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit.odf" title="dipy.reconst.sfm.SparseFascicleFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</p></td>
<td><p>The orientation distribution function of the SFM</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit.predict" title="dipy.reconst.sfm.SparseFascicleFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(*[, gtab, response, S0])</p></td>
<td><p>Predict the signal based on the SFM parameters</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#SparseFascicleFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.odf" title="Link to this definition">#</a></dt>
<dd><p>The orientation distribution function of the SFM</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>The points in which the ODF is evaluated</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>odf</strong><span class="classifier">ndarray of shape (x, y, z, sphere.vertices.shape[0])</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#SparseFascicleFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict the signal based on the SFM parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable, optional</span></dt><dd><p>The bvecs/bvals to predict the signal on. Default: the gtab from
the model object.</p>
</dd>
<dt><strong>response</strong><span class="classifier">list of 3 elements, optional</span></dt><dd><p>The eigenvalues of a tensor which will serve as a kernel
function. Default: the response of the model object. Default to use
<cite>model.response</cite>.</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float or array, optional</span></dt><dd><p>The non-diffusion-weighted signal. Default: use the S0 of the data</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pred_sig</strong><span class="classifier">ndarray</span></dt><dd><p>The signal predicted in each voxel/direction</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="sfm-design-matrix">
<h3>sfm_design_matrix<a class="headerlink" href="#sfm-design-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.sfm.sfm_design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">sfm_design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'signal'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/sfm.html#sfm_design_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.sfm.sfm_design_matrix" title="Link to this definition">#</a></dt>
<dd><p>Construct the SFM design matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable or Sphere</span></dt><dd><p>Sets the rows of the matrix, if the mode is ‘signal’, this should be a
GradientTable. If mode is ‘odf’ this should be a Sphere.</p>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>Sets the columns of the matrix</p>
</dd>
<dt><strong>response</strong><span class="classifier">list of 3 elements</span></dt><dd><p>The eigenvalues of a tensor which will serve as a kernel
function.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {‘signal’ | ‘odf’}, optional</span></dt><dd><p>Choose the (default) ‘signal’ for a design matrix containing predicted
signal in the measurements defined by the gradient table for putative
fascicles oriented along the vertices of the sphere. Otherwise, choose
‘odf’ for an odf convolution matrix, with values of the odf calculated
from a tensor with the provided response eigenvalues, evaluated at the
b-vectors in the gradient table, for the tensors with principal
diffusion directions along the vertices of the sphere.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mat</strong><span class="classifier">ndarray</span></dt><dd><p>A design matrix that can be used for one of the following operations:
when the ‘signal’ mode is used, each column contains the putative
signal in each of the bvectors of the <cite>gtab</cite> if a fascicle is oriented
in the direction encoded by the sphere vertex corresponding to this
column. This is used for deconvolution with a measured DWI signal. If
the ‘odf’ mode is chosen, each column instead contains the values of
the tensor ODF for a tensor with a principal diffusion direction
corresponding to this vertex. This is used to generate odfs from the
fits of the SFM for the purpose of tracking.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dipy.data</span> <span class="k">as</span> <span class="nn">dpd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">gtab</span> <span class="o">=</span> <span class="n">dpd</span><span class="o">.</span><span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">dpd</span><span class="o">.</span><span class="n">get_sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.sfm</span> <span class="kn">import</span> <span class="n">sfm_design_matrix</span>
</pre></div>
</div>
<p>A canonical tensor approximating corpus-callosum voxels
:footcite:p`Rokem2014`:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor_matrix</span> <span class="o">=</span> <span class="n">sfm_design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="p">[</span><span class="mf">0.0015</span><span class="p">,</span> <span class="mf">0.0005</span><span class="p">,</span> <span class="mf">0.0005</span><span class="p">])</span>
</pre></div>
</div>
<p>A ‘stick’ function :footcite:p`Behrens2007`:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stick_matrix</span> <span class="o">=</span> <span class="n">sfm_design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="sphharmmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a><a class="headerlink" href="#sphharmmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">SphHarmModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#SphHarmModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>To be subclassed by all models that return a SphHarmFit when fit.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data)</p></td>
<td><p>To be implemented by specific odf models</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel.sampling_matrix" title="dipy.reconst.shm.SphHarmModel.sampling_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code></a>(sphere)</p></td>
<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmModel.sampling_matrix">
<span class="sig-name descname"><span class="pre">sampling_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#SphHarmModel.sampling_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel.sampling_matrix" title="Link to this definition">#</a></dt>
<dd><p>The matrix needed to sample ODFs from coefficients of the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>Points used to sample ODF.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sampling_matrix</strong><span class="classifier">array</span></dt><dd><p>The size of the matrix will be (N, M) where N is the number of
vertices on sphere and M is the number of coefficients needed by
the model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="qballbasemodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a><a class="headerlink" href="#qballbasemodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.QballBaseModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">QballBaseModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#QballBaseModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></p>
<p>To be subclassed by Qball type models.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel.fit" title="dipy.reconst.shm.QballBaseModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fits the model to diffusion data and returns the model fit</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</p></td>
<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.QballBaseModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#QballBaseModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fits the model to diffusion data and returns the model fit</p>
</dd></dl>

</dd></dl>

</section>
<section id="sphharmfit">
<h3><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a><a class="headerlink" href="#sphharmfit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">SphHarmFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shm_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#SphHarmFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<p>Diffusion data fit to a spherical harmonic model</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong></dt><dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit.shm_coeff" title="dipy.reconst.shm.SphHarmFit.shm_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm_coeff</span></code></a></dt><dd><p>The spherical harmonic coefficients of the odf</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit.odf" title="dipy.reconst.shm.SphHarmFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</p></td>
<td><p>Samples the odf function on the points of a sphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit.predict" title="dipy.reconst.shm.SphHarmFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(*[, gtab, S0])</p></td>
<td><p>Predict the diffusion signal from the model coefficients.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>gfa</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.gfa">
<span class="sig-name descname"><span class="pre">gfa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#SphHarmFit.gfa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.gfa" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#SphHarmFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.odf" title="Link to this definition">#</a></dt>
<dd><p>Samples the odf function on the points of a sphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>The points on which to sample the odf.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>values</strong><span class="classifier">ndarray</span></dt><dd><p>The value of the odf on each point of <cite>sphere</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#SphHarmFit.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict the diffusion signal from the model coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">a GradientTable class instance</span></dt><dd><p>The directions and bvalues on which prediction is desired</p>
</dd>
<dt><strong>S0</strong><span class="classifier">float array</span></dt><dd><p>The mean non-diffusion-weighted signal in each voxel.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.shape" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.shm_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shm_coeff</span></span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.shm_coeff" title="Link to this definition">#</a></dt>
<dd><p>The spherical harmonic coefficients of the odf</p>
<p>Make this a property for now, if there is a use case for modifying
the coefficients we can add a setter or expose the coefficients more
directly</p>
</dd></dl>

</dd></dl>

</section>
<section id="csaodfmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.CsaOdfModel" title="dipy.reconst.shm.CsaOdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a><a class="headerlink" href="#csaodfmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.CsaOdfModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">CsaOdfModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#CsaOdfModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a></p>
<p>Implementation of Constant Solid Angle reconstruction method.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-aganj2009" id="id361" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data, *[, mask])</p></td>
<td><p>Fits the model to diffusion data and returns the model fit</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</p></td>
<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">References</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="dipy.reconst.shm.CsaOdfModel.max">
<span class="sig-name descname"><span class="pre">max</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0.999</span></em><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.max" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="dipy.reconst.shm.CsaOdfModel.min">
<span class="sig-name descname"><span class="pre">min</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0.001</span></em><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.min" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="opdtmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.OpdtModel" title="dipy.reconst.shm.OpdtModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpdtModel</span></code></a><a class="headerlink" href="#opdtmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.OpdtModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">OpdtModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#OpdtModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.OpdtModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a></p>
<p>Implementation of Orientation Probability Density Transform
reconstruction method.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-tristanvega2009a" id="id362" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-tristanvega2010" id="id363" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> for
further details about the method.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data, *[, mask])</p></td>
<td><p>Fits the model to diffusion data and returns the model fit</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</p></td>
<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="qballmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.QballModel" title="dipy.reconst.shm.QballModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballModel</span></code></a><a class="headerlink" href="#qballmodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.QballModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">QballModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#QballModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.QballModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a></p>
<p>Implementation of regularized Qball reconstruction method.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id364" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data, *[, mask])</p></td>
<td><p>Fits the model to diffusion data and returns the model fit</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</p></td>
<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="residualbootstrapwrapper">
<h3><a class="reference internal" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="dipy.reconst.shm.ResidualBootstrapWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a><a class="headerlink" href="#residualbootstrapwrapper" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.ResidualBootstrapWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">ResidualBootstrapWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where_dwi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#ResidualBootstrapWrapper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Returns a residual bootstrap sample of the signal_object when indexed</p>
<p>Wraps a signal_object, this signal object can be an interpolator. When
indexed, the wrapper indexes the signal_object to get the signal.
There wrapper than samples the residual bootstrap distribution of signal and
returns that sample.</p>
</dd></dl>

</section>
<section id="forward-sdeconv-mat">
<h3>forward_sdeconv_mat<a class="headerlink" href="#forward-sdeconv-mat" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.forward_sdeconv_mat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">forward_sdeconv_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_rh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_values</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#forward_sdeconv_mat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.forward_sdeconv_mat" title="Link to this definition">#</a></dt>
<dd><p>Build forward spherical deconvolution matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>r_rh</strong><span class="classifier">ndarray</span></dt><dd><p>Rotational harmonics coefficients for the single fiber response
function. Each element <code class="docutils literal notranslate"><span class="pre">rh[i]</span></code> is associated with spherical harmonics
of order <code class="docutils literal notranslate"><span class="pre">2*i</span></code>.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">ndarray</span></dt><dd><p>The orders (<span class="math notranslate nohighlight">\(l\)</span>) of spherical harmonic function associated with each row
of the deconvolution matrix. Only even orders are allowed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">ndarray (N, N)</span></dt><dd><p>Deconvolution matrix with shape (N, N)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="sh-to-rh">
<h3>sh_to_rh<a class="headerlink" href="#sh-to-rh" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sh_to_rh">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sh_to_rh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_sh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_values</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#sh_to_rh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.sh_to_rh" title="Link to this definition">#</a></dt>
<dd><p>Spherical harmonics (SH) to rotational harmonics (RH)</p>
<p>Calculate the rotational harmonic decomposition up to
harmonic phase factor <code class="docutils literal notranslate"><span class="pre">m</span></code>, order <code class="docutils literal notranslate"><span class="pre">l</span></code> for an axially and antipodally
symmetric function. Note that all <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">!=</span> <span class="pre">0</span></code> coefficients
will be ignored as axial symmetry is assumed. Hence, there
will be <code class="docutils literal notranslate"><span class="pre">(sh_order/2</span> <span class="pre">+</span> <span class="pre">1)</span></code> non-zero coefficients.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id365" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>r_sh</strong><span class="classifier">ndarray (N,)</span></dt><dd><p>ndarray of SH coefficients for the single fiber response function.
These coefficients must correspond to the real spherical harmonic
functions produced by <cite>shm.real_sh_descoteaux_from_index</cite>.</p>
</dd>
<dt><strong>m_values</strong><span class="classifier">ndarray (N,)</span></dt><dd><p>The phase factors (<span class="math notranslate nohighlight">\(m\)</span>) of the spherical harmonic function associated with
each coefficient.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">ndarray (N,)</span></dt><dd><p>The orders (<span class="math notranslate nohighlight">\(l\)</span>) of the spherical harmonic function associated with each
coefficient.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>r_rh</strong><span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt><dd><p>Rotational harmonics coefficients representing the input <cite>r_sh</cite></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sh_descoteaux_from_index</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sh_descoteaux</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="gen-dirac">
<h3>gen_dirac<a class="headerlink" href="#gen-dirac" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.gen_dirac">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">gen_dirac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#gen_dirac"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.gen_dirac" title="Link to this definition">#</a></dt>
<dd><p>Generate Dirac delta function orientated in (theta, phi) on the sphere</p>
<p>The spherical harmonics (SH) representation of this Dirac is returned as
coefficients to spherical harmonic functions produced from <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>
basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>m_values</strong><span class="classifier">ndarray (N,)</span></dt><dd><p>The phase factors of the spherical harmonic function associated with
each coefficient.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">ndarray (N,)</span></dt><dd><p>The order (<span class="math notranslate nohighlight">\(l\)</span>) of the spherical harmonic function associated with each
coefficient.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>legacy: bool, optional</strong></dt><dd><p>If true, uses DIPY’s legacy descoteaux07 implementation (where <span class="math notranslate nohighlight">\(|m|\)</span>
is used for m &lt; 0). Else, implements the basis as defined in
Descoteaux et al. 2007 (without the absolute value).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dirac</strong><span class="classifier">ndarray</span></dt><dd><p>SH coefficients representing the Dirac function. The shape of this is
<cite>(m + 2) * (m + 1) / 2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sh_descoteaux_from_index</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sh_descoteaux</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

</section>
<section id="spherical-harmonics">
<h3>spherical_harmonics<a class="headerlink" href="#spherical-harmonics" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.spherical_harmonics">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">spherical_harmonics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_scipy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#spherical_harmonics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.spherical_harmonics" title="Link to this definition">#</a></dt>
<dd><p>Compute spherical harmonics.</p>
<p>This may take scalar or array arguments. The inputs will be broadcast
against each other.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>m_values</strong><span class="classifier">array of int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">l</span></code></span></dt><dd><p>The phase factors (<span class="math notranslate nohighlight">\(m\)</span>) of the harmonics.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">array of int <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt><dd><p>The orders (<span class="math notranslate nohighlight">\(l\)</span>) of the harmonics.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
<dt><strong>use_scipy</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, use scipy implementation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_mn</strong><span class="classifier">complex float</span></dt><dd><p>The harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a faster implementation of scipy.special.sph_harm for
scipy version &lt; 0.15.0. For scipy 0.15 and onwards, we use the scipy
implementation of the function.</p>
<p>The usual definitions for <code class="docutils literal notranslate"><span class="pre">theta`</span> <span class="pre">and</span> <span class="pre">`phi</span></code> used in DIPY are interchanged
in the method definition to agree with the definitions in
scipy.special.sph_harm, where <cite>theta</cite> represents the azimuthal coordinate
and <cite>phi</cite> represents the polar coordinate.</p>
<p>Although scipy uses a naming convention where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the order and <code class="docutils literal notranslate"><span class="pre">n</span></code>
is the degree of the SH, the opposite of DIPY’s, their definition for
both parameters is the same as ours, with <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">l</span></code>.</p>
</dd></dl>

</section>
<section id="real-sph-harm">
<h3>real_sph_harm<a class="headerlink" href="#real-sph-harm" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sph_harm">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sph_harm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#real_sph_harm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.real_sph_harm" title="Link to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>dipy.reconst.shm.real_sph_harm is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux_from_index instead</p>
<ul class="simple">
<li><p>deprecated from version: 1.3</p></li>
<li><p>Will raise &lt;class ‘dipy.utils.deprecator.ExpiredDeprecationError’&gt; as of version: 2.0</p></li>
</ul>
<p>Where the real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> is defined to be:</p>
<div class="math notranslate nohighlight">
 Y_l^m =
 \begin{cases}
     \sqrt{2} * \Im(Y_l^m) \; if m &gt; 0 \\
     Y^0_l \; if m = 0 \\
     \sqrt{2} * \Re(Y_l^{|m|}) \; if m &lt; 0 \\
 \end{cases}</div><p>This may take scalar or array arguments. The inputs will be broadcast
against each other.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>m_values</strong><span class="classifier">array of int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">l</span></code></span></dt><dd><p>The phase factors (<span class="math notranslate nohighlight">\(m\)</span>) of the harmonics.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">array of int <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt><dd><p>The orders (<span class="math notranslate nohighlight">\(l\)</span>) of the harmonics.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_mn</strong><span class="classifier">real float</span></dt><dd><p>The real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.special.sph_harm</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

</section>
<section id="real-sh-tournier-from-index">
<h3>real_sh_tournier_from_index<a class="headerlink" href="#real-sh-tournier-from-index" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sh_tournier_from_index">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sh_tournier_from_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#real_sh_tournier_from_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.real_sh_tournier_from_index" title="Link to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>The SH are computed as initially defined in <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id366" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> then
updated in MRtrix3 <a class="footnote-reference brackets" href="#footcite-tournier2019" id="id367" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a>, where the real harmonic
<span class="math notranslate nohighlight">\(Y_l^m\)</span> is defined to be:</p>
<div class="math notranslate nohighlight">
 Y_l^m =
 \begin{cases}
     \sqrt{2} * \Re(Y_l^m)  \; if m &gt; 0 \\
     Y^0_l \; if m = 0 \\
     \sqrt{2} * \Im(Y_l^{|m|}) \; if m &lt; 0 \\
 \end{cases}</div><p>This may take scalar or array arguments. The inputs will be broadcast
against each other.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>m_values</strong><span class="classifier">array of int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">l</span></code></span></dt><dd><p>The phase factors (<span class="math notranslate nohighlight">\(m\)</span>) of the harmonics.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">array of int <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt><dd><p>The orders (<span class="math notranslate nohighlight">\(l\)</span>) of the harmonics.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>legacy: bool, optional</strong></dt><dd><p>If true, uses MRtrix 0.2 SH basis definition, where the <code class="docutils literal notranslate"><span class="pre">sqrt(2)</span></code>
factor is omitted. Else, uses the MRtrix 3 definition presented above.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>real_sh</strong><span class="classifier">real float</span></dt><dd><p>The real harmonics <span class="math notranslate nohighlight">\(Y_l^m\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id368">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-tournier2019" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id367">1</a>,<a role="doc-backlink" href="#id371">2</a>,<a role="doc-backlink" href="#id382">3</a>,<a role="doc-backlink" href="#id385">4</a>,<a role="doc-backlink" href="#id388">5</a>,<a role="doc-backlink" href="#id394">6</a>,<a role="doc-backlink" href="#id396">7</a>,<a role="doc-backlink" href="#id400">8</a>,<a role="doc-backlink" href="#id402">9</a>,<a role="doc-backlink" href="#id405">10</a>)</span>
<p>Jacques-Donald Tournier, Robert Smith, David Raffelt, Rami Tabbara, Thijs Dhollander, Maximilian Pietsch, Daan Christiaens, Ben Jeurissen, Chun-Hung Yeh, and Alan Connelly. MRtrix3: A fast, flexible and open software framework for medical image processing and visualisation. <em>NeuroImage</em>, 202:116137, November 2019. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2019.116137">https://doi.org/10.1016/j.neuroimage.2019.116137</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2019.116137">doi:10.1016/j.neuroimage.2019.116137</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="real-sh-descoteaux-from-index">
<h3>real_sh_descoteaux_from_index<a class="headerlink" href="#real-sh-descoteaux-from-index" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sh_descoteaux_from_index">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sh_descoteaux_from_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#real_sh_descoteaux_from_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.real_sh_descoteaux_from_index" title="Link to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>The definition adopted here follows <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id369" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>, where the
real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> is defined to be:</p>
<div class="math notranslate nohighlight">
 Y_l^m =
 \begin{cases}
     \sqrt{2} * \Im(Y_l^m) \; if m &gt; 0 \\
     Y^0_l \; if m = 0 \\
     \sqrt{2} * \Re(Y_l^m)  \; if m &lt; 0 \\
 \end{cases}</div><p>This may take scalar or array arguments. The inputs will be broadcast
against each other.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>m_values</strong><span class="classifier">array of int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">l</span></code></span></dt><dd><p>The phase factors (<span class="math notranslate nohighlight">\(m\)</span>) of the harmonics.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">array of int <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt><dd><p>The orders (<span class="math notranslate nohighlight">\(l\)</span>) of the harmonics.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>legacy: bool, optional</strong></dt><dd><p>If true, uses DIPY’s legacy descoteaux07 implementation (where <span class="math notranslate nohighlight">\(|m|\)</span>
is used for m &lt; 0). Else, implements the basis as defined in
Descoteaux et al. 2007 (without the absolute value).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>real_sh</strong><span class="classifier">real float</span></dt><dd><p>The real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="real-sh-tournier">
<h3>real_sh_tournier<a class="headerlink" href="#real-sh-tournier" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sh_tournier">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sh_tournier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#real_sh_tournier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.real_sh_tournier" title="Link to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>The SH are computed as initially defined in <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id370" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> then
updated in MRtrix3 <a class="footnote-reference brackets" href="#footcite-tournier2019" id="id371" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a>, where the real harmonic
<span class="math notranslate nohighlight">\(Y_l^m\)</span> is defined to be:</p>
<div class="math notranslate nohighlight">
 Y_l^m =
 \begin{cases}
     \sqrt{2} * \Re(Y_l^m)  \; if m &gt; 0 \\
     Y^0_l \; if m = 0 \\
     \sqrt{2} * \Im(Y_l^{|m|}) \; if m &lt; 0 \\
 \end{cases}</div><p>This may take scalar or array arguments. The inputs will be broadcast
against each other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_order_max</strong><span class="classifier">int</span></dt><dd><p>The maximum order (<span class="math notranslate nohighlight">\(l\)</span>) of the spherical harmonic basis.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>If true, returns a basis including odd order SH functions as well as
even order SH functions. Else returns only even order SH functions.</p>
</dd>
<dt><strong>legacy: bool, optional</strong></dt><dd><p>If true, uses MRtrix 0.2 SH basis definition, where the <code class="docutils literal notranslate"><span class="pre">sqrt(2)</span></code>
factor is omitted. Else, uses MRtrix 3 definition presented above.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>real_sh</strong><span class="classifier">real float</span></dt><dd><p>The real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.</p>
</dd>
<dt><strong>m_values</strong><span class="classifier">array of int</span></dt><dd><p>The phase factor (<span class="math notranslate nohighlight">\(m\)</span>) of the harmonics.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">array of int</span></dt><dd><p>The order (<span class="math notranslate nohighlight">\(l\)</span>) of the harmonics.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="real-sh-descoteaux">
<h3>real_sh_descoteaux<a class="headerlink" href="#real-sh-descoteaux" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sh_descoteaux">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sh_descoteaux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#real_sh_descoteaux"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.real_sh_descoteaux" title="Link to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>The definition adopted here follows <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id372" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>, where the
real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> is defined to be:</p>
<div class="math notranslate nohighlight">
 Y_l^m =
 \begin{cases}
     \sqrt{2} * \Im(Y_l^m) \; if m &gt; 0 \\
     Y^0_l \; if m = 0 \\
     \sqrt{2} * \Re(Y_l^m)  \; if m &lt; 0 \\
 \end{cases}</div><p>This may take scalar or array arguments. The inputs will be broadcast
against each other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_order_max</strong><span class="classifier">int</span></dt><dd><p>The maximum order (<span class="math notranslate nohighlight">\(l\)</span>) of the spherical harmonic basis.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>If true, returns a basis including odd order SH functions as well as
even order SH functions. Otherwise returns only even order SH
functions.</p>
</dd>
<dt><strong>legacy: bool, optional</strong></dt><dd><p>If true, uses DIPY’s legacy descoteaux07 implementation (where <span class="math notranslate nohighlight">\(|m|\)</span>
for m &lt; 0). Else, implements the basis as defined in Descoteaux et al.
2007.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>real_sh</strong><span class="classifier">real float</span></dt><dd><p>The real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.</p>
</dd>
<dt><strong>m_values</strong><span class="classifier">array of int</span></dt><dd><p>The phase factor (<span class="math notranslate nohighlight">\(m\)</span>) of the harmonics.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">array of int</span></dt><dd><p>The order (<span class="math notranslate nohighlight">\(l\)</span>) of the harmonics.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="real-sym-sh-mrtrix">
<h3>real_sym_sh_mrtrix<a class="headerlink" href="#real-sym-sh-mrtrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sym_sh_mrtrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sym_sh_mrtrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#real_sym_sh_mrtrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.real_sym_sh_mrtrix" title="Link to this definition">#</a></dt>
<dd><p>dipy.reconst.shm.real_sym_sh_mrtrix is deprecated, Please use dipy.reconst.shm.real_sh_tournier instead</p>
<ul class="simple">
<li><p>deprecated from version: 1.3</p></li>
<li><p>Will raise &lt;class ‘dipy.utils.deprecator.ExpiredDeprecationError’&gt; as of version: 2.0</p></li>
</ul>
<p>Compute real symmetric spherical harmonics.</p>
<p>The SH are computed as initially defined in Tournier <em>et al.</em><a class="footnote-reference brackets" href="#footcite-tournier2007" id="id373" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>,
where the real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> is defined to be:</p>
<div class="math notranslate nohighlight">
 Y_l^m =
 \begin{cases}
     \Re(Y_l^m) \; if m &gt; 0 \\
     Y^0_l \; if m = 0 \\
     \Im(Y_l^{|m|}) \; if m &lt; 0 \\
 \end{cases}</div><p>This may take scalar or array arguments. The inputs will be broadcast
against each other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_order_max</strong><span class="classifier">int</span></dt><dd><p>The maximum order (<span class="math notranslate nohighlight">\(l\)</span>) of the spherical harmonic basis.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_mn</strong><span class="classifier">real float</span></dt><dd><p>The real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code> as
implemented in mrtrix. Warning: the basis is Tournier <em>et al.</em><a class="footnote-reference brackets" href="#footcite-tournier2007" id="id374" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>;
<a class="footnote-reference brackets" href="#footcite-tournier2004" id="id375" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a> is slightly different.</p>
</dd>
<dt><strong>m_values</strong><span class="classifier">array</span></dt><dd><p>The phase factor (<span class="math notranslate nohighlight">\(m\)</span>) of the harmonics.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">array</span></dt><dd><p>The order (<span class="math notranslate nohighlight">\(l\)</span>) of the harmonics.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="real-sym-sh-basis">
<h3>real_sym_sh_basis<a class="headerlink" href="#real-sym-sh-basis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sym_sh_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sym_sh_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#real_sym_sh_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.real_sym_sh_basis" title="Link to this definition">#</a></dt>
<dd><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p>
<p>dipy.reconst.shm.real_sym_sh_basis is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux instead</p>
<ul class="simple">
<li><p>deprecated from version: 1.3</p></li>
<li><p>Will raise &lt;class ‘dipy.utils.deprecator.ExpiredDeprecationError’&gt; as of version: 2.0</p></li>
</ul>
<p>Samples the basis functions up to order <cite>sh_order_max</cite> at points on the
sphere given by <cite>theta</cite> and <cite>phi</cite>. The basis functions are defined here the
same way as in <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id376" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> where the real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span>
is defined to be:</p>
<div class="math notranslate nohighlight">
 Y_l^m =
 \begin{cases}
     \sqrt{2} * \Im(Y_l^m) \; if m &gt; 0 \\
     Y^0_l \; if m = 0 \\
     \sqrt{2} * \Im(Y_l^{|m|}) \; if m &lt; 0 \\
 \end{cases}</div><p>This may take scalar or array arguments. The inputs will be broadcast
against each other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_order_max</strong><span class="classifier">int</span></dt><dd><p>The maximum order (<span class="math notranslate nohighlight">\(l\)</span>) of the spherical harmonic basis. Even int &gt; 0,
max spherical harmonic order</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_mn</strong><span class="classifier">real float</span></dt><dd><p>The real harmonic <span class="math notranslate nohighlight">\(Y_l^m\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code></p>
</dd>
<dt><strong>m_values</strong><span class="classifier">array of int</span></dt><dd><p>The phase factor (<span class="math notranslate nohighlight">\(m\)</span>) of the harmonics.</p>
</dd>
<dt><strong>l_values</strong><span class="classifier">array of int</span></dt><dd><p>The order (<span class="math notranslate nohighlight">\(l\)</span>) of the harmonics.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="sph-harm-ind-list">
<h3>sph_harm_ind_list<a class="headerlink" href="#sph-harm-ind-list" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sph_harm_ind_list">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sph_harm_ind_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#sph_harm_ind_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.sph_harm_ind_list" title="Link to this definition">#</a></dt>
<dd><p>Returns the order (<code class="docutils literal notranslate"><span class="pre">l</span></code>) and phase_factor (<code class="docutils literal notranslate"><span class="pre">m</span></code>) of all the symmetric
spherical harmonics of order less then or equal to <code class="docutils literal notranslate"><span class="pre">sh_order_max</span></code>.
The results, <code class="docutils literal notranslate"><span class="pre">m_list</span></code> and <code class="docutils literal notranslate"><span class="pre">l_list</span></code> are kx1 arrays, where k depends on
<code class="docutils literal notranslate"><span class="pre">sh_order_max</span></code>.
They can be passed to <a class="reference internal" href="#dipy.reconst.shm.real_sh_descoteaux_from_index" title="dipy.reconst.shm.real_sh_descoteaux_from_index"><code class="xref py py-func docutils literal notranslate"><span class="pre">real_sh_descoteaux_from_index()</span></code></a> and
:func:<code class="docutils literal notranslate"><span class="pre">real_sh_tournier_from_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_order_max</strong><span class="classifier">int</span></dt><dd><p>The maximum order (<span class="math notranslate nohighlight">\(l\)</span>) of the spherical harmonic basis.
Even int &gt; 0, max order to return</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True for SH basis with even and odd order terms</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>m_list</strong><span class="classifier">array of int</span></dt><dd><p>phase factors (<span class="math notranslate nohighlight">\(m\)</span>) of even spherical harmonics</p>
</dd>
<dt><strong>l_list</strong><span class="classifier">array of int</span></dt><dd><p>orders (<span class="math notranslate nohighlight">\(l\)</span>) of even spherical harmonics</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sh_descoteaux_from_index</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sh_tournier_from_index</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

</section>
<section id="order-from-ncoef">
<h3>order_from_ncoef<a class="headerlink" href="#order-from-ncoef" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.order_from_ncoef">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">order_from_ncoef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ncoef</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#order_from_ncoef"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.order_from_ncoef" title="Link to this definition">#</a></dt>
<dd><p>Given a number <code class="docutils literal notranslate"><span class="pre">n</span></code> of coefficients, calculate back the <code class="docutils literal notranslate"><span class="pre">sh_order_max</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ncoef: int</strong></dt><dd><p>number of coefficients</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True when coefficients are for a full SH basis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>sh_order_max: int</dt><dd><p>maximum order (<span class="math notranslate nohighlight">\(l\)</span>) of SH basis</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="smooth-pinv">
<h3>smooth_pinv<a class="headerlink" href="#smooth-pinv" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.smooth_pinv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">smooth_pinv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#smooth_pinv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.smooth_pinv" title="Link to this definition">#</a></dt>
<dd><p>Regularized pseudo-inverse</p>
<p>Computes a regularized least square inverse of B</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>B</strong><span class="classifier">array_like (n, m)</span></dt><dd><p>Matrix to be inverted</p>
</dd>
<dt><strong>L</strong><span class="classifier">array_like (m,)</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inv</strong><span class="classifier">ndarray (m, n)</span></dt><dd><p>regularized least square inverse of B</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In the literature this inverse is often written <span class="math notranslate nohighlight">\((B^{T}B+L^{2})^{-1}B^{T}\)</span>.
However here this inverse is implemented using the pseudo-inverse because
it is more numerically stable than the direct implementation of the matrix
product.</p>
</dd></dl>

</section>
<section id="lazy-index">
<h3>lazy_index<a class="headerlink" href="#lazy-index" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.lazy_index">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">lazy_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#lazy_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.lazy_index" title="Link to this definition">#</a></dt>
<dd><p>Produces a lazy index</p>
<p>Returns a slice that can be used for indexing an array, if no slice can be
made index is returned as is.</p>
</dd></dl>

</section>
<section id="normalize-data">
<h3>normalize_data<a class="headerlink" href="#normalize-data" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.normalize_data">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">normalize_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where_b0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#normalize_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.normalize_data" title="Link to this definition">#</a></dt>
<dd><p>Normalizes the data with respect to the mean b0</p>
</dd></dl>

</section>
<section id="hat">
<h3>hat<a class="headerlink" href="#hat" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.hat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">hat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#hat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.hat" title="Link to this definition">#</a></dt>
<dd><p>Returns the hat matrix for the design matrix B</p>
</dd></dl>

</section>
<section id="lcr-matrix">
<h3>lcr_matrix<a class="headerlink" href="#lcr-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.lcr_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">lcr_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#lcr_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.lcr_matrix" title="Link to this definition">#</a></dt>
<dd><p>Returns a matrix for computing leveraged, centered residuals from data</p>
<p>if r = (d-Hd), the leveraged centered residuals are lcr = (r/l)-mean(r/l)
returns the matrix R, such that lcr = Rd</p>
</dd></dl>

</section>
<section id="bootstrap-data-array">
<h3>bootstrap_data_array<a class="headerlink" href="#bootstrap-data-array" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.bootstrap_data_array">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">bootstrap_data_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#bootstrap_data_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.bootstrap_data_array" title="Link to this definition">#</a></dt>
<dd><p>Applies the Residual Bootstraps to the data given H and R</p>
<p>data must be normalized, ie 0 &lt; data &lt;= 1</p>
<p>This function, and the bootstrap_data_voxel function, calculate
residual-bootstrap samples given a Hat matrix and a Residual matrix. These
samples can be used for non-parametric statistics or for bootstrap
probabilistic tractography,</p>
<p>See <a class="footnote-reference brackets" href="#footcite-berman2008" id="id377" role="doc-noteref"><span class="fn-bracket">[</span>71<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#footcite-haroon2009" id="id378" role="doc-noteref"><span class="fn-bracket">[</span>72<span class="fn-bracket">]</span></a>, and
<a class="footnote-reference brackets" href="#footcite-jeurissen2011" id="id379" role="doc-noteref"><span class="fn-bracket">[</span>73<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id380">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-berman2008" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id377">71</a><span class="fn-bracket">]</span></span>
<p>Jeffrey I. Berman, SungWon Chung, Pratik Mukherjee, Christopher P. Hess, Eric T. Han, and Roland G. Henry. Probabilistic streamline q-ball tractography using the residual bootstrap. <em>NeuroImage</em>, 39(1):215–222, 2008. URL: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2007.08.021">https://doi.org/10.1016/j.neuroimage.2007.08.021</a>, <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2007.08.021">doi:10.1016/j.neuroimage.2007.08.021</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-haroon2009" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id378">72</a><span class="fn-bracket">]</span></span>
<p>Hamied A. Haroon, David M. Morris, Karl V. Embleton, Daniel C. Alexander, and Geoffrey J. M. Parker. Using the Model-Based Residual Bootstrap to Quantify Uncertainty in Fiber Orientations From $Q$-Ball Analysis. <em>IEEE Transactions on Medical Imaging</em>, 28(4):535–550, 2009. <a class="reference external" href="https://doi.org/10.1109/TMI.2008.2006528">doi:10.1109/TMI.2008.2006528</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-jeurissen2011" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id379">73</a><span class="fn-bracket">]</span></span>
<p>Ben Jeurissen, Alexander Leemans, Derek K. Jones, Jacques-Donald Tournier, and Jan Sijbers. Probabilistic fiber tracking using the residual bootstrap with constrained spherical deconvolution. <em>Human Brain Mapping</em>, 32(3):461–479, 2011. URL: <a class="reference external" href="https://doi.org/10.1002/hbm.21032">https://doi.org/10.1002/hbm.21032</a>, <a class="reference external" href="https://doi.org/10.1002/hbm.21032">doi:10.1002/hbm.21032</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="bootstrap-data-voxel">
<h3>bootstrap_data_voxel<a class="headerlink" href="#bootstrap-data-voxel" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.bootstrap_data_voxel">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">bootstrap_data_voxel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#bootstrap_data_voxel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.bootstrap_data_voxel" title="Link to this definition">#</a></dt>
<dd><p>Like bootstrap_data_array but faster when for a single voxel</p>
<p>data must be 1d and normalized</p>
</dd></dl>

</section>
<section id="sf-to-sh">
<h3>sf_to_sh<a class="headerlink" href="#sf-to-sh" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sf_to_sh">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sf_to_sh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#sf_to_sh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.sf_to_sh" title="Link to this definition">#</a></dt>
<dd><p>Spherical function to spherical harmonics (SH).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sf</strong><span class="classifier">ndarray</span></dt><dd><p>Values of a function on the given <code class="docutils literal notranslate"><span class="pre">sphere</span></code>.</p>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>The points on which the sf is defined.</p>
</dd>
<dt><strong>sh_order_max</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum SH order (l) in the SH fit.  For <code class="docutils literal notranslate"><span class="pre">sh_order_max</span></code>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients for a
symmetric basis and <code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)</span></code>
coefficients for a full SH basis.</p>
</dd>
<dt><strong>basis_type</strong><span class="classifier">{None, ‘tournier07’, ‘descoteaux07’}, optional</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id381" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-tournier2019" id="id382" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a> basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id383" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>
basis,
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True for using a SH basis containing even and odd order SH functions.
False for using a SH basis consisting only of even order SH functions.</p>
</dd>
<dt><strong>legacy: bool, optional</strong></dt><dd><p>True to use a legacy basis definition for backward compatibility
with previous <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> and <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> implementations.</p>
</dd>
<dt><strong>smooth</strong><span class="classifier">float, optional</span></dt><dd><p>Lambda-regularization in the SH fit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sh</strong><span class="classifier">ndarray</span></dt><dd><p>SH coefficients representing the input function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="sh-to-sf">
<h3>sh_to_sf<a class="headerlink" href="#sh-to-sf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sh_to_sf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sh_to_sf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#sh_to_sf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.sh_to_sf" title="Link to this definition">#</a></dt>
<dd><p>Spherical harmonics (SH) to spherical function (SF).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh</strong><span class="classifier">ndarray</span></dt><dd><p>SH coefficients representing a spherical function.</p>
</dd>
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>The points on which to sample the spherical function.</p>
</dd>
<dt><strong>sh_order_max</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum SH order (l) in the SH fit.  For <code class="docutils literal notranslate"><span class="pre">sh_order_max</span></code>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients for a
symmetric basis and <code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)</span></code>
coefficients for a full SH basis.</p>
</dd>
<dt><strong>basis_type</strong><span class="classifier">{None, ‘tournier07’, ‘descoteaux07’}, optional</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id384" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-tournier2019" id="id385" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a> basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id386" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>
basis,
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True to use a SH basis containing even and odd order SH functions.
Else, use a SH basis consisting only of even order SH functions.</p>
</dd>
<dt><strong>legacy: bool, optional</strong></dt><dd><p>True to use a legacy basis definition for backward compatibility
with previous <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> and <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> implementations.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sf</strong><span class="classifier">ndarray</span></dt><dd><p>Spherical function values on the <code class="docutils literal notranslate"><span class="pre">sphere</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="sh-to-sf-matrix">
<h3>sh_to_sf_matrix<a class="headerlink" href="#sh-to-sf-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sh_to_sf_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sh_to_sf_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#sh_to_sf_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.sh_to_sf_matrix" title="Link to this definition">#</a></dt>
<dd><p>Matrix that transforms Spherical harmonics (SH) to spherical
function (SF).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sphere</strong><span class="classifier">Sphere</span></dt><dd><p>The points on which to sample the spherical function.</p>
</dd>
<dt><strong>sh_order_max</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum SH order in the SH fit.  For <code class="docutils literal notranslate"><span class="pre">sh_order_max</span></code>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients for a
symmetric basis and <code class="docutils literal notranslate"><span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_max</span> <span class="pre">+</span> <span class="pre">1)</span></code>
coefficients for a full SH basis.</p>
</dd>
<dt><strong>basis_type</strong><span class="classifier">{None, ‘tournier07’, ‘descoteaux07’}, optional</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id387" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-tournier2019" id="id388" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a> basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id389" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>
basis,
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>If True, uses a SH basis containing even and odd order SH functions.
Else, uses a SH basis consisting only of even order SH functions.</p>
</dd>
<dt><strong>legacy: bool, optional</strong></dt><dd><p>True to use a legacy basis definition for backward compatibility
with previous <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> and <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> implementations.</p>
</dd>
<dt><strong>return_inv</strong><span class="classifier">bool, optional</span></dt><dd><p>If True then the inverse of the matrix is also returned.</p>
</dd>
<dt><strong>smooth</strong><span class="classifier">float, optional</span></dt><dd><p>Lambda-regularization in the SH fit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>B</strong><span class="classifier">ndarray</span></dt><dd><p>Matrix that transforms spherical harmonics to spherical function
<code class="docutils literal notranslate"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></code>.</p>
</dd>
<dt><strong>invB</strong><span class="classifier">ndarray</span></dt><dd><p>Inverse of B.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="calculate-max-order">
<h3>calculate_max_order<a class="headerlink" href="#calculate-max-order" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.calculate_max_order">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">calculate_max_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_coeffs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#calculate_max_order"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.calculate_max_order" title="Link to this definition">#</a></dt>
<dd><p>Calculate the maximal harmonic order (l), given that you know the
number of parameters that were estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_coeffs</strong><span class="classifier">int</span></dt><dd><p>The number of SH coefficients</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True if the used SH basis contains even and odd order SH functions.
False if the SH basis consists only of even order SH functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>L</strong><span class="classifier">int</span></dt><dd><p>The maximal SH order (l), given the number of coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The calculation in this function for the symmetric SH basis
proceeds according to the following logic:</p>
<div class="math notranslate nohighlight">
\[n = \frac{1}{2} (L+1) (L+2)
\rarrow 2n = L^2 + 3L + 2
\rarrow L^2 + 3L + 2 - 2n = 0
\rarrow L^2 + 3L + 2(1-n) = 0
\rarrow L_{1,2} = \frac{-3 \pm \sqrt{9 - 8 (1-n)}}{2}
\rarrow L{1,2} = \frac{-3 \pm \sqrt{1 + 8n}}{2}\]</div>
<p>Finally, the positive value is chosen between the two options.</p>
<p>For a full SH basis, the calculation consists in solving the equation
<span class="math notranslate nohighlight">\(n = (L + 1)^2\)</span> for <span class="math notranslate nohighlight">\(L\)</span>, which gives <span class="math notranslate nohighlight">\(L = sqrt(n) - 1\)</span>.</p>
</dd></dl>

</section>
<section id="anisotropic-power">
<h3>anisotropic_power<a class="headerlink" href="#anisotropic-power" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.anisotropic_power">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">anisotropic_power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeffs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#anisotropic_power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.anisotropic_power" title="Link to this definition">#</a></dt>
<dd><p>Calculate anisotropic power map with a given SH coefficient matrix.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-dellacqua2014" id="id390" role="doc-noteref"><span class="fn-bracket">[</span>74<span class="fn-bracket">]</span></a> for further details about the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_coeffs</strong><span class="classifier">ndarray</span></dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel.</p>
</dd>
<dt><strong>norm_factor: float, optional</strong></dt><dd><p>The value to normalize the ap values.</p>
</dd>
<dt><strong>power</strong><span class="classifier">int, optional</span></dt><dd><p>The degree to which power maps are calculated.</p>
</dd>
<dt><strong>non_negative: bool, optional</strong></dt><dd><p>Whether to rectify the resulting map to be non-negative.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>log_ap</strong><span class="classifier">ndarray</span></dt><dd><p>The log of the resulting power image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Calculate AP image based on a IxJxKxC SH coefficient matrix based on the
equation:</p>
<div class="math notranslate nohighlight">
\[AP = \sum_{l=2,4,6,...}{\frac{1}{2l+1} \sum_{m=-l}^l{|a_{l,m}|^n}}\]</div>
<p>Where the last dimension, C, is made of a flattened array of <span class="math notranslate nohighlight">\(l`x:math:`m\)</span>
coefficients, where <span class="math notranslate nohighlight">\(l\)</span> are the SH orders, and <span class="math notranslate nohighlight">\(m = 2l+1\)</span>,
So l=1 has 1 coefficient, l=2 has 5, … l=8 has 17 and so on.
A l=2 SH coefficient matrix will then be composed of a IxJxKx6 volume.
The power, <span class="math notranslate nohighlight">\(n\)</span> is usually set to <span class="math notranslate nohighlight">\(n=2\)</span>.</p>
<p>The final AP image is then shifted by -log(norm_factor), to be strictly
non-negative. Remaining values &lt; 0 are discarded (set to 0), per default,
and this option is controlled through the <cite>non_negative</cite> keyword argument.</p>
<p class="rubric">References</p>
<div class="docutils container" id="id391">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-dellacqua2014" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id390">74</a><span class="fn-bracket">]</span></span>
<p>Flavio Dell’Acqua, Luis Lacerda, Marco Catani, and Andrew Simmons. Anisotropic Power Maps: A diffusion contrast to reveal low anisotropy tissues from HARDI data. In <em>Joint Annual Meeting ISMRM-ESMRMB 2014 SMRT 23rd Annual Meeting</em>, volume. Milan, Italy, 2014. International Society for Magnetic Resonance in Medicine (ISMRM).</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="convert-sh-to-full-basis">
<h3>convert_sh_to_full_basis<a class="headerlink" href="#convert-sh-to-full-basis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.convert_sh_to_full_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">convert_sh_to_full_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeffs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#convert_sh_to_full_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.convert_sh_to_full_basis" title="Link to this definition">#</a></dt>
<dd><p>Given an array of SH coeffs from a symmetric basis, returns the
coefficients for the full SH basis by filling odd order SH coefficients
with zeros</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_coeffs: ndarray</strong></dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>full_sh_coeffs: ndarray</dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel in
a full SH basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="convert-sh-from-legacy">
<h3>convert_sh_from_legacy<a class="headerlink" href="#convert-sh-from-legacy" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.convert_sh_from_legacy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">convert_sh_from_legacy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_basis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#convert_sh_from_legacy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.convert_sh_from_legacy" title="Link to this definition">#</a></dt>
<dd><p>Convert SH coefficients in legacy SH basis to SH coefficients
of the new SH basis for <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> or <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> bases.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id392" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id393" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-tournier2019" id="id394" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a> for the <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> and <code class="docutils literal notranslate"><span class="pre">tournier07</span></code>
bases, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_coeffs: ndarray</strong></dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel.</p>
</dd>
<dt><strong>sh_basis: {‘descoteaux07’, ‘tournier07’}</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id395" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-tournier2019" id="id396" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a> basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id397" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>
basis.</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True if the input SH basis includes both even and odd
order SH functions, else False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>out_sh_coeffs: ndarray</dt><dd><p>The array of coefficients expressed in the new SH basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="convert-sh-to-legacy">
<h3>convert_sh_to_legacy<a class="headerlink" href="#convert-sh-to-legacy" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.convert_sh_to_legacy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">convert_sh_to_legacy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_basis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#convert_sh_to_legacy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.convert_sh_to_legacy" title="Link to this definition">#</a></dt>
<dd><p>Convert SH coefficients in new SH basis to SH coefficients for
the legacy SH basis for <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> or <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> bases.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id398" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id399" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-tournier2019" id="id400" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a> for the <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> and <code class="docutils literal notranslate"><span class="pre">tournier07</span></code>
bases, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_coeffs: ndarray</strong></dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel.</p>
</dd>
<dt><strong>sh_basis: {‘descoteaux07’, ‘tournier07’}</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="footnote-reference brackets" href="#footcite-tournier2007" id="id401" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-tournier2019" id="id402" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a> basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id403" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>
basis.</p>
</dd>
<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True if the input SH basis includes both even and odd
order SH functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>out_sh_coeffs: ndarray</dt><dd><p>The array of coefficients expressed in the legacy SH basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="convert-sh-descoteaux-tournier">
<h3>convert_sh_descoteaux_tournier<a class="headerlink" href="#convert-sh-descoteaux-tournier" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.convert_sh_descoteaux_tournier">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">convert_sh_descoteaux_tournier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeffs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shm.html#convert_sh_descoteaux_tournier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shm.convert_sh_descoteaux_tournier" title="Link to this definition">#</a></dt>
<dd><p>Convert SH coefficients between legacy-descoteaux07 and tournier07.</p>
<p>Convert SH coefficients between the legacy <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> SH basis and
the non-legacy <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> SH basis. Because this conversion is equal to
its own inverse, it can be used to convert in either direction:
legacy-descoteaux to non-legacy-tournier or non-legacy-tournier to
legacy-descoteaux.</p>
<p>This can be used to convert SH representations between DIPY and MRtrix3.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-descoteaux2007" id="id404" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> and <a class="footnote-reference brackets" href="#footcite-tournier2019" id="id405" role="doc-noteref"><span class="fn-bracket">[</span>70<span class="fn-bracket">]</span></a> for the
origin of these SH bases.</p>
<p>See <a class="reference internal" href="#r6590f9ba5c5e-mrtrixbasis" id="id406">[mrtrixbasis]</a> for a description of the basis used in MRtrix3.
See <a class="reference internal" href="#r6590f9ba5c5e-mrtrixdipybases" id="id407">[mrtrixdipybases]</a> for more details on the conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sh_coeffs: ndarray</strong></dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>out_sh_coeffs: ndarray</dt><dd><p>The array of coefficients expressed in the “other” SH basis. If the
input was in the legacy-descoteaux basis then the output will be in the
non-legacy-tournier basis, and vice versa.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r6590f9ba5c5e-mrtrixbasis" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id406">mrtrixbasis</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://mrtrix.readthedocs.io/en/latest/concepts/spherical_harmonics.html">https://mrtrix.readthedocs.io/en/latest/concepts/spherical_harmonics.html</a></p>
</div>
<div class="citation" id="r6590f9ba5c5e-mrtrixdipybases" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id407">mrtrixdipybases</a><span class="fn-bracket">]</span></span>
<p><a class="github reference external" href="https://github.com/dipy/dipy/discussions/2959#discussioncomment-7481675">dipy/dipy#2959</a></p>
</div>
</div>
</dd></dl>

</section>
<section id="shoremodel">
<h3><a class="reference internal" href="#dipy.reconst.shore.ShoreModel" title="dipy.reconst.shore.ShoreModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreModel</span></code></a><a class="headerlink" href="#shoremodel" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">ShoreModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">700</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.025330295910584444</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constrain_e0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>Simple Harmonic Oscillator based Reconstruction and Estimation
(SHORE) of the diffusion signal.</p>
<p>The main idea of SHORE <a class="footnote-reference brackets" href="#footcite-ozarslan2008" id="id410" role="doc-noteref"><span class="fn-bracket">[</span>75<span class="fn-bracket">]</span></a> is to model the diffusion
signal as a linear combination of continuous functions <span class="math notranslate nohighlight">\(\phi_i\)</span>,</p>
<div class="math notranslate nohighlight">
\[S(\mathbf{q})= \sum_{i=0}^I  c_{i} \phi_{i}(\mathbf{q})\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> is the wave vector which corresponds to different
gradient directions. Numerous continuous functions <span class="math notranslate nohighlight">\(\phi_i\)</span> can be used to
model <span class="math notranslate nohighlight">\(S\)</span>. Some are presented in <a class="footnote-reference brackets" href="#footcite-merlet2013" id="id411" role="doc-noteref"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></a>,
<a class="footnote-reference brackets" href="#footcite-rathi2011" id="id412" role="doc-noteref"><span class="fn-bracket">[</span>77<span class="fn-bracket">]</span></a>, and <a class="footnote-reference brackets" href="#footcite-cheng2011" id="id413" role="doc-noteref"><span class="fn-bracket">[</span>78<span class="fn-bracket">]</span></a>.</p>
<p>From the <span class="math notranslate nohighlight">\(c_i\)</span> coefficients, there exist analytical formulae to estimate
the ODF, the return to the origin probability (RTOP), the mean square
displacement (MSD), amongst others <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id414" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</p></td>
<td><p>Clear the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag, key, *[, default])</p></td>
<td><p>Retrieve a value from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag, key, value)</p></td>
<td><p>Store a value in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreModel.fit" title="dipy.reconst.shore.ShoreModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *[, mask])</p></td>
<td><p>Fit method for every voxel in data</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">Notes</p>
<p>The implementation of SHORE depends on CVXPY (<a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a>).</p>
<p class="rubric">References</p>
<div class="docutils container" id="id415">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-ozarslan2008" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id410">75</a><span class="fn-bracket">]</span></span>
<p>Evren Özarslan, Cheng Guan Koay, and Peter J. Basser. Simple harmonic oscillator based reconstruction and estimation for one-dimensional q-space magnetic resonance (1D-SHORE). In <em>ISMRM 16th Scientific Meeting &amp; Exhibition SMRT 17th Annual Meeting</em>, volume 16, 35. Toronto, Canada, 2008. International Society for Magnetic Resonance in Medicine (ISMRM).</p>
</aside>
<aside class="footnote brackets" id="footcite-merlet2013" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id411">1</a>,<a role="doc-backlink" href="#id420">2</a>,<a role="doc-backlink" href="#id421">3</a>,<a role="doc-backlink" href="#id422">4</a>)</span>
<p>Sylvain L. Merlet and Rachid Deriche. Continuous diffusion signal, EAP and ODF estimation via Compressive Sensing in diffusion MRI. <em>Medical Image Analysis</em>, 17(5):556–572, July 2013. URL: <a class="reference external" href="https://doi.org/10.1016/j.media.2013.02.010">https://doi.org/10.1016/j.media.2013.02.010</a>, <a class="reference external" href="https://doi.org/10.1016/j.media.2013.02.010">doi:10.1016/j.media.2013.02.010</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-rathi2011" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id412">77</a><span class="fn-bracket">]</span></span>
<p>Yogesh Rathi, Oleg Michailovich, Kawin Setsompop, Sylvain Bouix, Martha E. Shenton, and Carl-Fredrik Westin. Sparse Multi-Shell Diffusion Imaging. In Gabor Fichtinger, Anne Martel, and Terry Peters, editors, <em>Medical Image Computing and Computer-Assisted Intervention – MICCAI 2011</em>, 58–65. Berlin, Heidelberg, 2011. Springer Berlin Heidelberg.</p>
</aside>
<aside class="footnote brackets" id="footcite-cheng2011" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id413">78</a><span class="fn-bracket">]</span></span>
<p>Jian Cheng, Tianzi Jiang, and Rachid Deriche. Theoretical Analysis and Practical Insights on EAP Estimation via a Unified HARDI Framework. In <em>MICCAI Workshop on Computational Diffusion MRI (CDMRI)</em>. Toronto, Canada, September 2011.</p>
</aside>
</aside>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreModel.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="shorefit">
<h3><a class="reference internal" href="#dipy.reconst.shore.ShoreFit" title="dipy.reconst.shore.ShoreFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreFit</span></code></a><a class="headerlink" href="#shorefit" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">ShoreFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shore_coef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreFit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreFit" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.shore_coeff" title="dipy.reconst.shore.ShoreFit.shore_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_coeff</span></code></a></dt><dd><p>The SHORE coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.fitted_signal" title="dipy.reconst.shore.ShoreFit.fitted_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fitted_signal</span></code></a>()</p></td>
<td><p>The fitted signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.msd" title="dipy.reconst.shore.ShoreFit.msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd</span></code></a>()</p></td>
<td><p>Calculates the analytical mean squared displacement (MSD).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.odf" title="dipy.reconst.shore.ShoreFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</p></td>
<td><p>Calculates the ODF for a given discrete sphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.odf_sh" title="dipy.reconst.shore.ShoreFit.odf_sh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sh</span></code></a>()</p></td>
<td><p>Calculates the real analytical ODF in terms of Spherical Harmonics.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.pdf" title="dipy.reconst.shore.ShoreFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>(r_points)</p></td>
<td><p>Diffusion propagator on a given set of real points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.pdf_grid" title="dipy.reconst.shore.ShoreFit.pdf_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf_grid</span></code></a>(gridsize, radius_max)</p></td>
<td><p>Applies the analytical FFT on <span class="math notranslate nohighlight">\(S\)</span> to generate the diffusion propagator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.rtop_pdf" title="dipy.reconst.shore.ShoreFit.rtop_pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_pdf</span></code></a>()</p></td>
<td><p>Calculates the analytical return to origin probability (RTOP) from the pdf.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.rtop_signal" title="dipy.reconst.shore.ShoreFit.rtop_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_signal</span></code></a>()</p></td>
<td><p>Calculates the analytical return to origin probability (RTOP) from the signal.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.fitted_signal">
<span class="sig-name descname"><span class="pre">fitted_signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreFit.fitted_signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.fitted_signal" title="Link to this definition">#</a></dt>
<dd><p>The fitted signal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.msd">
<span class="sig-name descname"><span class="pre">msd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreFit.msd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.msd" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical mean squared displacement (MSD).</p>
<p>See <a class="footnote-reference brackets" href="#footcite-wu2007" id="id416" role="doc-noteref"><span class="fn-bracket">[</span>32<span class="fn-bracket">]</span></a> for a definition of the method.</p>
<div class="math notranslate nohighlight">
 MSD:{DSI}=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}
 \int_{-\infty}^{\infty} P(\hat{\mathbf{r}}) \cdot
 \hat{\mathbf{r}}^{2} \ dr_x \ dr_y \ dr_z</div><p>where <span class="math notranslate nohighlight">\(\hat{\mathbf{r}}\)</span> is a point in the 3D propagator space (see
Wu and Alexander<a class="footnote-reference brackets" href="#footcite-wu2007" id="id417" role="doc-noteref"><span class="fn-bracket">[</span>32<span class="fn-bracket">]</span></a>).</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreFit.odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.odf" title="Link to this definition">#</a></dt>
<dd><p>Calculates the ODF for a given discrete sphere.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.odf_sh">
<span class="sig-name descname"><span class="pre">odf_sh</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreFit.odf_sh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.odf_sh" title="Link to this definition">#</a></dt>
<dd><p>Calculates the real analytical ODF in terms of Spherical
Harmonics.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_points</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreFit.pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.pdf" title="Link to this definition">#</a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.pdf_grid">
<span class="sig-name descname"><span class="pre">pdf_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_max</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreFit.pdf_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.pdf_grid" title="Link to this definition">#</a></dt>
<dd><p>Applies the analytical FFT on <span class="math notranslate nohighlight">\(S\)</span> to generate the diffusion
propagator. This is calculated on a discrete 3D grid in order to
obtain an EAP similar to that which is obtained with DSI.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gridsize</strong><span class="classifier">unsigned int</span></dt><dd><p>dimension of the propagator grid</p>
</dd>
<dt><strong>radius_max</strong><span class="classifier">float</span></dt><dd><p>maximal radius in which to compute the propagator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eap</strong><span class="classifier">ndarray</span></dt><dd><p>the ensemble average propagator in the 3D grid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.rtop_pdf">
<span class="sig-name descname"><span class="pre">rtop_pdf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreFit.rtop_pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.rtop_pdf" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical return to origin probability (RTOP)
from the pdf.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id418" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.rtop_signal">
<span class="sig-name descname"><span class="pre">rtop_signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#ShoreFit.rtop_signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.rtop_signal" title="Link to this definition">#</a></dt>
<dd><p>Calculates the analytical return to origin probability (RTOP)
from the signal.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-ozarslan2013" id="id419" role="doc-noteref"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></a> for further details about the method.</p>
<p class="rubric">References</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.shore_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shore_coeff</span></span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.shore_coeff" title="Link to this definition">#</a></dt>
<dd><p>The SHORE coefficients</p>
</dd></dl>

</dd></dl>

</section>
<section id="shore-matrix">
<h3>shore_matrix<a class="headerlink" href="#shore-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.025330295910584444</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#shore_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.shore_matrix" title="Link to this definition">#</a></dt>
<dd><p>Compute the SHORE matrix for modified Merlet’s 3D-SHORE.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-merlet2013" id="id420" role="doc-noteref"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></a> for the definition.</p>
<div class="math notranslate nohighlight">
\textbf{E}(q\textbf{u})=\sum_{l=0, even}^{N_{max}}
                       \sum_{n=l}^{(N_{max}+l)/2}
                       \sum_{m=-l}^l c_{nlm}
                       \phi_{nlm}(q\textbf{u})</div><p>where <span class="math notranslate nohighlight">\(\phi_{nlm}\)</span> is</p>
<div class="math notranslate nohighlight">
\phi_{nlm}^{SHORE}(q\textbf{u})=\Biggl[\dfrac{2(n-l)!}
    {\zeta^{3/2} \Gamma(n+3/2)} \Biggr]^{1/2}
    \Biggl(\dfrac{q^2}{\zeta}\Biggr)^{l/2}
    exp\Biggl(\dfrac{-q^2}{2\zeta}\Biggr)
    L^{l+1/2}_{n-l} \Biggl(\dfrac{q^2}{\zeta}\Biggr)
    Y_l^m(\textbf{u})</div><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt><strong>zeta</strong><span class="classifier">unsigned int,</span></dt><dd><p>scale factor</p>
</dd>
<dt><strong>gtab</strong><span class="classifier">GradientTable,</span></dt><dd><p>gradient directions and bvalues container class</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float, optional</span></dt><dd><p>diffusion time. By default the value that makes q=sqrt(b).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="shore-matrix-pdf">
<h3>shore_matrix_pdf<a class="headerlink" href="#shore-matrix-pdf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_matrix_pdf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_matrix_pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#shore_matrix_pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.shore_matrix_pdf" title="Link to this definition">#</a></dt>
<dd><p>Compute the SHORE propagator matrix.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-merlet2013" id="id421" role="doc-noteref"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></a> for the definition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt><strong>zeta</strong><span class="classifier">unsigned int,</span></dt><dd><p>scale factor</p>
</dd>
<dt><strong>rtab</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>real space points in which calculates the pdf</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="shore-matrix-odf">
<h3>shore_matrix_odf<a class="headerlink" href="#shore-matrix-odf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_matrix_odf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_matrix_odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere_vertices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#shore_matrix_odf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.shore_matrix_odf" title="Link to this definition">#</a></dt>
<dd><p>Compute the SHORE ODF matrix.</p>
<p>See <a class="footnote-reference brackets" href="#footcite-merlet2013" id="id422" role="doc-noteref"><span class="fn-bracket">[</span>76<span class="fn-bracket">]</span></a> for the definition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt><strong>zeta</strong><span class="classifier">unsigned int,</span></dt><dd><p>scale factor</p>
</dd>
<dt><strong>sphere_vertices</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>vertices of the odf sphere</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="l-shore">
<h3>l_shore<a class="headerlink" href="#l-shore" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.l_shore">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">l_shore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#l_shore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.l_shore" title="Link to this definition">#</a></dt>
<dd><p>Returns the angular regularisation matrix for SHORE basis</p>
</dd></dl>

</section>
<section id="n-shore">
<h3>n_shore<a class="headerlink" href="#n-shore" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.n_shore">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">n_shore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#n_shore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.n_shore" title="Link to this definition">#</a></dt>
<dd><p>Returns the angular regularisation matrix for SHORE basis</p>
</dd></dl>

</section>
<section id="id423">
<h3>create_rspace<a class="headerlink" href="#id423" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.create_rspace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">create_rspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_max</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#create_rspace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.create_rspace" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Create the real space table, that contains the points in which</dt><dd><p>to compute the pdf.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gridsize</strong><span class="classifier">unsigned int</span></dt><dd><p>dimension of the propagator grid</p>
</dd>
<dt><strong>radius_max</strong><span class="classifier">float</span></dt><dd><p>maximal radius in which compute the propagator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vecs</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>positions of the pdf points in a 3D matrix</p>
</dd>
<dt><strong>tab</strong><span class="classifier">array, shape (N,3)</span></dt><dd><p>real space points in which calculates the pdf</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="shore-indices">
<h3>shore_indices<a class="headerlink" href="#shore-indices" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_indices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#shore_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.shore_indices" title="Link to this definition">#</a></dt>
<dd><p>Given the basis order and the index, return the shore indices n, l, m
for modified Merlet’s 3D-SHORE</p>
<div class="math notranslate nohighlight">
\begin{equation}
    \textbf{E}(q\textbf{u})=\sum_{l=0, even}^{N_{max}}
                            \sum_{n=l}^{(N_{max}+l)/2}
                            \sum_{m=-l}^l c_{nlm}
                            \phi_{nlm}(q\textbf{u})
\end{equation}</div><p>where <span class="math notranslate nohighlight">\(\phi_{nlm}\)</span> is</p>
<div class="math notranslate nohighlight">
\begin{equation}
    \phi_{nlm}^{SHORE}(q\textbf{u})=\Biggl[\dfrac{2(n-l)!}
        {\zeta^{3/2} \Gamma(n+3/2)} \Biggr]^{1/2}
        \Biggl(\dfrac{q^2}{\zeta}\Biggr)^{l/2}
        exp\Biggl(\dfrac{-q^2}{2\zeta}\Biggr)
        L^{l+1/2}_{n-l} \Biggl(\dfrac{q^2}{\zeta}\Biggr)
        Y_l^m(\textbf{u}).
\end{equation}</div><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int</span></dt><dd><p>an even integer that represent the maximal order of the basis</p>
</dd>
<dt><strong>index</strong><span class="classifier">unsigned int</span></dt><dd><p>index of the coefficients, start from 0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>n</strong><span class="classifier">unsigned int</span></dt><dd><p>the index n of the modified shore basis</p>
</dd>
<dt><strong>l</strong><span class="classifier">unsigned int</span></dt><dd><p>the index l of the modified shore basis</p>
</dd>
<dt><strong>m</strong><span class="classifier">unsigned int</span></dt><dd><p>the index m of the modified shore basis</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="shore-order">
<h3>shore_order<a class="headerlink" href="#shore-order" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_order">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/shore.html#shore_order"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.shore.shore_order" title="Link to this definition">#</a></dt>
<dd><p>Given the indices (n,l,m) of the basis, return the minimum order
for those indices and their index for modified Merlet’s 3D-SHORE.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">unsigned int</span></dt><dd><p>the index n of the modified shore basis</p>
</dd>
<dt><strong>ell</strong><span class="classifier">unsigned int</span></dt><dd><p>the index l of the modified shore basis</p>
</dd>
<dt><strong>m</strong><span class="classifier">unsigned int</span></dt><dd><p>the index m of the modified shore basis</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>radial_order</strong><span class="classifier">unsigned int</span></dt><dd><p>an even integer that represent the maximal order of the basis</p>
</dd>
<dt><strong>index</strong><span class="classifier">unsigned int</span></dt><dd><p>index of the coefficient corresponding to (n,l,m), start from 0</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="dki-design-matrix">
<h3>dki_design_matrix<a class="headerlink" href="#dki-design-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.utils.dki_design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.utils.</span></span><span class="sig-name descname"><span class="pre">dki_design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/utils.html#dki_design_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.utils.dki_design_matrix" title="Link to this definition">#</a></dt>
<dd><p>Construct B design matrix for DKI.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab</strong><span class="classifier">GradientTable</span></dt><dd><p>Measurement directions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>B</strong><span class="classifier">array (N, 22)</span></dt><dd><p>Design matrix or B matrix for the DKI model</p>
<div class="math notranslate nohighlight">
\[B[j, :] = (Bxx, Bxy, Byy, Bxz, Byz, Bzz,
           Bxxxx, Byyyy, Bzzzz, Bxxxy, Bxxxz,
           Bxyyy, Byyyz, Bxzzz, Byzzz, Bxxyy,
           Bxxzz, Byyzz, Bxxyz, Bxyyz, Bxyzz,
           BlogS0)\]</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="cti-design-matrix">
<h3>cti_design_matrix<a class="headerlink" href="#cti-design-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.utils.cti_design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.utils.</span></span><span class="sig-name descname"><span class="pre">cti_design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/utils.html#cti_design_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.utils.cti_design_matrix" title="Link to this definition">#</a></dt>
<dd><p>Construct B design matrix for CTI.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtab1: dipy.core.gradients.GradientTable</strong></dt><dd><p>A GradientTable class instance for first DDE diffusion epoch</p>
</dd>
<dt><strong>gtab2: dipy.core.gradients.GradientTable</strong></dt><dd><p>A GradientTable class instance for second DDE diffusion epoch</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>B: array(N, 43)</dt><dd></dd>
<dt>Design matrix or B matrix for the CTI model assuming multiple</dt><dd></dd>
<dt>Gaussian Components</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="convert-tensors">
<h3>convert_tensors<a class="headerlink" href="#convert-tensors" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.utils.convert_tensors">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.utils.</span></span><span class="sig-name descname"><span class="pre">convert_tensors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_format</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_format</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/utils.html#convert_tensors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.utils.convert_tensors" title="Link to this definition">#</a></dt>
<dd><p>Convert tensors from one format to another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">ndarray</span></dt><dd><p>Input tensor.</p>
</dd>
<dt><strong>from_format</strong><span class="classifier">str</span></dt><dd><p>Format of the input tensor. Options: ‘dipy’, ‘mrtrix’, ‘ants’, ‘fsl’.</p>
</dd>
<dt><strong>to_format</strong><span class="classifier">str</span></dt><dd><p>Format of the output tensor. Options: ‘dipy’, ‘mrtrix’, ‘ants’, ‘fsl’.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>DIPY order: [Dxx, Dxy, Dyy, Dxz, Dyz, Dzz].
Shape: [i, j , k, 6].
See: <a class="github reference external" href="https://github.com/dipy/dipy/blob/master/dipy/reconst/dti.py#L1639">dipy/dipy</a></p></li>
<li><dl class="simple">
<dt>MRTRIX order: [Dxx, Dyy, Dzz, Dxy, Dxz, Dyz]</dt><dd><p>Shape: [i, j , k, 6].
See: <a class="reference external" href="https://mrtrix.readthedocs.io/en/dev/reference/commands/dwi2tensor.html">https://mrtrix.readthedocs.io/en/dev/reference/commands/dwi2tensor.html</a>  # noqa</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ANTS: [Dxx, Dxy, Dyy, Dxz, Dyz, Dzz].</dt><dd><p>Shape: [i, j , k, 1, 6]  -  Note the extra dimension (5D)
See: <a class="github reference external" href="https://github.com/ANTsX/ANTs/wiki/Importing-diffusion-tensor-data-from-other-software">ANTsX/ANTs</a>  # noqa</p>
</dd>
</dl>
</li>
<li><p>FSL: [Dxx, Dxy, Dxz, Dyy, Dyz, Dzz]
Shape: [i, j , k, 6]. (Also used for the Fibernavigator)
Ref: <a class="reference external" href="https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FDT/UserGuide">https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FDT/UserGuide</a></p></li>
</ul>
</dd></dl>

</section>
<section id="simple-cutoff">
<h3>simple_cutoff<a class="headerlink" href="#simple-cutoff" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.weights_method.simple_cutoff">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.weights_method.</span></span><span class="sig-name descname"><span class="pre">simple_cutoff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">residuals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_residuals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leverages</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/weights_method.html#simple_cutoff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.weights_method.simple_cutoff" title="Link to this definition">#</a></dt>
<dd><p>Define outliers based on the signal (rather than the log-signal).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>residuals</strong><span class="classifier">ndarray</span></dt><dd><p>Residuals of the signal (observed signal - fitted signal).</p>
</dd>
<dt><strong>log_residuals</strong><span class="classifier">ndarray</span></dt><dd><p>Residuals of the log signal (log observed signal - fitted log signal).</p>
</dd>
<dt><strong>pred_sig</strong><span class="classifier">ndarray</span></dt><dd><p>The predicted signal, given a previous fit.</p>
</dd>
<dt><strong>design_matrix</strong><span class="classifier">ndarray (g, …)</span></dt><dd><p>Design matrix holding the covariants used to solve for the
regression coefficients.</p>
</dd>
<dt><strong>leverages</strong><span class="classifier">ndarray</span></dt><dd><p>The leverages (diagonal of the ‘hat matrix’) of the fit.</p>
</dd>
<dt><strong>C</strong><span class="classifier">float</span></dt><dd><p>Estimate of the standard deviation of the error.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float, optional</span></dt><dd><p>Cut-off value for defining outliers based on fitting residuals.
Here the condition is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="n">residuals</span><span class="o">|</span> <span class="o">&gt;</span> <span class="n">cut_off</span> <span class="n">x</span> <span class="n">C</span> <span class="n">x</span> <span class="n">HAT_factor</span>
</pre></div>
</div>
<p>where HAT_factor = sqrt(1 - leverages) adjusts for leverage effects.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="two-eyes-cutoff">
<h3>two_eyes_cutoff<a class="headerlink" href="#two-eyes-cutoff" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.weights_method.two_eyes_cutoff">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.weights_method.</span></span><span class="sig-name descname"><span class="pre">two_eyes_cutoff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">residuals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_residuals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leverages</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/weights_method.html#two_eyes_cutoff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.weights_method.two_eyes_cutoff" title="Link to this definition">#</a></dt>
<dd><p>Define outliers with two-eyes approach.</p>
<p>see <a class="footnote-reference brackets" href="#footcite-collier2015" id="id424" role="doc-noteref"><span class="fn-bracket">[</span>79<span class="fn-bracket">]</span></a> for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">ndarray</span></dt><dd><p>Residuals of the signal (observed signal - fitted signal).</p>
</dd>
<dt><strong>log_residuals</strong><span class="classifier">ndarray</span></dt><dd><p>Residuals of the log signal (log observed signal - fitted log signal).</p>
</dd>
<dt><strong>pred_sig</strong><span class="classifier">ndarray</span></dt><dd><p>The predicted signal, given a previous fit.</p>
</dd>
<dt><strong>design_matrix</strong><span class="classifier">ndarray (g, …)</span></dt><dd><p>Design matrix holding the covariants used to solve for the
regression coefficients.</p>
</dd>
<dt><strong>leverages</strong><span class="classifier">ndarray</span></dt><dd><p>The leverages (diagonal of the ‘hat matrix’) of the fit.</p>
</dd>
<dt><strong>C</strong><span class="classifier">float</span></dt><dd><p>Estimate of the standard deviation of the error.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float, optional</span></dt><dd><p>Cut-off value for defining outliers based on fitting residuals,
see <a class="footnote-reference brackets" href="#footcite-collier2015" id="id425" role="doc-noteref"><span class="fn-bracket">[</span>79<span class="fn-bracket">]</span></a> for the two-eyes approached used here.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div class="docutils container" id="id426">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-collier2015" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>79<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id424">1</a>,<a role="doc-backlink" href="#id425">2</a>,<a role="doc-backlink" href="#id427">3</a>)</span>
<p>Quinten Collier, Jelle Veraart, Ben Jeurissen, Arno den Dekker, and Jan Sijbers. Iterative reweighted linear least squares for accurate, fast, and robust estimation of diffusion magnetic resonance parameters: IRLLS for Estimation of Diffusion MR Parameters. <em>Magnetic Resonance in Medicine</em>, 73(6):2174–2184, 2015. URL: <a class="reference external" href="https://doi.org/10.1002/mrm.25351">https://doi.org/10.1002/mrm.25351</a>, <a class="reference external" href="https://doi.org/10.1002/mrm.25351">doi:10.1002/mrm.25351</a>.</p>
</aside>
</aside>
</div>
</dd></dl>

</section>
<section id="weights-method-wls-m-est">
<h3>weights_method_wls_m_est<a class="headerlink" href="#weights-method-wls-m-est" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.weights_method.weights_method_wls_m_est">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.weights_method.</span></span><span class="sig-name descname"><span class="pre">weights_method_wls_m_est</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leverages</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_robust</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_est='gm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff=3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outlier_condition_func=&lt;function</span> <span class="pre">simple_cutoff&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/weights_method.html#weights_method_wls_m_est"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.weights_method.weights_method_wls_m_est" title="Link to this definition">#</a></dt>
<dd><p>Calculate M-estimator weights for WLS model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>The measured signal.</p>
</dd>
<dt><strong>pred_sig</strong><span class="classifier">ndarray</span></dt><dd><p>The predicted signal, given a previous fit.
Has the same shape as data.</p>
</dd>
<dt><strong>design_matrix</strong><span class="classifier">ndarray (g, …)</span></dt><dd><p>Design matrix holding the covariants used to solve for the
regression coefficients.</p>
</dd>
<dt><strong>leverages</strong><span class="classifier">ndarray</span></dt><dd><p>The leverages (diagonal of the ‘hat matrix’) of the fit.</p>
</dd>
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The current iteration number.</p>
</dd>
<dt><strong>total_idx</strong><span class="classifier">int</span></dt><dd><p>The total number of iterations.</p>
</dd>
<dt><strong>last_robust</strong><span class="classifier">ndarray</span></dt><dd><p>True for inlier indices and False for outlier indices. Must have the
same shape as data.</p>
</dd>
<dt><strong>m_est</strong><span class="classifier">str, optional.</span></dt><dd><p>M-estimator weighting scheme to use. Currently,
‘gm’ (Geman-McClure) and ‘cauchy’ are provided.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float, optional</span></dt><dd><p>Cut-off value for defining outliers based on fitting residuals.
Will be passed to the outlier_condition_func.
Typical example: <code class="docutils literal notranslate"><span class="pre">|residuals|</span> <span class="pre">&gt;</span> <span class="pre">cut_off</span> <span class="pre">x</span> <span class="pre">standard_deviation</span></code></p>
</dd>
<dt><strong>outlier_condition_func</strong><span class="classifier">callable, optional</span></dt><dd><p>A function with args and returns as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">is_an_outlier</span> <span class="o">=</span> <span class="n">outlier_condition_func</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">log_residuals</span><span class="p">,</span>
    <span class="n">pred_sig</span><span class="p">,</span> <span class="n">design_matrix</span><span class="p">,</span> <span class="n">leverages</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Robust weights are calculated specifically for the WLS problem, i.e. the
usual form of the WLS problem is accounted for when defining these new
weights, see <a class="footnote-reference brackets" href="#footcite-collier2015" id="id427" role="doc-noteref"><span class="fn-bracket">[</span>79<span class="fn-bracket">]</span></a>. On the second-to-last iteration,
OLS is performed without outliers. On the last iteration, WLS is performed
without outliers.</p>
<p class="rubric">References</p>
</dd></dl>

</section>
<section id="weights-method-nlls-m-est">
<h3>weights_method_nlls_m_est<a class="headerlink" href="#weights-method-nlls-m-est" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.weights_method.weights_method_nlls_m_est">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.weights_method.</span></span><span class="sig-name descname"><span class="pre">weights_method_nlls_m_est</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leverages</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_robust</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_est='gm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff=3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outlier_condition_func=&lt;function</span> <span class="pre">simple_cutoff&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dipy/reconst/weights_method.html#weights_method_nlls_m_est"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dipy.reconst.weights_method.weights_method_nlls_m_est" title="Link to this definition">#</a></dt>
<dd><p>Calculate M-estimator weights for NLLS model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>The measured signal.</p>
</dd>
<dt><strong>pred_sig</strong><span class="classifier">ndarray</span></dt><dd><p>The predicted signal, given a previous fit.
Has the same shape as data.</p>
</dd>
<dt><strong>design_matrix</strong><span class="classifier">ndarray (g, …)</span></dt><dd><p>Design matrix holding the covariants used to solve for the
regression coefficients.</p>
</dd>
<dt><strong>leverages</strong><span class="classifier">ndarray</span></dt><dd><p>The leverages (diagonal of the ‘hat matrix’) of the fit.</p>
</dd>
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The current iteration number.</p>
</dd>
<dt><strong>total_idx</strong><span class="classifier">int</span></dt><dd><p>The total number of iterations.</p>
</dd>
<dt><strong>last_robust</strong><span class="classifier">ndarray</span></dt><dd><p>True for inlier indices and False for outlier indices. Must have the
same shape as data.</p>
</dd>
<dt><strong>m_est</strong><span class="classifier">str, optional.</span></dt><dd><p>M-estimator weighting scheme to use. Currently,
‘gm’ (Geman-McClure) and ‘cauchy’ are provided.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float, optional</span></dt><dd><p>Cut-off value for defining outliers based on fitting residuals.
Will be passed to the outlier_condition_func.
Typical example: <code class="docutils literal notranslate"><span class="pre">|residuals|</span> <span class="pre">&gt;</span> <span class="pre">cut_off</span> <span class="pre">x</span> <span class="pre">standard_deviation</span></code></p>
</dd>
<dt><strong>outlier_condition_func</strong><span class="classifier">callable, optional</span></dt><dd><p>A function with args and returns as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">is_an_outlier</span> <span class="o">=</span> <span class="n">outlier_condition_func</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">log_residuals</span><span class="p">,</span>
    <span class="n">pred_sig</span><span class="p">,</span> <span class="n">design_matrix</span><span class="p">,</span> <span class="n">leverages</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Robust weights are calculated specifically for the NLLS problem.
On the last iteration, NLLS is performed without outliers.</p>
</dd></dl>

</section>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="dipy.nn.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nn</span></code></p>
      </div>
    </a>
    <a class="right-next"
       href="dipy.segment.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><code class="xref py py-mod docutils literal notranslate"><span class="pre">segment</span></code></p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.base">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.base</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.bingham">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.bingham</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.cache">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cache</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.cross_validation">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cross_validation</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.csdeconv">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.csdeconv</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.cti">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cti</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.dki">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.dki_micro">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki_micro</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.dsi">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dsi</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.dti">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dti</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.forecast">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.forecast</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.fwdti">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.fwdti</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.gqi">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.gqi</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.ivim">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.ivim</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.mapmri">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.mapmri</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.mcsd">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.mcsd</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.msdki">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.msdki</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.multi_voxel">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.multi_voxel</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.odf">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.odf</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.qtdmri">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.qtdmri</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.qti">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.qti</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">References</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.rumba">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.rumba</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.sfm">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.sfm</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">References</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.shm">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shm</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">References</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.shore">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shore</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.utils">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.utils</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.weights_method">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.weights_method</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reconstmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.base.ReconstModel"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.base.ReconstModel.fit"><code class="docutils literal notranslate"><span class="pre">ReconstModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reconstfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.base.ReconstFit"><code class="docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binghammetrics"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinghamMetrics</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.amplitude_lobe"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.amplitude_lobe()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.fd_lobe"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.fd_lobe()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.fd_voxel"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.fd_voxel()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.fs_lobe"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.fs_lobe()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.fs_voxel"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.fs_voxel()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.kappa1_lobe"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.kappa1_lobe()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.kappa2_lobe"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.kappa2_lobe()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.kappa_total_lobe"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.kappa_total_lobe()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.odf"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.odi1_lobe"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.odi1_lobe()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.odi1_voxel"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.odi1_voxel()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.odi2_lobe"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.odi2_lobe()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.odi2_voxel"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.odi2_voxel()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.odi_total_lobe"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.odi_total_lobe()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.BinghamMetrics.odi_total_voxel"><code class="docutils literal notranslate"><span class="pre">BinghamMetrics.odi_total_voxel()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bingham-to-sf">bingham_to_sf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.bingham_to_sf"><code class="docutils literal notranslate"><span class="pre">bingham_to_sf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bingham-fiber-density">bingham_fiber_density</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.bingham_fiber_density"><code class="docutils literal notranslate"><span class="pre">bingham_fiber_density()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bingham-fiber-spread">bingham_fiber_spread</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.bingham_fiber_spread"><code class="docutils literal notranslate"><span class="pre">bingham_fiber_spread()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#k2odi">k2odi</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.k2odi"><code class="docutils literal notranslate"><span class="pre">k2odi()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odi2k">odi2k</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.odi2k"><code class="docutils literal notranslate"><span class="pre">odi2k()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#weighted-voxel-metric">weighted_voxel_metric</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.weighted_voxel_metric"><code class="docutils literal notranslate"><span class="pre">weighted_voxel_metric()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sf-to-bingham">sf_to_bingham</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.sf_to_bingham"><code class="docutils literal notranslate"><span class="pre">sf_to_bingham()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sh-to-bingham">sh_to_bingham</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.bingham.sh_to_bingham"><code class="docutils literal notranslate"><span class="pre">sh_to_bingham()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cache.Cache"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cache.Cache.cache_clear"><code class="docutils literal notranslate"><span class="pre">Cache.cache_clear()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cache.Cache.cache_get"><code class="docutils literal notranslate"><span class="pre">Cache.cache_get()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cache.Cache.cache_set"><code class="docutils literal notranslate"><span class="pre">Cache.cache_set()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#coeff-of-determination">coeff_of_determination</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cross_validation.coeff_of_determination"><code class="docutils literal notranslate"><span class="pre">coeff_of_determination()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kfold-xval">kfold_xval</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cross_validation.kfold_xval"><code class="docutils literal notranslate"><span class="pre">kfold_xval()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axsymshresponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.AxSymShResponse"><code class="docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.AxSymShResponse.basis"><code class="docutils literal notranslate"><span class="pre">AxSymShResponse.basis()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.AxSymShResponse.on_sphere"><code class="docutils literal notranslate"><span class="pre">AxSymShResponse.on_sphere()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constrainedsphericaldeconvmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><code class="docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit"><code class="docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict"><code class="docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constrainedsdtmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSDTModel"><code class="docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.fit"><code class="docutils literal notranslate"><span class="pre">ConstrainedSDTModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#estimate-response">estimate_response</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.estimate_response"><code class="docutils literal notranslate"><span class="pre">estimate_response()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forward-sdt-deconv-mat">forward_sdt_deconv_mat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat"><code class="docutils literal notranslate"><span class="pre">forward_sdt_deconv_mat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#csdeconv">csdeconv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.csdeconv"><code class="docutils literal notranslate"><span class="pre">csdeconv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odf-deconv">odf_deconv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.odf_deconv"><code class="docutils literal notranslate"><span class="pre">odf_deconv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odf-sh-to-sharp">odf_sh_to_sharp</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.odf_sh_to_sharp"><code class="docutils literal notranslate"><span class="pre">odf_sh_to_sharp()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mask-for-response-ssst">mask_for_response_ssst</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.mask_for_response_ssst"><code class="docutils literal notranslate"><span class="pre">mask_for_response_ssst()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#response-from-mask-ssst">response_from_mask_ssst</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.response_from_mask_ssst"><code class="docutils literal notranslate"><span class="pre">response_from_mask_ssst()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#auto-response-ssst">auto_response_ssst</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.auto_response_ssst"><code class="docutils literal notranslate"><span class="pre">auto_response_ssst()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recursive-response">recursive_response</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.recursive_response"><code class="docutils literal notranslate"><span class="pre">recursive_response()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fa-trace-to-lambdas">fa_trace_to_lambdas</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas"><code class="docutils literal notranslate"><span class="pre">fa_trace_to_lambdas()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#correlationtensormodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CorrelationTensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorModel"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorModel.fit"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorModel.predict"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#correlationtensorfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">CorrelationTensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.K_aniso"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.K_aniso</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.K_iso"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.K_iso</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.K_micro"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.K_micro</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.K_total"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.K_total()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.ct"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.ct</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.predict"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-qte-to-cti">from_qte_to_cti</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.from_qte_to_cti"><code class="docutils literal notranslate"><span class="pre">from_qte_to_cti()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-gaussian-k-from-c">multi_gaussian_k_from_c</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.multi_gaussian_k_from_c"><code class="docutils literal notranslate"><span class="pre">multi_gaussian_k_from_c()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#split-cti-params">split_cti_params</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.split_cti_params"><code class="docutils literal notranslate"><span class="pre">split_cti_params()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cti-prediction">cti_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.cti_prediction"><code class="docutils literal notranslate"><span class="pre">cti_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#params-to-cti-params">params_to_cti_params</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.params_to_cti_params"><code class="docutils literal notranslate"><span class="pre">params_to_cti_params()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ls-fit-cti">ls_fit_cti</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.ls_fit_cti"><code class="docutils literal notranslate"><span class="pre">ls_fit_cti()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionkurtosismodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel.fit"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel.iterative_fit"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel.iterative_fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel.multi_fit"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel.multi_fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel.predict"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionkurtosisfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.ak"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.ak()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.akc"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.akc()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.kfa"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.kfa</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.kmax"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.kmax()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.kt"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.kt</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.mk"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.mk()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.mkt"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.mkt()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.predict"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.rk"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.rk()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.rtk"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.rtk()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#carlson-rf">carlson_rf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.carlson_rf"><code class="docutils literal notranslate"><span class="pre">carlson_rf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#carlson-rd">carlson_rd</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.carlson_rd"><code class="docutils literal notranslate"><span class="pre">carlson_rd()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-diffusion">directional_diffusion</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.directional_diffusion"><code class="docutils literal notranslate"><span class="pre">directional_diffusion()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-diffusion-variance">directional_diffusion_variance</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.directional_diffusion_variance"><code class="docutils literal notranslate"><span class="pre">directional_diffusion_variance()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-kurtosis">directional_kurtosis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.directional_kurtosis"><code class="docutils literal notranslate"><span class="pre">directional_kurtosis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#apparent-kurtosis-coef">apparent_kurtosis_coef</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.apparent_kurtosis_coef"><code class="docutils literal notranslate"><span class="pre">apparent_kurtosis_coef()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mean-kurtosis">mean_kurtosis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.mean_kurtosis"><code class="docutils literal notranslate"><span class="pre">mean_kurtosis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radial-kurtosis">radial_kurtosis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.radial_kurtosis"><code class="docutils literal notranslate"><span class="pre">radial_kurtosis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axial-kurtosis">axial_kurtosis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.axial_kurtosis"><code class="docutils literal notranslate"><span class="pre">axial_kurtosis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kurtosis-maximum">kurtosis_maximum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.kurtosis_maximum"><code class="docutils literal notranslate"><span class="pre">kurtosis_maximum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mean-kurtosis-tensor">mean_kurtosis_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.mean_kurtosis_tensor"><code class="docutils literal notranslate"><span class="pre">mean_kurtosis_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radial-tensor-kurtosis">radial_tensor_kurtosis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.radial_tensor_kurtosis"><code class="docutils literal notranslate"><span class="pre">radial_tensor_kurtosis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kurtosis-fractional-anisotropy">kurtosis_fractional_anisotropy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.kurtosis_fractional_anisotropy"><code class="docutils literal notranslate"><span class="pre">kurtosis_fractional_anisotropy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dki-prediction">dki_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.dki_prediction"><code class="docutils literal notranslate"><span class="pre">dki_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#params-to-dki-params">params_to_dki_params</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.params_to_dki_params"><code class="docutils literal notranslate"><span class="pre">params_to_dki_params()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ls-fit-dki">ls_fit_dki</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.ls_fit_dki"><code class="docutils literal notranslate"><span class="pre">ls_fit_dki()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cls-fit-dki">cls_fit_dki</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.cls_fit_dki"><code class="docutils literal notranslate"><span class="pre">cls_fit_dki()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wrotate">Wrotate</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.Wrotate"><code class="docutils literal notranslate"><span class="pre">Wrotate()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wrotate-element">Wrotate_element</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.Wrotate_element"><code class="docutils literal notranslate"><span class="pre">Wrotate_element()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wcons">Wcons</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.Wcons"><code class="docutils literal notranslate"><span class="pre">Wcons()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#split-dki-param">split_dki_param</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.split_dki_param"><code class="docutils literal notranslate"><span class="pre">split_dki_param()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kurtosismicrostructuremodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kurtosismicrostructuralfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.awf</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.axonal_diffusivity</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.hindered_ad</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.hindered_evals</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.hindered_rd</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.restricted_evals</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.tortuosity</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axonal-water-fraction">axonal_water_fraction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.axonal_water_fraction"><code class="docutils literal notranslate"><span class="pre">axonal_water_fraction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusion-components">diffusion_components</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.diffusion_components"><code class="docutils literal notranslate"><span class="pre">diffusion_components()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dkimicro-prediction">dkimicro_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.dkimicro_prediction"><code class="docutils literal notranslate"><span class="pre">dkimicro_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tortuosity">tortuosity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.tortuosity"><code class="docutils literal notranslate"><span class="pre">tortuosity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionspectrummodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumModel"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumModel.fit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionspectrumfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.msd_discrete()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.odf"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.pdf"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.rtop_pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.rtop_signal()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionspectrumdeconvmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionspectrumdeconvfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit.pdf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-qspace">create_qspace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.create_qspace"><code class="docutils literal notranslate"><span class="pre">create_qspace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-qtable">create_qtable</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.create_qtable"><code class="docutils literal notranslate"><span class="pre">create_qtable()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hanning-filter">hanning_filter</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.hanning_filter"><code class="docutils literal notranslate"><span class="pre">hanning_filter()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pdf-interp-coords">pdf_interp_coords</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.pdf_interp_coords"><code class="docutils literal notranslate"><span class="pre">pdf_interp_coords()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pdf-odf">pdf_odf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.pdf_odf"><code class="docutils literal notranslate"><span class="pre">pdf_odf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#half-to-full-qspace">half_to_full_qspace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.half_to_full_qspace"><code class="docutils literal notranslate"><span class="pre">half_to_full_qspace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#project-hemisph-bvecs">project_hemisph_bvecs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.project_hemisph_bvecs"><code class="docutils literal notranslate"><span class="pre">project_hemisph_bvecs()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#threshold-propagator">threshold_propagator</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.threshold_propagator"><code class="docutils literal notranslate"><span class="pre">threshold_propagator()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gen-psf">gen_PSF</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.gen_PSF"><code class="docutils literal notranslate"><span class="pre">gen_PSF()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lr-deconv">LR_deconv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.LR_deconv"><code class="docutils literal notranslate"><span class="pre">LR_deconv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tensormodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorModel"><code class="docutils literal notranslate"><span class="pre">TensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorModel.fit"><code class="docutils literal notranslate"><span class="pre">TensorModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorModel.predict"><code class="docutils literal notranslate"><span class="pre">TensorModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tensorfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit"><code class="docutils literal notranslate"><span class="pre">TensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.S0_hat"><code class="docutils literal notranslate"><span class="pre">TensorFit.S0_hat</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.ad"><code class="docutils literal notranslate"><span class="pre">TensorFit.ad()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.adc"><code class="docutils literal notranslate"><span class="pre">TensorFit.adc()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.color_fa"><code class="docutils literal notranslate"><span class="pre">TensorFit.color_fa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.directions"><code class="docutils literal notranslate"><span class="pre">TensorFit.directions</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.evals"><code class="docutils literal notranslate"><span class="pre">TensorFit.evals</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.evecs"><code class="docutils literal notranslate"><span class="pre">TensorFit.evecs</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.fa"><code class="docutils literal notranslate"><span class="pre">TensorFit.fa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.ga"><code class="docutils literal notranslate"><span class="pre">TensorFit.ga()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.linearity"><code class="docutils literal notranslate"><span class="pre">TensorFit.linearity()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.lower_triangular"><code class="docutils literal notranslate"><span class="pre">TensorFit.lower_triangular()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.md"><code class="docutils literal notranslate"><span class="pre">TensorFit.md()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.mode"><code class="docutils literal notranslate"><span class="pre">TensorFit.mode()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.odf"><code class="docutils literal notranslate"><span class="pre">TensorFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.planarity"><code class="docutils literal notranslate"><span class="pre">TensorFit.planarity()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.predict"><code class="docutils literal notranslate"><span class="pre">TensorFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.quadratic_form"><code class="docutils literal notranslate"><span class="pre">TensorFit.quadratic_form</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.rd"><code class="docutils literal notranslate"><span class="pre">TensorFit.rd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.shape"><code class="docutils literal notranslate"><span class="pre">TensorFit.shape</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.sphericity"><code class="docutils literal notranslate"><span class="pre">TensorFit.sphericity()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.trace"><code class="docutils literal notranslate"><span class="pre">TensorFit.trace()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractional-anisotropy">fractional_anisotropy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.fractional_anisotropy"><code class="docutils literal notranslate"><span class="pre">fractional_anisotropy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#geodesic-anisotropy">geodesic_anisotropy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.geodesic_anisotropy"><code class="docutils literal notranslate"><span class="pre">geodesic_anisotropy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mean-diffusivity">mean_diffusivity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.mean_diffusivity"><code class="docutils literal notranslate"><span class="pre">mean_diffusivity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axial-diffusivity">axial_diffusivity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.axial_diffusivity"><code class="docutils literal notranslate"><span class="pre">axial_diffusivity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radial-diffusivity">radial_diffusivity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.radial_diffusivity"><code class="docutils literal notranslate"><span class="pre">radial_diffusivity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#trace">trace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.trace"><code class="docutils literal notranslate"><span class="pre">trace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#color-fa">color_fa</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.color_fa"><code class="docutils literal notranslate"><span class="pre">color_fa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#determinant">determinant</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.determinant"><code class="docutils literal notranslate"><span class="pre">determinant()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isotropic">isotropic</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.isotropic"><code class="docutils literal notranslate"><span class="pre">isotropic()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deviatoric">deviatoric</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.deviatoric"><code class="docutils literal notranslate"><span class="pre">deviatoric()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#norm">norm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.norm"><code class="docutils literal notranslate"><span class="pre">norm()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mode">mode</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.mode"><code class="docutils literal notranslate"><span class="pre">mode()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linearity">linearity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.linearity"><code class="docutils literal notranslate"><span class="pre">linearity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#planarity">planarity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.planarity"><code class="docutils literal notranslate"><span class="pre">planarity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sphericity">sphericity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.sphericity"><code class="docutils literal notranslate"><span class="pre">sphericity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#apparent-diffusion-coef">apparent_diffusion_coef</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.apparent_diffusion_coef"><code class="docutils literal notranslate"><span class="pre">apparent_diffusion_coef()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tensor-prediction">tensor_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.tensor_prediction"><code class="docutils literal notranslate"><span class="pre">tensor_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iter-fit-tensor">iter_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.iter_fit_tensor"><code class="docutils literal notranslate"><span class="pre">iter_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wls-fit-tensor">wls_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.wls_fit_tensor"><code class="docutils literal notranslate"><span class="pre">wls_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ols-fit-tensor">ols_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.ols_fit_tensor"><code class="docutils literal notranslate"><span class="pre">ols_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nlls-fit-tensor">nlls_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.nlls_fit_tensor"><code class="docutils literal notranslate"><span class="pre">nlls_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#restore-fit-tensor">restore_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.restore_fit_tensor"><code class="docutils literal notranslate"><span class="pre">restore_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterative-fit-tensor">iterative_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.iterative_fit_tensor"><code class="docutils literal notranslate"><span class="pre">iterative_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#robust-fit-tensor-wls">robust_fit_tensor_wls</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.robust_fit_tensor_wls"><code class="docutils literal notranslate"><span class="pre">robust_fit_tensor_wls()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#robust-fit-tensor-nlls">robust_fit_tensor_nlls</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.robust_fit_tensor_nlls"><code class="docutils literal notranslate"><span class="pre">robust_fit_tensor_nlls()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-lower-triangular">from_lower_triangular</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.from_lower_triangular"><code class="docutils literal notranslate"><span class="pre">from_lower_triangular()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lower-triangular">lower_triangular</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.lower_triangular"><code class="docutils literal notranslate"><span class="pre">lower_triangular()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#decompose-tensor">decompose_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.decompose_tensor"><code class="docutils literal notranslate"><span class="pre">decompose_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#design-matrix">design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.design_matrix"><code class="docutils literal notranslate"><span class="pre">design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantize-evecs">quantize_evecs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.quantize_evecs"><code class="docutils literal notranslate"><span class="pre">quantize_evecs()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#eig-from-lo-tri">eig_from_lo_tri</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.eig_from_lo_tri"><code class="docutils literal notranslate"><span class="pre">eig_from_lo_tri()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forecastmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastModel"><code class="docutils literal notranslate"><span class="pre">ForecastModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastModel.fit"><code class="docutils literal notranslate"><span class="pre">ForecastModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forecastfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit"><code class="docutils literal notranslate"><span class="pre">ForecastFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.dpar"><code class="docutils literal notranslate"><span class="pre">ForecastFit.dpar</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.dperp"><code class="docutils literal notranslate"><span class="pre">ForecastFit.dperp</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.fractional_anisotropy"><code class="docutils literal notranslate"><span class="pre">ForecastFit.fractional_anisotropy()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.mean_diffusivity"><code class="docutils literal notranslate"><span class="pre">ForecastFit.mean_diffusivity()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.odf"><code class="docutils literal notranslate"><span class="pre">ForecastFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.predict"><code class="docutils literal notranslate"><span class="pre">ForecastFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.sh_coeff"><code class="docutils literal notranslate"><span class="pre">ForecastFit.sh_coeff</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#find-signal-means">find_signal_means</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.find_signal_means"><code class="docutils literal notranslate"><span class="pre">find_signal_means()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forecast-error-func">forecast_error_func</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.forecast_error_func"><code class="docutils literal notranslate"><span class="pre">forecast_error_func()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#psi-l">psi_l</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.psi_l"><code class="docutils literal notranslate"><span class="pre">psi_l()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forecast-matrix">forecast_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.forecast_matrix"><code class="docutils literal notranslate"><span class="pre">forecast_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rho-matrix">rho_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.rho_matrix"><code class="docutils literal notranslate"><span class="pre">rho_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lb-forecast">lb_forecast</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.lb_forecast"><code class="docutils literal notranslate"><span class="pre">lb_forecast()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#freewatertensormodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorModel"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorModel.fit"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorModel.predict"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#freewatertensorfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorFit"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorFit.f"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorFit.f</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorFit.predict"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fwdti-prediction">fwdti_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.fwdti_prediction"><code class="docutils literal notranslate"><span class="pre">fwdti_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wls-iter">wls_iter</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.wls_iter"><code class="docutils literal notranslate"><span class="pre">wls_iter()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id215">wls_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.wls_fit_tensor"><code class="docutils literal notranslate"><span class="pre">wls_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nls-iter">nls_iter</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.nls_iter"><code class="docutils literal notranslate"><span class="pre">nls_iter()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nls-fit-tensor">nls_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.nls_fit_tensor"><code class="docutils literal notranslate"><span class="pre">nls_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lower-triangular-to-cholesky">lower_triangular_to_cholesky</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.lower_triangular_to_cholesky"><code class="docutils literal notranslate"><span class="pre">lower_triangular_to_cholesky()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cholesky-to-lower-triangular">cholesky_to_lower_triangular</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.cholesky_to_lower_triangular"><code class="docutils literal notranslate"><span class="pre">cholesky_to_lower_triangular()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalizedqsamplingmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingModel"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.fit"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalizedqsamplingfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingFit"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.odf"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit.odf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#normalize-qa">normalize_qa</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.normalize_qa"><code class="docutils literal notranslate"><span class="pre">normalize_qa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#squared-radial-component">squared_radial_component</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.squared_radial_component"><code class="docutils literal notranslate"><span class="pre">squared_radial_component()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#npa">npa</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.npa"><code class="docutils literal notranslate"><span class="pre">npa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equatorial-zone-vertices">equatorial_zone_vertices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.equatorial_zone_vertices"><code class="docutils literal notranslate"><span class="pre">equatorial_zone_vertices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#polar-zone-vertices">polar_zone_vertices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.polar_zone_vertices"><code class="docutils literal notranslate"><span class="pre">polar_zone_vertices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#upper-hemi-map">upper_hemi_map</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.upper_hemi_map"><code class="docutils literal notranslate"><span class="pre">upper_hemi_map()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equatorial-maximum">equatorial_maximum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.equatorial_maximum"><code class="docutils literal notranslate"><span class="pre">equatorial_maximum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#patch-vertices">patch_vertices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.patch_vertices"><code class="docutils literal notranslate"><span class="pre">patch_vertices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#patch-maximum">patch_maximum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.patch_maximum"><code class="docutils literal notranslate"><span class="pre">patch_maximum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odf-sum">odf_sum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.odf_sum"><code class="docutils literal notranslate"><span class="pre">odf_sum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#patch-sum">patch_sum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.patch_sum"><code class="docutils literal notranslate"><span class="pre">patch_sum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#triple-odf-maxima">triple_odf_maxima</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.triple_odf_maxima"><code class="docutils literal notranslate"><span class="pre">triple_odf_maxima()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivimmodeltrr"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimModelTRR</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR.estimate_f_D_star()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR.estimate_linear_fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR.fit"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR.predict"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivimmodelvp"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimModelVP</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP"><code class="docutils literal notranslate"><span class="pre">IvimModelVP</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.cvx_fit"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.cvx_fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.fit"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.ivim_mix_cost_one()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.nlls_cost"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.nlls_cost()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.phi"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.phi()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.stoc_search_cost"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.stoc_search_cost()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.x_and_f_to_x_f()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.x_f_to_x_and_f()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivimfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit"><code class="docutils literal notranslate"><span class="pre">IvimFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.D"><code class="docutils literal notranslate"><span class="pre">IvimFit.D</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.D_star"><code class="docutils literal notranslate"><span class="pre">IvimFit.D_star</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.S0_predicted"><code class="docutils literal notranslate"><span class="pre">IvimFit.S0_predicted</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.perfusion_fraction"><code class="docutils literal notranslate"><span class="pre">IvimFit.perfusion_fraction</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.predict"><code class="docutils literal notranslate"><span class="pre">IvimFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.shape"><code class="docutils literal notranslate"><span class="pre">IvimFit.shape</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivim-prediction">ivim_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.ivim_prediction"><code class="docutils literal notranslate"><span class="pre">ivim_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#f-d-star-prediction">f_D_star_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.f_D_star_prediction"><code class="docutils literal notranslate"><span class="pre">f_D_star_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#f-d-star-error">f_D_star_error</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.f_D_star_error"><code class="docutils literal notranslate"><span class="pre">f_D_star_error()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivim-model-selector">ivim_model_selector</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.ivim_model_selector"><code class="docutils literal notranslate"><span class="pre">ivim_model_selector()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmrimodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriModel"><code class="docutils literal notranslate"><span class="pre">MapmriModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriModel.fit"><code class="docutils literal notranslate"><span class="pre">MapmriModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmrifit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit"><code class="docutils literal notranslate"><span class="pre">MapmriFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.fitted_signal"><code class="docutils literal notranslate"><span class="pre">MapmriFit.fitted_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.mapmri_R"><code class="docutils literal notranslate"><span class="pre">MapmriFit.mapmri_R</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.mapmri_coeff"><code class="docutils literal notranslate"><span class="pre">MapmriFit.mapmri_coeff</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.mapmri_mu"><code class="docutils literal notranslate"><span class="pre">MapmriFit.mapmri_mu</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.msd"><code class="docutils literal notranslate"><span class="pre">MapmriFit.msd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.ng"><code class="docutils literal notranslate"><span class="pre">MapmriFit.ng()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.ng_parallel"><code class="docutils literal notranslate"><span class="pre">MapmriFit.ng_parallel()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.ng_perpendicular"><code class="docutils literal notranslate"><span class="pre">MapmriFit.ng_perpendicular()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal"><code class="docutils literal notranslate"><span class="pre">MapmriFit.norm_of_laplacian_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.odf"><code class="docutils literal notranslate"><span class="pre">MapmriFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.odf_sh"><code class="docutils literal notranslate"><span class="pre">MapmriFit.odf_sh()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.pdf"><code class="docutils literal notranslate"><span class="pre">MapmriFit.pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.predict"><code class="docutils literal notranslate"><span class="pre">MapmriFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.qiv"><code class="docutils literal notranslate"><span class="pre">MapmriFit.qiv()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.rtap"><code class="docutils literal notranslate"><span class="pre">MapmriFit.rtap()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.rtop"><code class="docutils literal notranslate"><span class="pre">MapmriFit.rtop()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.rtpp"><code class="docutils literal notranslate"><span class="pre">MapmriFit.rtpp()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isotropic-scale-factor">isotropic_scale_factor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.isotropic_scale_factor"><code class="docutils literal notranslate"><span class="pre">isotropic_scale_factor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-index-matrix">mapmri_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_index_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#b-mat">b_mat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.b_mat"><code class="docutils literal notranslate"><span class="pre">b_mat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#b-mat-isotropic">b_mat_isotropic</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.b_mat_isotropic"><code class="docutils literal notranslate"><span class="pre">b_mat_isotropic()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-phi-1d">mapmri_phi_1d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_phi_1d"><code class="docutils literal notranslate"><span class="pre">mapmri_phi_1d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-phi-matrix">mapmri_phi_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_phi_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_phi_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-psi-1d">mapmri_psi_1d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_psi_1d"><code class="docutils literal notranslate"><span class="pre">mapmri_psi_1d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-psi-matrix">mapmri_psi_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_psi_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_psi_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-odf-matrix">mapmri_odf_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_odf_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_odf_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-phi-matrix">mapmri_isotropic_phi_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_phi_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-radial-signal-basis">mapmri_isotropic_radial_signal_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_signal_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-m-mu-independent">mapmri_isotropic_M_mu_independent</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_independent()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-m-mu-dependent">mapmri_isotropic_M_mu_dependent</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_dependent()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-psi-matrix">mapmri_isotropic_psi_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_psi_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-radial-pdf-basis">mapmri_isotropic_radial_pdf_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_pdf_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-k-mu-independent">mapmri_isotropic_K_mu_independent</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_independent()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-k-mu-dependent">mapmri_isotropic_K_mu_dependent</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_dependent()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binomialfloat">binomialfloat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.binomialfloat"><code class="docutils literal notranslate"><span class="pre">binomialfloat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-odf-matrix">mapmri_isotropic_odf_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-odf-sh-matrix">mapmri_isotropic_odf_sh_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_sh_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-laplacian-reg-matrix">mapmri_isotropic_laplacian_reg_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-laplacian-reg-matrix-from-index-matrix">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-index-matrix">mapmri_isotropic_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_index_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-rspace">create_rspace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.create_rspace"><code class="docutils literal notranslate"><span class="pre">create_rspace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#delta">delta</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.delta"><code class="docutils literal notranslate"><span class="pre">delta()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#map-laplace-u">map_laplace_u</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.map_laplace_u"><code class="docutils literal notranslate"><span class="pre">map_laplace_u()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#map-laplace-t">map_laplace_t</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.map_laplace_t"><code class="docutils literal notranslate"><span class="pre">map_laplace_t()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#map-laplace-s">map_laplace_s</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.map_laplace_s"><code class="docutils literal notranslate"><span class="pre">map_laplace_s()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-stu-reg-matrices">mapmri_STU_reg_matrices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_STU_reg_matrices"><code class="docutils literal notranslate"><span class="pre">mapmri_STU_reg_matrices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-laplacian-reg-matrix">mapmri_laplacian_reg_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_laplacian_reg_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalized-crossvalidation-array">generalized_crossvalidation_array</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.generalized_crossvalidation_array"><code class="docutils literal notranslate"><span class="pre">generalized_crossvalidation_array()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalized-crossvalidation">generalized_crossvalidation</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.generalized_crossvalidation"><code class="docutils literal notranslate"><span class="pre">generalized_crossvalidation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gcv-cost-function">gcv_cost_function</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.gcv_cost_function"><code class="docutils literal notranslate"><span class="pre">gcv_cost_function()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multishellresponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiShellResponse</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellResponse"><code class="docutils literal notranslate"><span class="pre">MultiShellResponse</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellResponse.iso"><code class="docutils literal notranslate"><span class="pre">MultiShellResponse.iso</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multishelldeconvmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiShellDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellDeconvModel"><code class="docutils literal notranslate"><span class="pre">MultiShellDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellDeconvModel.fit"><code class="docutils literal notranslate"><span class="pre">MultiShellDeconvModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellDeconvModel.predict"><code class="docutils literal notranslate"><span class="pre">MultiShellDeconvModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#msdeconvfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MSDeconvFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MSDeconvFit"><code class="docutils literal notranslate"><span class="pre">MSDeconvFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MSDeconvFit.all_shm_coeff"><code class="docutils literal notranslate"><span class="pre">MSDeconvFit.all_shm_coeff</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MSDeconvFit.shm_coeff"><code class="docutils literal notranslate"><span class="pre">MSDeconvFit.shm_coeff</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MSDeconvFit.volume_fractions"><code class="docutils literal notranslate"><span class="pre">MSDeconvFit.volume_fractions</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qpfitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">QpFitter</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.QpFitter"><code class="docutils literal notranslate"><span class="pre">QpFitter</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-tissue-basis">multi_tissue_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.multi_tissue_basis"><code class="docutils literal notranslate"><span class="pre">multi_tissue_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solve-qp">solve_qp</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.solve_qp"><code class="docutils literal notranslate"><span class="pre">solve_qp()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-shell-fiber-response">multi_shell_fiber_response</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.multi_shell_fiber_response"><code class="docutils literal notranslate"><span class="pre">multi_shell_fiber_response()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mask-for-response-msmt">mask_for_response_msmt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.mask_for_response_msmt"><code class="docutils literal notranslate"><span class="pre">mask_for_response_msmt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#response-from-mask-msmt">response_from_mask_msmt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.response_from_mask_msmt"><code class="docutils literal notranslate"><span class="pre">response_from_mask_msmt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#auto-response-msmt">auto_response_msmt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.auto_response_msmt"><code class="docutils literal notranslate"><span class="pre">auto_response_msmt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#meandiffusionkurtosismodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#meandiffusionkurtosisfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.S0_hat"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.S0_hat</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.msd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.msk()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.smt2di()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.smt2f()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.smt2uFA()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mean-signal-bvalue">mean_signal_bvalue</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.mean_signal_bvalue"><code class="docutils literal notranslate"><span class="pre">mean_signal_bvalue()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#msk-from-awf">msk_from_awf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.msk_from_awf"><code class="docutils literal notranslate"><span class="pre">msk_from_awf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#awf-from-msk">awf_from_msk</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.awf_from_msk"><code class="docutils literal notranslate"><span class="pre">awf_from_msk()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#msdki-prediction">msdki_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.msdki_prediction"><code class="docutils literal notranslate"><span class="pre">msdki_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wls-fit-msdki">wls_fit_msdki</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.wls_fit_msdki"><code class="docutils literal notranslate"><span class="pre">wls_fit_msdki()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id302">design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.design_matrix"><code class="docutils literal notranslate"><span class="pre">design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multivoxelfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.MultiVoxelFit"><code class="docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.MultiVoxelFit.predict"><code class="docutils literal notranslate"><span class="pre">MultiVoxelFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.MultiVoxelFit.shape"><code class="docutils literal notranslate"><span class="pre">MultiVoxelFit.shape</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#callablearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CallableArray</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.CallableArray"><code class="docutils literal notranslate"><span class="pre">CallableArray</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-voxel-fit">multi_voxel_fit</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.multi_voxel_fit"><code class="docutils literal notranslate"><span class="pre">multi_voxel_fit()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odfmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfModel"><code class="docutils literal notranslate"><span class="pre">OdfModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfModel.fit"><code class="docutils literal notranslate"><span class="pre">OdfModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odffit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfFit"><code class="docutils literal notranslate"><span class="pre">OdfFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfFit.odf"><code class="docutils literal notranslate"><span class="pre">OdfFit.odf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gfa">gfa</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.gfa"><code class="docutils literal notranslate"><span class="pre">gfa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minmax-normalize">minmax_normalize</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.minmax_normalize"><code class="docutils literal notranslate"><span class="pre">minmax_normalize()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmrimodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriModel"><code class="docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriModel.fit"><code class="docutils literal notranslate"><span class="pre">QtdmriModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmrifit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit"><code class="docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.fitted_signal"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.fitted_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.msd"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.msd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.norm_of_laplacian_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.odf"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.odf_sh"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.odf_sh()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.pdf"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.predict"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.qiv"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.qiv()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.qtdmri_to_mapmri_coef()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.rtap"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.rtap()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.rtop"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.rtop()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.rtpp"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.rtpp()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_abs"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.sparsity_abs()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_density"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.sparsity_density()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-to-mapmri-matrix">qtdmri_to_mapmri_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_to_mapmri_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-to-mapmri-matrix">qtdmri_isotropic_to_mapmri_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_to_mapmri_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-temporal-normalization">qtdmri_temporal_normalization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_temporal_normalization"><code class="docutils literal notranslate"><span class="pre">qtdmri_temporal_normalization()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-mapmri-normalization">qtdmri_mapmri_normalization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_mapmri_normalization"><code class="docutils literal notranslate"><span class="pre">qtdmri_mapmri_normalization()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-mapmri-isotropic-normalization">qtdmri_mapmri_isotropic_normalization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization"><code class="docutils literal notranslate"><span class="pre">qtdmri_mapmri_isotropic_normalization()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-signal-matrix">qtdmri_signal_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_signal_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-eap-matrix">qtdmri_eap_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_eap_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-signal-matrix">qtdmri_isotropic_signal_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_signal_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-eap-matrix">qtdmri_isotropic_eap_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_eap_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radial-basis-opt">radial_basis_opt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.radial_basis_opt"><code class="docutils literal notranslate"><span class="pre">radial_basis_opt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#angular-basis-opt">angular_basis_opt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.angular_basis_opt"><code class="docutils literal notranslate"><span class="pre">angular_basis_opt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radial-basis-eap-opt">radial_basis_EAP_opt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.radial_basis_EAP_opt"><code class="docutils literal notranslate"><span class="pre">radial_basis_EAP_opt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#angular-basis-eap-opt">angular_basis_EAP_opt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.angular_basis_EAP_opt"><code class="docutils literal notranslate"><span class="pre">angular_basis_EAP_opt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#temporal-basis">temporal_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.temporal_basis"><code class="docutils literal notranslate"><span class="pre">temporal_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-index-matrix">qtdmri_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_index_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-index-matrix">qtdmri_isotropic_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-laplacian-reg-matrix">qtdmri_laplacian_reg_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_laplacian_reg_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-laplacian-reg-matrix">qtdmri_isotropic_laplacian_reg_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_laplacian_reg_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part23-reg-matrix-q">part23_reg_matrix_q</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part23_reg_matrix_q"><code class="docutils literal notranslate"><span class="pre">part23_reg_matrix_q()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part23-iso-reg-matrix-q">part23_iso_reg_matrix_q</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part23_iso_reg_matrix_q"><code class="docutils literal notranslate"><span class="pre">part23_iso_reg_matrix_q()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part4-reg-matrix-q">part4_reg_matrix_q</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part4_reg_matrix_q"><code class="docutils literal notranslate"><span class="pre">part4_reg_matrix_q()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part4-iso-reg-matrix-q">part4_iso_reg_matrix_q</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part4_iso_reg_matrix_q"><code class="docutils literal notranslate"><span class="pre">part4_iso_reg_matrix_q()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part1-reg-matrix-tau">part1_reg_matrix_tau</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part1_reg_matrix_tau"><code class="docutils literal notranslate"><span class="pre">part1_reg_matrix_tau()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part23-reg-matrix-tau">part23_reg_matrix_tau</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part23_reg_matrix_tau"><code class="docutils literal notranslate"><span class="pre">part23_reg_matrix_tau()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part4-reg-matrix-tau">part4_reg_matrix_tau</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part4_reg_matrix_tau"><code class="docutils literal notranslate"><span class="pre">part4_reg_matrix_tau()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#h">H</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.H"><code class="docutils literal notranslate"><span class="pre">H()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id345">generalized_crossvalidation</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.generalized_crossvalidation"><code class="docutils literal notranslate"><span class="pre">generalized_crossvalidation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id347">GCV_cost_function</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.GCV_cost_function"><code class="docutils literal notranslate"><span class="pre">GCV_cost_function()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-scaling">qtdmri_isotropic_scaling</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_scaling"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_scaling()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-anisotropic-scaling">qtdmri_anisotropic_scaling</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling"><code class="docutils literal notranslate"><span class="pre">qtdmri_anisotropic_scaling()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#design-matrix-spatial">design_matrix_spatial</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.design_matrix_spatial"><code class="docutils literal notranslate"><span class="pre">design_matrix_spatial()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-rt-space-grid">create_rt_space_grid</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.create_rt_space_grid"><code class="docutils literal notranslate"><span class="pre">create_rt_space_grid()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-number-of-coefficients">qtdmri_number_of_coefficients</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_number_of_coefficients"><code class="docutils literal notranslate"><span class="pre">qtdmri_number_of_coefficients()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#l1-crossvalidation">l1_crossvalidation</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.l1_crossvalidation"><code class="docutils literal notranslate"><span class="pre">l1_crossvalidation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#elastic-crossvalidation">elastic_crossvalidation</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.elastic_crossvalidation"><code class="docutils literal notranslate"><span class="pre">elastic_crossvalidation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualise-gradient-table-g-delta-rainbow">visualise_gradient_table_G_Delta_rainbow</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow"><code class="docutils literal notranslate"><span class="pre">visualise_gradient_table_G_Delta_rainbow()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtimodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtiModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiModel"><code class="docutils literal notranslate"><span class="pre">QtiModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiModel.fit"><code class="docutils literal notranslate"><span class="pre">QtiModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiModel.predict"><code class="docutils literal notranslate"><span class="pre">QtiModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtifit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtiFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit"><code class="docutils literal notranslate"><span class="pre">QtiFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.S0_hat"><code class="docutils literal notranslate"><span class="pre">QtiFit.S0_hat()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.c_c"><code class="docutils literal notranslate"><span class="pre">QtiFit.c_c()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.c_m"><code class="docutils literal notranslate"><span class="pre">QtiFit.c_m()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.c_md"><code class="docutils literal notranslate"><span class="pre">QtiFit.c_md()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.c_mu"><code class="docutils literal notranslate"><span class="pre">QtiFit.c_mu()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.d_sq"><code class="docutils literal notranslate"><span class="pre">QtiFit.d_sq()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.fa"><code class="docutils literal notranslate"><span class="pre">QtiFit.fa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.k_bulk"><code class="docutils literal notranslate"><span class="pre">QtiFit.k_bulk()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.k_mu"><code class="docutils literal notranslate"><span class="pre">QtiFit.k_mu()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.k_shear"><code class="docutils literal notranslate"><span class="pre">QtiFit.k_shear()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.md"><code class="docutils literal notranslate"><span class="pre">QtiFit.md()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.mean_d_sq"><code class="docutils literal notranslate"><span class="pre">QtiFit.mean_d_sq()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.mk"><code class="docutils literal notranslate"><span class="pre">QtiFit.mk()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.predict"><code class="docutils literal notranslate"><span class="pre">QtiFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.ufa"><code class="docutils literal notranslate"><span class="pre">QtiFit.ufa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.v_iso"><code class="docutils literal notranslate"><span class="pre">QtiFit.v_iso()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.v_md"><code class="docutils literal notranslate"><span class="pre">QtiFit.v_md()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.v_shear"><code class="docutils literal notranslate"><span class="pre">QtiFit.v_shear()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-3x3-to-6x1">from_3x3_to_6x1</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.from_3x3_to_6x1"><code class="docutils literal notranslate"><span class="pre">from_3x3_to_6x1()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-6x1-to-3x3">from_6x1_to_3x3</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.from_6x1_to_3x3"><code class="docutils literal notranslate"><span class="pre">from_6x1_to_3x3()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-6x6-to-21x1">from_6x6_to_21x1</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.from_6x6_to_21x1"><code class="docutils literal notranslate"><span class="pre">from_6x6_to_21x1()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-21x1-to-6x6">from_21x1_to_6x6</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.from_21x1_to_6x6"><code class="docutils literal notranslate"><span class="pre">from_21x1_to_6x6()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cvxpy-1x6-to-3x3">cvxpy_1x6_to_3x3</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.cvxpy_1x6_to_3x3"><code class="docutils literal notranslate"><span class="pre">cvxpy_1x6_to_3x3()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cvxpy-1x21-to-6x6">cvxpy_1x21_to_6x6</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.cvxpy_1x21_to_6x6"><code class="docutils literal notranslate"><span class="pre">cvxpy_1x21_to_6x6()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dtd-covariance">dtd_covariance</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.dtd_covariance"><code class="docutils literal notranslate"><span class="pre">dtd_covariance()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qti-signal">qti_signal</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.qti_signal"><code class="docutils literal notranslate"><span class="pre">qti_signal()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id351">design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.design_matrix"><code class="docutils literal notranslate"><span class="pre">design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rumbasdmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">RumbaSDModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaSDModel"><code class="docutils literal notranslate"><span class="pre">RumbaSDModel</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rumbafit"><code class="xref py py-class docutils literal notranslate"><span class="pre">RumbaFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit"><code class="docutils literal notranslate"><span class="pre">RumbaFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.combined_odf_iso"><code class="docutils literal notranslate"><span class="pre">RumbaFit.combined_odf_iso()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.f_csf"><code class="docutils literal notranslate"><span class="pre">RumbaFit.f_csf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.f_gm"><code class="docutils literal notranslate"><span class="pre">RumbaFit.f_gm()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.f_iso"><code class="docutils literal notranslate"><span class="pre">RumbaFit.f_iso()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.f_wm"><code class="docutils literal notranslate"><span class="pre">RumbaFit.f_wm()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.odf"><code class="docutils literal notranslate"><span class="pre">RumbaFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.predict"><code class="docutils literal notranslate"><span class="pre">RumbaFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rumba-deconv">rumba_deconv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.rumba_deconv"><code class="docutils literal notranslate"><span class="pre">rumba_deconv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mbessel-ratio">mbessel_ratio</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.mbessel_ratio"><code class="docutils literal notranslate"><span class="pre">mbessel_ratio()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generate-kernel">generate_kernel</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.generate_kernel"><code class="docutils literal notranslate"><span class="pre">generate_kernel()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rumba-deconv-global">rumba_deconv_global</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.rumba_deconv_global"><code class="docutils literal notranslate"><span class="pre">rumba_deconv_global()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isotropicmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicModel"><code class="docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicModel.fit"><code class="docutils literal notranslate"><span class="pre">IsotropicModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isotropicfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicFit"><code class="docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicFit.predict"><code class="docutils literal notranslate"><span class="pre">IsotropicFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exponentialisotropicmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicModel"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicModel.fit"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exponentialisotropicfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicFit"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicFit.predict"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sparsefasciclemodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleModel"><code class="docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleModel.design_matrix"><code class="docutils literal notranslate"><span class="pre">SparseFascicleModel.design_matrix()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleModel.fit"><code class="docutils literal notranslate"><span class="pre">SparseFascicleModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sparsefasciclefit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleFit"><code class="docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleFit.odf"><code class="docutils literal notranslate"><span class="pre">SparseFascicleFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleFit.predict"><code class="docutils literal notranslate"><span class="pre">SparseFascicleFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sfm-design-matrix">sfm_design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.sfm_design_matrix"><code class="docutils literal notranslate"><span class="pre">sfm_design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sphharmmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmModel"><code class="docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmModel.sampling_matrix"><code class="docutils literal notranslate"><span class="pre">SphHarmModel.sampling_matrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qballbasemodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.QballBaseModel"><code class="docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.QballBaseModel.fit"><code class="docutils literal notranslate"><span class="pre">QballBaseModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sphharmfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit"><code class="docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.gfa"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.gfa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.odf"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.predict"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.shape"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.shape</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.shm_coeff"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.shm_coeff</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#csaodfmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.CsaOdfModel"><code class="docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.CsaOdfModel.max"><code class="docutils literal notranslate"><span class="pre">CsaOdfModel.max</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.CsaOdfModel.min"><code class="docutils literal notranslate"><span class="pre">CsaOdfModel.min</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#opdtmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpdtModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.OpdtModel"><code class="docutils literal notranslate"><span class="pre">OpdtModel</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qballmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.QballModel"><code class="docutils literal notranslate"><span class="pre">QballModel</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#residualbootstrapwrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.ResidualBootstrapWrapper"><code class="docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forward-sdeconv-mat">forward_sdeconv_mat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.forward_sdeconv_mat"><code class="docutils literal notranslate"><span class="pre">forward_sdeconv_mat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sh-to-rh">sh_to_rh</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sh_to_rh"><code class="docutils literal notranslate"><span class="pre">sh_to_rh()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gen-dirac">gen_dirac</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.gen_dirac"><code class="docutils literal notranslate"><span class="pre">gen_dirac()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spherical-harmonics">spherical_harmonics</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.spherical_harmonics"><code class="docutils literal notranslate"><span class="pre">spherical_harmonics()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sph-harm">real_sph_harm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sph_harm"><code class="docutils literal notranslate"><span class="pre">real_sph_harm()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sh-tournier-from-index">real_sh_tournier_from_index</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sh_tournier_from_index"><code class="docutils literal notranslate"><span class="pre">real_sh_tournier_from_index()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sh-descoteaux-from-index">real_sh_descoteaux_from_index</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sh_descoteaux_from_index"><code class="docutils literal notranslate"><span class="pre">real_sh_descoteaux_from_index()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sh-tournier">real_sh_tournier</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sh_tournier"><code class="docutils literal notranslate"><span class="pre">real_sh_tournier()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sh-descoteaux">real_sh_descoteaux</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sh_descoteaux"><code class="docutils literal notranslate"><span class="pre">real_sh_descoteaux()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sym-sh-mrtrix">real_sym_sh_mrtrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sym_sh_mrtrix"><code class="docutils literal notranslate"><span class="pre">real_sym_sh_mrtrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sym-sh-basis">real_sym_sh_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sym_sh_basis"><code class="docutils literal notranslate"><span class="pre">real_sym_sh_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sph-harm-ind-list">sph_harm_ind_list</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sph_harm_ind_list"><code class="docutils literal notranslate"><span class="pre">sph_harm_ind_list()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#order-from-ncoef">order_from_ncoef</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.order_from_ncoef"><code class="docutils literal notranslate"><span class="pre">order_from_ncoef()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#smooth-pinv">smooth_pinv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.smooth_pinv"><code class="docutils literal notranslate"><span class="pre">smooth_pinv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lazy-index">lazy_index</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.lazy_index"><code class="docutils literal notranslate"><span class="pre">lazy_index()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#normalize-data">normalize_data</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.normalize_data"><code class="docutils literal notranslate"><span class="pre">normalize_data()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hat">hat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.hat"><code class="docutils literal notranslate"><span class="pre">hat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lcr-matrix">lcr_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.lcr_matrix"><code class="docutils literal notranslate"><span class="pre">lcr_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bootstrap-data-array">bootstrap_data_array</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.bootstrap_data_array"><code class="docutils literal notranslate"><span class="pre">bootstrap_data_array()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bootstrap-data-voxel">bootstrap_data_voxel</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.bootstrap_data_voxel"><code class="docutils literal notranslate"><span class="pre">bootstrap_data_voxel()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sf-to-sh">sf_to_sh</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sf_to_sh"><code class="docutils literal notranslate"><span class="pre">sf_to_sh()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sh-to-sf">sh_to_sf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sh_to_sf"><code class="docutils literal notranslate"><span class="pre">sh_to_sf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sh-to-sf-matrix">sh_to_sf_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sh_to_sf_matrix"><code class="docutils literal notranslate"><span class="pre">sh_to_sf_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calculate-max-order">calculate_max_order</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.calculate_max_order"><code class="docutils literal notranslate"><span class="pre">calculate_max_order()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anisotropic-power">anisotropic_power</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.anisotropic_power"><code class="docutils literal notranslate"><span class="pre">anisotropic_power()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convert-sh-to-full-basis">convert_sh_to_full_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.convert_sh_to_full_basis"><code class="docutils literal notranslate"><span class="pre">convert_sh_to_full_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convert-sh-from-legacy">convert_sh_from_legacy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.convert_sh_from_legacy"><code class="docutils literal notranslate"><span class="pre">convert_sh_from_legacy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convert-sh-to-legacy">convert_sh_to_legacy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.convert_sh_to_legacy"><code class="docutils literal notranslate"><span class="pre">convert_sh_to_legacy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convert-sh-descoteaux-tournier">convert_sh_descoteaux_tournier</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.convert_sh_descoteaux_tournier"><code class="docutils literal notranslate"><span class="pre">convert_sh_descoteaux_tournier()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shoremodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreModel"><code class="docutils literal notranslate"><span class="pre">ShoreModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreModel.fit"><code class="docutils literal notranslate"><span class="pre">ShoreModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shorefit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit"><code class="docutils literal notranslate"><span class="pre">ShoreFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.fitted_signal"><code class="docutils literal notranslate"><span class="pre">ShoreFit.fitted_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.msd"><code class="docutils literal notranslate"><span class="pre">ShoreFit.msd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.odf"><code class="docutils literal notranslate"><span class="pre">ShoreFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.odf_sh"><code class="docutils literal notranslate"><span class="pre">ShoreFit.odf_sh()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.pdf"><code class="docutils literal notranslate"><span class="pre">ShoreFit.pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.pdf_grid"><code class="docutils literal notranslate"><span class="pre">ShoreFit.pdf_grid()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.rtop_pdf"><code class="docutils literal notranslate"><span class="pre">ShoreFit.rtop_pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.rtop_signal"><code class="docutils literal notranslate"><span class="pre">ShoreFit.rtop_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.shore_coeff"><code class="docutils literal notranslate"><span class="pre">ShoreFit.shore_coeff</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-matrix">shore_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_matrix"><code class="docutils literal notranslate"><span class="pre">shore_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-matrix-pdf">shore_matrix_pdf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_matrix_pdf"><code class="docutils literal notranslate"><span class="pre">shore_matrix_pdf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-matrix-odf">shore_matrix_odf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_matrix_odf"><code class="docutils literal notranslate"><span class="pre">shore_matrix_odf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#l-shore">l_shore</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.l_shore"><code class="docutils literal notranslate"><span class="pre">l_shore()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#n-shore">n_shore</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.n_shore"><code class="docutils literal notranslate"><span class="pre">n_shore()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id423">create_rspace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.create_rspace"><code class="docutils literal notranslate"><span class="pre">create_rspace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-indices">shore_indices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_indices"><code class="docutils literal notranslate"><span class="pre">shore_indices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-order">shore_order</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_order"><code class="docutils literal notranslate"><span class="pre">shore_order()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dki-design-matrix">dki_design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.utils.dki_design_matrix"><code class="docutils literal notranslate"><span class="pre">dki_design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cti-design-matrix">cti_design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.utils.cti_design_matrix"><code class="docutils literal notranslate"><span class="pre">cti_design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convert-tensors">convert_tensors</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.utils.convert_tensors"><code class="docutils literal notranslate"><span class="pre">convert_tensors()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#simple-cutoff">simple_cutoff</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.weights_method.simple_cutoff"><code class="docutils literal notranslate"><span class="pre">simple_cutoff()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#two-eyes-cutoff">two_eyes_cutoff</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.weights_method.two_eyes_cutoff"><code class="docutils literal notranslate"><span class="pre">two_eyes_cutoff()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#weights-method-wls-m-est">weights_method_wls_m_est</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.weights_method.weights_method_wls_m_est"><code class="docutils literal notranslate"><span class="pre">weights_method_wls_m_est()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#weights-method-nlls-m-est">weights_method_nlls_m_est</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.weights_method.weights_method_nlls_m_est"><code class="docutils literal notranslate"><span class="pre">weights_method_nlls_m_est()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  
<script type="module" src="../_static/scripts/grg-sphinx-theme.js"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item"><div>
  <h3 class="footer-heading">
    Never miss an update from us!
  </h3>
  <p class="footer-sub-heading">
    Don't worry! we are not going to spam you.
  </p>
  <div class="input-group mb-3 mar-t-10">
    <input type="text" class="form-control" placeholder="You email" aria-label="You email" id="grg-subscribe-email">
    <div class="input-group-append pointer" onclick="(document.getElementById('grg-subscribe-email').value)">
      <span class="input-group-text subscribe">Subscribe</span>
    </div>
  </div>  
  <ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dipy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/dipymri" title="Twitter/X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Twitter/X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/c/diffusionimaginginpython" title="YouTube" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-youtube fa-lg" aria-hidden="true"></i>
            <span class="sr-only">YouTube</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/dipy/" title="LinkedIn" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i>
            <span class="sr-only">LinkedIn</span></a>
        </li>
</ul>
</div></div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><div class="grid-3">
  
  <div>
    <h5 class="footer-heading">
      About
    </h5>
    <ul class="footer-section">
      
        
        <li class="pad-v-5">
          <a href="https://dipy.org/team">
            Developers
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://github.com/dipy/dipy/discussions" target="_blank" rel="noopener noreferrer">
            Support
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="../user_guide/installation.html">
            Download
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="../user_guide/getting_started.html">
            Get Started
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="../examples_built/index.html">
            Tutorials
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://www.youtube.com/c/diffusionimaginginpython" target="_blank" rel="noopener noreferrer">
            Videos
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
    </ul>
  </div>
  
  <div>
    <h5 class="footer-heading">
      Friends
    </h5>
    <ul class="footer-section">
      
        
        <li class="pad-v-5">
          <a href="http://nipy.org/" target="_blank" rel="noopener noreferrer">
            Nipy Projects
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="http://fury.gl/" target="_blank" rel="noopener noreferrer">
            FURY
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="http://nipy.org/nibabel" target="_blank" rel="noopener noreferrer">
            Nibabel
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://tortoise.nibib.nih.gov/" target="_blank" rel="noopener noreferrer">
            Tortoise
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
    </ul>
  </div>
  
  <div>
    <h5 class="footer-heading">
      Support
    </h5>
    <ul class="footer-section">
      
        
        <li class="pad-v-5">
          <a href="https://engineering.indiana.edu/" target="_blank" rel="noopener noreferrer">
            The department of Intelligent Systems Engineering of Indiana University
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://www.nibib.nih.gov/" target="_blank" rel="noopener noreferrer">
            The National Institute of Biomedical Imaging and Bioengineering, NIH
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://escience.washington.edu" target="_blank" rel="noopener noreferrer">
            The Gordon and Betty Moore Foundation and the Alfred P. Sloan Foundation, through the University of Washington eScience Institute Data Science Environment
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://summerofcode.withgoogle.com/" target="_blank" rel="noopener noreferrer">
            Google supported DIPY through the Google Summer of Code Program (2015-2024)
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
    </ul>
  </div>
  
</div></div>
      
    </div>
  
</div>

    <div class="copyright-text">
      <i class="fa-regular fa-copyright"></i> Copyright 2008-2025,DIPY developers. Created using Grg Sphinx Theme and PyData Sphinx Theme.
    </div>
  </footer>
  </body>
</html>