
<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>DIPY &#8212; dipy 1.8.0dev0 documentation</title>
  
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/dipy.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

  
<link rel="stylesheet" href="../../_static/styles/grg-sphinx-theme.css"/>

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'auto_examples/reconstruction/reconst_rumba';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />

  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">




  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
<nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    <p class="title logo__title">dipy 1.8.0dev0 documentation</p>
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../documentation.html">
                        Documentation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../stateoftheart.html">
                        A quick overview of features
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

</nav>
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../documentation.html">
                        Documentation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../stateoftheart.html">
                        A quick overview of features
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item"><nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="reconst_qtiplus.html">Applying positivity constraints to Q-space Trajectory Imaging (QTI+)</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_shore.html">Continuous and analytical diffusion signal modelling with 3D-SHORE</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_dsi.html">Reconstruct with Diffusion Spectrum Imaging</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_dsid.html">DSI Deconvolution vs DSI</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_shore_metrics.html">Calculate SHORE scalar maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_gqi.html">Reconstruct with Generalized Q-Sampling Imaging</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_csa.html">Reconstruct with Constant Solid Angle (Q-Ball)</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_sfm.html">Reconstruction with the Sparse Fascicle Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_dsi_metrics.html">Calculate DSI-based scalar maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_dki.html">Reconstruction of the diffusion signal with the kurtosis tensor model</a></li>
<li class="toctree-l1"><a class="reference internal" href="kfold_xval.html">K-fold cross-validation for model comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_qti.html">Reconstruct with Q-space Trajectory Imaging (QTI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_dti.html">Reconstruction of the diffusion signal with the Tensor model</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_forecast.html">Crossing invariant fiber response function with FORECAST model</a></li>
<li class="toctree-l1"><a class="reference internal" href="restore_dti.html">Using the RESTORE algorithm for robust tensor fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_dki_micro.html">Reconstruction of the diffusion signal with the WMTI model</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_sh.html">Signal Reconstruction Using Spherical Harmonics</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_fwdti.html">Using the free water elimination model to remove DTI free water contamination</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_ivim.html">Intravoxel incoherent motion</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_csd.html">Reconstruction with Constrained Spherical Deconvolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_mcsd.html">Reconstruction with Multi-Shell Multi-Tissue CSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_mapmri.html">Continuous and analytical diffusion signal modelling with MAP-MRI</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_msdki.html">Mean signal diffusion kurtosis imaging (MSDKI)</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Reconstruction with Robust and Unbiased Model-BAsed Spherical Deconvolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="reconst_qtdmri.html">Estimating diffusion time dependent q-space indices using qt-dMRI</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">DIPY</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
<div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-auto-examples-reconstruction-reconst-rumba-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<section class="sphx-glr-example-title" id="reconstruction-with-robust-and-unbiased-model-based-spherical-deconvolution">
<span id="sphx-glr-auto-examples-reconstruction-reconst-rumba-py"></span><h1>Reconstruction with Robust and Unbiased Model-BAsed Spherical Deconvolution<a class="headerlink" href="#reconstruction-with-robust-and-unbiased-model-based-spherical-deconvolution" title="Permalink to this heading">#</a></h1>
<p>This example shows how to use RUMBA-SD to reconstruct fiber orientation
density functions (fODFs). This model was introduced by Canales-Rodriguez
et al <a class="reference internal" href="../../examples_built/reconstruction/reconst_rumba.html#canalesrodriguez2015" id="id1"><span>[CanalesRodriguez2015]</span></a>.</p>
<p>RUMBA-SD uses a priori information about the fiber response function (axial
and perpendicular diffusivities) to generate a convolution kernel mapping the
fODFs on a sphere to the recorded data. The fODFs are then estimated using an
iterative, maximum likelihood estimation algorithm adapted from Richardson-Lucy
(RL) deconvolution <a class="reference internal" href="../../examples_built/reconstruction/reconst_rumba.html#richardson1972" id="id2"><span>[Richardson1972]</span></a>. Specifically, the RL algorithm assumes
Gaussian noise, while RUMBA assumes Rician/Noncentral Chi noise – these more
accurately reflect the noise generated by MRI scanners <a class="reference internal" href="../../examples_built/reconstruction/reconst_rumba.html#constantinides1997" id="id3"><span>[Constantinides1997]</span></a>.
This algorithm also contains an optional compartment for estimating an
isotropic volume fraction to account for partial volume effects. RUMBA-SD works
with single- and multi-shell data, as well as data recorded in Cartesian or
spherical coordinate systems.</p>
<p>The result from RUMBA-SD can be smoothed by applying total variation spatial
regularization (termed RUMBA-SD + TV), a technique which promotes a more
coherent estimate of the fODFs across neighboring voxels <a class="reference internal" href="../../examples_built/reconstruction/reconst_rumba.html#rudin1992" id="id4"><span>[Rudin1992]</span></a>.
This regularization ability is also included in this implementation.</p>
<dl class="simple">
<dt>This example will showcase how to:</dt><dd><ol class="arabic simple">
<li><p>Estimate the fiber response function</p></li>
<li><p>Reconstruct the fODFs voxel-wise or globally with TV regularization</p></li>
<li><p>Visualize fODF maps</p></li>
</ol>
</dd>
</dl>
<p>To begin, we will load the data, consisting of 10 b0s and 150 non-b0s with a
b-value of 2000.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="kn">import</span> <a href="../../reference/dipy.core.html#dipy.core.gradients.gradient_table" title="dipy.core.gradients.gradient_table" class="sphx-glr-backref-module-dipy-core-gradients sphx-glr-backref-type-py-function"><span class="n">gradient_table</span></a>
<span class="kn">from</span> <span class="nn">dipy.data</span> <span class="kn">import</span> <span class="n">get_fnames</span><span class="p">,</span> <a href="../../reference/dipy.data.html#dipy.data.get_sphere" title="dipy.data.get_sphere" class="sphx-glr-backref-module-dipy-data sphx-glr-backref-type-py-function"><span class="n">get_sphere</span></a>
<span class="kn">from</span> <span class="nn">dipy.io.gradients</span> <span class="kn">import</span> <span class="n">read_bvals_bvecs</span>
<span class="kn">from</span> <span class="nn">dipy.io.image</span> <span class="kn">import</span> <a href="../../reference/dipy.io.html#dipy.io.image.load_nifti" title="dipy.io.image.load_nifti" class="sphx-glr-backref-module-dipy-io-image sphx-glr-backref-type-py-function"><span class="n">load_nifti</span></a>

<span class="n">hardi_fname</span><span class="p">,</span> <span class="n">hardi_bval_fname</span><span class="p">,</span> <span class="n">hardi_bvec_fname</span> <span class="o">=</span> <span class="n">get_fnames</span><span class="p">(</span><span class="s1">&#39;stanford_hardi&#39;</span><span class="p">)</span>
<span class="n">data</span><span class="p">,</span> <span class="n">affine</span> <span class="o">=</span> <a href="../../reference/dipy.io.html#dipy.io.image.load_nifti" title="dipy.io.image.load_nifti" class="sphx-glr-backref-module-dipy-io-image sphx-glr-backref-type-py-function"><span class="n">load_nifti</span></a><span class="p">(</span><span class="n">hardi_fname</span><span class="p">)</span>

<span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span> <span class="o">=</span> <span class="n">read_bvals_bvecs</span><span class="p">(</span><span class="n">hardi_bval_fname</span><span class="p">,</span> <span class="n">hardi_bvec_fname</span><span class="p">)</span>
<span class="n">gtab</span> <span class="o">=</span> <a href="../../reference/dipy.core.html#dipy.core.gradients.gradient_table" title="dipy.core.gradients.gradient_table" class="sphx-glr-backref-module-dipy-core-gradients sphx-glr-backref-type-py-function"><span class="n">gradient_table</span></a><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="p">)</span>

<span class="n">sphere</span> <span class="o">=</span> <a href="../../reference/dipy.data.html#dipy.data.get_sphere" title="dipy.data.get_sphere" class="sphx-glr-backref-module-dipy-data sphx-glr-backref-type-py-function"><span class="n">get_sphere</span></a><span class="p">(</span><span class="s1">&#39;symmetric362&#39;</span><span class="p">)</span>
</pre></div>
</div>
<section id="step-1-estimation-of-the-fiber-response-function">
<h2>Step 1. Estimation of the fiber response function<a class="headerlink" href="#step-1-estimation-of-the-fiber-response-function" title="Permalink to this heading">#</a></h2>
<p>There are multiple ways to estimate the fiber response function.</p>
<p><strong>Strategy 1: use default values</strong>
One simple approach is to use the values included as the default arguments in
the RumbaSDModel constructor. The white matter response, <cite>wm_response</cite> has three
values corresponding to the tensor eigenvalues (1.7e-3, 0.2e-3, 0.2e-3). The
model has compartments for cerebrospinal fluid (CSF) (<cite>csf_response</cite>) and
grey matter (GM) (<cite>gm_response</cite>) as well, with these mean diffusivities set
to 3.0e-3 and 0.8e-3 respectively <a class="reference internal" href="../../examples_built/reconstruction/reconst_rumba.html#canalesrodriguez2015" id="id5"><span>[CanalesRodriguez2015]</span></a>. These default
values will often be adequate as RUMBA-SD is robust against impulse response
imprecision [Dell’Acqua2007]_.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dipy.reconst.rumba</span> <span class="kn">import</span> <a href="../../reference/dipy.reconst.html#dipy.reconst.rumba.RumbaSDModel" title="dipy.reconst.rumba.RumbaSDModel" class="sphx-glr-backref-module-dipy-reconst-rumba sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">RumbaSDModel</span></a>

<span class="n">rumba</span> <span class="o">=</span> <a href="../../reference/dipy.reconst.html#dipy.reconst.rumba.RumbaSDModel" title="dipy.reconst.rumba.RumbaSDModel" class="sphx-glr-backref-module-dipy-reconst-rumba sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">RumbaSDModel</span></a><span class="p">(</span><span class="n">gtab</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;wm_response: </span><span class="si">{</span><span class="n">rumba</span><span class="o">.</span><span class="n">wm_response</span><span class="si">}</span><span class="s2">, &quot;</span> <span class="o">+</span>
      <span class="sa">f</span><span class="s2">&quot;csf_response: </span><span class="si">{</span><span class="n">rumba</span><span class="o">.</span><span class="n">csf_response</span><span class="si">}</span><span class="s2">, &quot;</span> <span class="o">+</span>
      <span class="sa">f</span><span class="s2">&quot;gm_response: </span><span class="si">{</span><span class="n">rumba</span><span class="o">.</span><span class="n">gm_response</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>wm_response: [0.0017 0.0002 0.0002]
csf_response: 0.003
gm_response: 0.0008</p>
<p>We can visualize what this default response looks like.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dipy.sims.voxel</span> <span class="kn">import</span> <a href="../../reference/dipy.sims.html#dipy.sims.voxel.single_tensor_odf" title="dipy.sims.voxel.single_tensor_odf" class="sphx-glr-backref-module-dipy-sims-voxel sphx-glr-backref-type-py-function"><span class="n">single_tensor_odf</span></a>
<span class="kn">from</span> <span class="nn">dipy.viz</span> <span class="kn">import</span> <span class="n">window</span><span class="p">,</span> <span class="n">actor</span>

<span class="c1"># Enables/disables interactive visualization</span>
<span class="n">interactive</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">scene</span> <span class="o">=</span> <span class="n">window</span><span class="o">.</span><span class="n">Scene</span><span class="p">()</span>

<span class="n">evals</span> <span class="o">=</span> <span class="n">rumba</span><span class="o">.</span><span class="n">wm_response</span>
<span class="n">evecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

<span class="n">response_odf</span> <span class="o">=</span> <a href="../../reference/dipy.sims.html#dipy.sims.voxel.single_tensor_odf" title="dipy.sims.voxel.single_tensor_odf" class="sphx-glr-backref-module-dipy-sims-voxel sphx-glr-backref-type-py-function"><span class="n">single_tensor_odf</span></a><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span><span class="p">)</span>
<span class="c1"># Transform our data from 1D to 4D</span>
<span class="n">response_odf</span> <span class="o">=</span> <span class="n">response_odf</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">response_actor</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">odf_slicer</span><span class="p">(</span><span class="n">response_odf</span><span class="p">,</span> <span class="n">sphere</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span>
                                  <span class="n">colormap</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">)</span>

<span class="n">scene</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">response_actor</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving illustration as default_response.png&#39;</span><span class="p">)</span>
<span class="n">window</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">out_path</span><span class="o">=</span><span class="s1">&#39;default_response.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>

<span class="k">if</span> <span class="n">interactive</span><span class="p">:</span>
    <span class="n">window</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id8">
<img alt="auto_examples/reconstruction/default_response.png" src="auto_examples/reconstruction/default_response.png" />
<figcaption>
<p><span class="caption-text">Default response function.</span><a class="headerlink" href="#id8" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="o">.</span><span class="n">rm</span><span class="p">(</span><span class="n">response_actor</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Strategy 2: estimate from local brain region</strong>
The <cite>csdeconv</cite> module contains functions for estimating this response.
<cite>auto_response_sst</cite> extracts an ROI in the center of the brain and isolates
single fiber populations from the corpus callosum using an FA mask with a
threshold of 0.7. These voxels are used to estimate the response function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dipy.reconst.csdeconv</span> <span class="kn">import</span> <a href="../../reference/dipy.reconst.html#dipy.reconst.csdeconv.auto_response_ssst" title="dipy.reconst.csdeconv.auto_response_ssst" class="sphx-glr-backref-module-dipy-reconst-csdeconv sphx-glr-backref-type-py-function"><span class="n">auto_response_ssst</span></a>

<span class="n">response</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <a href="../../reference/dipy.reconst.html#dipy.reconst.csdeconv.auto_response_ssst" title="dipy.reconst.csdeconv.auto_response_ssst" class="sphx-glr-backref-module-dipy-reconst-csdeconv sphx-glr-backref-type-py-function"><span class="n">auto_response_ssst</span></a><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">roi_radii</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fa_thr</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</pre></div>
</div>
<p>(array([0.00139919, 0.0003007 , 0.0003007]), 416.7372408293461)</p>
<p>This response contains the estimated eigenvalues in its first element, and the
estimated S0 in the second. The eigenvalues are all we care about for using
RUMBA-SD.</p>
<p>We can visualize this estimated response as well.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">evals</span> <span class="o">=</span> <span class="n">response</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">evecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

<span class="n">response_odf</span> <span class="o">=</span> <a href="../../reference/dipy.sims.html#dipy.sims.voxel.single_tensor_odf" title="dipy.sims.voxel.single_tensor_odf" class="sphx-glr-backref-module-dipy-sims-voxel sphx-glr-backref-type-py-function"><span class="n">single_tensor_odf</span></a><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span><span class="p">)</span>
<span class="c1"># transform our data from 1D to 4D</span>
<span class="n">response_odf</span> <span class="o">=</span> <span class="n">response_odf</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">response_actor</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">odf_slicer</span><span class="p">(</span><span class="n">response_odf</span><span class="p">,</span> <span class="n">sphere</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span>
                                  <span class="n">colormap</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">)</span>
<span class="n">scene</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">response_actor</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving illustration as estimated_response.png&#39;</span><span class="p">)</span>
<span class="n">window</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">out_path</span><span class="o">=</span><span class="s1">&#39;estimated_response.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>
<span class="k">if</span> <span class="n">interactive</span><span class="p">:</span>
    <span class="n">window</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id9">
<img alt="auto_examples/reconstruction/estimated_response.png" src="auto_examples/reconstruction/estimated_response.png" />
<figcaption>
<p><span class="caption-text">Estimated response function.</span><a class="headerlink" href="#id9" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="o">.</span><span class="n">rm</span><span class="p">(</span><span class="n">response_actor</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Strategy 3: recursive, data-driven estimation</strong>
The other method for extracting a response function uses a recursive approach.
Here, we initialize a “fat” response function, which is used in CSD. From this
deconvolution, the voxels with one peak are extracted and their data is
averaged to get a new response function. This is repeated iteratively until
convergence <a class="reference internal" href="../../examples_built/reconstruction/reconst_rumba.html#tax2014" id="id6"><span>[Tax2014]</span></a>.</p>
<p>To shorten computation time, a mask can be estimated for the data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dipy.reconst.csdeconv</span> <span class="kn">import</span> <a href="../../reference/dipy.reconst.html#dipy.reconst.csdeconv.recursive_response" title="dipy.reconst.csdeconv.recursive_response" class="sphx-glr-backref-module-dipy-reconst-csdeconv sphx-glr-backref-type-py-function"><span class="n">recursive_response</span></a>
<span class="kn">from</span> <span class="nn">dipy.segment.mask</span> <span class="kn">import</span> <a href="../../reference/dipy.segment.html#dipy.segment.mask.median_otsu" title="dipy.segment.mask.median_otsu" class="sphx-glr-backref-module-dipy-segment-mask sphx-glr-backref-type-py-function"><span class="n">median_otsu</span></a>

<span class="n">b0_mask</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <a href="../../reference/dipy.segment.html#dipy.segment.mask.median_otsu" title="dipy.segment.mask.median_otsu" class="sphx-glr-backref-module-dipy-segment-mask sphx-glr-backref-type-py-function"><span class="n">median_otsu</span></a><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">median_radius</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">numpass</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">vol_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="n">rec_response</span> <span class="o">=</span> <a href="../../reference/dipy.reconst.html#dipy.reconst.csdeconv.recursive_response" title="dipy.reconst.csdeconv.recursive_response" class="sphx-glr-backref-module-dipy-reconst-csdeconv sphx-glr-backref-type-py-function"><span class="n">recursive_response</span></a><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">sh_order</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                                  <span class="n">peak_thr</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">init_fa</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span>
                                  <span class="n">init_trace</span><span class="o">=</span><span class="mf">0.0021</span><span class="p">,</span> <span class="nb">iter</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">convergence</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
                                  <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_processes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now visualize this response, which will look like a pancake.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rec_response_signal</span> <span class="o">=</span> <span class="n">rec_response</span><span class="o">.</span><span class="n">on_sphere</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
<span class="c1"># transform our data from 1D to 4D</span>
<span class="n">rec_response_signal</span> <span class="o">=</span> <span class="n">rec_response_signal</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">response_actor</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">odf_slicer</span><span class="p">(</span><span class="n">rec_response_signal</span><span class="p">,</span> <span class="n">sphere</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span>
                                  <span class="n">colormap</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">)</span>

<span class="n">scene</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">response_actor</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving illustration as recursive_response.png&#39;</span><span class="p">)</span>
<span class="n">window</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">out_path</span><span class="o">=</span><span class="s1">&#39;recursive_response.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>
<span class="k">if</span> <span class="n">interactive</span><span class="p">:</span>
    <span class="n">window</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id10">
<img alt="auto_examples/reconstruction/recursive_response.png" src="auto_examples/reconstruction/recursive_response.png" />
<figcaption>
<p><span class="caption-text">Recursive response function.</span><a class="headerlink" href="#id10" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="o">.</span><span class="n">rm</span><span class="p">(</span><span class="n">response_actor</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="step-2-fodf-reconstruction">
<h2>Step 2. fODF Reconstruction<a class="headerlink" href="#step-2-fodf-reconstruction" title="Permalink to this heading">#</a></h2>
<p>We will now use the estimated response function with the RUMBA-SD model to
reconstruct the fODFs. We will use the default value for <cite>csf_response</cite> and
<cite>gm_response</cite>. If one doesn’t wish to fit these compartments, one can specify
either argument as <cite>None</cite>. This will result in the corresponding volume
fraction map being all zeroes. The GM compartment can only be accurately
estimated with at least 3-shell data. With less shells, it is recommended
to only keep the compartment for CSF. Since this data is single-shell, we will
only compute the CSF compartment.</p>
<p>RUMBA-SD can fit the data voxelwise or globally. By default, a voxelwise
approach is used (<cite>voxelwise</cite> is set to <cite>True</cite>). However, by setting
<cite>voxelwise</cite> to false, the whole brain can be fit at once. In this global
setting, one can specify the use of TV regularization with <cite>use_tv</cite>, and the
model can log updates on its progress and estimated signal-to-noise ratios by
setting <cite>verbose</cite> to True. By default, both <cite>use_tv</cite> and <cite>verbose</cite> are set to
<cite>False</cite> as they have no bearing on the voxelwise fit.</p>
<p>When constructing the RUMBA-SD model, one can also specify <cite>n_iter</cite>,
<cite>recon_type</cite>, <cite>n_coils</cite>, <cite>R</cite>, and <cite>sphere</cite>. <cite>n_iter</cite> is the number of
iterations for the iterative estimation, and the default value of 600
should be suitable for most applications. <cite>recon_type</cite> is the technique used
by the MRI scanner to reconstruct the MRI signal, and should be either ‘smf’
for ‘spatial matched filter’, or ‘sos’ for ‘sum-of-squares’; ‘smf’ is a common
choice and is the default, but the specifications of the MRI scanner used to
collect the data should be checked. If ‘sos’ is used, then it’s important to
specify <cite>n_coils</cite>, which is the number of coils in the MRI scanner. With ‘smf’,
this isn’t important and the default argument of 1 can be used. <cite>R</cite> is the
acceleration factor of the MRI scanner, which is termed the iPAT factor for
SIEMENS, the ASSET factor for GE, or the SENSE factor for PHILIPS. 1 is a
common choice, and is the default for the model. This is only important when
using TV regularization, which will be covered later in the tutorial. Finally,
<cite>sphere</cite> specifies the sphere on which to construct the fODF. The default is
‘repulsion724’ sphere, but this tutorial will use <cite>symmetric362</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rumba</span> <span class="o">=</span> <a href="../../reference/dipy.reconst.html#dipy.reconst.rumba.RumbaSDModel" title="dipy.reconst.rumba.RumbaSDModel" class="sphx-glr-backref-module-dipy-reconst-rumba sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">RumbaSDModel</span></a><span class="p">(</span>
    <span class="n">gtab</span><span class="p">,</span> <span class="n">wm_response</span><span class="o">=</span><span class="n">response</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gm_response</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sphere</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>
</pre></div>
</div>
<p>For efficiency, we will only fit a small part of the data. This is the same
portion of data used in
<a class="reference internal" href="../../examples_built/reconstruction/reconst_csd.html#sphx-glr-examples-built-reconstruction-reconst-csd-py"><span class="std std-ref">Reconstruction with Constrained Spherical Deconvolution</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_small</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span> <span class="mi">55</span><span class="p">:</span><span class="mi">85</span><span class="p">,</span> <span class="mi">38</span><span class="p">:</span><span class="mi">39</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Option 1: voxel-wise fit</strong>
This is the default approach for generating ODFs, wherein each voxel is fit
sequentially.</p>
<p>We will estimate the fODFs using the ‘symmetric362’ sphere. This
will take about a minute to compute.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rumba_fit</span> <span class="o">=</span> <span class="n">rumba</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data_small</span><span class="p">)</span>
<span class="n">odf</span> <span class="o">=</span> <span class="n">rumba_fit</span><span class="o">.</span><span class="n">odf</span><span class="p">()</span>
</pre></div>
</div>
<p>The inclusion of RUMBA-SD’s CSF compartment means we can also extract
the isotropic volume fraction map as well as the white matter volume fraction
map (the fODF sum at each voxel). These values are normalized such that they
sum to 1. If neither isotropic compartment is included, then the isotropic
volume fraction map will all be zeroes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f_iso</span> <span class="o">=</span> <span class="n">rumba_fit</span><span class="o">.</span><span class="n">f_iso</span>
<span class="n">f_wm</span> <span class="o">=</span> <span class="n">rumba_fit</span><span class="o">.</span><span class="n">f_wm</span>
</pre></div>
</div>
<p>We can visualize these maps using adjacent heatmaps.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="n">ax0</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">f_wm</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Voxelwise White Matter Volume Fraction&quot;</span><span class="p">)</span>

<span class="n">ax1</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">f_iso</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Voxelwise Isotropic Volume Fraction&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ax0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;wm_iso_partition.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id11">
<img alt="auto_examples/reconstruction/wm_iso_partition.png" src="auto_examples/reconstruction/wm_iso_partition.png" />
<figcaption>
<p><span class="caption-text">White matter and isotropic volume fractions</span><a class="headerlink" href="#id11" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To visualize the fODFs, it’s recommended to combine the fODF and the isotropic
components. This is done using the <cite>RumbaFit</cite> object’s method
<cite>combined_odf_iso</cite>. To reach a proper scale for visualization, the argument
<cite>norm=True</cite> is used in FURY’s <cite>odf_slicer</cite> method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">combined</span> <span class="o">=</span> <span class="n">rumba_fit</span><span class="o">.</span><span class="n">combined_odf_iso</span>

<span class="n">fodf_spheres</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">odf_slicer</span><span class="p">(</span>
    <span class="n">combined</span><span class="p">,</span> <span class="n">sphere</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">scene</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fodf_spheres</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving illustration as rumba_odfs.png&#39;</span><span class="p">)</span>
<span class="n">window</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">out_path</span><span class="o">=</span><span class="s1">&#39;rumba_odfs.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="k">if</span> <span class="n">interactive</span><span class="p">:</span>
    <span class="n">window</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id12">
<img alt="auto_examples/reconstruction/rumba_odfs.png" src="auto_examples/reconstruction/rumba_odfs.png" />
<figcaption>
<p><span class="caption-text">RUMBA-SD fODFs</span><a class="headerlink" href="#id12" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="o">.</span><span class="n">rm</span><span class="p">(</span><span class="n">fodf_spheres</span><span class="p">)</span>
</pre></div>
</div>
<p>We can extract the peaks from these fODFs using <cite>peaks_from_model</cite>. This will
reconstruct the fODFs again, so will take about a minute to run.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dipy.direction</span> <span class="kn">import</span> <span class="n">peaks_from_model</span>

<span class="n">rumba_peaks</span> <span class="o">=</span> <span class="n">peaks_from_model</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">rumba</span><span class="p">,</span>
                               <span class="n">data</span><span class="o">=</span><span class="n">data_small</span><span class="p">,</span>
                               <span class="n">sphere</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span>
                               <span class="n">relative_peak_threshold</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span>
                               <span class="n">min_separation_angle</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                               <span class="n">normalize_peaks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">num_processes</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>For visualization, we scale up the peak values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">peak_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">rumba_peaks</span><span class="o">.</span><span class="n">peak_values</span> <span class="o">*</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">peak_dirs</span> <span class="o">=</span> <span class="n">rumba_peaks</span><span class="o">.</span><span class="n">peak_dirs</span>

<span class="n">fodf_peaks</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">peak_slicer</span><span class="p">(</span><span class="n">peak_dirs</span><span class="p">,</span> <span class="n">peak_values</span><span class="p">)</span>
<span class="n">scene</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fodf_peaks</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving illustration as rumba_peaks.png&#39;</span><span class="p">)</span>
<span class="n">window</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">out_path</span><span class="o">=</span><span class="s1">&#39;rumba_peaks.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="k">if</span> <span class="n">interactive</span><span class="p">:</span>
    <span class="n">window</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id13">
<img alt="auto_examples/reconstruction/rumba_peaks.png" src="auto_examples/reconstruction/rumba_peaks.png" />
<figcaption>
<p><span class="caption-text">RUMBA-SD peaks</span><a class="headerlink" href="#id13" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="o">.</span><span class="n">rm</span><span class="p">(</span><span class="n">fodf_peaks</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Option 2: global fit</strong>
Instead of the voxel-wise fit, RUMBA also comes with an implementation of
global fitting where all voxels are fit simultaneously. This comes with some
potential benefits such as:</p>
<ol class="arabic simple">
<li><p>More efficient fitting due to matrix parallelization, in exchange for
larger demands on RAM (&gt;= 16 GB should be sufficient)</p></li>
<li><p>The option for spatial regularization; specifically, TV regularization is
built into the fitting function (RUMBA-SD + TV)</p></li>
</ol>
<p>This is done by setting <cite>voxelwise</cite> to <cite>False</cite>, and setting <cite>use_tv</cite> to <cite>True</cite>.</p>
<p>TV regularization requires a volume without any singleton dimensions, so we’ll
have to start by expanding our data slice.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rumba</span> <span class="o">=</span> <a href="../../reference/dipy.reconst.html#dipy.reconst.rumba.RumbaSDModel" title="dipy.reconst.rumba.RumbaSDModel" class="sphx-glr-backref-module-dipy-reconst-rumba sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">RumbaSDModel</span></a><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">wm_response</span><span class="o">=</span><span class="n">response</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gm_response</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">voxelwise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_tv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sphere</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>
<span class="n">data_tv</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span> <span class="mi">55</span><span class="p">:</span><span class="mi">85</span><span class="p">,</span> <span class="mi">38</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span>
</pre></div>
</div>
<p>Now, we fit the model in the same way. This will take about 90 seconds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rumba_fit</span> <span class="o">=</span> <span class="n">rumba</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data_tv</span><span class="p">)</span>

<span class="n">odf</span> <span class="o">=</span> <span class="n">rumba_fit</span><span class="o">.</span><span class="n">odf</span><span class="p">()</span>
<span class="n">combined</span> <span class="o">=</span> <span class="n">rumba_fit</span><span class="o">.</span><span class="n">combined_odf_iso</span>
</pre></div>
</div>
<p>Now we can visualize the combined fODF map as before.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fodf_spheres</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">odf_slicer</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="n">sphere</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="n">scene</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fodf_spheres</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving illustration as rumba_global_odfs.png&#39;</span><span class="p">)</span>
<span class="n">window</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">out_path</span><span class="o">=</span><span class="s1">&#39;rumba_global_odfs.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="k">if</span> <span class="n">interactive</span><span class="p">:</span>
    <span class="n">window</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id14">
<img alt="auto_examples/reconstruction/rumba_global_odfs.png" src="auto_examples/reconstruction/rumba_global_odfs.png" />
<figcaption>
<p><span class="caption-text">RUMBA-SD + TV fODFs</span><a class="headerlink" href="#id14" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>This can be compared with the result without TV regularization, and one can
observe that the coherence between neighboring voxels is improved.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="o">.</span><span class="n">rm</span><span class="p">(</span><span class="n">fodf_spheres</span><span class="p">)</span>
</pre></div>
</div>
<p>For peak detection, <cite>peaks_from_model</cite> cannot be used as it doesn’t support
global fitting approaches. Instead, we’ll compute our peaks using a for loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dipy.direction</span> <span class="kn">import</span> <span class="n">peak_directions</span>

<span class="n">shape</span> <span class="o">=</span> <span class="n">odf</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">npeaks</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># maximum number of peaks returned for a given voxel</span>
<span class="n">peak_dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">npeaks</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="n">peak_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">npeaks</span><span class="p">,)))</span>

<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>  <span class="c1"># iterate through each voxel</span>
    <span class="c1"># Get peaks of odf</span>
    <span class="n">direction</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">peak_directions</span><span class="p">(</span><span class="n">odf</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">sphere</span><span class="p">,</span>
                                       <span class="n">relative_peak_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                                       <span class="n">min_separation_angle</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>

    <span class="c1"># Calculate peak metrics</span>
    <span class="k">if</span> <span class="n">pk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">npeaks</span><span class="p">,</span> <span class="n">pk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">peak_dirs</span><span class="p">[</span><span class="n">idx</span><span class="p">][:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="n">peak_values</span><span class="p">[</span><span class="n">idx</span><span class="p">][:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

<span class="c1"># Scale up for visualization</span>
<span class="n">peak_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">peak_values</span> <span class="o">*</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">fodf_peaks</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">peak_slicer</span><span class="p">(</span><span class="n">peak_dirs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                               <span class="n">peak_values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
<span class="n">scene</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fodf_peaks</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving illustration as rumba_global_peaks.png&#39;</span><span class="p">)</span>
<span class="n">window</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">out_path</span><span class="o">=</span><span class="s1">&#39;rumba_global_peaks.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="k">if</span> <span class="n">interactive</span><span class="p">:</span>
    <span class="n">window</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id15">
<img alt="auto_examples/reconstruction/rumba_global_peaks.png" src="auto_examples/reconstruction/rumba_global_peaks.png" />
<figcaption>
<p><span class="caption-text">RUMBA-SD + TV peaks</span><a class="headerlink" href="#id15" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span><span class="o">.</span><span class="n">rm</span><span class="p">(</span><span class="n">fodf_peaks</span><span class="p">)</span>
</pre></div>
</div>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h3>
<div role="list" class="citation-list">
<div class="citation" id="canalesrodriguez2015" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>CanalesRodriguez2015<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id5">2</a>)</span>
<p>Canales-Rodríguez, E. J., Daducci, A., Sotiropoulos,
S. N., Caruyer, E., Aja-Fernández, S., Radua, J., Mendizabal, J. M. Y.,
Iturria-Medina, Y., Melie-García, L., Alemán-Gómez, Y., Thiran, J.-P.,
Sarró, S., Pomarol-Clotet, E., &amp; Salvador, R. (2015). Spherical
Deconvolution of Multichannel Diffusion MRI Data with Non-Gaussian Noise
Models and Spatial Regularization. PLOS ONE, 10(10), e0138910.
<a class="reference external" href="https://doi.org/10.1371/journal.pone.0138910">https://doi.org/10.1371/journal.pone.0138910</a></p>
</div>
<div class="citation" id="richardson1972" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Richardson1972</a><span class="fn-bracket">]</span></span>
<p>Richardson, W. H. (1972). Bayesian-Based Iterative Method
of Image Restoration*. JOSA, 62(1), 55–59.
<a class="reference external" href="https://doi.org/10.1364/JOSA.62.000055">https://doi.org/10.1364/JOSA.62.000055</a></p>
</div>
<div class="citation" id="constantinides1997" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">Constantinides1997</a><span class="fn-bracket">]</span></span>
<p>Constantinides, C. D., Atalar, E., &amp; McVeigh, E. R.
(1997). Signal-to-Noise Measurements in Magnitude Images from NMR Phased
Arrays. Magnetic Resonance in Medicine: Official Journal of the Society of
Magnetic Resonance in Medicine / Society of Magnetic Resonance in Medicine,
38(5), 852–857.</p>
</div>
<div class="citation" id="rudin1992" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">Rudin1992</a><span class="fn-bracket">]</span></span>
<p>Rudin, L. I., Osher, S., &amp; Fatemi, E. (1992). Nonlinear total
variation based noise removal algorithms. Physica D: Nonlinear Phenomena,
60(1), 259–268. <a class="reference external" href="https://doi.org/10.1016/0167-2789(92)90242-F">https://doi.org/10.1016/0167-2789(92)90242-F</a></p>
</div>
<div class="citation" id="dellacqua2007" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>DellAcqua2007<span class="fn-bracket">]</span></span>
<p>Dell’Acqua, F., Rizzo, G., Scifo, P., Clarke, R., Scotti,
G., &amp; Fazio, F. (2007). A Model-Based Deconvolution Approach to Solve Fiber
Crossing in Diffusion-Weighted MR Imaging. IEEE Transactions on Bio-Medical
Engineering, 54, 462–472. <a class="reference external" href="https://doi.org/10.1109/TBME.2006.888830">https://doi.org/10.1109/TBME.2006.888830</a></p>
</div>
<div class="citation" id="tax2014" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">Tax2014</a><span class="fn-bracket">]</span></span>
<p>Tax, C. M. W., Jeurissen, B., Vos, S. B., Viergever, M. A., &amp;
Leemans, A. (2014). Recursive calibration of the fiber response
function for spherical deconvolution of diffusion MRI data.
NeuroImage, 86, 67–80.
<a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2013.07.067">https://doi.org/10.1016/j.neuroimage.2013.07.067</a></p>
</div>
</div>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.000 seconds)</p>
<div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-examples-reconstruction-reconst-rumba-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/14ee9a2f398c27d8c82dbef55eac0e53/reconst_rumba.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">reconst_rumba.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/50e22302e056b18c9e1b0fe7bbe1bfa1/reconst_rumba.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">reconst_rumba.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</section>
</section>
</section>

<div class="section ablog__blog_comments">
  
  
</div>

                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#step-1-estimation-of-the-fiber-response-function">Step 1. Estimation of the fiber response function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#step-2-fodf-reconstruction">Step 2. fODF Reconstruction</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  
<script type="module" src="../../_static/scripts/grg-sphinx-theme.js"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
      © Copyright 2008-2023, dipy developers &lt;neuroimaging@python.org&gt;.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.0.
    <br/>
  </p>
</div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
</div>

    <div class="copyright-text">
      <i class="fa-regular fa-copyright"></i> 
    </div>
  </footer>
  </body>
</html>