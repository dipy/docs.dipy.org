
<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>DIPY &#8212; dipy 1.8.0dev0 documentation</title>
  
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/dipy.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

  
<link rel="stylesheet" href="../_static/styles/grg-sphinx-theme.css"/>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'reference/dipy.reconst';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://docs.dipy.org/dev/_static/version_switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '1.8.0';
        </script>
    <link rel="icon" href="../_static/dipy-favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="segment" href="dipy.segment.html" />
    <link rel="prev" title="nn" href="dipy.nn.html" />
  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
<nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/dipy-logo.png" class="logo__image only-light" alt="DIPY"/>
    <script>document.write(`<img src="../_static/dipy-logo.png" class="logo__image only-dark" alt="DIPY"/>`);</script>
  
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  
  <ul class="bd-navbar-elements navbar-nav">
    
          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Docs
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
      <li class="nav-item">
        <a class="nav-link" href="../index.html">
          Overview
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../examples_built/index.html">
          Tutorials
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../recipes.html">
          Recipes
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../interfaces/index.html">
          CLI / Workflows
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="index.html">
          API
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../reference_cmd/index.html">
          CLI API
        </a>
      </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Workshops
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Latest
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2024" target="_blank">
            DIPY Workshop 2024 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Past
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2023" target="_blank">
            DIPY Workshop 2023 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2022" target="_blank">
            DIPY Workshop 2022 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2021" target="_blank">
            DIPY Workshop 2021 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2020" target="_blank">
            DIPY Workshop 2020 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2019" target="_blank">
            DIPY Workshop 2019 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Community
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        News
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/calendar">
            Calendar
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://mail.python.org/mailman3/lists/dipy.python.org/" target="_blank">
            Newsletters <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/blog">
            Blog
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://www.youtube.com/c/diffusionimaginginpython" target="_blank">
            Youtube <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Help
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://app.gitter.im/#/room/%23dipy_dipy:gitter.im" target="_blank">
            Live Chat (Gitter) <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://github.com/dipy/dipy/discussions" target="_blank">
            Github Discussions <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    About
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/team">
            Team
          </a>
        </li>

      <li class="nav-item">
        <a class="nav-link" href="../faq.html">
          FAQ
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../mission.html">
          Mission Statement
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../stateoftheart.html">
          Releases
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../cite.html">
          Cite
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../glossary.html">
          Glossary
        </a>
      </li>
                </ul>
            </li>
          
  </ul>
  
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
      
        <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button type="button" class="version-switcher__button btn btn-sm navbar-btn dropdown-toggle" data-bs-toggle="dropdown">
      1.8.0  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div class="version-switcher__menu dropdown-menu list-group-flush py-0">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dipy" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/dipymri" title="Twitter/X" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter/X</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/c/diffusionimaginginpython" title="YouTube" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-youtube"></i></span>
            <label class="sr-only">YouTube</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/dipy/" title="LinkedIn" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-linkedin"></i></span>
            <label class="sr-only">LinkedIn</label></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

</nav>
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  
  <ul class="bd-navbar-elements navbar-nav">
    
          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Docs
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
      <li class="nav-item">
        <a class="nav-link" href="../index.html">
          Overview
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../examples_built/index.html">
          Tutorials
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../recipes.html">
          Recipes
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../interfaces/index.html">
          CLI / Workflows
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="index.html">
          API
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../reference_cmd/index.html">
          CLI API
        </a>
      </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Workshops
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Latest
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2024" target="_blank">
            DIPY Workshop 2024 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Past
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2023" target="_blank">
            DIPY Workshop 2023 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2022" target="_blank">
            DIPY Workshop 2022 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2021" target="_blank">
            DIPY Workshop 2021 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2020" target="_blank">
            DIPY Workshop 2020 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/workshops/dipy-workshop-2019" target="_blank">
            DIPY Workshop 2019 <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    Community
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
    <li class="nav-item">
      <p class="nav-section-title nav-link">
        News
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/calendar">
            Calendar
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://mail.python.org/mailman3/lists/dipy.python.org/" target="_blank">
            Newsletters <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/blog">
            Blog
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://www.youtube.com/c/diffusionimaginginpython" target="_blank">
            Youtube <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

    <li class="nav-item">
      <p class="nav-section-title nav-link">
        Help
      </p>
    </li>

        <li class="nav-item">
          <a class="nav-link" href="https://app.gitter.im/#/room/%23dipy_dipy:gitter.im" target="_blank">
            Live Chat (Gitter) <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="https://github.com/dipy/dipy/discussions" target="_blank">
            Github Discussions <i class="fa-solid fa-arrow-up-long external-icon mar-l-5"></i>
          </a>
        </li>
                </ul>
            </li>
          

          <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-header-nav-more-links">
                    About
                </button>
                <ul id="pst-header-nav-more-links" class="dropdown-menu">
                    
        <li class="nav-item">
          <a class="nav-link" href="https://dipy.org/team">
            Team
          </a>
        </li>

      <li class="nav-item">
        <a class="nav-link" href="../faq.html">
          FAQ
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../mission.html">
          Mission Statement
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../stateoftheart.html">
          Releases
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../cite.html">
          Cite
        </a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="../glossary.html">
          Glossary
        </a>
      </li>
                </ul>
            </li>
          
  </ul>
  
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
        
          <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button type="button" class="version-switcher__button btn btn-sm navbar-btn dropdown-toggle" data-bs-toggle="dropdown">
      1.8.0  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div class="version-switcher__menu dropdown-menu list-group-flush py-0">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dipy" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/dipymri" title="Twitter/X" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter/X</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/c/diffusionimaginginpython" title="YouTube" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-youtube"></i></span>
            <label class="sr-only">YouTube</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/dipy/" title="LinkedIn" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-linkedin"></i></span>
            <label class="sr-only">LinkedIn</label></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item"><nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="dipy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dipy</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.__config__.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__config__</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.align.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">align</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.boots.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">boots</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.core.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">core</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.data.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.denoise.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">denoise</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.direction.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">direction</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.io.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.nn.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nn</span></code></a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.segment.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">segment</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.sims.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sims</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.stats.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stats</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.tracking.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracking</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.viz.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">viz</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dipy.workflows.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">workflows</span></code></a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">API Reference</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">DIPY</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="module-dipy.reconst">
<span id="reconst"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst</span></code><a class="headerlink" href="#module-dipy.reconst" title="Permalink to this heading">#</a></h1>
<table class="autosummary longtable table autosummary">
<tbody>
</tbody>
</table>
<section id="module-dipy.reconst.base">
<span id="module-reconst-base"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.base</span></code><a class="headerlink" href="#module-dipy.reconst.base" title="Permalink to this heading">#</a></h2>
<p>Base-classes for reconstruction models and reconstruction fits.</p>
<p>All the models in the reconst module follow the same template: a Model object
is used to represent the abstract properties of the model, that are independent
of the specifics of the data . These properties are reused whenever fitting a
particular set of data (different voxels, for example).</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</p></td>
<td><p>Abstract class for signal reconstruction models</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstFit</span></code></a>(model, data)</p></td>
<td><p>Abstract class which holds the fit result of ReconstModel</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.benchmarks">
<span id="module-reconst-benchmarks"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.benchmarks.bench_bounding_box">
<span id="module-reconst-benchmarks-bench-bounding-box"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_bounding_box</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_bounding_box" title="Permalink to this heading">#</a></h2>
<p>Benchmarks for bounding_box</p>
<p>Run all benchmarks with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="k">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>With Pytest, Run this benchmark with:</p>
<blockquote>
<div><p>pytest -svv -c bench.ini /path/to/bench_bounding_box.py</p>
</div></blockquote>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box" title="dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_bounding_box</span></code></a>()</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.benchmarks.bench_csd">
<span id="module-reconst-benchmarks-bench-csd"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_csd</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_csd" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.num_grad" title="dipy.reconst.benchmarks.bench_csd.num_grad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_grad</span></code></a>(gtab)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.bench_csdeconv" title="dipy.reconst.benchmarks.bench_csd.bench_csdeconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_csdeconv</span></code></a>([center, width])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.benchmarks.bench_peaks">
<span id="module-reconst-benchmarks-bench-peaks"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_peaks</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_peaks" title="Permalink to this heading">#</a></h2>
<p>Benchmarks for peak finding</p>
<p>Run all benchmarks with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="k">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>With Pytest, Run this benchmark with:</p>
<blockquote>
<div><p>pytest -svv -c bench.ini /path/to/bench_peaks.py</p>
</div></blockquote>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.bench_local_maxima" title="dipy.reconst.benchmarks.bench_peaks.bench_local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_local_maxima</span></code></a>()</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.benchmarks.bench_squash">
<span id="module-reconst-benchmarks-bench-squash"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_squash</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_squash" title="Permalink to this heading">#</a></h2>
<p>Benchmarks for fast squashing</p>
<p>Run all benchmarks with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="k">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>With Pytest, Run this benchmark with:</p>
<blockquote>
<div><p>pytest -svv -c bench.ini /path/to/bench_squash.py</p>
</div></blockquote>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.old_squash" title="dipy.reconst.benchmarks.bench_squash.old_squash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">old_squash</span></code></a>(arr[, mask, fill])</p></td>
<td><p>Try and make a standard array from an object array</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.bench_quick_squash" title="dipy.reconst.benchmarks.bench_squash.bench_quick_squash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_quick_squash</span></code></a>()</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.benchmarks.bench_vec_val_sum">
<span id="module-reconst-benchmarks-bench-vec-val-sum"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_vec_val_sum</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_vec_val_sum" title="Permalink to this heading">#</a></h2>
<p>Benchmarks for vec / val summation routine</p>
<p>Run benchmarks with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="k">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>With Pytest, Run this benchmark with:</p>
<blockquote>
<div><p>pytest -svv -c bench.ini /path/to/bench_vec_val_sum.py</p>
</div></blockquote>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect" title="dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_vec_val_vect</span></code></a>()</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.cache">
<span id="module-reconst-cache"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cache</span></code><a class="headerlink" href="#module-dipy.reconst.cache" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a>()</p></td>
<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.cross_validation">
<span id="module-reconst-cross-validation"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cross_validation</span></code><a class="headerlink" href="#module-dipy.reconst.cross_validation" title="Permalink to this heading">#</a></h2>
<p>Cross-validation analysis of diffusion models.</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cross_validation.coeff_of_determination" title="dipy.reconst.cross_validation.coeff_of_determination"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coeff_of_determination</span></code></a>(data, model[, axis])</p></td>
<td><p>Calculate the coefficient of determination for a model prediction,</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cross_validation.kfold_xval" title="dipy.reconst.cross_validation.kfold_xval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kfold_xval</span></code></a>(model, data, folds, *model_args, ...)</p></td>
<td><p>Perform k-fold cross-validation.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.csdeconv">
<span id="module-reconst-csdeconv"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.csdeconv</span></code><a class="headerlink" href="#module-dipy.reconst.csdeconv" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse" title="dipy.reconst.csdeconv.AxSymShResponse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a>(S0, dwi_response[, bvalue])</p></td>
<td><p>A simple wrapper for response functions represented using only axially symmetric, even spherical harmonic functions (ie, m == 0 and n even).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a>(gtab, response)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="dipy.reconst.csdeconv.ConstrainedSDTModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a>(gtab, ratio[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.auto_response" title="dipy.reconst.csdeconv.auto_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_response</span></code></a>(gtab, data[, roi_center, ...])</p></td>
<td><p>Automatic estimation of ssst response function using FA.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.response_from_mask" title="dipy.reconst.csdeconv.response_from_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">response_from_mask</span></code></a>(gtab, data, mask)</p></td>
<td><p>Computation of single-shell single-tissue (ssst) response</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.estimate_response" title="dipy.reconst.csdeconv.estimate_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_response</span></code></a>(gtab, evals, S0)</p></td>
<td><p>Estimate single fiber response function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat" title="dipy.reconst.csdeconv.forward_sdt_deconv_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward_sdt_deconv_mat</span></code></a>(ratio, n[, r2_term])</p></td>
<td><p>Build forward sharpening deconvolution transform (SDT) matrix

Parameters
----------
ratio : float
    ratio = <span class="math notranslate nohighlight">\(\frac{\lambda_2}{\lambda_1}\)</span> of the single fiber response
    function
n : ndarray (N,)
    The degree of spherical harmonic function associated with each row of
    the deconvolution matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.csdeconv" title="dipy.reconst.csdeconv.csdeconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csdeconv</span></code></a>(dwsignal, X, B_reg[, tau, ...])</p></td>
<td><p>Constrained-regularized spherical deconvolution (CSD) <a href="#id1311"><span class="problematic" id="id1">[1]_</span></a>

Deconvolves the axially symmetric single fiber response function <cite>r_rh</cite> in
rotational harmonics coefficients from the diffusion weighted signal in
<cite>dwsignal</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.odf_deconv" title="dipy.reconst.csdeconv.odf_deconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_deconv</span></code></a>(odf_sh, R, B_reg[, lambda_, tau, ...])</p></td>
<td><p>ODF constrained-regularized spherical deconvolution using
the Sharpening Deconvolution Transform (SDT) <a href="#id1312"><span class="problematic" id="id2">[1]_</span></a>, <a href="#id1313"><span class="problematic" id="id3">[2]_</span></a>. Parameters
----------
odf_sh : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)
     ndarray of SH coefficients for the ODF spherical function to be
     deconvolved
R : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,
     <code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>)
     SDT matrix in SH basis
B_reg : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,
     <code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>)
     SH basis matrix used for deconvolution
<a href="#id1314"><span class="problematic" id="id1315">lambda_</span></a> : float
     lambda parameter in minimization equation (default 1.0)
tau : float
     threshold (tau <a href="#id4"><span class="problematic" id="id5">*</span></a>max(fODF)) controlling the amplitude below
     which the corresponding fODF is assumed to be zero. r2_term : bool
     True if ODF is computed from model that uses the <span class="math notranslate nohighlight">\(r^2\)</span> term in the
     integral. Recall that Tuch's ODF (used in Q-ball Imaging <a href="#id1316"><span class="problematic" id="id6">[1]_</span></a>) and
     the true normalized ODF definition differ from a <span class="math notranslate nohighlight">\(r^2\)</span> term in the ODF
     integral. The original Sharpening Deconvolution Transform (SDT)
     technique <a href="#id1317"><span class="problematic" id="id7">[2]_</span></a> is expecting Tuch's ODF without the <span class="math notranslate nohighlight">\(r^2\)</span> (see <a href="#id1318"><span class="problematic" id="id8">[3]_</span></a> for
     the mathematical details). Now, this function supports ODF that have
     been computed using the <span class="math notranslate nohighlight">\(r^2\)</span> term because the proper analytical
     response function has be derived. For example, models such as DSI,
     GQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved
     with the r2_term=True. Returns
-------
fodf_sh : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)
     Spherical harmonics coefficients of the constrained-regularized fiber
     ODF
num_it : int
     Number of iterations in the constrained-regularization used for
     convergence

References
----------
.. [1] Tuch, D. MRM 2004. Q-Ball Imaging. .. [2] Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
       Probabilistic Tractography Based on Complex Fibre Orientation
       Distributions
.. [3] Descoteaux, M, PhD thesis, INRIA Sophia-Antipolis, 2008. .</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.odf_sh_to_sharp" title="dipy.reconst.csdeconv.odf_sh_to_sharp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sh_to_sharp</span></code></a>(odfs_sh, sphere[, basis, ...])</p></td>
<td><p>Sharpen odfs using the sharpening deconvolution transform <a href="#id1319"><span class="problematic" id="id9">[2]_</span></a>

This function can be used to sharpen any smooth ODF spherical function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.mask_for_response_ssst" title="dipy.reconst.csdeconv.mask_for_response_ssst"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mask_for_response_ssst</span></code></a>(gtab, data[, ...])</p></td>
<td><p>Computation of mask for single-shell single-tissue (ssst) response</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.response_from_mask_ssst" title="dipy.reconst.csdeconv.response_from_mask_ssst"><code class="xref py py-obj docutils literal notranslate"><span class="pre">response_from_mask_ssst</span></code></a>(gtab, data, mask)</p></td>
<td><p>Computation of single-shell single-tissue (ssst) response</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.auto_response_ssst" title="dipy.reconst.csdeconv.auto_response_ssst"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_response_ssst</span></code></a>(gtab, data[, roi_center, ...])</p></td>
<td><p>Automatic estimation of single-shell single-tissue (ssst) response</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.recursive_response" title="dipy.reconst.csdeconv.recursive_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recursive_response</span></code></a>(gtab, data[, mask, ...])</p></td>
<td><p>Recursive calibration of response function using peak threshold</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas" title="dipy.reconst.csdeconv.fa_trace_to_lambdas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa_trace_to_lambdas</span></code></a>([fa, trace])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.cti">
<span id="module-reconst-cti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cti</span></code><a class="headerlink" href="#module-dipy.reconst.cti" title="Permalink to this heading">#</a></h2>
<p>Classes and functions for fitting the correlation tensor model</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorModel" title="dipy.reconst.cti.CorrelationTensorModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CorrelationTensorModel</span></code></a>(gtab1, gtab2[, ...])</p></td>
<td><p>Class for the Correlation Tensor Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit" title="dipy.reconst.cti.CorrelationTensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CorrelationTensorFit</span></code></a>(model, model_params)</p></td>
<td><p>Class for fitting the Correlation Tensor Model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.from_qte_to_cti" title="dipy.reconst.cti.from_qte_to_cti"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_qte_to_cti</span></code></a>(C)</p></td>
<td><p>Rescales the qte C elements to the C elements used in CTI.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cti.multi_gaussian_k_from_c" title="dipy.reconst.cti.multi_gaussian_k_from_c"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_gaussian_k_from_c</span></code></a>(ccti, MD)</p></td>
<td><p>Computes the multiple Gaussian diffusion kurtosis tensor from the covariance tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.split_cti_params" title="dipy.reconst.cti.split_cti_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_cti_params</span></code></a>(cti_params)</p></td>
<td><p>Splits CTI params into DTI, DKI, CTI portions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cti.cti_prediction" title="dipy.reconst.cti.cti_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cti_prediction</span></code></a>(cti_params, gtab1, gtab2[, S0])</p></td>
<td><p>Predict a signal given correlation tensor imaging parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.cti.params_to_cti_params" title="dipy.reconst.cti.params_to_cti_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">params_to_cti_params</span></code></a>(result[, min_diffusivity])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.cti.ls_fit_cti" title="dipy.reconst.cti.ls_fit_cti"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ls_fit_cti</span></code></a>(design_matrix, data, ...[, ...])</p></td>
<td><p>Compute the diffusion kurtosis and covariance tensors using an ordinary or weighted linear least squares approach</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.dki">
<span id="module-reconst-dki"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki</span></code><a class="headerlink" href="#module-dipy.reconst.dki" title="Permalink to this heading">#</a></h2>
<p>Classes and functions for fitting the diffusion kurtosis model</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="dipy.reconst.dki.DiffusionKurtosisModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a>(gtab[, fit_method])</p></td>
<td><p>Class for the Diffusion Kurtosis Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a>(model, model_params)</p></td>
<td><p>Class for fitting the Diffusion Kurtosis Model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.carlson_rf" title="dipy.reconst.dki.carlson_rf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">carlson_rf</span></code></a>(x, y, z[, errtol])</p></td>
<td><p>Compute the Carlson's incomplete elliptic integral of the first kind</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.carlson_rd" title="dipy.reconst.dki.carlson_rd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">carlson_rd</span></code></a>(x, y, z[, errtol])</p></td>
<td><p>Compute the Carlson's incomplete elliptic integral of the second kind</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.directional_diffusion" title="dipy.reconst.dki.directional_diffusion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_diffusion</span></code></a>(dt, V[, min_diffusivity])</p></td>
<td><p>Calculate the apparent diffusion coefficient (adc) in each direction of a sphere for a single voxel <a href="#id1320"><span class="problematic" id="id10">[1]_</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.directional_diffusion_variance" title="dipy.reconst.dki.directional_diffusion_variance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_diffusion_variance</span></code></a>(kt, V[, ...])</p></td>
<td><p>Calculate the apparent diffusion variance (adv) in each direction of a sphere for a single voxel <a href="#id1321"><span class="problematic" id="id11">[1]_</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.directional_kurtosis" title="dipy.reconst.dki.directional_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_kurtosis</span></code></a>(dt, md, kt, V[, ...])</p></td>
<td><p>Calculate the apparent kurtosis coefficient (akc) in each direction of a sphere for a single voxel <a href="#id1322"><span class="problematic" id="id12">[1]_</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.apparent_kurtosis_coef" title="dipy.reconst.dki.apparent_kurtosis_coef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apparent_kurtosis_coef</span></code></a>(dki_params, sphere[, ...])</p></td>
<td><p>Calculate the apparent kurtosis coefficient (AKC) in each direction
of a sphere <a href="#id1323"><span class="problematic" id="id13">[1]_</span></a>

Parameters
----------
dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.mean_kurtosis" title="dipy.reconst.dki.mean_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_kurtosis</span></code></a>(dki_params[, min_kurtosis, ...])</p></td>
<td><p>Compute mean kurtosis (MK) from the kurtosis tensor

Parameters
----------
dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.radial_kurtosis" title="dipy.reconst.dki.radial_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_kurtosis</span></code></a>(dki_params[, min_kurtosis, ...])</p></td>
<td><p>Compute radial kurtosis (RK) of a diffusion kurtosis tensor <a href="#id1324"><span class="problematic" id="id14">[1]_</span></a>, <a href="#id1325"><span class="problematic" id="id15">[2]_</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.axial_kurtosis" title="dipy.reconst.dki.axial_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axial_kurtosis</span></code></a>(dki_params[, min_kurtosis, ...])</p></td>
<td><p>Compute axial kurtosis (AK) from the kurtosis tensor <a href="#id1326"><span class="problematic" id="id16">[1]_</span></a>, <a href="#id1327"><span class="problematic" id="id17">[2]_</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.kurtosis_maximum" title="dipy.reconst.dki.kurtosis_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis_maximum</span></code></a>(dki_params[, sphere, gtol, ...])</p></td>
<td><p>Compute kurtosis maximum value</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.mean_kurtosis_tensor" title="dipy.reconst.dki.mean_kurtosis_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_kurtosis_tensor</span></code></a>(dki_params[, ...])</p></td>
<td><p>Compute mean of the kurtosis tensor (MKT) <a href="#id1328"><span class="problematic" id="id18">[1]_</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.kurtosis_fractional_anisotropy" title="dipy.reconst.dki.kurtosis_fractional_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis_fractional_anisotropy</span></code></a>(dki_params)</p></td>
<td><p>Compute the anisotropy of the kurtosis tensor (KFA) <a href="#id1329"><span class="problematic" id="id19">[1]_</span></a>

Parameters
----------
dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.dki_prediction" title="dipy.reconst.dki.dki_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dki_prediction</span></code></a>(dki_params, gtab[, S0])</p></td>
<td><p>Predict a signal given diffusion kurtosis imaging parameters</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.params_to_dki_params" title="dipy.reconst.dki.params_to_dki_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">params_to_dki_params</span></code></a>(result[, min_diffusivity])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.ls_fit_dki" title="dipy.reconst.dki.ls_fit_dki"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ls_fit_dki</span></code></a>(design_matrix, data, ...[, ...])</p></td>
<td><p>Compute the diffusion and kurtosis tensors using an ordinary or weighted linear least squares approach <a href="#id1330"><span class="problematic" id="id20">[1]_</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.cls_fit_dki" title="dipy.reconst.dki.cls_fit_dki"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cls_fit_dki</span></code></a>(design_matrix, data, ...[, ...])</p></td>
<td><p>Compute the diffusion and kurtosis tensors using a constrained ordinary or weighted linear least squares approach <a href="#id1331"><span class="problematic" id="id21">[1]_</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.Wrotate" title="dipy.reconst.dki.Wrotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wrotate</span></code></a>(kt, Basis)</p></td>
<td><p>Rotate a kurtosis tensor from the standard Cartesian coordinate system to another coordinate system basis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.Wrotate_element" title="dipy.reconst.dki.Wrotate_element"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wrotate_element</span></code></a>(kt, indi, indj, indk, indl, B)</p></td>
<td><p>Compute the the specified index element of a kurtosis tensor rotated to the coordinate system basis B</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki.Wcons" title="dipy.reconst.dki.Wcons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wcons</span></code></a>(k_elements)</p></td>
<td><p>Construct the full 4D kurtosis tensors from its 15 independent elements</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki.split_dki_param" title="dipy.reconst.dki.split_dki_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_dki_param</span></code></a>(dki_params)</p></td>
<td><p>Extract the diffusion tensor eigenvalues, the diffusion tensor eigenvector matrix, and the 15 independent elements of the kurtosis tensor from the model parameters estimated from the DKI model</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.dki_micro">
<span id="module-reconst-dki-micro"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki_micro</span></code><a class="headerlink" href="#module-dipy.reconst.dki_micro" title="Permalink to this heading">#</a></h2>
<p>Classes and functions for fitting the DKI-based microstructural model</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a>(gtab[, fit_method])</p></td>
<td><p>Class for the Diffusion Kurtosis Microstructural Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a>(model, model_params)</p></td>
<td><p>Class for fitting the Diffusion Kurtosis Microstructural Model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.axonal_water_fraction" title="dipy.reconst.dki_micro.axonal_water_fraction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axonal_water_fraction</span></code></a>(dki_params[, sphere, ...])</p></td>
<td><p>Computes the axonal water fraction from DKI <a href="#id1332"><span class="problematic" id="id22">[1]_</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.diffusion_components" title="dipy.reconst.dki_micro.diffusion_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diffusion_components</span></code></a>(dki_params[, sphere, ...])</p></td>
<td><p>Extracts the restricted and hindered diffusion tensors of well aligned fibers from diffusion kurtosis imaging parameters <a href="#id1333"><span class="problematic" id="id23">[1]_</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.dkimicro_prediction" title="dipy.reconst.dki_micro.dkimicro_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dkimicro_prediction</span></code></a>(params, gtab[, S0])</p></td>
<td><p>Signal prediction given the DKI microstructure model parameters. Parameters
----------
params : ndarray (x, y, z, 40) or (n, 40)
All parameters estimated from the diffusion kurtosis microstructure model. Parameters are ordered as follows:
        1) Three diffusion tensor's eigenvalues
        2) Three lines of the eigenvector matrix each containing the
           first, second and third coordinates of the eigenvector
        3) Fifteen elements of the kurtosis tensor
        4) Six elements of the hindered diffusion tensor
        5) Six elements of the restricted diffusion tensor
        6) Axonal water fraction
gtab : a GradientTable class instance
    The gradient table for this prediction
S0 : float or ndarray
    The non diffusion-weighted signal in every voxel, or across all
    voxels. Default: 1

Returns
-------
S : (..., N) ndarray
    Simulated signal based on the DKI microstructure model

Notes
-----
1) The predicted signal is given by:
<span class="math notranslate nohighlight">\(S(\theta, b) = S_0 * [f * e^{-b ADC_{r}} + (1-f) * e^{-b ADC_{h}]\)</span>, where
:math:` ADC_{r} and ADC_{h} are the apparent diffusion coefficients of the
diffusion hindered and restricted compartment for a given direction
<cite>theta:math:</cite>, <cite>b:math:</cite> is the b value provided in the GradientTable input for that
direction, <a href="#id24"><span class="problematic" id="id25">`</span></a>f$ is the volume fraction of the restricted diffusion
compartment (also known as the axonal water fraction). 2) In the original article of DKI microstructural model <a href="#id1334"><span class="problematic" id="id26">[1]_</span></a>, the hindered
and restricted tensors were defined as the intra-cellular and
extra-cellular diffusion compartments respectively. .</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dki_micro.tortuosity" title="dipy.reconst.dki_micro.tortuosity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tortuosity</span></code></a>(hindered_ad, hindered_rd)</p></td>
<td><p>Computes the tortuosity of the hindered diffusion compartment given its axial and radial diffusivities</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.dsi">
<span id="module-reconst-dsi"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dsi</span></code><a class="headerlink" href="#module-dipy.reconst.dsi" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a>(gtab[, qgrid_size, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a>(model, data)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a>(gtab[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a>(model, data)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.create_qspace" title="dipy.reconst.dsi.create_qspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_qspace</span></code></a>(gtab, origin)</p></td>
<td><p>create the 3D grid which holds the signal values (q-space)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.create_qtable" title="dipy.reconst.dsi.create_qtable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_qtable</span></code></a>(gtab, origin)</p></td>
<td><p>create a normalized version of gradients</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.hanning_filter" title="dipy.reconst.dsi.hanning_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hanning_filter</span></code></a>(gtab, filter_width, origin)</p></td>
<td><p>create a hanning window</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.pdf_interp_coords" title="dipy.reconst.dsi.pdf_interp_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf_interp_coords</span></code></a>(sphere, rradius, origin)</p></td>
<td><p>Precompute coordinates for ODF calculation from the PDF</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.pdf_odf" title="dipy.reconst.dsi.pdf_odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf_odf</span></code></a>(Pr, rradius, interp_coords)</p></td>
<td><p>Calculates the real ODF from the diffusion propagator(PDF) Pr</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.half_to_full_qspace" title="dipy.reconst.dsi.half_to_full_qspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">half_to_full_qspace</span></code></a>(data, gtab)</p></td>
<td><p>Half to full Cartesian grid mapping</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.project_hemisph_bvecs" title="dipy.reconst.dsi.project_hemisph_bvecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project_hemisph_bvecs</span></code></a>(gtab)</p></td>
<td><p>Project any near identical bvecs to the other hemisphere</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.threshold_propagator" title="dipy.reconst.dsi.threshold_propagator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold_propagator</span></code></a>(P[, estimated_snr])</p></td>
<td><p>Applies hard threshold on the propagator to remove background noise for the deconvolution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dsi.gen_PSF" title="dipy.reconst.dsi.gen_PSF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_PSF</span></code></a>(qgrid_sampling, siz_x, siz_y, siz_z)</p></td>
<td><p>Generate a PSF for DSI Deconvolution by taking the ifft of the binary q-space sampling mask and truncating it to keep only the center.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dsi.LR_deconv" title="dipy.reconst.dsi.LR_deconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LR_deconv</span></code></a>(prop, psf[, numit, acc_factor])</p></td>
<td><p>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.dti">
<span id="module-reconst-dti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dti</span></code><a class="headerlink" href="#module-dipy.reconst.dti" title="Permalink to this heading">#</a></h2>
<p>Classes and functions for fitting tensors</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorModel" title="dipy.reconst.dti.TensorModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorModel</span></code></a>(gtab[, fit_method, return_S0_hat])</p></td>
<td><p>Diffusion Tensor</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorFit</span></code></a>(model, model_params[, model_S0])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.fractional_anisotropy" title="dipy.reconst.dti.fractional_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractional_anisotropy</span></code></a>(evals[, axis])</p></td>
<td><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.geodesic_anisotropy" title="dipy.reconst.dti.geodesic_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geodesic_anisotropy</span></code></a>(evals[, axis])</p></td>
<td><p>Geodesic anisotropy (GA) of a diffusion tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.mean_diffusivity" title="dipy.reconst.dti.mean_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_diffusivity</span></code></a>(evals[, axis])</p></td>
<td><p>Mean Diffusivity (MD) of a diffusion tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.axial_diffusivity" title="dipy.reconst.dti.axial_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axial_diffusivity</span></code></a>(evals[, axis])</p></td>
<td><p>Axial Diffusivity (AD) of a diffusion tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.radial_diffusivity" title="dipy.reconst.dti.radial_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_diffusivity</span></code></a>(evals[, axis])</p></td>
<td><p>Radial Diffusivity (RD) of a diffusion tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.trace" title="dipy.reconst.dti.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>(evals[, axis])</p></td>
<td><p>Trace of a diffusion tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.color_fa" title="dipy.reconst.dti.color_fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code></a>(fa, evecs)</p></td>
<td><p>Color fractional anisotropy of diffusion tensor</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.determinant" title="dipy.reconst.dti.determinant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">determinant</span></code></a>(q_form)</p></td>
<td><p>The determinant of a tensor, given in quadratic form</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.isotropic" title="dipy.reconst.dti.isotropic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isotropic</span></code></a>(q_form)</p></td>
<td><p>Calculate the isotropic part of the tensor <a href="#id1335"><span class="problematic" id="id27">[1]_</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.deviatoric" title="dipy.reconst.dti.deviatoric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deviatoric</span></code></a>(q_form)</p></td>
<td><p>Calculate the deviatoric (anisotropic) part of the tensor <a href="#id1336"><span class="problematic" id="id28">[1]_</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.norm" title="dipy.reconst.dti.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>(q_form)</p></td>
<td><p>Calculate the Frobenius norm of a tensor quadratic form</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.mode" title="dipy.reconst.dti.mode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code></a>(q_form)</p></td>
<td><p>Mode (MO) of a diffusion tensor <a href="#id1337"><span class="problematic" id="id29">[1]_</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.linearity" title="dipy.reconst.dti.linearity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code></a>(evals[, axis])</p></td>
<td><p>The linearity of the tensor <a href="#id1338"><span class="problematic" id="id30">[1]_</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.planarity" title="dipy.reconst.dti.planarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code></a>(evals[, axis])</p></td>
<td><p>The planarity of the tensor <a href="#id1339"><span class="problematic" id="id31">[1]_</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.sphericity" title="dipy.reconst.dti.sphericity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code></a>(evals[, axis])</p></td>
<td><p>The sphericity of the tensor <a href="#id1340"><span class="problematic" id="id32">[1]_</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.apparent_diffusion_coef" title="dipy.reconst.dti.apparent_diffusion_coef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apparent_diffusion_coef</span></code></a>(q_form, sphere)</p></td>
<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction of a sphere.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.tensor_prediction" title="dipy.reconst.dti.tensor_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_prediction</span></code></a>(dti_params, gtab, S0)</p></td>
<td><p>Predict a signal given tensor parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.iter_fit_tensor" title="dipy.reconst.dti.iter_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_fit_tensor</span></code></a>([step])</p></td>
<td><p>Wrap a fit_tensor func and iterate over chunks of data with given length</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.wls_fit_tensor" title="dipy.reconst.dti.wls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_tensor</span></code></a>(design_matrix, data[, ...])</p></td>
<td><p>Computes weighted least squares (WLS) fit to calculate self-diffusion tensor using a linear regression model <a href="#id1341"><span class="problematic" id="id33">[1]_</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.ols_fit_tensor" title="dipy.reconst.dti.ols_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ols_fit_tensor</span></code></a>(design_matrix, data[, ...])</p></td>
<td><p>Computes ordinary least squares (OLS) fit to calculate self-diffusion tensor using a linear regression model <a href="#id1342"><span class="problematic" id="id34">[1]_</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.nlls_fit_tensor" title="dipy.reconst.dti.nlls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlls_fit_tensor</span></code></a>(design_matrix, data[, ...])</p></td>
<td><p>Fit the cumulant expansion params (e.g.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.restore_fit_tensor" title="dipy.reconst.dti.restore_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">restore_fit_tensor</span></code></a>(design_matrix, data[, ...])</p></td>
<td><p>Use the RESTORE algorithm <a href="#id1343"><span class="problematic" id="id35">[1]_</span></a> to calculate a robust tensor fit</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti._lt_indices" title="dipy.reconst.dti._lt_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_lt_indices</span></code></a></p></td>
<td><p>ndarray(shape, dtype=float, buffer=None, offset=0,</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.from_lower_triangular" title="dipy.reconst.dti.from_lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_lower_triangular</span></code></a>(D)</p></td>
<td><p>Returns a tensor given the six unique tensor elements</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti._lt_rows" title="dipy.reconst.dti._lt_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_lt_rows</span></code></a></p></td>
<td><p>ndarray(shape, dtype=float, buffer=None, offset=0,</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti._lt_cols" title="dipy.reconst.dti._lt_cols"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_lt_cols</span></code></a></p></td>
<td><p>ndarray(shape, dtype=float, buffer=None, offset=0,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.lower_triangular" title="dipy.reconst.dti.lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_triangular</span></code></a>(tensor[, b0])</p></td>
<td><p>Returns the six lower triangular values of the tensor ordered as (Dxx, Dxy, Dyy, Dxz, Dyz, Dzz) and a dummy variable if b0 is not None.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a>(tensor[, min_diffusivity])</p></td>
<td><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.design_matrix" title="dipy.reconst.dti.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>(gtab[, dtype])</p></td>
<td><p>Constructs design matrix for DTI weighted least squares or least squares fitting.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.dti.quantize_evecs" title="dipy.reconst.dti.quantize_evecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantize_evecs</span></code></a>(evecs[, odf_vertices])</p></td>
<td><p>Find the closest orientation of an evenly distributed sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.dti.eig_from_lo_tri" title="dipy.reconst.dti.eig_from_lo_tri"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eig_from_lo_tri</span></code></a>(data[, min_diffusivity])</p></td>
<td><p>Calculates tensor eigenvalues/eigenvectors from an array containing the lower diagonal form of the six unique tensor elements.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.eudx_direction_getter">
<span id="module-reconst-eudx-direction-getter"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.eudx_direction_getter</span></code><a class="headerlink" href="#module-dipy.reconst.eudx_direction_getter" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter" title="dipy.reconst.eudx_direction_getter.EuDXDirectionGetter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EuDXDirectionGetter</span></code></a></p></td>
<td><p>Deterministic Direction Getter based on peak directions.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.forecast">
<span id="module-reconst-forecast"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.forecast</span></code><a class="headerlink" href="#module-dipy.reconst.forecast" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.ForecastModel" title="dipy.reconst.forecast.ForecastModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForecastModel</span></code></a>(gtab[, sh_order, lambda_lb, ...])</p></td>
<td><p>Fiber ORientation Estimated using Continuous Axially Symmetric Tensors (FORECAST) [1,2,3]_.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit" title="dipy.reconst.forecast.ForecastFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForecastFit</span></code></a>(model, data, sh_coef, d_par, d_perp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.find_signal_means" title="dipy.reconst.forecast.find_signal_means"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_signal_means</span></code></a>(b_unique, data_norm, ...)</p></td>
<td><p>Calculate the mean signal for each shell.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.forecast_error_func" title="dipy.reconst.forecast.forecast_error_func"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forecast_error_func</span></code></a>(x, b_unique, E)</p></td>
<td><p>Calculates the difference between the mean signal calculated using the parameter vector x and the average signal E using FORECAST and SMT</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.psi_l" title="dipy.reconst.forecast.psi_l"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psi_l</span></code></a>(l, b)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.forecast_matrix" title="dipy.reconst.forecast.forecast_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forecast_matrix</span></code></a>(sh_order, d_par, d_perp, bvals)</p></td>
<td><p>Compute the FORECAST radial matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.forecast.rho_matrix" title="dipy.reconst.forecast.rho_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rho_matrix</span></code></a>(sh_order, vecs)</p></td>
<td><p>Compute the SH matrix <span class="math notranslate nohighlight">\(\rho\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.forecast.lb_forecast" title="dipy.reconst.forecast.lb_forecast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lb_forecast</span></code></a>(sh_order)</p></td>
<td><p>Returns the Laplace-Beltrami regularization matrix for FORECAST</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.fwdti">
<span id="module-reconst-fwdti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.fwdti</span></code><a class="headerlink" href="#module-dipy.reconst.fwdti" title="Permalink to this heading">#</a></h2>
<p>Classes and functions for fitting tensors without free water
contamination</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel" title="dipy.reconst.fwdti.FreeWaterTensorModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a>(gtab[, fit_method])</p></td>
<td><p>Class for the Free Water Elimination Diffusion Tensor Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit" title="dipy.reconst.fwdti.FreeWaterTensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a>(model, model_params)</p></td>
<td><p>Class for fitting the Free Water Tensor Model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.fwdti_prediction" title="dipy.reconst.fwdti.fwdti_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fwdti_prediction</span></code></a>(params, gtab[, S0, Diso])</p></td>
<td><p>Signal prediction given the free water DTI model parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.wls_iter" title="dipy.reconst.fwdti.wls_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_iter</span></code></a>(design_matrix, sig, S0[, Diso, ...])</p></td>
<td><p>Applies weighted linear least squares fit of the water free elimination
model to single voxel signals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.wls_fit_tensor" title="dipy.reconst.fwdti.wls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_tensor</span></code></a>(gtab, data[, Diso, mask, ...])</p></td>
<td><p>Computes weighted least squares (WLS) fit to calculate self-diffusion
tensor using a linear regression model <a href="#id1344"><span class="problematic" id="id36">[1]_</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.nls_iter" title="dipy.reconst.fwdti.nls_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nls_iter</span></code></a>(design_matrix, sig, S0[, Diso, ...])</p></td>
<td><p>Applies non linear least squares fit of the water free elimination
model to single voxel signals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.nls_fit_tensor" title="dipy.reconst.fwdti.nls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nls_fit_tensor</span></code></a>(gtab, data[, mask, Diso, ...])</p></td>
<td><p>Fit the water elimination tensor model using the non-linear least-squares.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.lower_triangular_to_cholesky" title="dipy.reconst.fwdti.lower_triangular_to_cholesky"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_triangular_to_cholesky</span></code></a>(tensor_elements)</p></td>
<td><p>Performs Cholesky decomposition of the diffusion tensor</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.fwdti.cholesky_to_lower_triangular" title="dipy.reconst.fwdti.cholesky_to_lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cholesky_to_lower_triangular</span></code></a>(R)</p></td>
<td><p>Convert Cholesky decomposition elements to the diffusion tensor elements</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.gqi">
<span id="module-reconst-gqi"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.gqi</span></code><a class="headerlink" href="#module-dipy.reconst.gqi" title="Permalink to this heading">#</a></h2>
<p>Classes and functions for generalized q-sampling</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="dipy.reconst.gqi.GeneralizedQSamplingModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a>(gtab[, method, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="dipy.reconst.gqi.GeneralizedQSamplingFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a>(model, data)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.normalize_qa" title="dipy.reconst.gqi.normalize_qa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_qa</span></code></a>(qa[, max_qa])</p></td>
<td><p>Normalize quantitative anisotropy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.squared_radial_component" title="dipy.reconst.gqi.squared_radial_component"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squared_radial_component</span></code></a>(x[, tol])</p></td>
<td><p>Part of the GQI2 integral</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.npa" title="dipy.reconst.gqi.npa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">npa</span></code></a>(self, odf[, width])</p></td>
<td><p>non-parametric anisotropy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.equatorial_zone_vertices" title="dipy.reconst.gqi.equatorial_zone_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equatorial_zone_vertices</span></code></a>(vertices, pole[, width])</p></td>
<td><p>finds the 'vertices' in the equatorial zone conjugate to 'pole' with width half 'width' degrees</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.polar_zone_vertices" title="dipy.reconst.gqi.polar_zone_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polar_zone_vertices</span></code></a>(vertices, pole[, width])</p></td>
<td><p>finds the 'vertices' in the equatorial band around the 'pole' of radius 'width' degrees</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.upper_hemi_map" title="dipy.reconst.gqi.upper_hemi_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper_hemi_map</span></code></a>(v)</p></td>
<td><p>maps a 3-vector into the z-upper hemisphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.equatorial_maximum" title="dipy.reconst.gqi.equatorial_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equatorial_maximum</span></code></a>(vertices, odf, pole, width)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.patch_vertices" title="dipy.reconst.gqi.patch_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">patch_vertices</span></code></a>(vertices, pole, width)</p></td>
<td><p>find 'vertices' within the cone of 'width' degrees around 'pole'</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.patch_maximum" title="dipy.reconst.gqi.patch_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">patch_maximum</span></code></a>(vertices, odf, pole, width)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.odf_sum" title="dipy.reconst.gqi.odf_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sum</span></code></a>(odf)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.gqi.patch_sum" title="dipy.reconst.gqi.patch_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">patch_sum</span></code></a>(vertices, odf, pole, width)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.gqi.triple_odf_maxima" title="dipy.reconst.gqi.triple_odf_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triple_odf_maxima</span></code></a>(vertices, odf, width)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.ivim">
<span id="module-reconst-ivim"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.ivim</span></code><a class="headerlink" href="#module-dipy.reconst.ivim" title="Permalink to this heading">#</a></h2>
<p>Classes and functions for fitting ivim model</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelTRR" title="dipy.reconst.ivim.IvimModelTRR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IvimModelTRR</span></code></a>(gtab[, split_b_D, split_b_S0, ...])</p></td>
<td><p>Ivim model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP" title="dipy.reconst.ivim.IvimModelVP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IvimModelVP</span></code></a>(gtab[, bounds, maxiter, xtol])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.IvimFit" title="dipy.reconst.ivim.IvimFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IvimFit</span></code></a>(model, model_params)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.ivim_prediction" title="dipy.reconst.ivim.ivim_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ivim_prediction</span></code></a>(params, gtab)</p></td>
<td><p>The Intravoxel incoherent motion (IVIM) model function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.f_D_star_prediction" title="dipy.reconst.ivim.f_D_star_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_D_star_prediction</span></code></a>(params, gtab, S0, D)</p></td>
<td><p>Function used to predict IVIM signal when S0 and D are known by considering f and D_star as the unknown parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.ivim.f_D_star_error" title="dipy.reconst.ivim.f_D_star_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_D_star_error</span></code></a>(params, gtab, signal, S0, D)</p></td>
<td><p>Error function used to fit f and D_star keeping S0 and D fixed</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.ivim.ivim_model_selector" title="dipy.reconst.ivim.ivim_model_selector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ivim_model_selector</span></code></a>(gtab[, fit_method])</p></td>
<td><p>Selector function to switch between the 2-stage Trust-Region Reflective based NLLS fitting method (also containing the linear fit): <cite>trr</cite> and the Variable Projections based fitting method: <cite>varpro</cite>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.mapmri">
<span id="module-reconst-mapmri"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.mapmri</span></code><a class="headerlink" href="#module-dipy.reconst.mapmri" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriModel" title="dipy.reconst.mapmri.MapmriModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MapmriModel</span></code></a>(gtab[, radial_order, ...])</p></td>
<td><p>Mean Apparent Propagator MRI (MAPMRI) <a href="#id1345"><span class="problematic" id="id37">[1]_</span></a> of the diffusion signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit" title="dipy.reconst.mapmri.MapmriFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MapmriFit</span></code></a>(model, mapmri_coef, mu, R, lopt[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.isotropic_scale_factor" title="dipy.reconst.mapmri.isotropic_scale_factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isotropic_scale_factor</span></code></a>(mu_squared)</p></td>
<td><p>Estimated isotropic scaling factor _[1] Eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_index_matrix" title="dipy.reconst.mapmri.mapmri_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_index_matrix</span></code></a>(radial_order)</p></td>
<td><p>Calculates the indices for the MAPMRI <a href="#id1346"><span class="problematic" id="id38">[1]_</span></a> basis in x, y and z.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.b_mat" title="dipy.reconst.mapmri.b_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b_mat</span></code></a>(index_matrix)</p></td>
<td><p>Calculates the B coefficients from <a href="#id1347"><span class="problematic" id="id39">[1]_</span></a> Eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.b_mat_isotropic" title="dipy.reconst.mapmri.b_mat_isotropic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b_mat_isotropic</span></code></a>(index_matrix)</p></td>
<td><p>Calculates the isotropic B coefficients from <a href="#id1348"><span class="problematic" id="id40">[1]_</span></a> Fig 8.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_phi_1d" title="dipy.reconst.mapmri.mapmri_phi_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_phi_1d</span></code></a>(n, q, mu)</p></td>
<td><p>One dimensional MAPMRI basis function from <a href="#id1349"><span class="problematic" id="id41">[1]_</span></a> Eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_phi_matrix" title="dipy.reconst.mapmri.mapmri_phi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_phi_matrix</span></code></a>(radial_order, mu, q_gradients)</p></td>
<td><p>Compute the MAPMRI phi matrix for the signal <a href="#id1350"><span class="problematic" id="id42">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_psi_1d" title="dipy.reconst.mapmri.mapmri_psi_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_psi_1d</span></code></a>(n, x, mu)</p></td>
<td><p>One dimensional MAPMRI propagator basis function from <a href="#id1351"><span class="problematic" id="id43">[1]_</span></a> Eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_psi_matrix" title="dipy.reconst.mapmri.mapmri_psi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_psi_matrix</span></code></a>(radial_order, mu, rgrad)</p></td>
<td><p>Compute the MAPMRI psi matrix for the propagator <a href="#id1352"><span class="problematic" id="id44">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_odf_matrix" title="dipy.reconst.mapmri.mapmri_odf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_odf_matrix</span></code></a>(radial_order, mu, s, vertices)</p></td>
<td><p>Compute the MAPMRI ODF matrix <a href="#id1353"><span class="problematic" id="id45">[1]_</span></a>  Eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_phi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_phi_matrix</span></code></a>(radial_order, mu, q)</p></td>
<td><p>Three dimensional isotropic MAPMRI signal basis function from <a href="#id1354"><span class="problematic" id="id46">[1]_</span></a> Eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis" title="dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_signal_basis</span></code></a>(j, l, ...)</p></td>
<td><p>Radial part of the isotropic 1D-SHORE signal basis <a href="#id1355"><span class="problematic" id="id47">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent" title="dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_independent</span></code></a>(...)</p></td>
<td><p>Computed the mu independent part of the signal design matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent" title="dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_dependent</span></code></a>(...)</p></td>
<td><p>Computed the mu dependent part of the signal design matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_psi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_psi_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Three dimensional isotropic MAPMRI propagator basis function from <a href="#id1356"><span class="problematic" id="id48">[1]_</span></a> Eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis" title="dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_pdf_basis</span></code></a>(j, l, mu, r)</p></td>
<td><p>Radial part of the isotropic 1D-SHORE propagator basis <a href="#id1357"><span class="problematic" id="id49">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent" title="dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_independent</span></code></a>(...)</p></td>
<td><p>Computes mu independent part of K.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent" title="dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_dependent</span></code></a>(...)</p></td>
<td><p>Computes mu dependent part of M.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.binomialfloat" title="dipy.reconst.mapmri.binomialfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">binomialfloat</span></code></a>(n, k)</p></td>
<td><p>Custom Binomial function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_odf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Compute the isotropic MAPMRI ODF matrix <a href="#id1358"><span class="problematic" id="id50">[1]_</span></a> Eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_sh_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Compute the isotropic MAPMRI ODF matrix <a href="#id1359"><span class="problematic" id="id51">[1]_</span></a> Eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix</span></code></a>(...)</p></td>
<td><p>Computes the Laplacian regularization matrix for MAP-MRI's isotropic implementation <a href="#id1360"><span class="problematic" id="id52">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</span></code></a>(...)</p></td>
<td><p>Computes the Laplacian regularization matrix for MAP-MRI's isotropic implementation <a href="#id1361"><span class="problematic" id="id53">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_index_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_index_matrix</span></code></a>(radial_order)</p></td>
<td><p>Calculates the indices for the isotropic MAPMRI basis <a href="#id1362"><span class="problematic" id="id54">[1]_</span></a> Fig 8.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.create_rspace" title="dipy.reconst.mapmri.create_rspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_rspace</span></code></a>(gridsize, radius_max)</p></td>
<td><p>Create the real space table, that contains the points in which to compute the pdf.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.delta" title="dipy.reconst.mapmri.delta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delta</span></code></a>(n, m)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.map_laplace_u" title="dipy.reconst.mapmri.map_laplace_u"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_laplace_u</span></code></a>(n, m)</p></td>
<td><p>S(n, m) static matrix for Laplacian regularization <a href="#id1363"><span class="problematic" id="id55">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.map_laplace_t" title="dipy.reconst.mapmri.map_laplace_t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_laplace_t</span></code></a>(n, m)</p></td>
<td><p>L(m, n) static matrix for Laplacian regularization <a href="#id1364"><span class="problematic" id="id56">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.map_laplace_s" title="dipy.reconst.mapmri.map_laplace_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_laplace_s</span></code></a>(n, m)</p></td>
<td><p>R(m,n) static matrix for Laplacian regularization <a href="#id1365"><span class="problematic" id="id57">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_STU_reg_matrices" title="dipy.reconst.mapmri.mapmri_STU_reg_matrices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_STU_reg_matrices</span></code></a>(radial_order)</p></td>
<td><p>Generate the static portions of the Laplacian regularization matrix according to <a href="#id1366"><span class="problematic" id="id58">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix" title="dipy.reconst.mapmri.mapmri_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_laplacian_reg_matrix</span></code></a>(ind_mat, mu, ...)</p></td>
<td><p>Put the Laplacian regularization matrix together <a href="#id1367"><span class="problematic" id="id59">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.generalized_crossvalidation_array" title="dipy.reconst.mapmri.generalized_crossvalidation_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generalized_crossvalidation_array</span></code></a>(data, M, LR)</p></td>
<td><p>Generalized Cross Validation Function <a href="#id1368"><span class="problematic" id="id60">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.generalized_crossvalidation" title="dipy.reconst.mapmri.generalized_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generalized_crossvalidation</span></code></a>(data, M, LR[, ...])</p></td>
<td><p>Generalized Cross Validation Function <a href="#id1369"><span class="problematic" id="id61">[1]_</span></a> eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mapmri.gcv_cost_function" title="dipy.reconst.mapmri.gcv_cost_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gcv_cost_function</span></code></a>(weight, args)</p></td>
<td><p>The GCV cost function that is iterated [4].</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.mcsd">
<span id="module-reconst-mcsd"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.mcsd</span></code><a class="headerlink" href="#module-dipy.reconst.mcsd" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellResponse" title="dipy.reconst.mcsd.MultiShellResponse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiShellResponse</span></code></a>(response, sh_order, shells)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellDeconvModel" title="dipy.reconst.mcsd.MultiShellDeconvModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiShellDeconvModel</span></code></a>(gtab, response[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.MSDeconvFit" title="dipy.reconst.mcsd.MSDeconvFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MSDeconvFit</span></code></a>(model, coeff, mask)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.QpFitter" title="dipy.reconst.mcsd.QpFitter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QpFitter</span></code></a>(X, reg)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.multi_tissue_basis" title="dipy.reconst.mcsd.multi_tissue_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_tissue_basis</span></code></a>(gtab, sh_order, iso_comp)</p></td>
<td><p>Builds a basis for multi-shell multi-tissue CSD model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.solve_qp" title="dipy.reconst.mcsd.solve_qp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_qp</span></code></a>(P, Q, G, H)</p></td>
<td><p>Helper function to set up and solve the Quadratic Program (QP) in CVXPY.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.multi_shell_fiber_response" title="dipy.reconst.mcsd.multi_shell_fiber_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_shell_fiber_response</span></code></a>(sh_order, bvals, ...)</p></td>
<td><p>Fiber response function estimation for multi-shell data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.mask_for_response_msmt" title="dipy.reconst.mcsd.mask_for_response_msmt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mask_for_response_msmt</span></code></a>(gtab, data[, ...])</p></td>
<td><p>Computation of masks for multi-shell multi-tissue (msmt) response</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.response_from_mask_msmt" title="dipy.reconst.mcsd.response_from_mask_msmt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">response_from_mask_msmt</span></code></a>(gtab, data, mask_wm, ...)</p></td>
<td><p>Computation of multi-shell multi-tissue (msmt) response</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.mcsd.auto_response_msmt" title="dipy.reconst.mcsd.auto_response_msmt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_response_msmt</span></code></a>(gtab, data[, tol, ...])</p></td>
<td><p>Automatic estimation of multi-shell multi-tissue (msmt) response</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.msdki">
<span id="module-reconst-msdki"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.msdki</span></code><a class="headerlink" href="#module-dipy.reconst.msdki" title="Permalink to this heading">#</a></h2>
<p>Classes and functions for fitting the mean signal diffusion kurtosis
model</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel" title="dipy.reconst.msdki.MeanDiffusionKurtosisModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel</span></code></a>(gtab[, bmag, ...])</p></td>
<td><p>Mean signal Diffusion Kurtosis Model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit</span></code></a>(model, model_params)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.mean_signal_bvalue" title="dipy.reconst.msdki.mean_signal_bvalue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_signal_bvalue</span></code></a>(data, gtab[, bmag])</p></td>
<td><p>Computes the average signal across different diffusion directions
for each unique b-value

Parameters
----------
data : ndarray ([X, Y, Z, ...], g)
    ndarray containing the data signals in its last dimension.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.msk_from_awf" title="dipy.reconst.msdki.msk_from_awf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msk_from_awf</span></code></a>(f)</p></td>
<td><p>Computes mean signal kurtosis from axonal water fraction estimates of the SMT2 model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.awf_from_msk" title="dipy.reconst.msdki.awf_from_msk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">awf_from_msk</span></code></a>(msk[, mask])</p></td>
<td><p>Computes the axonal water fraction from the mean signal kurtosis assuming the 2-compartmental spherical mean technique model <a href="#id1370"><span class="problematic" id="id62">[1]_</span></a>, <a href="#id1371"><span class="problematic" id="id63">[2]_</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.msdki_prediction" title="dipy.reconst.msdki.msdki_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msdki_prediction</span></code></a>(msdki_params, gtab[, S0])</p></td>
<td><p>Predict the mean signal given the parameters of the mean signal DKI, an
GradientTable object and S0 signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.msdki.wls_fit_msdki" title="dipy.reconst.msdki.wls_fit_msdki"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_msdki</span></code></a>(design_matrix, msignal, ng[, ...])</p></td>
<td><p>Fits the mean signal diffusion kurtosis imaging based on a weighted least square solution <a href="#id1372"><span class="problematic" id="id64">[1]_</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.msdki.design_matrix" title="dipy.reconst.msdki.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>(ubvals)</p></td>
<td><p>Constructs design matrix for the mean signal diffusion kurtosis model</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.multi_voxel">
<span id="module-reconst-multi-voxel"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.multi_voxel</span></code><a class="headerlink" href="#module-dipy.reconst.multi_voxel" title="Permalink to this heading">#</a></h2>
<p>Tools to easily make multi voxel models</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="dipy.reconst.multi_voxel.MultiVoxelFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a>(model, fit_array, mask)</p></td>
<td><p>Holds an array of fits and allows access to their attributes and methods</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.multi_voxel.CallableArray" title="dipy.reconst.multi_voxel.CallableArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CallableArray</span></code></a></p></td>
<td><p>An array which can be called like a function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.multi_voxel.multi_voxel_fit" title="dipy.reconst.multi_voxel.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>
<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.odf">
<span id="module-reconst-odf"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.odf</span></code><a class="headerlink" href="#module-dipy.reconst.odf" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfModel</span></code></a>(gtab)</p></td>
<td><p>An abstract class to be sub-classed by specific odf models</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfFit</span></code></a>(model, data)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.odf.gfa" title="dipy.reconst.odf.gfa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gfa</span></code></a>(samples)</p></td>
<td><p>The general fractional anisotropy of a function evaluated
on the unit sphere

Parameters
----------
samples : ndarray
    Values of data on the unit sphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.odf.minmax_normalize" title="dipy.reconst.odf.minmax_normalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minmax_normalize</span></code></a>(samples[, out])</p></td>
<td><p>Min-max normalization of a function evaluated on the unit sphere</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.qtdmri">
<span id="module-reconst-qtdmri"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.qtdmri</span></code><a class="headerlink" href="#module-dipy.reconst.qtdmri" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriModel" title="dipy.reconst.qtdmri.QtdmriModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a>(gtab[, radial_order, ...])</p></td>
<td><p>The q:math:<cite>tau</cite>-dMRI model [1] to analytically and continuously represent
the q:math:<cite>tau</cite> diffusion signal attenuation over diffusion sensitization
q and diffusion time <span class="math notranslate nohighlight">\(\tau\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit" title="dipy.reconst.qtdmri.QtdmriFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a>(model, qtdmri_coef, us, ut, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix" title="dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_to_mapmri_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Generates the matrix that maps the qtdmri coefficients to MAP-MRI coefficients.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_to_mapmri_matrix</span></code></a>(...)</p></td>
<td><p>Generates the matrix that maps the spherical qtdmri coefficients to MAP-MRI coefficients.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_temporal_normalization" title="dipy.reconst.qtdmri.qtdmri_temporal_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_temporal_normalization</span></code></a>(ut)</p></td>
<td><p>Normalization factor for the temporal basis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_mapmri_normalization" title="dipy.reconst.qtdmri.qtdmri_mapmri_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_mapmri_normalization</span></code></a>(mu)</p></td>
<td><p>Normalization factor for Cartesian MAP-MRI basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization" title="dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_mapmri_isotropic_normalization</span></code></a>(j, l, u0)</p></td>
<td><p>Normalization factor for Spherical MAP-MRI basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix_" title="dipy.reconst.qtdmri.qtdmri_signal_matrix_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_signal_matrix_</span></code></a>(radial_order, ...[, ...])</p></td>
<td><p>Function to generate the qtdmri signal basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix" title="dipy.reconst.qtdmri.qtdmri_signal_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_signal_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix" title="dipy.reconst.qtdmri.qtdmri_eap_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_eap_matrix</span></code></a>(radial_order, time_order, ...)</p></td>
<td><p>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_" title="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_signal_matrix_</span></code></a>(...[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_signal_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix_" title="dipy.reconst.qtdmri.qtdmri_eap_matrix_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_eap_matrix_</span></code></a>(radial_order, time_order, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_" title="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_eap_matrix_</span></code></a>(radial_order, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_eap_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.radial_basis_opt" title="dipy.reconst.qtdmri.radial_basis_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_basis_opt</span></code></a>(j, l, us, q)</p></td>
<td><p>Spatial basis dependent on spatial scaling factor us</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.angular_basis_opt" title="dipy.reconst.qtdmri.angular_basis_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angular_basis_opt</span></code></a>(l, m, q, theta, phi)</p></td>
<td><p>Angular basis independent of spatial scaling factor us.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.radial_basis_EAP_opt" title="dipy.reconst.qtdmri.radial_basis_EAP_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_basis_EAP_opt</span></code></a>(j, l, us, r)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.angular_basis_EAP_opt" title="dipy.reconst.qtdmri.angular_basis_EAP_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angular_basis_EAP_opt</span></code></a>(j, l, m, r, theta, phi)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.temporal_basis" title="dipy.reconst.qtdmri.temporal_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">temporal_basis</span></code></a>(o, ut, tau)</p></td>
<td><p>Temporal basis dependent on temporal scaling factor ut</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_index_matrix" title="dipy.reconst.qtdmri.qtdmri_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_index_matrix</span></code></a>(radial_order, time_order)</p></td>
<td><p>Computes the SHORE basis order indices according to [1].</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_index_matrix</span></code></a>(radial_order, ...)</p></td>
<td><p>Computes the SHORE basis order indices according to [1].</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix" title="dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_laplacian_reg_matrix</span></code></a>(ind_mat, us, ut)</p></td>
<td><p>Computes the cartesian qt-dMRI Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_laplacian_reg_matrix</span></code></a>(...[, ...])</p></td>
<td><p>Computes the spherical qt-dMRI Laplacian regularization matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part23_reg_matrix_q" title="dipy.reconst.qtdmri.part23_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part23_reg_matrix_q</span></code></a>(ind_mat, U_mat, T_mat, us)</p></td>
<td><p>Partial cartesian spatial Laplacian regularization matrix following second line of Eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part23_iso_reg_matrix_q" title="dipy.reconst.qtdmri.part23_iso_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part23_iso_reg_matrix_q</span></code></a>(ind_mat, us)</p></td>
<td><p>Partial spherical spatial Laplacian regularization matrix following the equation below Eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part4_reg_matrix_q" title="dipy.reconst.qtdmri.part4_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part4_reg_matrix_q</span></code></a>(ind_mat, U_mat, us)</p></td>
<td><p>Partial cartesian spatial Laplacian regularization matrix following equation Eq.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part4_iso_reg_matrix_q" title="dipy.reconst.qtdmri.part4_iso_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part4_iso_reg_matrix_q</span></code></a>(ind_mat, us)</p></td>
<td><p>Partial spherical spatial Laplacian regularization matrix following the equation below Eq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part1_reg_matrix_tau" title="dipy.reconst.qtdmri.part1_reg_matrix_tau"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part1_reg_matrix_tau</span></code></a>(ind_mat, ut)</p></td>
<td><p>Partial temporal Laplacian regularization matrix following Appendix B in [1].</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part23_reg_matrix_tau" title="dipy.reconst.qtdmri.part23_reg_matrix_tau"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part23_reg_matrix_tau</span></code></a>(ind_mat, ut)</p></td>
<td><p>Partial temporal Laplacian regularization matrix following Appendix B in [1].</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.part4_reg_matrix_tau" title="dipy.reconst.qtdmri.part4_reg_matrix_tau"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part4_reg_matrix_tau</span></code></a>(ind_mat, ut)</p></td>
<td><p>Partial temporal Laplacian regularization matrix following Appendix B in [1].</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.H" title="dipy.reconst.qtdmri.H"><code class="xref py py-obj docutils literal notranslate"><span class="pre">H</span></code></a>(value)</p></td>
<td><p>Step function of H(x)=1 if x&gt;=0 and zero otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.generalized_crossvalidation" title="dipy.reconst.qtdmri.generalized_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generalized_crossvalidation</span></code></a>(data, M, LR[, ...])</p></td>
<td><p>Generalized Cross Validation Function [1].</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.GCV_cost_function" title="dipy.reconst.qtdmri.GCV_cost_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GCV_cost_function</span></code></a>(weight, arguments)</p></td>
<td><p>Generalized Cross Validation Function that is iterated [1].</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_scaling" title="dipy.reconst.qtdmri.qtdmri_isotropic_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_scaling</span></code></a>(data, q, tau)</p></td>
<td><p>Constructs design matrix for fitting an exponential to the diffusion time points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling" title="dipy.reconst.qtdmri.qtdmri_anisotropic_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_anisotropic_scaling</span></code></a>(data, q, bvecs, tau)</p></td>
<td><p>Constructs design matrix for fitting an exponential to the diffusion time points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.design_matrix_spatial" title="dipy.reconst.qtdmri.design_matrix_spatial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix_spatial</span></code></a>(bvecs, qvals)</p></td>
<td><p>Constructs design matrix for DTI weighted least squares or least squares fitting.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.create_rt_space_grid" title="dipy.reconst.qtdmri.create_rt_space_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_rt_space_grid</span></code></a>(grid_size_r, ...)</p></td>
<td><p>Generates EAP grid (for potential positivity constraint).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_number_of_coefficients" title="dipy.reconst.qtdmri.qtdmri_number_of_coefficients"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_number_of_coefficients</span></code></a>(radial_order, ...)</p></td>
<td><p>Computes the total number of coefficients of the qtdmri basis given a radial and temporal order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.l1_crossvalidation" title="dipy.reconst.qtdmri.l1_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">l1_crossvalidation</span></code></a>(b0s_mask, E, M[, ...])</p></td>
<td><p>cross-validation function to find the optimal weight of alpha for sparsity regularization</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.elastic_crossvalidation" title="dipy.reconst.qtdmri.elastic_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">elastic_crossvalidation</span></code></a>(b0s_mask, E, M, L, lopt)</p></td>
<td><p>cross-validation function to find the optimal weight of alpha for sparsity regularization when also Laplacian regularization is used.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow" title="dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualise_gradient_table_G_Delta_rainbow</span></code></a>(gtab)</p></td>
<td><p>This function visualizes a q-tau acquisition scheme as a function of gradient strength and pulse separation (big_delta).</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.qti">
<span id="module-reconst-qti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.qti</span></code><a class="headerlink" href="#module-dipy.reconst.qti" title="Permalink to this heading">#</a></h2>
<p>Classes and functions for fitting the covariance tensor model of q-space
trajectory imaging (QTI) by Westin et al. as presented in “Q-space trajectory
imaging for multidimensional diffusion MRI of the human brain” NeuroImage vol.
135 (2016): 345-62. <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.02.039">https://doi.org/10.1016/j.neuroimage.2016.02.039</a></p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiModel" title="dipy.reconst.qti.QtiModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtiModel</span></code></a>(gtab[, fit_method, cvxpy_solver])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.QtiFit" title="dipy.reconst.qti.QtiFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtiFit</span></code></a>(params)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.from_3x3_to_6x1" title="dipy.reconst.qti.from_3x3_to_6x1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_3x3_to_6x1</span></code></a>(T)</p></td>
<td><p>Convert symmetric 3 x 3 matrices into 6 x 1 vectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.from_6x1_to_3x3" title="dipy.reconst.qti.from_6x1_to_3x3"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_6x1_to_3x3</span></code></a>(V)</p></td>
<td><p>Convert 6 x 1 vectors into symmetric 3 x 3 matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.from_6x6_to_21x1" title="dipy.reconst.qti.from_6x6_to_21x1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_6x6_to_21x1</span></code></a>(T)</p></td>
<td><p>Convert symmetric 6 x 6 matrices into 21 x 1 vectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.from_21x1_to_6x6" title="dipy.reconst.qti.from_21x1_to_6x6"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_21x1_to_6x6</span></code></a>(V)</p></td>
<td><p>Convert 21 x 1 vectors into symmetric 6 x 6 matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.cvxpy_1x6_to_3x3" title="dipy.reconst.qti.cvxpy_1x6_to_3x3"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cvxpy_1x6_to_3x3</span></code></a>(V)</p></td>
<td><p>Convert a 1 x 6 vector into a symmetric 3 x 3 matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.cvxpy_1x21_to_6x6" title="dipy.reconst.qti.cvxpy_1x21_to_6x6"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cvxpy_1x21_to_6x6</span></code></a>(V)</p></td>
<td><p>Convert 1 x 21 vector into a symmetric 6 x 6 matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.dtd_covariance" title="dipy.reconst.qti.dtd_covariance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtd_covariance</span></code></a>(DTD)</p></td>
<td><p>Calculate covariance of a diffusion tensor distribution (DTD).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.qti.qti_signal" title="dipy.reconst.qti.qti_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qti_signal</span></code></a>(gtab, D, C[, S0])</p></td>
<td><p>Generate signals using the covariance tensor signal representation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.qti.design_matrix" title="dipy.reconst.qti.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>(btens)</p></td>
<td><p>Calculate the design matrix from the b-tensors.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.quick_squash">
<span id="module-reconst-quick-squash"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.quick_squash</span></code><a class="headerlink" href="#module-dipy.reconst.quick_squash" title="Permalink to this heading">#</a></h2>
<p>Detect common dtype across object array</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.quick_squash.quick_squash" title="dipy.reconst.quick_squash.quick_squash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quick_squash</span></code></a>(obj_arr[, mask, fill])</p></td>
<td><p>Try and make a standard array from an object array</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.quick_squash.reduce" title="dipy.reconst.quick_squash.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce</span></code></a>(function, sequence[, initial])</p></td>
<td><p>Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.recspeed">
<span id="module-reconst-recspeed"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.recspeed</span></code><a class="headerlink" href="#module-dipy.reconst.recspeed" title="Permalink to this heading">#</a></h2>
<p>Optimized routines for creating voxel diffusion models</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.recspeed.adj_to_countarrs" title="dipy.reconst.recspeed.adj_to_countarrs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adj_to_countarrs</span></code></a>(adj_inds)</p></td>
<td><p>Convert adjacency sequence to counts and flattened indices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.recspeed.argmax_from_adj" title="dipy.reconst.recspeed.argmax_from_adj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax_from_adj</span></code></a>(vals, vertex_inds, adj_inds)</p></td>
<td><p>Indices of local maxima from <cite>vals</cite> given adjacent points</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.recspeed.argmax_from_countarrs" title="dipy.reconst.recspeed.argmax_from_countarrs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax_from_countarrs</span></code></a>(vals, vertinds, ...)</p></td>
<td><p>Indices of local maxima from <cite>vals</cite> from count, array neighbors</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.recspeed.le_to_odf" title="dipy.reconst.recspeed.le_to_odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">le_to_odf</span></code></a>(odf, LEs, radius, odfn, radiusn, ...)</p></td>
<td><p>odf for interpolated Laplacian normalized signal</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.recspeed.local_maxima" title="dipy.reconst.recspeed.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">local_maxima</span></code></a>(odf, edges)</p></td>
<td><p>Local maxima of a function evaluated on a discrete set of points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.recspeed.proc_reco_args" title="dipy.reconst.recspeed.proc_reco_args"><code class="xref py py-obj docutils literal notranslate"><span class="pre">proc_reco_args</span></code></a>(vals, vertinds)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.recspeed.remove_similar_vertices" title="dipy.reconst.recspeed.remove_similar_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_similar_vertices</span></code></a>(vertices, theta[, ...])</p></td>
<td><p>Remove vertices that are less than <cite>theta</cite> degrees from any other

Returns vertices that are at least theta degrees from any other vertex.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.recspeed.search_descending" title="dipy.reconst.recspeed.search_descending"><code class="xref py py-obj docutils literal notranslate"><span class="pre">search_descending</span></code></a>(a, relative_threshold)</p></td>
<td><p><cite>i</cite> in descending array <cite>a</cite> so <cite>a[i] &lt; a[0] * relative_threshold</cite></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.recspeed.sum_on_blocks_1d" title="dipy.reconst.recspeed.sum_on_blocks_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum_on_blocks_1d</span></code></a>(arr, blocks, out, outn)</p></td>
<td><p>Summations on blocks of 1d array</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.rumba">
<span id="module-reconst-rumba"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.rumba</span></code><a class="headerlink" href="#module-dipy.reconst.rumba" title="Permalink to this heading">#</a></h2>
<p>Robust and Unbiased Model-BAsed Spherical Deconvolution (RUMBA-SD)</p>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaSDModel" title="dipy.reconst.rumba.RumbaSDModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RumbaSDModel</span></code></a>(gtab[, wm_response, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit" title="dipy.reconst.rumba.RumbaFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RumbaFit</span></code></a>(model, model_params)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.logger" title="dipy.reconst.rumba.logger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logger</span></code></a></p></td>
<td><p>Instances of the Logger class represent a single logging channel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.rumba.rumba_deconv" title="dipy.reconst.rumba.rumba_deconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rumba_deconv</span></code></a>(data, kernel[, n_iter, ...])</p></td>
<td><p>Fit fODF and GM/CSF volume fractions for a voxel using RUMBA-SD <a href="#id1373"><span class="problematic" id="id65">[1]_</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.mbessel_ratio" title="dipy.reconst.rumba.mbessel_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mbessel_ratio</span></code></a>(n, x)</p></td>
<td><p>Fast computation of modified Bessel function ratio (first kind).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.rumba.generate_kernel" title="dipy.reconst.rumba.generate_kernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_kernel</span></code></a>(gtab, sphere, wm_response, ...)</p></td>
<td><p>Generate deconvolution kernel</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.rumba.rumba_deconv_global" title="dipy.reconst.rumba.rumba_deconv_global"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rumba_deconv_global</span></code></a>(data, kernel, mask[, ...])</p></td>
<td><p>Fit fODF for all voxels simultaneously using RUMBA-SD.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.sfm">
<span id="module-reconst-sfm"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.sfm</span></code><a class="headerlink" href="#module-dipy.reconst.sfm" title="Permalink to this heading">#</a></h2>
<p>The Sparse Fascicle Model.</p>
<p>This is an implementation of the sparse fascicle model described in
<a class="reference internal" href="#id1178" id="id66"><span>[Rokem2015]</span></a>. The multi b-value version of this model is described in
<a class="reference internal" href="#id1179" id="id67"><span>[Rokem2014]</span></a>.</p>
<div role="list" class="citation-list">
<div class="citation" id="rokem2015" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Rokem2015<span class="fn-bracket">]</span></span>
<p>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick
N. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell
(2015). Evaluating the accuracy of diffusion MRI models in white
matter. PLoS ONE 10(4): e0123272. doi:10.1371/journal.pone.0123272</p>
</div>
<div class="citation" id="rokem2014" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Rokem2014<span class="fn-bracket">]</span></span>
<p>Ariel Rokem, Kimberly L. Chan, Jason D. Yeatman, Franco
Pestilli,  Brian A. Wandell (2014). Evaluating the accuracy of diffusion
models at multiple b-values with cross-validation. ISMRM 2014.</p>
</div>
</div>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a>(gtab)</p></td>
<td><p>A base-class for the representation of isotropic signals.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a>(model, params)</p></td>
<td><p>A fit object for representing the isotropic signal as the mean of the diffusion-weighted signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="dipy.reconst.sfm.ExponentialIsotropicModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a>(gtab)</p></td>
<td><p>Representing the isotropic signal as a fit to an exponential decay function with b-values</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="dipy.reconst.sfm.ExponentialIsotropicFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a>(model, params)</p></td>
<td><p>A fit to the ExponentialIsotropicModel object, based on data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel" title="dipy.reconst.sfm.SparseFascicleModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a>(gtab[, sphere, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit" title="dipy.reconst.sfm.SparseFascicleFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a>(model, beta, S0, iso)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.sfm.sfm_design_matrix" title="dipy.reconst.sfm.sfm_design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sfm_design_matrix</span></code></a>(gtab, sphere, response[, mode])</p></td>
<td><p>Construct the SFM design matrix</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.shm">
<span id="module-reconst-shm"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shm</span></code><a class="headerlink" href="#module-dipy.reconst.shm" title="Permalink to this heading">#</a></h2>
<p>Tools for using spherical harmonic models to fit diffusion data.</p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h3>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id68" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Aganj, I., et al. 2009. ODF Reconstruction in Q-Ball Imaging With Solid
Angle Consideration.</p>
</aside>
<aside class="footnote brackets" id="id69" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Descoteaux, M., et al. 2007. Regularized, fast, and robust analytical
Q-ball imaging.</p>
</aside>
<aside class="footnote brackets" id="id70" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Tristan-Vega, A., et al. 2010. A new methodology for estimation of fiber
populations in white matter of the brain with Funk-Radon transform.</p>
</aside>
<aside class="footnote brackets" id="id71" role="note">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Tristan-Vega, A., et al. 2009. Estimation of fiber orientation
probability density functions in high angular resolution diffusion
imaging.</p>
</aside>
</aside>
<p>Note about the Transpose:
In the literature the matrix representation of these methods is often written
as Y = Bx where B is some design matrix and Y and x are column vectors. In our
case the input data, a dwi stored as a nifti file for example, is stored as row
vectors (ndarrays) of the form (x, y, z, n), where n is the number of diffusion
directions. We could transpose and reshape the data to be (n, x*y*z), so that
we could directly plug it into the above equation. However, I have chosen to
keep the data as is and implement the relevant equations rewritten in the
following form: Y.T = x.T B.T, or in python syntax data = np.dot(sh_coef, B.T)
where data is Y.T and sh_coef is x.T.</p>
</section>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a>(gtab)</p></td>
<td><p>To be subclassed by all models that return a SphHarmFit when fit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a>(gtab, sh_order[, smooth, ...])</p></td>
<td><p>To be subclassed by Qball type models.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a>(model, shm_coef, mask)</p></td>
<td><p>Diffusion data fit to a spherical harmonic model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.CsaOdfModel" title="dipy.reconst.shm.CsaOdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a>(gtab, sh_order[, smooth, ...])</p></td>
<td><p>Implementation of Constant Solid Angle reconstruction method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.OpdtModel" title="dipy.reconst.shm.OpdtModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OpdtModel</span></code></a>(gtab, sh_order[, smooth, ...])</p></td>
<td><p>Implementation of Orientation Probability Density Transform reconstruction method.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.QballModel" title="dipy.reconst.shm.QballModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QballModel</span></code></a>(gtab, sh_order[, smooth, ...])</p></td>
<td><p>Implementation of regularized Qball reconstruction method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="dipy.reconst.shm.ResidualBootstrapWrapper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a>(signal_object, B, ...)</p></td>
<td><p>Returns a residual bootstrap sample of the signal_object when indexed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.forward_sdeconv_mat" title="dipy.reconst.shm.forward_sdeconv_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward_sdeconv_mat</span></code></a>(r_rh, n)</p></td>
<td><p>Build forward spherical deconvolution matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.sh_to_rh" title="dipy.reconst.shm.sh_to_rh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_rh</span></code></a>(r_sh, m, n)</p></td>
<td><p>Spherical harmonics (SH) to rotational harmonics (RH)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.gen_dirac" title="dipy.reconst.shm.gen_dirac"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_dirac</span></code></a>(m, n, theta, phi[, legacy])</p></td>
<td><p>Generate Dirac delta function orientated in (theta, phi) on the sphere</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.spherical_harmonics" title="dipy.reconst.shm.spherical_harmonics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spherical_harmonics</span></code></a>(m, n, theta, phi[, ...])</p></td>
<td><p>Compute spherical harmonics.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sph_harm" title="dipy.reconst.shm.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a>(m, n, theta, phi)</p></td>
<td><p>Compute real spherical harmonics.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sh_tournier_from_index" title="dipy.reconst.shm.real_sh_tournier_from_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sh_tournier_from_index</span></code></a>(m, n, theta, phi)</p></td>
<td><p>Compute real spherical harmonics as initially defined in Tournier
2007 <a href="#id1374"><span class="problematic" id="id72">[1]_</span></a> then updated in MRtrix3 <a href="#id1375"><span class="problematic" id="id73">[2]_</span></a>, where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span>
is defined to be:

    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                      if m = 0
    Imag(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)    if m &lt; 0

This may take scalar or array arguments.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sh_descoteaux_from_index" title="dipy.reconst.shm.real_sh_descoteaux_from_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sh_descoteaux_from_index</span></code></a>(m, n, theta, phi)</p></td>
<td><p>Compute real spherical harmonics as in Descoteaux et al. 2007 <a href="#id1376"><span class="problematic" id="id74">[1]_</span></a>,
where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:

    Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                      if m = 0
    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &lt; 0

This may take scalar or array arguments.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sh_tournier" title="dipy.reconst.shm.real_sh_tournier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sh_tournier</span></code></a>(sh_order, theta, phi[, ...])</p></td>
<td><p>Compute real spherical harmonics as initially defined in Tournier
2007 <a href="#id1377"><span class="problematic" id="id75">[1]_</span></a> then updated in MRtrix3 <a href="#id1378"><span class="problematic" id="id76">[2]_</span></a>, where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span>
is defined to be:

    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                      if m = 0
    Imag(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)    if m &lt; 0

This may take scalar or array arguments.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sh_descoteaux" title="dipy.reconst.shm.real_sh_descoteaux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sh_descoteaux</span></code></a>(sh_order, theta, phi[, ...])</p></td>
<td><p>Compute real spherical harmonics as in Descoteaux et al. 2007 <a href="#id1379"><span class="problematic" id="id77">[1]_</span></a>,
where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:

    Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                      if m = 0
    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &lt; 0

This may take scalar or array arguments.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sym_sh_mrtrix" title="dipy.reconst.shm.real_sym_sh_mrtrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sym_sh_mrtrix</span></code></a>(sh_order, theta, phi)</p></td>
<td><p>dipy.reconst.shm.real_sym_sh_mrtrix is deprecated, Please use dipy.reconst.shm.real_sh_tournier instead

* deprecated from version: 1.3
* Will raise &lt;class 'dipy.utils.deprecator.ExpiredDeprecationError'&gt; as of version: 2.0

Compute real symmetric spherical harmonics as in Tournier 2007 <a href="#id1380"><span class="problematic" id="id78">[2]_</span></a>, where
the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be::

    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>)       if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>             if m = 0
    Imag(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>)     if m &lt; 0

This may take scalar or array arguments.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.real_sym_sh_basis" title="dipy.reconst.shm.real_sym_sh_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sym_sh_basis</span></code></a>(sh_order, theta, phi)</p></td>
<td><p>Samples a real symmetric spherical harmonic basis at point on the sphere

dipy.reconst.shm.real_sym_sh_basis is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux instead

* deprecated from version: 1.3
* Will raise &lt;class 'dipy.utils.deprecator.ExpiredDeprecationError'&gt; as of version: 2.0

Samples the basis functions up to order <cite>sh_order</cite> at points on the sphere
given by <cite>theta</cite> and <cite>phi</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.sph_harm_ind_list" title="dipy.reconst.shm.sph_harm_ind_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sph_harm_ind_list</span></code></a>(sh_order[, full_basis])</p></td>
<td><p>Returns the degree (<code class="docutils literal notranslate"><span class="pre">m</span></code>) and order (<code class="docutils literal notranslate"><span class="pre">n</span></code>) of all the symmetric spherical harmonics of degree less then or equal to <code class="docutils literal notranslate"><span class="pre">sh_order</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.order_from_ncoef" title="dipy.reconst.shm.order_from_ncoef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order_from_ncoef</span></code></a>(ncoef[, full_basis])</p></td>
<td><p>Given a number <code class="docutils literal notranslate"><span class="pre">n</span></code> of coefficients, calculate back the <code class="docutils literal notranslate"><span class="pre">sh_order</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.smooth_pinv" title="dipy.reconst.shm.smooth_pinv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth_pinv</span></code></a>(B, L)</p></td>
<td><p>Regularized pseudo-inverse

Computes a regularized least square inverse of B

Parameters
----------
B : array_like (n, m)
    Matrix to be inverted
L : array_like (m,)

Returns
-------
inv : ndarray (m, n)
    regularized least square inverse of B

Notes
-----
In the literature this inverse is often written <span class="math notranslate nohighlight">\((B^{T}B+L^{2})^{-1}B^{T}\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.lazy_index" title="dipy.reconst.shm.lazy_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lazy_index</span></code></a>(index)</p></td>
<td><p>Produces a lazy index</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_data</span></code></a>(data, where_b0[, min_signal, out])</p></td>
<td><p>Normalizes the data with respect to the mean b0</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.hat" title="dipy.reconst.shm.hat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hat</span></code></a>(B)</p></td>
<td><p>Returns the hat matrix for the design matrix B</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.lcr_matrix" title="dipy.reconst.shm.lcr_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lcr_matrix</span></code></a>(H)</p></td>
<td><p>Returns a matrix for computing leveraged, centered residuals from data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.bootstrap_data_array" title="dipy.reconst.shm.bootstrap_data_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bootstrap_data_array</span></code></a>(data, H, R[, permute])</p></td>
<td><p>Applies the Residual Bootstraps to the data given H and R</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.bootstrap_data_voxel" title="dipy.reconst.shm.bootstrap_data_voxel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bootstrap_data_voxel</span></code></a>(data, H, R[, permute])</p></td>
<td><p>Like bootstrap_data_array but faster when for a single voxel</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.sf_to_sh" title="dipy.reconst.shm.sf_to_sh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sf_to_sh</span></code></a>(sf, sphere[, sh_order, basis_type, ...])</p></td>
<td><p>Spherical function to spherical harmonics (SH).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.sh_to_sf" title="dipy.reconst.shm.sh_to_sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_sf</span></code></a>(sh, sphere[, sh_order, basis_type, ...])</p></td>
<td><p>Spherical harmonics (SH) to spherical function (SF).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.sh_to_sf_matrix" title="dipy.reconst.shm.sh_to_sf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_sf_matrix</span></code></a>(sphere[, sh_order, ...])</p></td>
<td><p>Matrix that transforms Spherical harmonics (SH) to spherical function (SF).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.calculate_max_order" title="dipy.reconst.shm.calculate_max_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_max_order</span></code></a>(n_coeffs[, full_basis])</p></td>
<td><p>Calculate the maximal harmonic order, given that you know the
number of parameters that were estimated.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.anisotropic_power" title="dipy.reconst.shm.anisotropic_power"><code class="xref py py-obj docutils literal notranslate"><span class="pre">anisotropic_power</span></code></a>(sh_coeffs[, norm_factor, ...])</p></td>
<td><p>Calculate anisotropic power map with a given SH coefficient matrix. Parameters
----------
sh_coeffs : ndarray
    A ndarray where the last dimension is the
    SH coefficients estimates for that voxel. norm_factor: float, optional
    The value to normalize the ap values. power : int, optional
    The degree to which power maps are calculated. non_negative: bool, optional
    Whether to rectify the resulting map to be non-negative. Returns
-------
log_ap : ndarray
    The log of the resulting power image. Notes
-----
Calculate AP image based on a IxJxKxC SH coefficient matrix based on the
equation:
.. math::
    AP = sum_{l=2,4,6,...}{frac{1}{2l+1} sum_{m=-l}^l{<a href="#id79"><span class="problematic" id="id80">|</span></a>a_{l,m}|^n}}

Where the last dimension, C, is made of a flattened array of <span class="math notranslate nohighlight">\(l`x:math:`m\)</span>
coefficients, where <span class="math notranslate nohighlight">\(l\)</span> are the SH orders, and <span class="math notranslate nohighlight">\(m = 2l+1\)</span>,
So l=1 has 1 coefficient, l=2 has 5, ... l=8 has 17 and so on. A l=2 SH coefficient matrix will then be composed of a IxJxKx6 volume. The power, <span class="math notranslate nohighlight">\(n\)</span> is usually set to <span class="math notranslate nohighlight">\(n=2\)</span>. The final AP image is then shifted by -log(norm_factor), to be strictly
non-negative. Remaining values &lt; 0 are discarded (set to 0), per default,
and this option is controlled through the <cite>non_negative</cite> keyword argument. References
----------
.. [1]  Dell'Acqua, F., Lacerda, L., Catani, M., Simmons, A., 2014. Anisotropic Power Maps: A diffusion contrast to reveal low
        anisotropy tissues from HARDI data,
        in: Proceedings of International Society for Magnetic Resonance in
        Medicine. Milan, Italy. .</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.convert_sh_to_full_basis" title="dipy.reconst.shm.convert_sh_to_full_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_sh_to_full_basis</span></code></a>(sh_coeffs)</p></td>
<td><p>Given an array of SH coeffs from a symmetric basis, returns the coefficients for the full SH basis by filling odd order SH coefficients with zeros</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shm.convert_sh_from_legacy" title="dipy.reconst.shm.convert_sh_from_legacy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_sh_from_legacy</span></code></a>(sh_coeffs, sh_basis)</p></td>
<td><p>Convert SH coefficients in legacy SH basis to SH coefficients of the new SH basis for <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> <a href="#id1381"><span class="problematic" id="id81">[1]_</span></a> or <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> [2]_[3]_ bases.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shm.convert_sh_to_legacy" title="dipy.reconst.shm.convert_sh_to_legacy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_sh_to_legacy</span></code></a>(sh_coeffs, sh_basis[, ...])</p></td>
<td><p>Convert SH coefficients in new SH basis to SH coefficients for the legacy SH basis for <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> <a href="#id1382"><span class="problematic" id="id82">[1]_</span></a> or <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> [2]_[3]_ bases.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.shore">
<span id="module-reconst-shore"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shore</span></code><a class="headerlink" href="#module-dipy.reconst.shore" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreModel" title="dipy.reconst.shore.ShoreModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShoreModel</span></code></a>(gtab[, radial_order, zeta, ...])</p></td>
<td><p>Simple Harmonic Oscillator based Reconstruction and Estimation
(SHORE) <a href="#id1383"><span class="problematic" id="id83">[1]_</span></a> of the diffusion signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.ShoreFit" title="dipy.reconst.shore.ShoreFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShoreFit</span></code></a>(model, shore_coef)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_matrix" title="dipy.reconst.shore.shore_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_matrix</span></code></a>(radial_order, zeta, gtab[, tau])</p></td>
<td><p>Compute the SHORE matrix for modified Merlet's 3D-SHORE <a href="#id1384"><span class="problematic" id="id84">[1]_</span></a>

..math::
        :nowrap:
            begin{equation}
                textbf{E}(qtextbf{u})=sum_{l=0, even}^{N_{max}}
                                        sum_{n=l}^{(N_{max}+l)/2}
                                        sum_{m=-l}^l c_{nlm}
                                        phi_{nlm}(qtextbf{u})
            end{equation}

where <span class="math notranslate nohighlight">\(\phi_{nlm}\)</span> is
..math::
        :nowrap:
            begin{equation}
                phi_{nlm}^{SHORE}(qtextbf{u})=Biggl[dfrac{2(n-l)!}
                    {zeta^{3/2} Gamma(n+3/2)} Biggr]^{1/2}
                    Biggl(dfrac{q^2}{zeta}Biggr)^{l/2}
                    expBiggl(dfrac{-q^2}{2zeta}Biggr)
                    L^{l+1/2}_{n-l} Biggl(dfrac{q^2}{zeta}Biggr)
                    Y_l^m(textbf{u}).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_matrix_pdf" title="dipy.reconst.shore.shore_matrix_pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_matrix_pdf</span></code></a>(radial_order, zeta, rtab)</p></td>
<td><p>Compute the SHORE propagator matrix <a href="#id1385"><span class="problematic" id="id85">[1]_</span></a>&quot;</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_matrix_odf" title="dipy.reconst.shore.shore_matrix_odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_matrix_odf</span></code></a>(radial_order, zeta, ...)</p></td>
<td><p>Compute the SHORE ODF matrix <a href="#id1386"><span class="problematic" id="id86">[1]_</span></a>&quot;</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.l_shore" title="dipy.reconst.shore.l_shore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">l_shore</span></code></a>(radial_order)</p></td>
<td><p>Returns the angular regularisation matrix for SHORE basis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.n_shore" title="dipy.reconst.shore.n_shore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_shore</span></code></a>(radial_order)</p></td>
<td><p>Returns the angular regularisation matrix for SHORE basis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.create_rspace" title="dipy.reconst.shore.create_rspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_rspace</span></code></a>(gridsize, radius_max)</p></td>
<td><p>Create the real space table, that contains the points in which</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_indices" title="dipy.reconst.shore.shore_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_indices</span></code></a>(radial_order, index)</p></td>
<td><p>Given the basis order and the index, return the shore indices n, l, m
for modified Merlet's 3D-SHORE
..math::
        :nowrap:
            begin{equation}
                textbf{E}(qtextbf{u})=sum_{l=0, even}^{N_{max}}
                                        sum_{n=l}^{(N_{max}+l)/2}
                                        sum_{m=-l}^l c_{nlm}
                                        phi_{nlm}(qtextbf{u})
            end{equation}

where <span class="math notranslate nohighlight">\(\phi_{nlm}\)</span> is
..math::
        :nowrap:
            begin{equation}
                phi_{nlm}^{SHORE}(qtextbf{u})=Biggl[dfrac{2(n-l)!}
                    {zeta^{3/2} Gamma(n+3/2)} Biggr]^{1/2}
                    Biggl(dfrac{q^2}{zeta}Biggr)^{l/2}
                    expBiggl(dfrac{-q^2}{2zeta}Biggr)
                    L^{l+1/2}_{n-l} Biggl(dfrac{q^2}{zeta}Biggr)
                    Y_l^m(textbf{u}).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.shore.shore_order" title="dipy.reconst.shore.shore_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_order</span></code></a>(n, l, m)</p></td>
<td><p>Given the indices (n,l,m) of the basis, return the minimum order for those indices and their index for modified Merlet's 3D-SHORE.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.utils">
<span id="module-reconst-utils"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.utils</span></code><a class="headerlink" href="#module-dipy.reconst.utils" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.utils.dki_design_matrix" title="dipy.reconst.utils.dki_design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dki_design_matrix</span></code></a>(gtab)</p></td>
<td><p>Construct B design matrix for DKI.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.reconst.utils.cti_design_matrix" title="dipy.reconst.utils.cti_design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cti_design_matrix</span></code></a>(gtab1, gtab2)</p></td>
<td><p>Construct B design matrix for CTI.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-dipy.reconst.vec_val_sum">
<span id="module-reconst-vec-val-sum"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.vec_val_sum</span></code><a class="headerlink" href="#module-dipy.reconst.vec_val_sum" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.reconst.vec_val_sum.vec_val_vect" title="dipy.reconst.vec_val_sum.vec_val_vect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vec_val_vect</span></code></a>(vecs, vals)</p></td>
<td><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p></td>
</tr>
</tbody>
</table>
<section id="reconstmodel">
<h3><a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#reconstmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.base.ReconstModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.base.</span></span><span class="sig-name descname"><span class="pre">ReconstModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.base.ReconstModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<section id="parameters">
<h4>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable class instance</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.base.ReconstModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstModel.fit" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="reconstfit">
<h3><a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><a class="headerlink" href="#reconstfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.base.ReconstFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.base.</span></span><span class="sig-name descname"><span class="pre">ReconstFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.base.ReconstFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstFit.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="bench-bounding-box">
<h3>bench_bounding_box<a class="headerlink" href="#bench-bounding-box" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.benchmarks.bench_bounding_box.</span></span><span class="sig-name descname"><span class="pre">bench_bounding_box</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="num-grad">
<h3>num_grad<a class="headerlink" href="#num-grad" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.benchmarks.bench_csd.num_grad">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.benchmarks.bench_csd.</span></span><span class="sig-name descname"><span class="pre">num_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.num_grad" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="bench-csdeconv">
<h3>bench_csdeconv<a class="headerlink" href="#bench-csdeconv" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.benchmarks.bench_csd.bench_csdeconv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.benchmarks.bench_csd.</span></span><span class="sig-name descname"><span class="pre">bench_csdeconv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(50,</span> <span class="pre">40,</span> <span class="pre">40)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.bench_csdeconv" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="bench-local-maxima">
<h3>bench_local_maxima<a class="headerlink" href="#bench-local-maxima" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.benchmarks.bench_peaks.bench_local_maxima">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.benchmarks.bench_peaks.</span></span><span class="sig-name descname"><span class="pre">bench_local_maxima</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.bench_local_maxima" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="old-squash">
<h3>old_squash<a class="headerlink" href="#old-squash" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.benchmarks.bench_squash.old_squash">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.benchmarks.bench_squash.</span></span><span class="sig-name descname"><span class="pre">old_squash</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.old_squash" title="Permalink to this definition">#</a></dt>
<dd><p>Try and make a standard array from an object array</p>
<p>This function takes an object array and attempts to convert it to a more
useful dtype. If array can be converted to a better dtype, Nones are
replaced by <cite>fill</cite>. To make the behaviour of this function more clear, here
are the most common cases:</p>
<ol class="arabic simple">
<li><p><cite>arr</cite> is an array of scalars of type <cite>T</cite>. Returns an array like
<cite>arr.astype(T)</cite></p></li>
<li><p><cite>arr</cite> is an array of arrays. All items in <cite>arr</cite> have the same shape
<cite>S</cite>. Returns an array with shape <cite>arr.shape + S</cite>.</p></li>
<li><p><cite>arr</cite> is an array of arrays of different shapes. Returns <cite>arr</cite>.</p></li>
<li><p>Items in <cite>arr</cite> are not ndarrys or scalars. Returns <cite>arr</cite>.</p></li>
</ol>
<section id="id87">
<h4>Parameters<a class="headerlink" href="#id87" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>arr<span class="classifier">array, dtype=object</span></dt><dd><p>The array to be converted.</p>
</dd>
<dt>mask<span class="classifier">array, dtype=bool, optional</span></dt><dd><p>Where arr has Nones.</p>
</dd>
<dt>fill<span class="classifier">number, optional</span></dt><dd><p>Nones are replaced by fill.</p>
</dd>
</dl>
</section>
<section id="returns">
<h4>Returns<a class="headerlink" href="#returns" title="Permalink to this heading">#</a></h4>
<p>result : array</p>
</section>
<section id="examples">
<h4>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">#</a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([2, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([0, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">old_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="bench-quick-squash">
<h3>bench_quick_squash<a class="headerlink" href="#bench-quick-squash" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.benchmarks.bench_squash.bench_quick_squash">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.benchmarks.bench_squash.</span></span><span class="sig-name descname"><span class="pre">bench_quick_squash</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.bench_quick_squash" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="bench-vec-val-vect">
<h3>bench_vec_val_vect<a class="headerlink" href="#bench-vec-val-vect" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.benchmarks.bench_vec_val_sum.</span></span><span class="sig-name descname"><span class="pre">bench_vec_val_vect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="cache">
<h3><a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#cache" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.cache.Cache">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.cache.</span></span><span class="sig-name descname"><span class="pre">Cache</span></span><a class="headerlink" href="#dipy.reconst.cache.Cache" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<section id="notes">
<h4>Notes<a class="headerlink" href="#notes" title="Permalink to this heading">#</a></h4>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cache.Cache.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cache.Cache.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cache.Cache.cache_clear">
<span class="sig-name descname"><span class="pre">cache_clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_clear" title="Permalink to this definition">#</a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cache.Cache.cache_get">
<span class="sig-name descname"><span class="pre">cache_get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_get" title="Permalink to this definition">#</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<section id="id88">
<h5>Parameters<a class="headerlink" href="#id88" title="Permalink to this heading">#</a></h5>
<dl class="simple">
<dt>tag<span class="classifier">str</span></dt><dd><p>Description of the cached value.</p>
</dd>
<dt>key<span class="classifier">object</span></dt><dd><p>Key object used to look up the cached value.</p>
</dd>
<dt>default<span class="classifier">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</section>
<section id="id89">
<h5>Returns<a class="headerlink" href="#id89" title="Permalink to this heading">#</a></h5>
<dl class="simple">
<dt>v<span class="classifier">object</span></dt><dd><p>Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cache.Cache.cache_set">
<span class="sig-name descname"><span class="pre">cache_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_set" title="Permalink to this definition">#</a></dt>
<dd><p>Store a value in the cache.</p>
<section id="id90">
<h5>Parameters<a class="headerlink" href="#id90" title="Permalink to this heading">#</a></h5>
<dl class="simple">
<dt>tag<span class="classifier">str</span></dt><dd><p>Description of the cached value.</p>
</dd>
<dt>key<span class="classifier">object</span></dt><dd><p>Key object used to look up the cached value.</p>
</dd>
<dt>value<span class="classifier">object</span></dt><dd><p>Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</section>
<section id="id91">
<h5>Examples<a class="headerlink" href="#id91" title="Permalink to this heading">#</a></h5>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="coeff-of-determination">
<h3>coeff_of_determination<a class="headerlink" href="#coeff-of-determination" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cross_validation.coeff_of_determination">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cross_validation.</span></span><span class="sig-name descname"><span class="pre">coeff_of_determination</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cross_validation.coeff_of_determination" title="Permalink to this definition">#</a></dt>
<dd><dl>
<dt>Calculate the coefficient of determination for a model prediction,</dt><dd><p>relative to data.</p>
<dl class="simple">
<dt>data<span class="classifier">ndarray</span></dt><dd><p>The data</p>
</dd>
<dt>model<span class="classifier">ndarray</span></dt><dd><p>The predictions of a model for this data. Same shape as the data.</p>
</dd>
<dt>axis: int, optional</dt><dd><p>The axis along which different samples are laid out (default: -1).</p>
</dd>
</dl>
<dl class="simple">
<dt>COD<span class="classifier">ndarray</span></dt><dd><p>The coefficient of determination. This has shape <cite>data.shape[:-1]</cite></p>
</dd>
</dl>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Coefficient_of_determination">https://en.wikipedia.org/wiki/Coefficient_of_determination</a></p>
<p>The coefficient of determination is calculated as:</p>
<div class="math notranslate nohighlight">
\[R^2 = 100 * (1 - \]</div>
</dd>
</dl>
<p>rac{SSE}{SSD})</p>
<blockquote>
<div><p>where SSE is the sum of the squared error between the model and the data
(sum of the squared residuals) and SSD is the sum of the squares of the
deviations of the data from the mean of the data (variance * N).</p>
</div></blockquote>
</dd></dl>

</section>
<section id="kfold-xval">
<h3>kfold_xval<a class="headerlink" href="#kfold-xval" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cross_validation.kfold_xval">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cross_validation.</span></span><span class="sig-name descname"><span class="pre">kfold_xval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">folds</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">model_args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">model_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cross_validation.kfold_xval" title="Permalink to this definition">#</a></dt>
<dd><p>Perform k-fold cross-validation.</p>
<p>It generate out-of-sample predictions for each measurement.</p>
<section id="id92">
<h4>Parameters<a class="headerlink" href="#id92" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">Model class instance</span></dt><dd><p>The type of the model to use for prediction. The corresponding Fit
object must have a <cite>predict</cite> function implemented One of the following:
<cite>reconst.dti.TensorModel</cite> or
<cite>reconst.csdeconv.ConstrainedSphericalDeconvModel</cite>.</p>
</dd>
<dt>data<span class="classifier">ndarray</span></dt><dd><p>Diffusion MRI data acquired with the GradientTable of the model. Shape
will typically be <cite>(x, y, z, b)</cite> where <cite>xyz</cite> are spatial dimensions and
b is the number of bvals/bvecs in the GradientTable.</p>
</dd>
<dt>folds<span class="classifier">int</span></dt><dd><p>The number of divisions to apply to the data</p>
</dd>
<dt>model_args<span class="classifier">list</span></dt><dd><p>Additional arguments to the model initialization</p>
</dd>
<dt>model_kwargs<span class="classifier">dict</span></dt><dd><p>Additional key-word arguments to the model initialization. If contains
the kwarg <cite>mask</cite>, this will be used as a key-word argument to the <cite>fit</cite>
method of the model object, rather than being used in the
initialization of the model object</p>
</dd>
</dl>
</section>
<section id="id93">
<h4>Notes<a class="headerlink" href="#id93" title="Permalink to this heading">#</a></h4>
<p>This function assumes that a prediction API is implemented in the Model
class for which prediction is conducted. That is, the Fit object that gets
generated upon fitting the model needs to have a <cite>predict</cite> method, which
receives a GradientTable class instance as input and produces a predicted
signal as output.</p>
<p>It also assumes that the model object has <cite>bval</cite> and <cite>bvec</cite> attributes
holding b-values and corresponding unit vectors.</p>
</section>
<section id="id94">
<h4>References<a class="headerlink" href="#id94" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id95" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Rokem, A., Chan, K.L. Yeatman, J.D., Pestilli, F., Mezer, A.,
Wandell, B.A., 2014. Evaluating the accuracy of diffusion models at
multiple b-values with cross-validation. ISMRM 2014.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="axsymshresponse">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse" title="dipy.reconst.csdeconv.AxSymShResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a><a class="headerlink" href="#axsymshresponse" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.AxSymShResponse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">AxSymShResponse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dwi_response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A simple wrapper for response functions represented using only axially
symmetric, even spherical harmonic functions (ie, m == 0 and n even).</p>
<section id="id96">
<h4>Parameters<a class="headerlink" href="#id96" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S0<span class="classifier">float</span></dt><dd><p>Signal with no diffusion weighting.</p>
</dd>
<dt>dwi_response<span class="classifier">array</span></dt><dd><p>Response function signal as coefficients to axially symmetric, even
spherical harmonic.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.AxSymShResponse.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dwi_response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.AxSymShResponse.basis">
<span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.basis" title="Permalink to this definition">#</a></dt>
<dd><p>A basis that maps the response coefficients onto a sphere.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.AxSymShResponse.on_sphere">
<span class="sig-name descname"><span class="pre">on_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.on_sphere" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates the response function on sphere.</p>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="constrainedsphericaldeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a><a class="headerlink" href="#constrainedsphericaldeconvmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">ConstrainedSphericalDeconvModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Constrained Spherical Deconvolution (CSD) <a href="#id1387"><span class="problematic" id="id97">[1]_</span></a>.</p>
<p>Spherical deconvolution computes a fiber orientation distribution
(FOD), also called fiber ODF (fODF) <a href="#id1388"><span class="problematic" id="id98">[2]_</span></a>, as opposed to a diffusion ODF
as the QballModel or the CsaOdfModel. This results in a sharper angular
profile with better angular resolution that is the best object to be
used for later deterministic and probabilistic tractography <a href="#id1389"><span class="problematic" id="id99">[3]_</span></a>.</p>
<p>A sharp fODF is obtained because a single fiber <em>response</em> function is
injected as <em>a priori</em> knowledge. The response function is often
data-driven and is thus provided as input to the
ConstrainedSphericalDeconvModel. It will be used as deconvolution
kernel, as described in <a href="#id1390"><span class="problematic" id="id100">[1]_</span></a>.</p>
<section id="id101">
<h4>Parameters<a class="headerlink" href="#id101" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
response : tuple or AxSymShResponse object</p>
<blockquote>
<div><p>A tuple with two elements. The first is the eigen-values as an (3,)
ndarray and the second is the signal value for the response
function without diffusion weighting (i.e. S0).  This is to be able
to generate a single fiber synthetic signal. The response function
will be used as deconvolution kernel (<a href="#id1391"><span class="problematic" id="id102">[1]_</span></a>).</p>
</div></blockquote>
<dl class="simple">
<dt>reg_sphere<span class="classifier">Sphere (optional)</span></dt><dd><p>sphere used to build the regularization B matrix.
Default: ‘symmetric362’.</p>
</dd>
<dt>sh_order<span class="classifier">int (optional)</span></dt><dd><p>maximal spherical harmonics order. Default: 8</p>
</dd>
<dt><a href="#id1392"><span class="problematic" id="id1393">lambda_</span></a><span class="classifier">float (optional)</span></dt><dd><p>weight given to the constrained-positivity regularization part of
the deconvolution equation (see <a href="#id1394"><span class="problematic" id="id103">[1]_</span></a>). Default: 1</p>
</dd>
<dt>tau<span class="classifier">float (optional)</span></dt><dd><p>threshold controlling the amplitude below which the corresponding
fODF is assumed to be zero.  Ideally, tau should be set to
zero. However, to improve the stability of the algorithm, tau is
set to tau*100 % of the mean fODF amplitude (here, 10% by default)
(see <a href="#id1395"><span class="problematic" id="id104">[1]_</span></a>). Default: 0.1</p>
</dd>
<dt>convergence<span class="classifier">int</span></dt><dd><p>Maximum number of iterations to allow the deconvolution to
converge.</p>
</dd>
</dl>
</section>
<section id="id105">
<h4>References<a class="headerlink" href="#id105" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id106" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of
the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical
deconvolution</p>
</aside>
<aside class="footnote brackets" id="id107" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions</p>
</aside>
<aside class="footnote brackets" id="id108" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Côté, M-A., et al. Medical Image Analysis 2013. Tractometer:
Towards validation of tractography pipelines</p>
</aside>
<aside class="footnote brackets" id="id109" role="note">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Tournier, J.D, et al. Imaging Systems and Technology
2012. MRtrix: Diffusion Tractography in Crossing Fiber Regions</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Compute a signal prediction given spherical harmonic coefficients
for the provided GradientTable class instance.</p>
<section id="id110">
<h4>Parameters<a class="headerlink" href="#id110" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sh_coeff<span class="classifier">ndarray</span></dt><dd><p>The spherical harmonic representation of the FOD from which to make
the signal prediction.</p>
</dd>
<dt>gtab<span class="classifier">GradientTable</span></dt><dd><p>The gradients for which the signal will be predicted. Uses the
model’s gradient table by default.</p>
</dd>
<dt>S0<span class="classifier">ndarray or float</span></dt><dd><p>The non diffusion-weighted signal value.</p>
</dd>
</dl>
</section>
<section id="id111">
<h4>Returns<a class="headerlink" href="#id111" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>pred_sig<span class="classifier">ndarray</span></dt><dd><p>The predicted signal.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="constrainedsdtmodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="dipy.reconst.csdeconv.ConstrainedSDTModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a><a class="headerlink" href="#constrainedsdtmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSDTModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">ConstrainedSDTModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSDTModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Spherical Deconvolution Transform (SDT) <a href="#id1396"><span class="problematic" id="id112">[1]_</span></a>.</p>
<p>The SDT computes a fiber orientation distribution (FOD) as opposed to a
diffusion ODF as the QballModel or the CsaOdfModel. This results in a
sharper angular profile with better angular resolution. The Constrained
SDTModel is similar to the Constrained CSDModel but mathematically it
deconvolves the q-ball ODF as oppposed to the HARDI signal (see <a href="#id1397"><span class="problematic" id="id113">[1]_</span></a>
for a comparison and a through discussion).</p>
<p>A sharp fODF is obtained because a single fiber <em>response</em> function is
injected as <em>a priori</em> knowledge. In the SDTModel, this response is a
single fiber q-ball ODF as opposed to a single fiber signal function
for the CSDModel. The response function will be used as deconvolution
kernel.</p>
<section id="id114">
<h4>Parameters<a class="headerlink" href="#id114" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
ratio : float</p>
<blockquote>
<div><p>ratio of the smallest vs the largest eigenvalue of the single
prolate tensor response function</p>
</div></blockquote>
<dl class="simple">
<dt>reg_sphere<span class="classifier">Sphere</span></dt><dd><p>sphere used to build the regularization B matrix</p>
</dd>
<dt>sh_order<span class="classifier">int</span></dt><dd><p>maximal spherical harmonics order</p>
</dd>
<dt><a href="#id1398"><span class="problematic" id="id1399">lambda_</span></a><span class="classifier">float</span></dt><dd><p>weight given to the constrained-positivity regularization part of
the deconvolution equation</p>
</dd>
<dt>tau<span class="classifier">float</span></dt><dd><p>threshold (tau <a href="#id115"><span class="problematic" id="id116">*</span></a>mean(fODF)) controlling the amplitude below
which the corresponding fODF is assumed to be zero.</p>
</dd>
</dl>
</section>
<section id="id117">
<h4>References<a class="headerlink" href="#id117" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id118" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.ConstrainedSDTModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="auto-response">
<h3>auto_response<a class="headerlink" href="#auto-response" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.auto_response">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">auto_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fa_callable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_number_of_voxels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.auto_response" title="Permalink to this definition">#</a></dt>
<dd><p>Automatic estimation of ssst response function using FA.</p>
<p>dipy.reconst.csdeconv.auto_response is deprecated, Please use dipy.reconst.csdeconv.auto_response_ssst instead</p>
<ul class="simple">
<li><p>deprecated from version: 1.2</p></li>
<li><p>Raises &lt;class ‘dipy.utils.deprecator.ExpiredDeprecationError’&gt; as of version: 1.4</p></li>
</ul>
<section id="id119">
<h4>Parameters<a class="headerlink" href="#id119" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
data : ndarray</p>
<blockquote>
<div><p>diffusion data</p>
</div></blockquote>
<dl class="simple">
<dt>roi_center<span class="classifier">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt>roi_radius<span class="classifier">int</span></dt><dd><p>radius of cubic ROI</p>
</dd>
<dt>fa_thr<span class="classifier">float</span></dt><dd><p>FA threshold</p>
</dd>
<dt>fa_callable<span class="classifier">callable</span></dt><dd><p>A callable that defines an operation that compares FA with the fa_thr.
The operator should have two positional arguments
(e.g., <cite>fa_operator(FA, fa_thr)</cite>) and it should return a bool array.</p>
</dd>
<dt>return_number_of_voxels<span class="classifier">bool</span></dt><dd><p>If True, returns the number of voxels used for estimating the response
function</p>
</dd>
</dl>
</section>
<section id="id120">
<h4>Returns<a class="headerlink" href="#id120" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>response<span class="classifier">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>
</dd>
<dt>ratio<span class="classifier">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>
</dd>
</dl>
</section>
<section id="id121">
<h4>Notes<a class="headerlink" href="#id121" title="Permalink to this heading">#</a></h4>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this, we look for voxels with very
anisotropic configurations. We get this information from
csdeconv.mask_for_response_ssst(), which returns a mask of selected voxels
(more details are available in the description of the function).</p>
<p>With the mask, we compute the response function by using
csdeconv.response_from_mask_ssst(), which returns the <cite>response</cite> and the
<cite>ratio</cite> (more details are available in the description of the function).</p>
</section>
</dd></dl>

</section>
<section id="response-from-mask">
<h3>response_from_mask<a class="headerlink" href="#response-from-mask" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.response_from_mask">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">response_from_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.response_from_mask" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computation of single-shell single-tissue (ssst) response</dt><dd><p>function from a given mask.</p>
</dd>
</dl>
<p>dipy.reconst.csdeconv.response_from_mask is deprecated, Please use dipy.reconst.csdeconv.response_from_mask_ssst instead</p>
<ul class="simple">
<li><p>deprecated from version: 1.2</p></li>
<li><p>Raises &lt;class ‘dipy.utils.deprecator.ExpiredDeprecationError’&gt; as of version: 1.4</p></li>
</ul>
<section id="id122">
<h4>Parameters<a class="headerlink" href="#id122" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
data : ndarray</p>
<blockquote>
<div><p>diffusion data</p>
</div></blockquote>
<dl class="simple">
<dt>mask<span class="classifier">ndarray</span></dt><dd><p>mask from where to compute the response function</p>
</dd>
</dl>
</section>
<section id="id123">
<h4>Returns<a class="headerlink" href="#id123" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>response<span class="classifier">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>
</dd>
<dt>ratio<span class="classifier">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>
</dd>
</dl>
</section>
<section id="id124">
<h4>Notes<a class="headerlink" href="#id124" title="Permalink to this heading">#</a></h4>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this, we look for voxels with very
anisotropic configurations. This information can be obtained by using
csdeconv.mask_for_response_ssst() through a mask of selected voxels
(see[1]_). The present function uses such a mask to compute the ssst
response function.</p>
<p>For the response we also need to find the average S0 in the ROI. This is
possible using <cite>gtab.b0s_mask()</cite> we can find all the S0 volumes (which
correspond to b-values equal 0) in the dataset.</p>
<p>The <cite>response</cite> consists always of a prolate tensor created by averaging
the highest and second highest eigenvalues in the ROI with FA higher than
threshold. We also include the average S0s.</p>
<p>We also return the <cite>ratio</cite> which is used for the SDT models.</p>
</section>
<section id="id125">
<h4>References<a class="headerlink" href="#id125" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id126" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</p>
</aside>
</aside>
<p>fiber orientation density function from diffusion-weighted MRI
data using spherical deconvolution</p>
</section>
</dd></dl>

</section>
<section id="estimate-response">
<h3>estimate_response<a class="headerlink" href="#estimate-response" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.estimate_response">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">estimate_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.estimate_response" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate single fiber response function</p>
<section id="id127">
<h4>Parameters<a class="headerlink" href="#id127" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
evals : ndarray
S0 : float</p>
<blockquote>
<div><p>non diffusion weighted</p>
</div></blockquote>
</section>
<section id="id128">
<h4>Returns<a class="headerlink" href="#id128" title="Permalink to this heading">#</a></h4>
<p>S : estimated signal</p>
</section>
</dd></dl>

</section>
<section id="forward-sdt-deconv-mat">
<h3>forward_sdt_deconv_mat<a class="headerlink" href="#forward-sdt-deconv-mat" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.forward_sdt_deconv_mat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">forward_sdt_deconv_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ratio</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r2_term</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat" title="Permalink to this definition">#</a></dt>
<dd><p>Build forward sharpening deconvolution transform (SDT) matrix

Parameters
———-
ratio : float
    ratio = <span class="math notranslate nohighlight">\(\frac{\lambda_2}{\lambda_1}\)</span> of the single fiber response
    function
n : ndarray (N,)
    The degree of spherical harmonic function associated with each row of
    the deconvolution matrix. Only even degrees are allowed.
r2_term : bool
    True if ODF comes from an ODF computed from a model using the <span class="math notranslate nohighlight">\(r^2\)</span>
    term in the integral. For example, DSI, GQI, SHORE, CSA, Tensor,
    Multi-tensor ODFs. This results in using the proper analytical response
    function solution solving from the single-fiber ODF with the r^2 term.
    This derivation is not published anywhere but is very similar to <a href="#id1400"><span class="problematic" id="id129">[1]_</span></a>.

Returns
——-
R : ndarray (N, N)
    SDT deconvolution matrix
P : ndarray (N, N)
    Funk-Radon Transform (FRT) matrix

References
———-
.. [1] Descoteaux, M. PhD Thesis. INRIA Sophia-Antipolis. 2008.</p>
</dd></dl>

</section>
<section id="csdeconv">
<h3>csdeconv<a class="headerlink" href="#csdeconv" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.csdeconv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">csdeconv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dwsignal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.csdeconv" title="Permalink to this definition">#</a></dt>
<dd><p>Constrained-regularized spherical deconvolution (CSD) <a href="#id1401"><span class="problematic" id="id130">[1]_</span></a>

Deconvolves the axially symmetric single fiber response function <cite>r_rh</cite> in
rotational harmonics coefficients from the diffusion weighted signal in
<cite>dwsignal</cite>.

Parameters
———-
dwsignal : array
    Diffusion weighted signals to be deconvolved.
X : array
    Prediction matrix which estimates diffusion weighted signals from FOD
    coefficients.
B_reg : array (N, B)
    SH basis matrix which maps FOD coefficients to FOD values on the
    surface of the sphere. B_reg should be scaled to account for lambda.
tau : float
    Threshold controlling the amplitude below which the corresponding fODF
    is assumed to be zero.  Ideally, tau should be set to zero. However, to
    improve the stability of the algorithm, tau is set to tau*100 % of the
    max fODF amplitude (here, 10% by default). This is similar to peak
    detection where peaks below 0.1 amplitude are usually considered noise
    peaks. Because SDT is based on a q-ball ODF deconvolution, and not
    signal deconvolution, using the max instead of mean (as in CSD), is
    more stable.
convergence : int
    Maximum number of iterations to allow the deconvolution to converge.
P : ndarray
    This is an optimization to avoid computing <code class="docutils literal notranslate"><span class="pre">dot(X.T,</span> <span class="pre">X)</span></code> many times.
    If the same <code class="docutils literal notranslate"><span class="pre">X</span></code> is used many times, <code class="docutils literal notranslate"><span class="pre">P</span></code> can be precomputed and
    passed to this function.

Returns
——-
fodf_sh : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)
     Spherical harmonics coefficients of the constrained-regularized fiber
     ODF.
num_it : int
     Number of iterations in the constrained-regularization used for
     convergence.

Notes
—–
This section describes how the fitting of the SH coefficients is done.
Problem is to minimise per iteration:

<span class="math notranslate nohighlight">\(F(f_n) = ||Xf_n - S||^2 + \lambda^2 ||H_{n-1} f_n||^2\)</span>

Where <span class="math notranslate nohighlight">\(X\)</span> maps current FOD SH coefficients <span class="math notranslate nohighlight">\(f_n\)</span> to DW signals <span class="math notranslate nohighlight">\(s\)</span> and
<span class="math notranslate nohighlight">\(H_{n-1}\)</span> maps FOD SH coefficients <span class="math notranslate nohighlight">\(f_n\)</span> to amplitudes along set of
negative directions identified in previous iteration, i.e. the matrix
formed by the rows of <span class="math notranslate nohighlight">\(B_{reg}\)</span> for which <span class="math notranslate nohighlight">\(Hf_{n-1}&lt;0\)</span> where <span class="math notranslate nohighlight">\(B_{reg}\)</span>
maps <span class="math notranslate nohighlight">\(f_n\)</span> to FOD amplitude on a sphere.

Solve by differentiating and setting to zero:

<span class="math notranslate nohighlight">\(\Rightarrow \frac{\delta F}{\delta f_n} = 2X^T(Xf_n - S) + 2 \lambda^2
H_{n-1}^TH_{n-1}f_n=0\)</span>

Or:

<span class="math notranslate nohighlight">\((X^TX + \lambda^2 H_{n-1}^TH_{n-1})f_n = X^Ts\)</span>

Define <span class="math notranslate nohighlight">\(Q = X^TX + \lambda^2 H_{n-1}^TH_{n-1}\)</span> , which by construction is a
square positive definite symmetric matrix of size <span class="math notranslate nohighlight">\(n_{SH} by n_{SH}\)</span>. If
needed, positive definiteness can be enforced with a small minimum norm
regulariser (helps a lot with poorly conditioned direction sets and/or
superresolution):

<span class="math notranslate nohighlight">\(Q = X^TX + (\lambda H_{n-1}^T) (\lambda H_{n-1}) + \mu I\)</span>

Solve <span class="math notranslate nohighlight">\(Qf_n = X^Ts\)</span> using Cholesky decomposition:

<span class="math notranslate nohighlight">\(Q = LL^T\)</span>

where <span class="math notranslate nohighlight">\(L\)</span> is lower triangular. Then problem can be solved by
back-substitution:

<span class="math notranslate nohighlight">\(L_y = X^Ts\)</span>

<span class="math notranslate nohighlight">\(L^Tf_n = y\)</span>

To speeds things up further, form <span class="math notranslate nohighlight">\(P = X^TX + \mu I\)</span>, and update to form
<span class="math notranslate nohighlight">\(Q\)</span> by rankn update with <span class="math notranslate nohighlight">\(H_{n-1}\)</span>. The dipy implementation looks like:

    form initially <span class="math notranslate nohighlight">\(P = X^T X + \mu I\)</span> and <span class="math notranslate nohighlight">\(\lambda B_{reg}\)</span>

    for each voxel: form <span class="math notranslate nohighlight">\(z = X^Ts\)</span>

        estimate <span class="math notranslate nohighlight">\(f_0\)</span> by solving <span class="math notranslate nohighlight">\(Pf_0=z\)</span>. We use a simplified <span class="math notranslate nohighlight">\(l_{max}=4\)</span>
        solution here, but it might not make a big difference.

        Then iterate until no change in rows of <span class="math notranslate nohighlight">\(H\)</span> used in <span class="math notranslate nohighlight">\(H_n\)</span>

            form <span class="math notranslate nohighlight">\(H_{n}\)</span> given <span class="math notranslate nohighlight">\(f_{n-1}\)</span>

            form <span class="math notranslate nohighlight">\(Q = P + (\lambda H_{n-1}^T) (\lambda H_{n-1}\)</span>) (this can
            be done by rankn update, but we currently do not use rankn
            update).

            solve <span class="math notranslate nohighlight">\(Qf_n = z\)</span> using Cholesky decomposition

We’d like to thanks Donald Tournier for his help with describing and
implementing this algorithm.

References
———-
.. [1] Tournier, J.D., et al. NeuroImage 2007. Robust determination of the
       fibre orientation distribution in diffusion MRI: Non-negativity
       constrained super-resolved spherical deconvolution.</p>
</dd></dl>

</section>
<section id="odf-deconv">
<h3>odf_deconv<a class="headerlink" href="#odf-deconv" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.odf_deconv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">odf_deconv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odf_sh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r2_term</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.odf_deconv" title="Permalink to this definition">#</a></dt>
<dd><p>ODF constrained-regularized spherical deconvolution using
the Sharpening Deconvolution Transform (SDT) <a href="#id1402"><span class="problematic" id="id131">[1]_</span></a>, <a href="#id1403"><span class="problematic" id="id132">[2]_</span></a>.

Parameters
———-
odf_sh : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)
     ndarray of SH coefficients for the ODF spherical function to be
     deconvolved
R : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,
     <code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>)
     SDT matrix in SH basis
B_reg : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,
     <code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>)
     SH basis matrix used for deconvolution
<a href="#id1404"><span class="problematic" id="id1405">lambda_</span></a> : float
     lambda parameter in minimization equation (default 1.0)
tau : float
     threshold (tau <a href="#id133"><span class="problematic" id="id134">*</span></a>max(fODF)) controlling the amplitude below
     which the corresponding fODF is assumed to be zero.
r2_term : bool
     True if ODF is computed from model that uses the <span class="math notranslate nohighlight">\(r^2\)</span> term in the
     integral.  Recall that Tuch’s ODF (used in Q-ball Imaging <a href="#id1406"><span class="problematic" id="id135">[1]_</span></a>) and
     the true normalized ODF definition differ from a <span class="math notranslate nohighlight">\(r^2\)</span> term in the ODF
     integral. The original Sharpening Deconvolution Transform (SDT)
     technique <a href="#id1407"><span class="problematic" id="id136">[2]_</span></a> is expecting Tuch’s ODF without the <span class="math notranslate nohighlight">\(r^2\)</span> (see <a href="#id1408"><span class="problematic" id="id137">[3]_</span></a> for
     the mathematical details).  Now, this function supports ODF that have
     been computed using the <span class="math notranslate nohighlight">\(r^2\)</span> term because the proper analytical
     response function has be derived.  For example, models such as DSI,
     GQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved
     with the r2_term=True.

Returns
——-
fodf_sh : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)
     Spherical harmonics coefficients of the constrained-regularized fiber
     ODF
num_it : int
     Number of iterations in the constrained-regularization used for
     convergence

References
———-
.. [1] Tuch, D. MRM 2004. Q-Ball Imaging.
.. [2] Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
       Probabilistic Tractography Based on Complex Fibre Orientation
       Distributions
.. [3] Descoteaux, M, PhD thesis, INRIA Sophia-Antipolis, 2008.</p>
</dd></dl>

</section>
<section id="odf-sh-to-sharp">
<h3>odf_sh_to_sharp<a class="headerlink" href="#odf-sh-to-sharp" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.odf_sh_to_sharp">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">odf_sh_to_sharp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odfs_sh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r2_term</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.odf_sh_to_sharp" title="Permalink to this definition">#</a></dt>
<dd><p>Sharpen odfs using the sharpening deconvolution transform <a href="#id1409"><span class="problematic" id="id138">[2]_</span></a>

This function can be used to sharpen any smooth ODF spherical function. In
theory, this should only be used to sharpen QballModel ODFs, but in
practice, one can play with the deconvolution ratio and sharpen almost any
ODF-like spherical function. The constrained-regularization is stable and
will not only sharpen the ODF peaks but also regularize the noisy peaks.

Parameters
———-
odfs_sh : ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>, )
    array of odfs expressed as spherical harmonics coefficients
sphere : Sphere
    sphere used to build the regularization matrix
basis : {None, ‘tournier07’, ‘descoteaux07’}
    different spherical harmonic basis:
    <code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
    <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a href="#id1410"><span class="problematic" id="id139">[4]_</span></a> basis, and
    <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a href="#id1411"><span class="problematic" id="id140">[3]_</span></a> basis
    (<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).
ratio : float,
    ratio of the smallest vs the largest eigenvalue of the single prolate
    tensor response function (<span class="math notranslate nohighlight">\(\frac{\lambda_2}{\lambda_1}\)</span>)
sh_order : int
    maximal SH order of the SH representation
<a href="#id1412"><span class="problematic" id="id1413">lambda_</span></a> : float
    lambda parameter (see odfdeconv) (default 1.0)
tau : float
    tau parameter in the L matrix construction (see odfdeconv)
    (default 0.1)
r2_term : bool
     True if ODF is computed from model that uses the <span class="math notranslate nohighlight">\(r^2\)</span> term in the
     integral.  Recall that Tuch’s ODF (used in Q-ball Imaging <a href="#id1414"><span class="problematic" id="id141">[1]_</span></a>) and
     the true normalized ODF definition differ from a <span class="math notranslate nohighlight">\(r^2\)</span> term in the ODF
     integral. The original Sharpening Deconvolution Transform (SDT)
     technique <a href="#id1415"><span class="problematic" id="id142">[2]_</span></a> is expecting Tuch’s ODF without the <span class="math notranslate nohighlight">\(r^2\)</span> (see <a href="#id1416"><span class="problematic" id="id143">[3]_</span></a> for
     the mathematical details).  Now, this function supports ODF that have
     been computed using the <span class="math notranslate nohighlight">\(r^2\)</span> term because the proper analytical
     response function has be derived.  For example, models such as DSI,
     GQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved
     with the r2_term=True.

Returns
——-
fodf_sh : ndarray
    sharpened odf expressed as spherical harmonics coefficients

References
———-
.. [1] Tuch, D. MRM 2004. Q-Ball Imaging.
.. [2] Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
       Probabilistic Tractography Based on Complex Fibre Orientation
       Distributions
.. [3] Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
       Regularized, Fast, and Robust Analytical Q-ball Imaging.
       Magn. Reson. Med. 2007;58:497-510.
.. [4] Tournier J.D., Calamante F. and Connelly A. Robust determination
       of the fibre orientation distribution in diffusion MRI:
       Non-negativity constrained super-resolved spherical deconvolution.
       NeuroImage. 2007;35(4):1459-1472.</p>
</dd></dl>

</section>
<section id="mask-for-response-ssst">
<h3>mask_for_response_ssst<a class="headerlink" href="#mask-for-response-ssst" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.mask_for_response_ssst">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">mask_for_response_ssst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.mask_for_response_ssst" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computation of mask for single-shell single-tissue (ssst) response</dt><dd><p>function using FA.</p>
</dd>
</dl>
<section id="id144">
<h4>Parameters<a class="headerlink" href="#id144" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
data : ndarray</p>
<blockquote>
<div><p>diffusion data (4D)</p>
</div></blockquote>
<dl class="simple">
<dt>roi_center<span class="classifier">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt>roi_radii<span class="classifier">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>
</dd>
<dt>fa_thr<span class="classifier">float</span></dt><dd><p>FA threshold</p>
</dd>
</dl>
</section>
<section id="id145">
<h4>Returns<a class="headerlink" href="#id145" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>mask<span class="classifier">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA above the FA threshold.</p>
</dd>
</dl>
</section>
<section id="id146">
<h4>Notes<a class="headerlink" href="#id146" title="Permalink to this heading">#</a></h4>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this, we look for voxels with very
anisotropic configurations. This function aims to accomplish that by
returning a mask of voxels within a ROI, that have a FA value above a
given threshold. For example we can use a ROI (20x20x20) at
the center of the volume and store the signal values for the voxels with
FA values higher than 0.7 (see <a href="#id1417"><span class="problematic" id="id147">[1]_</span></a>).</p>
</section>
<section id="id148">
<h4>References<a class="headerlink" href="#id148" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id149" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</p>
</aside>
</aside>
<p>fiber orientation density function from diffusion-weighted MRI
data using spherical deconvolution</p>
</section>
</dd></dl>

</section>
<section id="response-from-mask-ssst">
<h3>response_from_mask_ssst<a class="headerlink" href="#response-from-mask-ssst" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.response_from_mask_ssst">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">response_from_mask_ssst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.response_from_mask_ssst" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computation of single-shell single-tissue (ssst) response</dt><dd><p>function from a given mask.</p>
</dd>
</dl>
<section id="id150">
<h4>Parameters<a class="headerlink" href="#id150" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
data : ndarray</p>
<blockquote>
<div><p>diffusion data</p>
</div></blockquote>
<dl class="simple">
<dt>mask<span class="classifier">ndarray</span></dt><dd><p>mask from where to compute the response function</p>
</dd>
</dl>
</section>
<section id="id151">
<h4>Returns<a class="headerlink" href="#id151" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>response<span class="classifier">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>
</dd>
<dt>ratio<span class="classifier">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>
</dd>
</dl>
</section>
<section id="id152">
<h4>Notes<a class="headerlink" href="#id152" title="Permalink to this heading">#</a></h4>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this, we look for voxels with very
anisotropic configurations. This information can be obtained by using
csdeconv.mask_for_response_ssst() through a mask of selected voxels
(see[1]_). The present function uses such a mask to compute the ssst
response function.</p>
<p>For the response we also need to find the average S0 in the ROI. This is
possible using <cite>gtab.b0s_mask()</cite> we can find all the S0 volumes (which
correspond to b-values equal 0) in the dataset.</p>
<p>The <cite>response</cite> consists always of a prolate tensor created by averaging
the highest and second highest eigenvalues in the ROI with FA higher than
threshold. We also include the average S0s.</p>
<p>We also return the <cite>ratio</cite> which is used for the SDT models.</p>
</section>
<section id="id153">
<h4>References<a class="headerlink" href="#id153" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id154" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</p>
</aside>
</aside>
<p>fiber orientation density function from diffusion-weighted MRI
data using spherical deconvolution</p>
</section>
</dd></dl>

</section>
<section id="auto-response-ssst">
<h3>auto_response_ssst<a class="headerlink" href="#auto-response-ssst" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.auto_response_ssst">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">auto_response_ssst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.auto_response_ssst" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Automatic estimation of single-shell single-tissue (ssst) response</dt><dd><p>function using FA.</p>
</dd>
</dl>
<section id="id155">
<h4>Parameters<a class="headerlink" href="#id155" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
data : ndarray</p>
<blockquote>
<div><p>diffusion data</p>
</div></blockquote>
<dl class="simple">
<dt>roi_center<span class="classifier">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt>roi_radii<span class="classifier">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>
</dd>
<dt>fa_thr<span class="classifier">float</span></dt><dd><p>FA threshold</p>
</dd>
</dl>
</section>
<section id="id156">
<h4>Returns<a class="headerlink" href="#id156" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>response<span class="classifier">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>
</dd>
<dt>ratio<span class="classifier">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>
</dd>
</dl>
</section>
<section id="id157">
<h4>Notes<a class="headerlink" href="#id157" title="Permalink to this heading">#</a></h4>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this, we look for voxels with very
anisotropic configurations. We get this information from
csdeconv.mask_for_response_ssst(), which returns a mask of selected voxels
(more details are available in the description of the function).</p>
<p>With the mask, we compute the response function by using
csdeconv.response_from_mask_ssst(), which returns the <cite>response</cite> and the
<cite>ratio</cite> (more details are available in the description of the function).</p>
</section>
</dd></dl>

</section>
<section id="recursive-response">
<h3>recursive_response<a class="headerlink" href="#recursive-response" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.recursive_response">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">recursive_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order=8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peak_thr=0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_fa=0.08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_trace=0.0021</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter=8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence=0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_processes=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere=&lt;dipy.core.sphere.HemiSphere</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.recursive_response" title="Permalink to this definition">#</a></dt>
<dd><p>Recursive calibration of response function using peak threshold</p>
<section id="id158">
<h4>Parameters<a class="headerlink" href="#id158" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
data : ndarray</p>
<blockquote>
<div><p>diffusion data</p>
</div></blockquote>
<dl class="simple">
<dt>mask<span class="classifier">ndarray, optional</span></dt><dd><p>mask for recursive calibration, for example a white matter mask. It has
shape <cite>data.shape[0:3]</cite> and dtype=bool. Default: use the entire data
array.</p>
</dd>
<dt>sh_order<span class="classifier">int, optional</span></dt><dd><p>maximal spherical harmonics order. Default: 8</p>
</dd>
<dt>peak_thr<span class="classifier">float, optional</span></dt><dd><p>peak threshold, how large the second peak can be relative to the first
peak in order to call it a single fiber population [1]. Default: 0.01</p>
</dd>
<dt>init_fa<span class="classifier">float, optional</span></dt><dd><p>FA of the initial ‘fat’ response function (tensor). Default: 0.08</p>
</dd>
<dt>init_trace<span class="classifier">float, optional</span></dt><dd><p>trace of the initial ‘fat’ response function (tensor). Default: 0.0021</p>
</dd>
<dt>iter<span class="classifier">int, optional</span></dt><dd><p>maximum number of iterations for calibration. Default: 8.</p>
</dd>
<dt>convergence<span class="classifier">float, optional</span></dt><dd><p>convergence criterion, maximum relative change of SH
coefficients. Default: 0.001.</p>
</dd>
<dt>parallel<span class="classifier">bool, optional</span></dt><dd><p>Whether to use parallelization in peak-finding during the calibration
procedure. Default: True</p>
</dd>
<dt>num_processes<span class="classifier">int, optional</span></dt><dd><p>If <cite>parallel</cite> is True, the number of subprocesses to use
(default multiprocessing.cpu_count()). If &lt; 0 the maximal number of
cores minus <code class="docutils literal notranslate"><span class="pre">num_processes</span> <span class="pre">+</span> <span class="pre">1</span></code> is used (enter -1 to use as many
cores as possible). 0 raises an error.</p>
</dd>
<dt>sphere<span class="classifier">Sphere, optional.</span></dt><dd><p>The sphere used for peak finding. Default: default_sphere.</p>
</dd>
</dl>
</section>
<section id="id159">
<h4>Returns<a class="headerlink" href="#id159" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>response<span class="classifier">ndarray</span></dt><dd><p>response function in SH coefficients</p>
</dd>
</dl>
</section>
<section id="id160">
<h4>Notes<a class="headerlink" href="#id160" title="Permalink to this heading">#</a></h4>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. Using an FA threshold is not a very robust method.
It is dependent on the dataset (non-informed used subjectivity), and still
depends on the diffusion tensor (FA and first eigenvector),
which has low accuracy at high b-value. This function recursively
calibrates the response function, for more information see [1].</p>
</section>
<section id="id161">
<h4>References<a class="headerlink" href="#id161" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id162" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Tax, C.M.W., et al. NeuroImage 2014. Recursive calibration of
the fiber response function for spherical deconvolution of
diffusion MRI data.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="fa-trace-to-lambdas">
<h3>fa_trace_to_lambdas<a class="headerlink" href="#fa-trace-to-lambdas" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.csdeconv.fa_trace_to_lambdas">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.csdeconv.</span></span><span class="sig-name descname"><span class="pre">fa_trace_to_lambdas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0021</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="correlationtensormodel">
<h3><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorModel" title="dipy.reconst.cti.CorrelationTensorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CorrelationTensorModel</span></code></a><a class="headerlink" href="#correlationtensormodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">CorrelationTensorModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Class for the Correlation Tensor Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Correlation Tensor Imaging Model [1]</p>
<section id="id163">
<h4>Parameters<a class="headerlink" href="#id163" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab1: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for first DDE diffusion epoch</p>
</dd>
<dt>gtab2: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for second DDE diffusion epoch</p>
</dd>
</dl>
<p>fit_method : str or callable, optional
args, kwargs :</p>
<blockquote>
<div><p>arguments and key-word arguments passed to the fit_method.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cti_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorModel.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal for the CTI model class instance given parameters</p>
<section id="id164">
<h4>Parameters<a class="headerlink" href="#id164" title="Permalink to this heading">#</a></h4>
<p>cti_params: numpy.ndarray (…, 48)
All parameters estimated from the correlation tensor model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
</ol>
<p>2. Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector
3. Fifteen elements of the kurtosis tensor
4. Twenty-One elements of the covariance tensor</p>
</div></blockquote>
<dl class="simple">
<dt>gtab1: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for first DDE diffusion epoch</p>
</dd>
<dt>gtab2: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for second DDE diffusion epoch</p>
</dd>
<dt>S0<span class="classifier">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</section>
<section id="id165">
<h4>Returns<a class="headerlink" href="#id165" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">numpy.ndarray</span></dt><dd><p>Predicted signal based on the CTI model</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="correlationtensorfit">
<h3><a class="reference internal" href="#dipy.reconst.cti.CorrelationTensorFit" title="dipy.reconst.cti.CorrelationTensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">CorrelationTensorFit</span></code></a><a class="headerlink" href="#correlationtensorfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">CorrelationTensorFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a></p>
<p>Class for fitting the Correlation Tensor Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a CorrelationTensorFit class instance.</p>
<section id="id166">
<h4>Parameters<a class="headerlink" href="#id166" title="Permalink to this heading">#</a></h4>
<dl>
<dt>model<span class="classifier">CorrelationTensorModel Class instance</span></dt><dd><p>Class instance containing the Correlation Tensor Model for the fit</p>
</dd>
<dt>model_params<span class="classifier">ndarray (x, y, z, 48) or (n, 48)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
<li><p>Twenty One elements of the covariance tensor</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.K_aniso">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">K_aniso</span></span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.K_aniso" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the anisotropic Source of Kurtosis (K_aniso)

    Notes
    —–
    The K_aniso is defined as[1]_:

    :math::

    [K_{aniso} = frac{6}{5} cdot frac{langle V_{lambda}(D_c)
                                          rangle}{overline{D}^2}]

where: <span class="math notranslate nohighlight">\(K_{aniso}\)</span> is the anisotropic kurtosis,
    <span class="math notranslate nohighlight">\(\langle V_{\lambda}(D_c) \rangle\)</span> represents the mean of the
    variance of eigenvalues of the diffusion tensor,
    <span class="math notranslate nohighlight">\(\overline{D}\)</span> is the mean of the diffusion tensor.

References
———-
.. [1]  [NetoHe2020] Henriques, R.N., Jespersen, S.N., Shemesh, N., 2020.
        Correlation tensor magnetic resonance imaging. Neuroimage 211.
        doi: 10.1016/j.neuroimage.2020.116605</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.K_iso">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">K_iso</span></span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.K_iso" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the isotropic Source of Kurtosis (K_iso)

Notes
—–
The K_iso is defined as :

:math::
    $$ K_{text{iso}} = 3 cdot frac{V(overline{D}^c)}{overline{D}^2} $$

where: :math:` K_{text{iso}} ` is the isotropic kurtosis,
    (V({overline{D}^c})) represents the variance of the diffusion
    tensor raised to the power c,
    (overline{D}) is the mean of the diffusion tensor.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.K_micro">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">K_micro</span></span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.K_micro" title="Permalink to this definition">#</a></dt>
<dd><p>Returns Microscopic Source of Kurtosis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.K_total">
<span class="sig-name descname"><span class="pre">K_total</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.K_total" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the total excess kurtosis.

Notes
—–
<span class="math notranslate nohighlight">\(K_total\)</span> is defined as :

:math::
    [Psi = frac{2}{5} cdot frac{D_{11}^2 + D_{22}^2 + D_{33}^2
                                     + 2D_{12}^2 + 2D_{13}^2 +
                                     2D_{23}^2{overline{D}^2} -
                                     frac{6}{5} ]
    [{overline{W}} = frac{1}{5} cdot (W_{1111} + W_{2222}
                                          + W_{3333} + 2W_{1122}
                                          + 2W_{1133} + 2W_{2233})      ]

where (Psi) is a variable representing a part of the total
excess kurtosis,
(D_{ij}) are elements of the diffusion tensor,
(overline{D}) is the mean of the diffusion tensor.
{overline{W}} is the mean kurtosis,
(W_{ijkl}) are elements of the kurtosis tensor.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.ct">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ct</span></span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.ct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the 21 independent elements of the covariance tensor as an
array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.cti.CorrelationTensorFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.CorrelationTensorFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Given a CTI model fit, predict the signal on the vertices of a
gradient table</p>
<section id="id167">
<h4>Parameters:<a class="headerlink" href="#id167" title="Permalink to this heading">#</a></h4>
<dl>
<dt>params: numpy.ndarray (…,43)</dt><dd><p>All parameters estimated from the correlation tensor model.
Parameters are ordered as follows:</p>
<ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
</ol>
<p>2. Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector
3. Fifteen elements of the kurtosis tensor
4. Twenty-One elements of the covariance tensor</p>
</dd>
<dt>gtab1: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for first DDE diffusion epoch</p>
</dd>
<dt>gtab2: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for second DDE diffusion epoch</p>
</dd>
<dt>S0<span class="classifier">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</section>
<section id="id168">
<h4>Returns<a class="headerlink" href="#id168" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">numpy.ndarray</span></dt><dd><p>Predicted signal based on the CTI model</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="from-qte-to-cti">
<h3>from_qte_to_cti<a class="headerlink" href="#from-qte-to-cti" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.from_qte_to_cti">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">from_qte_to_cti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.from_qte_to_cti" title="Permalink to this definition">#</a></dt>
<dd><p>Rescales the qte C elements to the C elements used in CTI.</p>
<section id="id169">
<h4>Parameters<a class="headerlink" href="#id169" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>C: array(…, 21)</dt><dd><p>Twenty-one elements of the covariance tensor in voigt notation plus
some extra scaling factors.</p>
</dd>
</dl>
</section>
<section id="id170">
<h4>Returns<a class="headerlink" href="#id170" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ccti: array(…, 21)</dt><dd><p>Covariance Tensor Elements with no hidden factors.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="multi-gaussian-k-from-c">
<h3>multi_gaussian_k_from_c<a class="headerlink" href="#multi-gaussian-k-from-c" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.multi_gaussian_k_from_c">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">multi_gaussian_k_from_c</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ccti</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.multi_gaussian_k_from_c" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the multiple Gaussian diffusion kurtosis tensor from the
covariance tensor.</p>
<section id="id171">
<h4>Parameters<a class="headerlink" href="#id171" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ccti: array(…, 21)</dt><dd><p>Covariance Tensor Elements with no hidden factors.</p>
</dd>
</dl>
<p>MD: Mean Diffusivity (MD) of a diffusion tensor.</p>
</section>
<section id="id172">
<h4>Returns<a class="headerlink" href="#id172" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>K: array (…, 15)</dt><dd><p>Fifteen elements of the kurtosis tensor</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="split-cti-params">
<h3>split_cti_params<a class="headerlink" href="#split-cti-params" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.split_cti_params">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">split_cti_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cti_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.split_cti_params" title="Permalink to this definition">#</a></dt>
<dd><p>Splits CTI params into DTI, DKI, CTI portions.</p>
<p>Extract the diffusion tensor eigenvalues, the diffusion tensor
eigenvector matrix, and the 21 independent elements of the covariance
tensor, and the 15 independent elements of the kurtosis tensor from the
model parameters estimated from the CTI model</p>
<section id="id173">
<h4>Parameters<a class="headerlink" href="#id173" title="Permalink to this heading">#</a></h4>
<blockquote>
<div><p>params: numpy.ndarray (…, 48)
All parameters estimated from the correlation tensor model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
</ol>
<p>2. Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector
3. Fifteen elements of the kurtosis tensor
4. Twenty-One elements of the covariance tensor</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="id174">
<h4>Returns<a class="headerlink" href="#id174" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>evals<span class="classifier">array (…, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt>evecs<span class="classifier">array (…, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. evecs[:,j] is associated with
evals[j])</p>
</dd>
<dt>kt<span class="classifier">array (…, 15)</span></dt><dd><p>Fifteen elements of the kurtosis tensor</p>
</dd>
<dt>ct: array(…, 21)</dt><dd><p>Twenty-one elements of the covariance tensor</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="cti-prediction">
<h3>cti_prediction<a class="headerlink" href="#cti-prediction" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.cti_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">cti_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cti_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.cti_prediction" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal given correlation tensor imaging parameters.</p>
<section id="id175">
<h4>Parameters<a class="headerlink" href="#id175" title="Permalink to this heading">#</a></h4>
<p>cti_params: numpy.ndarray (…, 48)
All parameters estimated from the correlation tensor model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
</ol>
<p>2. Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector
3. Fifteen elements of the kurtosis tensor
4. Twenty-One elements of the covariance tensor</p>
</div></blockquote>
<dl class="simple">
<dt>gtab1: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for first DDE diffusion epoch</p>
</dd>
<dt>gtab2: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for second DDE diffusion epoch</p>
</dd>
<dt>S0<span class="classifier">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</section>
<section id="id176">
<h4>Returns<a class="headerlink" href="#id176" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">ndarray</span></dt><dd><p>Simulated signal based on the CTI model</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="params-to-cti-params">
<h3>params_to_cti_params<a class="headerlink" href="#params-to-cti-params" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.params_to_cti_params">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">params_to_cti_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.params_to_cti_params" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="ls-fit-cti">
<h3>ls_fit_cti<a class="headerlink" href="#ls-fit-cti" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.cti.ls_fit_cti">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.cti.</span></span><span class="sig-name descname"><span class="pre">ls_fit_cti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cti.ls_fit_cti" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the diffusion kurtosis and covariance tensors using an
ordinary or weighted linear least squares approach</p>
<section id="id177">
<h4>Parameters<a class="headerlink" href="#id177" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (g, 43)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt>data<span class="classifier">array (g)</span></dt><dd><p>Data or response variables holding the data.</p>
</dd>
<dt>inverse_design_matrix<span class="classifier">array (43, g)</span></dt><dd><p>Inverse of the design matrix.</p>
</dd>
<dt>weights<span class="classifier">bool, optional</span></dt><dd><p>Parameter indicating whether weights are used. Default: True.</p>
</dd>
<dt>min_diffusivity<span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than <cite>min_diffusivity</cite>
are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</section>
<section id="id178">
<h4>Returns<a class="headerlink" href="#id178" title="Permalink to this heading">#</a></h4>
<p>cti_params : array (48)
All parameters estimated from the diffusion kurtosis model for all N
voxels. Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor eigenvalues.</p></li>
<li><dl class="simple">
<dt>Three blocks of three elements, containing the first second and</dt><dd><p>third coordinates of the diffusion tensor eigenvectors.</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor.</p></li>
<li><p>Twenty One elements of the covariance tensor.</p></li>
</ol>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="diffusionkurtosismodel">
<h3><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="dipy.reconst.dki.DiffusionKurtosisModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a><a class="headerlink" href="#diffusionkurtosismodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">DiffusionKurtosisModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Class for the Diffusion Kurtosis Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Diffusion Kurtosis Tensor Model [1]</p>
<section id="id179">
<h4>Parameters<a class="headerlink" href="#id179" title="Permalink to this heading">#</a></h4>
<dl>
<dt>gtab<span class="classifier">GradientTable instance</span></dt><dd><p>The gradient table for the data set.</p>
</dd>
<dt>fit_method<span class="classifier">str or callable, optional</span></dt><dd><dl>
<dt>str be one of the following:</dt><dd><p>‘OLS’ or ‘ULLS’ for ordinary least squares.
‘WLS’, ‘WLLS’ or ‘UWLLS’ for weighted ordinary least squares.</p>
<blockquote>
<div><p>See dki.ls_fit_dki.</p>
</div></blockquote>
<p>‘CLS’ for LMI constrained ordinary least squares [2].
‘CWLS’ for LMI constrained weighted least squares [2].</p>
<blockquote>
<div><p>See dki.cls_fit_dki.</p>
</div></blockquote>
</dd>
<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href="#id180"><span class="problematic" id="id181">*</span></a>args, <a href="#id182"><span class="problematic" id="id183">**</span></a>kwargs).</p>
</dd>
</dl>
<p>Default: “WLS”</p>
</dd>
<dt>args, kwargs :</dt><dd><p>arguments and key-word arguments passed to the fit_method.</p>
</dd>
</dl>
</section>
<section id="id184">
<h4>References<a class="headerlink" href="#id184" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id185" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</p>
</aside>
<aside class="footnote brackets" id="id186" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Dela Haije et al. “Enforcing necessary non-negativity constraints
for common diffusion MRI models using sum of squares
programming”. NeuroImage 209, 2020, 116405.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.fit" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel.multi_fit">
<span class="sig-name descname"><span class="pre">multi_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.multi_fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal for this DKI model class instance given parameters</p>
<section id="id187">
<h4>Parameters<a class="headerlink" href="#id187" title="Permalink to this heading">#</a></h4>
<p>dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
</ol>
<p>2. Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector
3. Fifteen elements of the kurtosis tensor</p>
<dl class="simple">
<dt>S0<span class="classifier">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="diffusionkurtosisfit">
<h3><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a><a class="headerlink" href="#diffusionkurtosisfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">DiffusionKurtosisFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a></p>
<p>Class for fitting the Diffusion Kurtosis Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a DiffusionKurtosisFit class instance</p>
<p>Since DKI is an extension of DTI, class instance is defined as subclass
of the TensorFit from dti.py</p>
<section id="id188">
<h4>Parameters<a class="headerlink" href="#id188" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">DiffusionKurtosisModel Class instance</span></dt><dd><p>Class instance containing the Diffusion Kurtosis Model for the fit</p>
</dd>
</dl>
<p>model_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><dl class="simple">
<dt>Three lines of the eigenvector matrix each containing the</dt><dd><p>first, second and third coordinates of the eigenvector</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.ak">
<span class="sig-name descname"><span class="pre">ak</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.ak" title="Permalink to this definition">#</a></dt>
<dd><p>Compute axial kurtosis (AK) of a diffusion kurtosis tensor <a href="#id1418"><span class="problematic" id="id189">[1]_</span></a></p>
<section id="id190">
<h4>Parameters<a class="headerlink" href="#id190" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>min_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores <a href="#id1419"><span class="problematic" id="id191">[2]_</span></a>)</p>
</dd>
<dt>max_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>. Default = 10</p>
</dd>
<dt>analytical<span class="classifier">bool (optional)</span></dt><dd><p>If True, AK is calculated from rotated diffusion kurtosis tensor,
otherwise it will be computed from the apparent diffusion kurtosis
values along the principal axis of the diffusion tensor
(see notes). Default is set to True.</p>
</dd>
</dl>
</section>
<section id="id192">
<h4>Returns<a class="headerlink" href="#id192" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ak<span class="classifier">array</span></dt><dd><p>Calculated AK.</p>
</dd>
</dl>
</section>
<section id="id193">
<h4>Notes<a class="headerlink" href="#id193" title="Permalink to this heading">#</a></h4>
<p>AK is defined as the directional kurtosis parallel to the fiber’s main
direction e1 <a href="#id1420"><span class="problematic" id="id194">[1]_</span></a>, <a href="#id1421"><span class="problematic" id="id195">[2]_</span></a>. You can compute AK using to approaches:</p>
<ol class="arabic simple">
<li><p>AK is calculated from rotated diffusion kurtosis tensor <a href="#id1422"><span class="problematic" id="id196">[2]_</span></a>, i.e.:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[AK = \hat{W}_{1111}
\frac{(\lambda_{1}+\lambda_{2}+\lambda_{3})^2}{(9 \lambda_{1}^2)}\]</div>
<ol class="arabic simple" start="2">
<li><p>AK can be sampled from the principal axis of the diffusion tensor:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[AK = K(\mathbf{\mathbf{e}_1)\]</div>
<p>Although both approaches leads to an exact calculation of AK, the
first approach will be referred to as the analytical method while the
second approach will be referred to as the numerical method based on
their analogy to the estimation strategies for MK and RK.</p>
</section>
<section id="id197">
<h4>References<a class="headerlink" href="#id197" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id198" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of
non-Gaussian water diffusion by kurtosis analysis. NMR in
Biomedicine 23(7): 698-710</p>
</aside>
<aside class="footnote brackets" id="id199" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</p>
</aside>
<aside class="footnote brackets" id="id200" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.akc">
<span class="sig-name descname"><span class="pre">akc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.akc" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the apparent kurtosis coefficient (AKC) in each
direction on the sphere for each voxel in the data

Parameters
———-
sphere : Sphere class instance

Returns
——-
akc : ndarray
   The estimates of the apparent kurtosis coefficient in every
   direction on the input sphere

Notes
—–
For each sphere direction with coordinates <span class="math notranslate nohighlight">\((n_{1}, n_{2}, n_{3})\)</span>, the
calculation of AKC is done using formula:

.. math ::

    AKC(n)=frac{MD^{2}}{ADC(n)^{2}}sum_{i=1}^{3}sum_{j=1}^{3}
    sum_{k=1}^{3}sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}

where <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the kurtosis tensor, MD the mean
diffusivity and ADC the apparent diffusion coefficient computed as:

.. math ::

    ADC(n)=sum_{i=1}^{3}sum_{j=1}^{3}n_{i}n_{j}D_{ij}

where <span class="math notranslate nohighlight">\(D_{ij}\)</span> are the elements of the diffusion tensor.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.kfa">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kfa</span></span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.kfa" title="Permalink to this definition">#</a></dt>
<dd><p>Return the kurtosis tensor (KFA) <a href="#id1423"><span class="problematic" id="id201">[1]_</span></a>

Notes
—–
The KFA is defined as <a href="#id1424"><span class="problematic" id="id202">[1]_</span></a>:

.. math::

     KFA equiv
     frac{||mathbf{W} - MKT mathbf{I}^{(4)}||_F}{||mathbf{W}||_F}

where <span class="math notranslate nohighlight">\(W\)</span> is the kurtosis tensor, MKT the kurtosis tensor mean, <span class="math notranslate nohighlight">\(I^(4)\)</span>
is the fully symmetric rank 2 isotropic tensor and <span class="math notranslate nohighlight">\(||...||_F\)</span> is the
tensor’s Frobenius norm <a href="#id1425"><span class="problematic" id="id203">[1]_</span></a>.

References
———-
.. [1] Glenn, G. R., Helpern, J. A., Tabesh, A., and Jensen, J. H.
       (2015). Quantitative assessment of diffusional kurtosis
       anisotropy. NMR in Biomedicine 28, 448–459. doi:10.1002/nbm.3271</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.kmax">
<span class="sig-name descname"><span class="pre">kmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.kmax" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the maximum value of a single voxel kurtosis tensor</p>
<section id="id204">
<h4>Parameters<a class="headerlink" href="#id204" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of
the maximum value of kurtosis.</p>
</dd>
<dt>gtol<span class="classifier">float, optional</span></dt><dd><p>This input is to refine kurtosis maximum under the precision of the
directions sampled on the sphere class instance. The gradient of
the convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken
from the initial sampled directions of the given sphere object</p>
</dd>
</dl>
</section>
<section id="id205">
<h4>Returns<a class="headerlink" href="#id205" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>max_value<span class="classifier">float</span></dt><dd><p>kurtosis tensor maximum value</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.kt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kt</span></span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.kt" title="Permalink to this definition">#</a></dt>
<dd><p>Return the 15 independent elements of the kurtosis tensor as an array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.mk">
<span class="sig-name descname"><span class="pre">mk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.mk" title="Permalink to this definition">#</a></dt>
<dd><p>Compute mean kurtosis (MK) from the kurtosis tensor

Parameters
———-
min_kurtosis : float (optional)
    To keep kurtosis values within a plausible biophysical range, mean
    kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
    with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit
    for regions that consist of water confined to spherical pores <a href="#id1426"><span class="problematic" id="id206">[4]_</span></a>)
max_kurtosis : float (optional)
    To keep kurtosis values within a plausible biophysical range, mean
    kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
    with <cite>max_kurtosis</cite>. Default = 10
analytical : bool (optional)
    If True, MK is calculated using its analytical solution, otherwise
    an exact numerical estimator is used (see Notes). Default is set to
    True.

Returns
——-
mk : array
    Calculated MK.

Notes
—–
The MK is defined as the average of directional kurtosis coefficients
across all spatial directions, which can be formulated by the following
surface integral[1]_:

.. math::

     MK equiv frac{1}{4pi} int dOmega_mathbf{n} K(mathbf{n})

This integral can be numerically solved by averaging directional
kurtosis values sampled for directions of a spherical t-design <a href="#id1427"><span class="problematic" id="id207">[2]_</span></a>.

Alternatively, MK can be solved from the analytical solution derived by
Tabesh et al. <a href="#id1428"><span class="problematic" id="id208">[3]_</span></a>. This solution is given by:

.. math::

    MK=F_1(lambda_1,lambda_2,lambda_3)hat{W}_{1111}+
       F_1(lambda_2,lambda_1,lambda_3)hat{W}_{2222}+
       F_1(lambda_3,lambda_2,lambda_1)hat{W}_{3333}+ \
       F_2(lambda_1,lambda_2,lambda_3)hat{W}_{2233}+
       F_2(lambda_2,lambda_1,lambda_3)hat{W}_{1133}+
       F_2(lambda_3,lambda_2,lambda_1)hat{W}_{1122}

where <span class="math notranslate nohighlight">\(\hat{W}_{ijkl}\)</span> are the components of the <span class="math notranslate nohighlight">\(W\)</span> tensor in the
coordinates system defined by the eigenvectors of the diffusion tensor
<span class="math notranslate nohighlight">\(\mathbf{D}\)</span> and

.. math::

    F_1(lambda_1,lambda_2,lambda_3)=
    frac{(lambda_1+lambda_2+lambda_3)^2}
    {18(lambda_1-lambda_2)(lambda_1-lambda_3)}
    [frac{sqrt{lambda_2lambda_3}}{lambda_1}
    R_F(frac{lambda_1}{lambda_2},frac{lambda_1}{lambda_3},1)+\
    frac{3lambda_1^2-lambda_1lambda_2-lambda_2lambda_3-
    lambda_1lambda_3}
    {3lambda_1 sqrt{lambda_2 lambda_3}}
    R_D(frac{lambda_1}{lambda_2},frac{lambda_1}{lambda_3},1)-1 ]

    F_2(lambda_1,lambda_2,lambda_3)=
    frac{(lambda_1+lambda_2+lambda_3)^2}
    {3(lambda_2-lambda_3)^2}
    [frac{lambda_2+lambda_3}{sqrt{lambda_2lambda_3}}
    R_F(frac{lambda_1}{lambda_2},frac{lambda_1}{lambda_3},1)+\
    frac{2lambda_1-lambda_2-lambda_3}{3sqrt{lambda_2 lambda_3}}
    R_D(frac{lambda_1}{lambda_2},frac{lambda_1}{lambda_3},1)-2]

where <span class="math notranslate nohighlight">\(R_f\)</span> and <span class="math notranslate nohighlight">\(R_d\)</span> are the Carlson’s elliptic integrals.

References
———-
.. [1] Jensen, J.H., Helpern, J.A., 2010. MRI quantification of
       non-Gaussian water diffusion by kurtosis analysis. NMR in
       Biomedicine 23(7): 698-710
.. [2] Hardin, R.H., Sloane, N.J.A., 1996. McLaren’s Improved Snub Cube
       and Other New Spherical Designs in Three Dimensions. Discrete
       and Computational Geometry 15, 429-441.
.. [3] Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
       Estimation of tensors and tensor-derived measures in diffusional
       kurtosis imaging. Magn Reson Med. 65(3), 823-836
.. [4] Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
       Robust estimation from DW-MRI using homogeneous polynomials.
       Proceedings of the 8th {IEEE} International Symposium on
       Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
       doi: 10.1109/ISBI.2011.5872402</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.mkt">
<span class="sig-name descname"><span class="pre">mkt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.mkt" title="Permalink to this definition">#</a></dt>
<dd><p>Compute mean of the kurtosis tensor (MKT) <a href="#id1429"><span class="problematic" id="id209">[1]_</span></a></p>
<section id="id210">
<h4>Parameters<a class="headerlink" href="#id210" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>min_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores <a href="#id1430"><span class="problematic" id="id211">[2]_</span></a>)</p>
</dd>
<dt>max_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</section>
<section id="id212">
<h4>Returns<a class="headerlink" href="#id212" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>mkt<span class="classifier">array</span></dt><dd><p>Calculated mean kurtosis tensor.</p>
</dd>
</dl>
</section>
<section id="id213">
<h4>Notes<a class="headerlink" href="#id213" title="Permalink to this heading">#</a></h4>
<p>The MKT is defined as <a href="#id1431"><span class="problematic" id="id214">[1]_</span></a>:</p>
<div class="math notranslate nohighlight">
\[MKT \equiv \frac{1}{4\pi} \int d
\Omega_{\mathnbf{n}} n_i n_j n_k n_l W_{ijkl}\]</div>
<p>which can be directly computed from the trace of the kurtosis tensor:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>MKT = frac{1}{5} Tr(mathbf{W}) = frac{1}{5}
(W_{1111} + W_{2222} + W_{3333} + 2W_{1122} + 2W_{1133} + 2W_{2233})</p>
</section>
<section id="id215">
<h4>References<a class="headerlink" href="#id215" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id216" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Hansen, B., Lund, T. E., Sangill, R., and Jespersen, S. N. 2013.
Experimentally and computationally fast method for estimation
of a mean kurtosis. Magnetic Resonance in Medicine69, 1754–1760.
388. doi:10.1002/mrm.24743</p>
</aside>
<aside class="footnote brackets" id="id217" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Given a DKI model fit, predict the signal on the vertices of a
gradient table

Parameters
———-
gtab : a GradientTable class instance
    The gradient table for this prediction

S0 : float or ndarray (optional)
    The non diffusion-weighted signal in every voxel, or across all
    voxels. Default: 1

Notes
—–
The predicted signal is given by:

.. math::

    S(n,b)=S_{0}e^{-bD(n)+frac{1}{6}b^{2}D(n)^{2}K(n)}

<span class="math notranslate nohighlight">\(\mathbf{D(n)}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{K(n)}\)</span> can be computed from the DT and KT
using the following equations:

.. math::

    D(n)=sum_{i=1}^{3}sum_{j=1}^{3}n_{i}n_{j}D_{ij}

and

.. math::

    K(n)=frac{MD^{2}}{D(n)^{2}}sum_{i=1}^{3}sum_{j=1}^{3}
    sum_{k=1}^{3}sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}

where <span class="math notranslate nohighlight">\(D_{ij}\)</span> and <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the second-order DT
and the fourth-order KT tensors, respectively, and <span class="math notranslate nohighlight">\(MD\)</span> is the mean
diffusivity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki.DiffusionKurtosisFit.rk">
<span class="sig-name descname"><span class="pre">rk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.rk" title="Permalink to this definition">#</a></dt>
<dd><p>Compute radial kurtosis (RK) of a diffusion kurtosis tensor <a href="#id1432"><span class="problematic" id="id218">[1]_</span></a></p>
<section id="id219">
<h4>Parameters<a class="headerlink" href="#id219" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>min_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,
radial kurtosis values that are smaller than <cite>min_kurtosis</cite> are
replaced with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis
limit for regions that consist of water confined to spherical pores
<a href="#id1433"><span class="problematic" id="id220">[3]_</span></a>)</p>
</dd>
<dt>max_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,
radial kurtosis values that are larger than <cite>max_kurtosis</cite> are
replaced with <cite>max_kurtosis</cite>. Default = 10</p>
</dd>
<dt>analytical<span class="classifier">bool (optional)</span></dt><dd><p>If True, RK is calculated using its analytical solution, otherwise
an exact numerical estimator is used (see Notes). Default is set to
True</p>
</dd>
</dl>
</section>
<section id="id221">
<h4>Returns<a class="headerlink" href="#id221" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>rk<span class="classifier">array</span></dt><dd><p>Calculated RK.</p>
</dd>
</dl>
</section>
<section id="id222">
<h4>Notes<a class="headerlink" href="#id222" title="Permalink to this heading">#</a></h4>
<p>RK is defined as the average of the directional kurtosis perpendicular
to the fiber’s main direction e1 <a href="#id1434"><span class="problematic" id="id223">[1]_</span></a>, <a href="#id1435"><span class="problematic" id="id224">[2]_</span></a>:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<dl class="simple">
<dt>RK equiv frac{1}{2pi} int dOmega _mathbf{theta}</dt><dd><p>K(mathbf{theta}) delta (mathbf{theta}cdot mathbf{e}_1)</p>
</dd>
</dl>
<p>This equation can be numerically computed by averaging apparent
directional kurtosis samples for directions perpendicular to e1.</p>
<p>Otherwise, RK can be calculated from its analytical solution <a href="#id1436"><span class="problematic" id="id225">[2]_</span></a>:</p>
<div class="math notranslate nohighlight">
\[K_{\bot} = G_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2222} +
           G_1(\lambda_1,\lambda_3,\lambda_2)\hat{W}_{3333} +
           G_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[G_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{18\lambda_2(\lambda_2-
\lambda_3)} \left (2\lambda_2 +
\frac{\lambda_3^2-3\lambda_2\lambda_3}{\sqrt{\lambda_2\lambda_3}}
\right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[ G_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{(\lambda_2-\lambda_3)^2}
\left ( \frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}-
2\right )\]</div>
</section>
<section id="id226">
<h4>References<a class="headerlink" href="#id226" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id227" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of
non-Gaussian water diffusion by kurtosis analysis. NMR in
Biomedicine 23(7): 698-710</p>
</aside>
<aside class="footnote brackets" id="id228" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</p>
</aside>
<aside class="footnote brackets" id="id229" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</p>
</aside>
</aside>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="carlson-rf">
<h3>carlson_rf<a class="headerlink" href="#carlson-rf" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.carlson_rf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">carlson_rf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0003</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.carlson_rf" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Carlson’s incomplete elliptic integral of the first kind</p>
<p>Carlson’s incomplete elliptic integral of the first kind is defined as:</p>
<div class="math notranslate nohighlight">
\[R_F = \frac{1}{2} \int_{0}^{\infty} \left [(t+x)(t+y)(t+z)  \right ]
^{-\frac{1}{2}}dt\]</div>
<section id="id230">
<h4>Parameters<a class="headerlink" href="#id230" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>x<span class="classifier">ndarray</span></dt><dd><p>First independent variable of the integral.</p>
</dd>
<dt>y<span class="classifier">ndarray</span></dt><dd><p>Second independent variable of the integral.</p>
</dd>
<dt>z<span class="classifier">ndarray</span></dt><dd><p>Third independent variable of the integral.</p>
</dd>
<dt>errtol<span class="classifier">float</span></dt><dd><p>Error tolerance. Integral is computed with relative error less in
magnitude than the defined value</p>
</dd>
</dl>
</section>
<section id="id231">
<h4>Returns<a class="headerlink" href="#id231" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>RF<span class="classifier">ndarray</span></dt><dd><p>Value of the incomplete first order elliptic integral</p>
</dd>
</dl>
</section>
<section id="id232">
<h4>Notes<a class="headerlink" href="#id232" title="Permalink to this heading">#</a></h4>
<p>x, y, and z have to be nonnegative and at most one of them is zero.</p>
</section>
<section id="id233">
<h4>References<a class="headerlink" href="#id233" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id234" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Carlson, B.C., 1994. Numerical computation of real or complex
elliptic integrals. arXiv:math/9409227 [math.CA]</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="carlson-rd">
<h3>carlson_rd<a class="headerlink" href="#carlson-rd" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.carlson_rd">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">carlson_rd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.carlson_rd" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Carlson’s incomplete elliptic integral of the second kind</p>
<p>Carlson’s incomplete elliptic integral of the second kind is defined as:</p>
<div class="math notranslate nohighlight">
\[R_D = \frac{3}{2} \int_{0}^{\infty} (t+x)^{-\frac{1}{2}}
(t+y)^{-\frac{1}{2}}(t+z)  ^{-\frac{3}{2}}\]</div>
<section id="id235">
<h4>Parameters<a class="headerlink" href="#id235" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>x<span class="classifier">ndarray</span></dt><dd><p>First independent variable of the integral.</p>
</dd>
<dt>y<span class="classifier">ndarray</span></dt><dd><p>Second independent variable of the integral.</p>
</dd>
<dt>z<span class="classifier">ndarray</span></dt><dd><p>Third independent variable of the integral.</p>
</dd>
<dt>errtol<span class="classifier">float</span></dt><dd><p>Error tolerance. Integral is computed with relative error less in
magnitude than the defined value</p>
</dd>
</dl>
</section>
<section id="id236">
<h4>Returns<a class="headerlink" href="#id236" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>RD<span class="classifier">ndarray</span></dt><dd><p>Value of the incomplete second order elliptic integral</p>
</dd>
</dl>
</section>
<section id="id237">
<h4>Notes<a class="headerlink" href="#id237" title="Permalink to this heading">#</a></h4>
<p>x, y, and z have to be nonnegative and at most x or y is zero.</p>
</section>
</dd></dl>

</section>
<section id="directional-diffusion">
<h3>directional_diffusion<a class="headerlink" href="#directional-diffusion" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.directional_diffusion">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">directional_diffusion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.directional_diffusion" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the apparent diffusion coefficient (adc) in each direction of
a sphere for a single voxel <a href="#id1437"><span class="problematic" id="id238">[1]_</span></a></p>
<section id="id239">
<h4>Parameters<a class="headerlink" href="#id239" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>dt<span class="classifier">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>
</dd>
<dt>V<span class="classifier">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt>min_diffusivity<span class="classifier">float (optional)</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>. Default = 0</p>
</dd>
</dl>
</section>
<section id="id240">
<h4>Returns<a class="headerlink" href="#id240" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>adc<span class="classifier">ndarray (g,)</span></dt><dd><p>Apparent diffusion coefficient (adc) in all g directions of a sphere
for a single voxel.</p>
</dd>
</dl>
</section>
<section id="id241">
<h4>References<a class="headerlink" href="#id241" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id242" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
Exploring the 3D geometry of the diffusion kurtosis tensor -
Impact on the development of robust tractography procedures and
novel biomarkers, NeuroImage 111: 85-99</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="directional-diffusion-variance">
<h3>directional_diffusion_variance<a class="headerlink" href="#directional-diffusion-variance" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.directional_diffusion_variance">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">directional_diffusion_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.directional_diffusion_variance" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the apparent diffusion variance (adv) in each direction of a
sphere for a single voxel <a href="#id1438"><span class="problematic" id="id243">[1]_</span></a></p>
<section id="id244">
<h4>Parameters<a class="headerlink" href="#id244" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>dt<span class="classifier">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>
</dd>
<dt>kt<span class="classifier">array (15,)</span></dt><dd><p>elements of the kurtosis tensor of the voxel.</p>
</dd>
<dt>V<span class="classifier">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt>min_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>Because high-amplitude negative values of kurtosis are not physically
and biologicaly pluasible, and these cause artefacts in
kurtosis-based measures, directional kurtosis values smaller than
<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7
(theoretical kurtosis limit for regions that consist of water confined
to spherical pores <a href="#id1439"><span class="problematic" id="id245">[2]_</span></a>)</p>
</dd>
<dt>adc<span class="classifier">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion coefficient (adc) in all g directions of a sphere
for a single voxel.</p>
</dd>
<dt>adv<span class="classifier">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion variance coefficient (advc) in all g directions of
a sphere for a single voxel.</p>
</dd>
</dl>
</section>
<section id="id246">
<h4>Returns<a class="headerlink" href="#id246" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>adv<span class="classifier">ndarray (g,)</span></dt><dd><p>Apparent diffusion variance (adv) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</section>
<section id="id247">
<h4>References<a class="headerlink" href="#id247" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id248" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
Exploring the 3D geometry of the diffusion kurtosis tensor -
Impact on the development of robust tractography procedures and
novel biomarkers, NeuroImage 111: 85-99</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="directional-kurtosis">
<h3>directional_kurtosis<a class="headerlink" href="#directional-kurtosis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.directional_kurtosis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">directional_kurtosis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">md</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.directional_kurtosis" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the apparent kurtosis coefficient (akc) in each direction of
a sphere for a single voxel <a href="#id1440"><span class="problematic" id="id249">[1]_</span></a></p>
<section id="id250">
<h4>Parameters<a class="headerlink" href="#id250" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>dt<span class="classifier">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>
</dd>
<dt>md<span class="classifier">float</span></dt><dd><p>mean diffusivity of the voxel</p>
</dd>
<dt>kt<span class="classifier">array (15,)</span></dt><dd><p>elements of the kurtosis tensor of the voxel.</p>
</dd>
<dt>V<span class="classifier">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt>min_diffusivity<span class="classifier">float (optional)</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>. Default = 0</p>
</dd>
<dt>min_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>Because high-amplitude negative values of kurtosis are not physically
and biologicaly pluasible, and these cause artefacts in
kurtosis-based measures, directional kurtosis values smaller than
<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7
(theoretical kurtosis limit for regions that consist of water confined
to spherical pores <a href="#id1441"><span class="problematic" id="id251">[2]_</span></a>)</p>
</dd>
<dt>adc<span class="classifier">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion coefficient (adc) in all g directions of a sphere
for a single voxel.</p>
</dd>
<dt>adv<span class="classifier">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion variance (advc) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</section>
<section id="id252">
<h4>Returns<a class="headerlink" href="#id252" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>akc<span class="classifier">ndarray (g,)</span></dt><dd><p>Apparent kurtosis coefficient (AKC) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</section>
<section id="id253">
<h4>References<a class="headerlink" href="#id253" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id254" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
Exploring the 3D geometry of the diffusion kurtosis tensor -
Impact on the development of robust tractography procedures and
novel biomarkers, NeuroImage 111: 85-99</p>
</aside>
<aside class="footnote brackets" id="id255" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="apparent-kurtosis-coef">
<h3>apparent_kurtosis_coef<a class="headerlink" href="#apparent-kurtosis-coef" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.apparent_kurtosis_coef">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">apparent_kurtosis_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.apparent_kurtosis_coef" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the apparent kurtosis coefficient (AKC) in each direction
of a sphere <a href="#id1442"><span class="problematic" id="id256">[1]_</span></a>

Parameters
———-
dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:
    1) Three diffusion tensor’s eigenvalues
    2) Three lines of the eigenvector matrix each containing the first,
        second and third coordinates of the eigenvectors respectively
    3) Fifteen elements of the kurtosis tensor
sphere : a Sphere class instance
    The AKC will be calculated for each of the vertices in the sphere
min_diffusivity : float (optional)
    Because negative eigenvalues are not physical and small eigenvalues
    cause quite a lot of noise in diffusion-based metrics, diffusivity
    values smaller than <cite>min_diffusivity</cite> are replaced with
    <cite>min_diffusivity</cite>. Default = 0
min_kurtosis : float (optional)
    Because high-amplitude negative values of kurtosis are not physically
    and biologicaly pluasible, and these cause artefacts in
    kurtosis-based measures, directional kurtosis values smaller than
    <cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7
    (theoretical kurtosis limit for regions that consist of water confined
    to spherical pores <a href="#id1443"><span class="problematic" id="id257">[2]_</span></a>)

Returns
——-
akc : ndarray (x, y, z, g) or (n, g)
    Apparent kurtosis coefficient (AKC) for all g directions of a sphere.

Notes
—–
For each sphere direction with coordinates <span class="math notranslate nohighlight">\((n_{1}, n_{2}, n_{3})\)</span>, the
calculation of AKC is done using formula <a href="#id1444"><span class="problematic" id="id258">[1]_</span></a>:

.. math ::

    AKC(n)=frac{MD^{2}}{ADC(n)^{2}}sum_{i=1}^{3}sum_{j=1}^{3}
    sum_{k=1}^{3}sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}

where <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the kurtosis tensor, MD the mean
diffusivity and ADC the apparent diffusion coefficient computed as:

.. math ::

    ADC(n)=sum_{i=1}^{3}sum_{j=1}^{3}n_{i}n_{j}D_{ij}

where <span class="math notranslate nohighlight">\(D_{ij}\)</span> are the elements of the diffusion tensor.

References
———-
.. [1] Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
       Exploring the 3D geometry of the diffusion kurtosis tensor -
       Impact on the development of robust tractography procedures and
       novel biomarkers, NeuroImage 111: 85-99
.. [2] Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
       Robust estimation from DW-MRI using homogeneous polynomials.
       Proceedings of the 8th {IEEE} International Symposium on
       Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
       doi: 10.1109/ISBI.2011.5872402</p>
</dd></dl>

</section>
<section id="mean-kurtosis">
<h3>mean_kurtosis<a class="headerlink" href="#mean-kurtosis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.mean_kurtosis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">mean_kurtosis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.mean_kurtosis" title="Permalink to this definition">#</a></dt>
<dd><p>Compute mean kurtosis (MK) from the kurtosis tensor

Parameters
———-
dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:
    1) Three diffusion tensor’s eigenvalues
    2) Three lines of the eigenvector matrix each containing the first,
        second and third coordinates of the eigenvector
    3) Fifteen elements of the kurtosis tensor
min_kurtosis : float (optional)
    To keep kurtosis values within a plausible biophysical range, mean
    kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
    <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
    that consist of water confined to spherical pores <a href="#id1445"><span class="problematic" id="id259">[4]_</span></a>)
max_kurtosis : float (optional)
    To keep kurtosis values within a plausible biophysical range, mean
    kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
    <cite>max_kurtosis</cite>. Default = 10
analytical : bool (optional)
    If True, MK is calculated using its analytical solution, otherwise an
    exact numerical estimator is used (see Notes). Default is set to True

Returns
——-
mk : array
    Calculated MK.

Notes
—–
The MK is defined as the average of directional kurtosis coefficients
across all spatial directions, which can be formulated by the following
surface integral[1]_:

.. math::

     MK equiv frac{1}{4pi} int dOmega_mathbf{n} K(mathbf{n})

This integral can be numerically solved by averaging directional
kurtosis values sampled for directions of a spherical t-design <a href="#id1446"><span class="problematic" id="id260">[2]_</span></a>.

Alternatively, MK can be solved from the analytical solution derived by
Tabesh et al. <a href="#id1447"><span class="problematic" id="id261">[3]_</span></a>. This solution is given by:

.. math::

    MK=F_1(lambda_1,lambda_2,lambda_3)hat{W}_{1111}+
       F_1(lambda_2,lambda_1,lambda_3)hat{W}_{2222}+
       F_1(lambda_3,lambda_2,lambda_1)hat{W}_{3333}+ \
       F_2(lambda_1,lambda_2,lambda_3)hat{W}_{2233}+
       F_2(lambda_2,lambda_1,lambda_3)hat{W}_{1133}+
       F_2(lambda_3,lambda_2,lambda_1)hat{W}_{1122}

where <span class="math notranslate nohighlight">\(\hat{W}_{ijkl}\)</span> are the components of the <span class="math notranslate nohighlight">\(W\)</span> tensor in the
coordinates system defined by the eigenvectors of the diffusion tensor
<span class="math notranslate nohighlight">\(\mathbf{D}\)</span> and

.. math::

    F_1(lambda_1,lambda_2,lambda_3)=
    frac{(lambda_1+lambda_2+lambda_3)^2}
    {18(lambda_1-lambda_2)(lambda_1-lambda_3)}
    [frac{sqrt{lambda_2lambda_3}}{lambda_1}
    R_F(frac{lambda_1}{lambda_2},frac{lambda_1}{lambda_3},1)+\
    frac{3lambda_1^2-lambda_1lambda_2-lambda_2lambda_3-
    lambda_1lambda_3}
    {3lambda_1 sqrt{lambda_2 lambda_3}}
    R_D(frac{lambda_1}{lambda_2},frac{lambda_1}{lambda_3},1)-1 ]

    F_2(lambda_1,lambda_2,lambda_3)=
    frac{(lambda_1+lambda_2+lambda_3)^2}
    {3(lambda_2-lambda_3)^2}
    [frac{lambda_2+lambda_3}{sqrt{lambda_2lambda_3}}
    R_F(frac{lambda_1}{lambda_2},frac{lambda_1}{lambda_3},1)+\
    frac{2lambda_1-lambda_2-lambda_3}{3sqrt{lambda_2 lambda_3}}
    R_D(frac{lambda_1}{lambda_2},frac{lambda_1}{lambda_3},1)-2]

where <span class="math notranslate nohighlight">\(R_f\)</span> and <span class="math notranslate nohighlight">\(R_d\)</span> are the Carlson’s elliptic integrals.

References
———-
.. [1] Jensen, J.H., Helpern, J.A., 2010. MRI quantification of
       non-Gaussian water diffusion by kurtosis analysis. NMR in
       Biomedicine 23(7): 698-710
.. [2] Hardin, R.H., Sloane, N.J.A., 1996. McLaren’s Improved Snub Cube and
       Other New Spherical Designs in Three Dimensions. Discrete and
       Computational Geometry 15, 429-441.
.. [3] Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
       Estimation of tensors and tensor-derived measures in diffusional
       kurtosis imaging. Magn Reson Med. 65(3), 823-836
.. [4] Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
       Robust estimation from DW-MRI using homogeneous polynomials.
       Proceedings of the 8th {IEEE} International Symposium on
       Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
       doi: 10.1109/ISBI.2011.5872402</p>
</dd></dl>

</section>
<section id="radial-kurtosis">
<h3>radial_kurtosis<a class="headerlink" href="#radial-kurtosis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.radial_kurtosis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">radial_kurtosis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.radial_kurtosis" title="Permalink to this definition">#</a></dt>
<dd><p>Compute radial kurtosis (RK) of a diffusion kurtosis tensor <a href="#id1448"><span class="problematic" id="id262">[1]_</span></a>, <a href="#id1449"><span class="problematic" id="id263">[2]_</span></a></p>
<section id="id264">
<h4>Parameters<a class="headerlink" href="#id264" title="Permalink to this heading">#</a></h4>
<p>dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><dl class="simple">
<dt>Three lines of the eigenvector matrix each containing the first,</dt><dd><p>second and third coordinates of the eigenvector</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
<dl class="simple">
<dt>min_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, radial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores <a href="#id1450"><span class="problematic" id="id265">[3]_</span></a>)</p>
</dd>
<dt>max_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, radial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>. Default = 10</p>
</dd>
<dt>analytical<span class="classifier">bool (optional)</span></dt><dd><p>If True, RK is calculated using its analytical solution, otherwise an
exact numerical estimator is used (see Notes). Default is set to True.</p>
</dd>
</dl>
</section>
<section id="id266">
<h4>Returns<a class="headerlink" href="#id266" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>rk<span class="classifier">array</span></dt><dd><p>Calculated RK.</p>
</dd>
</dl>
</section>
<section id="id267">
<h4>Notes<a class="headerlink" href="#id267" title="Permalink to this heading">#</a></h4>
<p>RK is defined as the average of the directional kurtosis perpendicular
to the fiber’s main direction e1 <a href="#id1451"><span class="problematic" id="id268">[1]_</span></a>, <a href="#id1452"><span class="problematic" id="id269">[2]_</span></a>:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<dl class="simple">
<dt>RK equiv frac{1}{2pi} int dOmega _mathbf{theta} K(mathbf{theta})</dt><dd><p>delta (mathbf{theta}cdot mathbf{e}_1)</p>
</dd>
</dl>
<p>This equation can be numerically computed by averaging apparent
directional kurtosis samples for directions perpendicular to e1.</p>
<p>Otherwise, RK can be calculated from its analytical solution <a href="#id1453"><span class="problematic" id="id270">[2]_</span></a>:</p>
<div class="math notranslate nohighlight">
\[K_{\bot} = G_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2222} +
           G_1(\lambda_1,\lambda_3,\lambda_2)\hat{W}_{3333} +
           G_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[G_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{18\lambda_2(\lambda_2-
\lambda_3)} \left (2\lambda_2 +
\frac{\lambda_3^2-3\lambda_2\lambda_3}{\sqrt{\lambda_2\lambda_3}}
\right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[G_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{(\lambda_2-\lambda_3)^2}
\left ( \frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}-2\right )\]</div>
</section>
<section id="id271">
<h4>References<a class="headerlink" href="#id271" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id272" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of
non-Gaussian water diffusion by kurtosis analysis. NMR in
Biomedicine 23(7): 698-710</p>
</aside>
<aside class="footnote brackets" id="id273" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</p>
</aside>
<aside class="footnote brackets" id="id274" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on Biomedical
Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="axial-kurtosis">
<h3>axial_kurtosis<a class="headerlink" href="#axial-kurtosis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.axial_kurtosis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">axial_kurtosis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.axial_kurtosis" title="Permalink to this definition">#</a></dt>
<dd><p>Compute axial kurtosis (AK) from the kurtosis tensor <a href="#id1454"><span class="problematic" id="id275">[1]_</span></a>, <a href="#id1455"><span class="problematic" id="id276">[2]_</span></a></p>
<section id="id277">
<h4>Parameters<a class="headerlink" href="#id277" title="Permalink to this heading">#</a></h4>
<p>dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><dl class="simple">
<dt>Three lines of the eigenvector matrix each containing the first,</dt><dd><p>second and third coordinates of the eigenvector</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
<dl class="simple">
<dt>min_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores <a href="#id1456"><span class="problematic" id="id278">[3]_</span></a>)</p>
</dd>
<dt>max_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>. Default = 10</p>
</dd>
<dt>analytical<span class="classifier">bool (optional)</span></dt><dd><p>If True, AK is calculated from rotated diffusion kurtosis tensor,
otherwise it will be computed from the apparent diffusion kurtosis
values along the principal axis of the diffusion tensor (see notes).
Default is set to True.</p>
</dd>
</dl>
</section>
<section id="id279">
<h4>Returns<a class="headerlink" href="#id279" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ak<span class="classifier">array</span></dt><dd><p>Calculated AK.</p>
</dd>
</dl>
</section>
<section id="id280">
<h4>Notes<a class="headerlink" href="#id280" title="Permalink to this heading">#</a></h4>
<p>AK is defined as the directional kurtosis parallel to the fiber’s main
direction e1 <a href="#id1457"><span class="problematic" id="id281">[1]_</span></a>, <a href="#id1458"><span class="problematic" id="id282">[2]_</span></a>. You can compute AK using to approaches:</p>
<ol class="arabic simple">
<li><p>AK is calculated from rotated diffusion kurtosis tensor <a href="#id1459"><span class="problematic" id="id283">[2]_</span></a>, i.e.:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[AK = \hat{W}_{1111}
    \frac{(\lambda_{1}+\lambda_{2}+\lambda_{3})^2}{(9 \lambda_{1}^2)}\]</div>
<ol class="arabic simple" start="2">
<li><p>AK can be sampled from the principal axis of the diffusion tensor:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[AK = K(\mathbf{\mathbf{e}_1)\]</div>
<p>Although both approaches leads to an exact calculation of AK, the first
approach will be referred to as the analytical method while the second
approach will be referred to as the numerical method based on their analogy
to the estimation strategies for MK and RK.</p>
</section>
<section id="id284">
<h4>References<a class="headerlink" href="#id284" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id285" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of
non-Gaussian water diffusion by kurtosis analysis. NMR in
Biomedicine 23(7): 698-710</p>
</aside>
<aside class="footnote brackets" id="id286" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</p>
</aside>
<aside class="footnote brackets" id="id287" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="kurtosis-maximum">
<h3>kurtosis_maximum<a class="headerlink" href="#kurtosis-maximum" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.kurtosis_maximum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">kurtosis_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.kurtosis_maximum" title="Permalink to this definition">#</a></dt>
<dd><p>Compute kurtosis maximum value</p>
<section id="id288">
<h4>Parameters<a class="headerlink" href="#id288" title="Permalink to this heading">#</a></h4>
<p>dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eingenvalues</p></li>
<li><dl class="simple">
<dt>Three lines of the eigenvector matrix each containing the first,</dt><dd><p>second and third coordinates of the eigenvector</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of the
maximal value of kurtosis.</p>
</dd>
<dt>gtol<span class="classifier">float, optional</span></dt><dd><p>This input is to refine kurtosis maximum under the precision of the
directions sampled on the sphere class instance. The gradient of the
convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken from
the initial sampled directions of the given sphere object</p>
</dd>
<dt>mask<span class="classifier">ndarray</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</section>
<section id="id289">
<h4>Returns<a class="headerlink" href="#id289" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>max_value<span class="classifier">float</span></dt><dd><p>kurtosis tensor maximum value</p>
</dd>
<dt>max_dir<span class="classifier">array (3,)</span></dt><dd><p>Cartesian coordinates of the direction of the maximal kurtosis value</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="mean-kurtosis-tensor">
<h3>mean_kurtosis_tensor<a class="headerlink" href="#mean-kurtosis-tensor" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.mean_kurtosis_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">mean_kurtosis_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.42857142857142855</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_kurtosis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.mean_kurtosis_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Compute mean of the kurtosis tensor (MKT) <a href="#id1460"><span class="problematic" id="id290">[1]_</span></a></p>
<section id="id291">
<h4>Parameters<a class="headerlink" href="#id291" title="Permalink to this heading">#</a></h4>
<p>dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><dl class="simple">
<dt>Three lines of the eigenvector matrix each containing the first,</dt><dd><p>second and third coordinates of the eigenvector</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
<dl class="simple">
<dt>min_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores <a href="#id1461"><span class="problematic" id="id292">[2]_</span></a>)</p>
</dd>
<dt>max_kurtosis<span class="classifier">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</section>
<section id="id293">
<h4>Returns<a class="headerlink" href="#id293" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>mkt<span class="classifier">array</span></dt><dd><p>Calculated mean kurtosis tensor.</p>
</dd>
</dl>
</section>
<section id="id294">
<h4>Notes<a class="headerlink" href="#id294" title="Permalink to this heading">#</a></h4>
<p>The MKT is defined as <a href="#id1462"><span class="problematic" id="id295">[1]_</span></a>:</p>
<div class="math notranslate nohighlight">
\[MKT \equiv \frac{1}{4\pi} \int d
\Omega_{\mathnbf{n}} n_i n_j n_k n_l W_{ijkl}\]</div>
<p>which can be directly computed from the trace of the kurtosis tensor:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>MKT = frac{1}{5} Tr(mathbf{W}) = frac{1}{5}
(W_{1111} + W_{2222} + W_{3333} + 2W_{1122} + 2W_{1133} + 2W_{2233})</p>
</section>
<section id="id296">
<h4>References<a class="headerlink" href="#id296" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id297" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Hansen, B., Lund, T. E., Sangill, R., and Jespersen, S. N. (2013).
Experimentally and computationally fast method for estimation of
a mean kurtosis.Magnetic Resonance in Medicine69,  1754–1760.388
doi:10.1002/mrm.24743</p>
</aside>
<aside class="footnote brackets" id="id298" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="kurtosis-fractional-anisotropy">
<h3>kurtosis_fractional_anisotropy<a class="headerlink" href="#kurtosis-fractional-anisotropy" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.kurtosis_fractional_anisotropy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">kurtosis_fractional_anisotropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.kurtosis_fractional_anisotropy" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the anisotropy of the kurtosis tensor (KFA) <a href="#id1463"><span class="problematic" id="id299">[1]_</span></a>

Parameters
———-
dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:
    1) Three diffusion tensor’s eigenvalues
    2) Three lines of the eigenvector matrix each containing the first,
        second and third coordinates of the eigenvector
    3) Fifteen elements of the kurtosis tensor
Returns
——-
kfa : array
    Calculated mean kurtosis tensor.

Notes
—–
The KFA is defined as <a href="#id1464"><span class="problematic" id="id300">[1]_</span></a>:

.. math::

     KFA equiv
     frac{||mathbf{W} - MKT mathbf{I}^{(4)}||_F}{||mathbf{W}||_F}

where <span class="math notranslate nohighlight">\(W\)</span> is the kurtosis tensor, MKT the kurtosis tensor mean, <span class="math notranslate nohighlight">\(I^(4)\)</span> is
the fully symmetric rank 2 isotropic tensor and <span class="math notranslate nohighlight">\(||...||_F\)</span> is the tensor’s
Frobenius norm <a href="#id1465"><span class="problematic" id="id301">[1]_</span></a>.

References
———-
.. [1] Glenn, G. R., Helpern, J. A., Tabesh, A., and Jensen, J. H. (2015).
       Quantitative assessment of diffusional kurtosis anisotropy.
       NMR in Biomedicine 28, 448–459. doi:10.1002/nbm.3271</p>
</dd></dl>

</section>
<section id="dki-prediction">
<h3>dki_prediction<a class="headerlink" href="#dki-prediction" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.dki_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">dki_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.dki_prediction" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal given diffusion kurtosis imaging parameters</p>
<blockquote>
<div><p>dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><dl class="simple">
<dt>Three lines of the eigenvector matrix each containing the first,</dt><dd><p>second and third coordinates of the eigenvector</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
<dl class="simple">
<dt>gtab<span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt>S0<span class="classifier">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
<dl class="simple">
<dt>S<span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated signal based on the DKI model:</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[S=S_{0}e^{-bD+\]</div>
</div></blockquote>
<p>rac{1}{6}b^{2}D^{2}K}</p>
</dd></dl>

</section>
<section id="params-to-dki-params">
<h3>params_to_dki_params<a class="headerlink" href="#params-to-dki-params" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.params_to_dki_params">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">params_to_dki_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.params_to_dki_params" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="ls-fit-dki">
<h3>ls_fit_dki<a class="headerlink" href="#ls-fit-dki" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.ls_fit_dki">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">ls_fit_dki</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.ls_fit_dki" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the diffusion and kurtosis tensors using an ordinary or
weighted linear least squares approach <a href="#id1466"><span class="problematic" id="id302">[1]_</span></a></p>
<section id="id303">
<h4>Parameters<a class="headerlink" href="#id303" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (g, 22)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt>data<span class="classifier">array (g)</span></dt><dd><p>Data or response variables holding the data.</p>
</dd>
<dt>inverse_design_matrix<span class="classifier">array (22, g)</span></dt><dd><p>Inverse of the design matrix.</p>
</dd>
<dt>weights<span class="classifier">bool, optional</span></dt><dd><p>Parameter indicating whether weights are used. Default: True.</p>
</dd>
<dt>min_diffusivity<span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than <cite>min_diffusivity</cite>
are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</section>
<section id="id304">
<h4>Returns<a class="headerlink" href="#id304" title="Permalink to this heading">#</a></h4>
<p>dki_params : array (27)
All parameters estimated from the diffusion kurtosis model for all N
voxels. Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor eigenvalues.</p></li>
<li><dl class="simple">
<dt>Three blocks of three elements, containing the first second and</dt><dd><p>third coordinates of the diffusion tensor eigenvectors.</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor.</p></li>
</ol>
</div></blockquote>
</section>
<section id="id305">
<h4>References<a class="headerlink" href="#id305" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>[1] Veraart, J., Sijbers, J., Sunaert, S., Leemans, A., Jeurissen, B.,</dt><dd><p>2013. Weighted linear least squares estimation of diffusion MRI
parameters: Strengths, limitations, and pitfalls. Magn Reson Med 81,
335-346.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="cls-fit-dki">
<h3>cls_fit_dki<a class="headerlink" href="#cls-fit-dki" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.cls_fit_dki">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">cls_fit_dki</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sdp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.cls_fit_dki" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the diffusion and kurtosis tensors using a constrained
ordinary or weighted linear least squares approach <a href="#id1467"><span class="problematic" id="id306">[1]_</span></a></p>
<section id="id307">
<h4>Parameters<a class="headerlink" href="#id307" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (g, 22)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt>data<span class="classifier">array (g)</span></dt><dd><p>Data or response variables holding the data.</p>
</dd>
<dt>inverse_design_matrix<span class="classifier">array (22, g)</span></dt><dd><p>Inverse of the design matrix.</p>
</dd>
<dt>sdp<span class="classifier">PositiveDefiniteLeastSquares instance</span></dt><dd><p>A CVXPY representation of a regularized least squares optimization
problem.</p>
</dd>
<dt>weights<span class="classifier">bool, optional</span></dt><dd><p>Parameter indicating whether weights are used. Default: True.</p>
</dd>
<dt>min_diffusivity<span class="classifier">float, optional</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than <cite>min_diffusivity</cite>
are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
<dt>cvxpy_solver<span class="classifier">str, optional</span></dt><dd><p>cvxpy solver name. Optionally optimize the positivity constraint with a
particular cvxpy solver. See <a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a> for details.
Default: None (cvxpy chooses its own solver).</p>
</dd>
</dl>
</section>
<section id="id308">
<h4>Returns<a class="headerlink" href="#id308" title="Permalink to this heading">#</a></h4>
<p>dki_params : array (27)
All parameters estimated from the diffusion kurtosis model for all N
voxels. Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor eigenvalues.</p></li>
<li><dl class="simple">
<dt>Three blocks of three elements, containing the first second and</dt><dd><p>third coordinates of the diffusion tensor eigenvectors.</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor.</p></li>
</ol>
</div></blockquote>
</section>
<section id="id309">
<h4>References<a class="headerlink" href="#id309" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id310" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Dela Haije et al. “Enforcing necessary non-negativity constraints for
common diffusion MRI models using sum of squares programming”.
NeuroImage 209, 2020, 116405.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="wrotate">
<h3>Wrotate<a class="headerlink" href="#wrotate" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.Wrotate">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">Wrotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.Wrotate" title="Permalink to this definition">#</a></dt>
<dd><p>Rotate a kurtosis tensor from the standard Cartesian coordinate system
to another coordinate system basis</p>
<section id="id311">
<h4>Parameters<a class="headerlink" href="#id311" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>kt<span class="classifier">(15,)</span></dt><dd><p>Vector with the 15 independent elements of the kurtosis tensor</p>
</dd>
<dt>Basis<span class="classifier">array (3, 3)</span></dt><dd><p>Vectors of the basis column-wise oriented</p>
</dd>
<dt>inds<span class="classifier">array(m, 4) (optional)</span></dt><dd><p>Array of vectors containing the four indexes of m specific elements of
the rotated kurtosis tensor. If not specified all 15 elements of the
rotated kurtosis tensor are computed.</p>
</dd>
</dl>
</section>
<section id="id312">
<h4>Returns<a class="headerlink" href="#id312" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>Wrot<span class="classifier">array (m,) or (15,)</span></dt><dd><p>Vector with the m independent elements of the rotated kurtosis tensor.
If ‘indices’ is not specified all 15 elements of the rotated kurtosis
tensor are computed.</p>
</dd>
</dl>
</section>
<section id="id313">
<h4>Notes<a class="headerlink" href="#id313" title="Permalink to this heading">#</a></h4>
<p>KT elements are assumed to be ordered as follows:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<dl class="simple">
<dt>begin{matrix} ( &amp; W_{xxxx} &amp; W_{yyyy} &amp; W_{zzzz} &amp; W_{xxxy} &amp; W_{xxxz}</dt><dd><p>&amp; … \
&amp; W_{xyyy} &amp; W_{yyyz} &amp; W_{xzzz} &amp; W_{yzzz} &amp; W_{xxyy}
&amp; … \
&amp; W_{xxzz} &amp; W_{yyzz} &amp; W_{xxyz} &amp; W_{xyyz} &amp; W_{xyzz}
&amp; &amp; )end{matrix}</p>
</dd>
</dl>
</section>
<section id="id314">
<h4>References<a class="headerlink" href="#id314" title="Permalink to this heading">#</a></h4>
<p>[1] Hui ES, Cheung MM, Qi L, Wu EX, 2008. Towards better MR
characterization of neural tissues using directional diffusion kurtosis
analysis. Neuroimage 42(1): 122-34</p>
</section>
</dd></dl>

</section>
<section id="wrotate-element">
<h3>Wrotate_element<a class="headerlink" href="#wrotate-element" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.Wrotate_element">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">Wrotate_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.Wrotate_element" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the the specified index element of a kurtosis tensor rotated
to the coordinate system basis B</p>
<section id="id315">
<h4>Parameters<a class="headerlink" href="#id315" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>kt<span class="classifier">ndarray (x, y, z, 15) or (n, 15)</span></dt><dd><p>Array containing the 15 independent elements of the kurtosis tensor</p>
</dd>
<dt>indi<span class="classifier">int</span></dt><dd><p>Rotated kurtosis tensor element index i (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt>indj<span class="classifier">int</span></dt><dd><p>Rotated kurtosis tensor element index j (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt>indk<span class="classifier">int</span></dt><dd><p>Rotated kurtosis tensor element index k (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt>indl: int</dt><dd><p>Rotated kurtosis tensor element index l (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt>B: array (x, y, z, 3, 3) or (n, 15)</dt><dd><p>Vectors of the basis column-wise oriented</p>
</dd>
</dl>
</section>
<section id="id316">
<h4>Returns<a class="headerlink" href="#id316" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>Wre<span class="classifier">float</span></dt><dd><p>rotated kurtosis tensor element of index ind_i, ind_j, ind_k, ind_l</p>
</dd>
</dl>
</section>
<section id="id317">
<h4>Notes<a class="headerlink" href="#id317" title="Permalink to this heading">#</a></h4>
<p>It is assumed that initial kurtosis tensor elementes are defined on the
Cartesian coordinate system.</p>
</section>
<section id="id318">
<h4>References<a class="headerlink" href="#id318" title="Permalink to this heading">#</a></h4>
<p>[1] Hui ES, Cheung MM, Qi L, Wu EX, 2008. Towards better MR
characterization of neural tissues using directional diffusion kurtosis
analysis. Neuroimage 42(1): 122-34</p>
</section>
</dd></dl>

</section>
<section id="wcons">
<h3>Wcons<a class="headerlink" href="#wcons" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.Wcons">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">Wcons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.Wcons" title="Permalink to this definition">#</a></dt>
<dd><p>Construct the full 4D kurtosis tensors from its 15 independent
elements</p>
<section id="id319">
<h4>Parameters<a class="headerlink" href="#id319" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>k_elements<span class="classifier">(15,)</span></dt><dd><p>elements of the kurtosis tensor in the following order:</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[\]</div>
<dl class="simple">
<dt>begin{matrix} ( &amp; W_{xxxx} &amp; W_{yyyy} &amp; W_{zzzz} &amp; W_{xxxy} &amp; W_{xxxz}</dt><dd><p>&amp; … \
&amp; W_{xyyy} &amp; W_{yyyz} &amp; W_{xzzz} &amp; W_{yzzz} &amp; W_{xxyy}
&amp; … \
&amp; W_{xxzz} &amp; W_{yyzz} &amp; W_{xxyz} &amp; W_{xyyz} &amp; W_{xyzz}
&amp; &amp; )end{matrix}</p>
</dd>
</dl>
</section>
<section id="id320">
<h4>Returns<a class="headerlink" href="#id320" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>W<span class="classifier">array(3, 3, 3, 3)</span></dt><dd><p>Full 4D kurtosis tensor</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="split-dki-param">
<h3>split_dki_param<a class="headerlink" href="#split-dki-param" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki.split_dki_param">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki.</span></span><span class="sig-name descname"><span class="pre">split_dki_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.split_dki_param" title="Permalink to this definition">#</a></dt>
<dd><p>Extract the diffusion tensor eigenvalues, the diffusion tensor
eigenvector matrix, and the 15 independent elements of the kurtosis tensor
from the model parameters estimated from the DKI model</p>
<section id="id321">
<h4>Parameters<a class="headerlink" href="#id321" title="Permalink to this heading">#</a></h4>
<p>dki_params : ndarray (x, y, z, 27) or (n, 27)
All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><dl class="simple">
<dt>Three lines of the eigenvector matrix each containing the first,</dt><dd><p>second and third coordinates of the eigenvector</p>
</dd>
</dl>
</li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</section>
<section id="id322">
<h4>Returns<a class="headerlink" href="#id322" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>eigvals<span class="classifier">array (x, y, z, 3) or (n, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt>eigvecs<span class="classifier">array (x, y, z, 3, 3) or (n, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
<dt>kt<span class="classifier">array (x, y, z, 15) or (n, 15)</span></dt><dd><p>Fifteen elements of the kurtosis tensor</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="kurtosismicrostructuremodel">
<h3><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a><a class="headerlink" href="#kurtosismicrostructuremodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructureModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">KurtosisMicrostructureModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="dipy.reconst.dki.DiffusionKurtosisModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a></p>
<p>Class for the Diffusion Kurtosis Microstructural Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructureModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a KurtosisMicrostrutureModel class instance <a href="#id1468"><span class="problematic" id="id323">[1]_</span></a>.</p>
<section id="id324">
<h4>Parameters<a class="headerlink" href="#id324" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable class instance</p>
<dl>
<dt>fit_method<span class="classifier">str or callable</span></dt><dd><p>str can be one of the following:
‘OLS’ or ‘ULLS’ to fit the diffusion tensor and kurtosis tensor
using the ordinary linear least squares solution</p>
<blockquote>
<div><p>dki.ols_fit_dki</p>
</div></blockquote>
<p>‘WLS’ or ‘UWLLS’ to fit the diffusion tensor and kurtosis tensor
using the ordinary linear least squares solution</p>
<blockquote>
<div><p>dki.wls_fit_dki</p>
</div></blockquote>
<dl class="simple">
<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href="#id325"><span class="problematic" id="id326">*</span></a>args, <a href="#id327"><span class="problematic" id="id328">**</span></a>kwargs)</p>
</dd>
</dl>
</dd>
<dt>args, kwargs<span class="classifier">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See dki.ols_fit_dki, dki.wls_fit_dki for details</p>
</dd>
</dl>
</section>
<section id="id329">
<h4>References<a class="headerlink" href="#id329" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id330" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">awf_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method of the Diffusion Kurtosis Microstructural Model</p>
<section id="id331">
<h4>Parameters<a class="headerlink" href="#id331" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">array</span></dt><dd><p>An 4D matrix containing the diffusion-weighted data.</p>
</dd>
<dt>mask<span class="classifier">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[-1]</p>
</dd>
<dt>sphere<span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of
the maximal value of kurtosis.</p>
</dd>
<dt>gtol<span class="classifier">float, optional</span></dt><dd><p>This input is to refine kurtosis maxima under the precision of the
directions sampled on the sphere class instance. The gradient of
the convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken
from the initial sampled directions of the given sphere object</p>
</dd>
<dt>awf_only<span class="classifier">bool, optiomal</span></dt><dd><p>If set to true only the axonal volume fraction is computed from
the kurtosis tensor. Default = False</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal for the DKI microstructural model class instance
given parameters.</p>
<section id="id332">
<h4>Parameters<a class="headerlink" href="#id332" title="Permalink to this heading">#</a></h4>
<dl>
<dt>params<span class="classifier">ndarray (x, y, z, 40) or (n, 40)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis
microstructural model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
<li><p>Six elements of the hindered diffusion tensor</p></li>
<li><p>Six elements of the restricted diffusion tensor</p></li>
<li><p>Axonal water fraction</p></li>
</ol>
</div></blockquote>
</dd>
<dt>S0<span class="classifier">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</section>
<section id="id333">
<h4>Notes<a class="headerlink" href="#id333" title="Permalink to this heading">#</a></h4>
<p>In the original article of DKI microstructural model <a href="#id1469"><span class="problematic" id="id334">[1]_</span></a>, the hindered
and restricted tensors were defined as the intra-cellular and
extra-cellular diffusion compartments respectively.</p>
</section>
<section id="id335">
<h4>References<a class="headerlink" href="#id335" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id336" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="kurtosismicrostructuralfit">
<h3><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a><a class="headerlink" href="#kurtosismicrostructuralfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">KurtosisMicrostructuralFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a></p>
<p>Class for fitting the Diffusion Kurtosis Microstructural Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a KurtosisMicrostructural Fit class instance.</p>
<section id="id337">
<h4>Parameters<a class="headerlink" href="#id337" title="Permalink to this heading">#</a></h4>
<dl>
<dt>model<span class="classifier">DiffusionKurtosisModel Class instance</span></dt><dd><p>Class instance containing the Diffusion Kurtosis Model for the fit</p>
</dd>
<dt>model_params<span class="classifier">ndarray (x, y, z, 40) or (n, 40)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis
microstructural model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
<li><p>Six elements of the hindered diffusion tensor</p></li>
<li><p>Six elements of the restricted diffusion tensor</p></li>
<li><p>Axonal water fraction</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</section>
<section id="id338">
<h4>Notes<a class="headerlink" href="#id338" title="Permalink to this heading">#</a></h4>
<p>In the original article of DKI microstructural model <a href="#id1470"><span class="problematic" id="id339">[1]_</span></a>, the hindered
and restricted tensors were defined as the intra-cellular and
extra-cellular diffusion compartments respectively.</p>
</section>
<section id="id340">
<h4>References<a class="headerlink" href="#id340" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id341" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">awf</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the volume fraction of the restricted diffusion compartment
also known as axonal water fraction.</p>
<section id="id342">
<h4>Notes<a class="headerlink" href="#id342" title="Permalink to this heading">#</a></h4>
<p>The volume fraction of the restricted diffusion compartment can be seem
as the volume fraction of the intra-cellular compartment <a href="#id1471"><span class="problematic" id="id343">[1]_</span></a>.</p>
</section>
<section id="id344">
<h4>References<a class="headerlink" href="#id344" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id345" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">axonal_diffusivity</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the axonal diffusivity defined as the restricted diffusion
tensor trace <a href="#id1472"><span class="problematic" id="id346">[1]_</span></a>.</p>
<section id="id347">
<h4>References<a class="headerlink" href="#id347" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id348" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hindered_ad</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the axial diffusivity of the hindered compartment.</p>
<section id="id349">
<h4>Notes<a class="headerlink" href="#id349" title="Permalink to this heading">#</a></h4>
<p>The hindered diffusion tensor can be seem as the tissue’s
extra-cellular diffusion compartment <a href="#id1473"><span class="problematic" id="id350">[1]_</span></a>.</p>
</section>
<section id="id351">
<h4>References<a class="headerlink" href="#id351" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id352" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hindered_evals</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the eigenvalues of the hindered diffusion compartment.</p>
<section id="id353">
<h4>Notes<a class="headerlink" href="#id353" title="Permalink to this heading">#</a></h4>
<p>The hindered diffusion tensor can be seem as the tissue’s
extra-cellular diffusion compartment <a href="#id1474"><span class="problematic" id="id354">[1]_</span></a>.</p>
</section>
<section id="id355">
<h4>References<a class="headerlink" href="#id355" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id356" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hindered_rd</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the radial diffusivity of the hindered compartment.</p>
<section id="id357">
<h4>Notes<a class="headerlink" href="#id357" title="Permalink to this heading">#</a></h4>
<p>The hindered diffusion tensor can be seem as the tissue’s
extra-cellular diffusion compartment <a href="#id1475"><span class="problematic" id="id358">[1]_</span></a>.</p>
</section>
<section id="id359">
<h4>References<a class="headerlink" href="#id359" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id360" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Given a DKI microstructural model fit, predict the signal on the
vertices of a gradient table

gtab : a GradientTable class instance
    The gradient table for this prediction

S0 : float or ndarray (optional)
    The non diffusion-weighted signal in every voxel, or across all
    voxels. Default: 1

Notes
—–
The predicted signal is given by:

<span class="math notranslate nohighlight">\(S(\theta, b) = S_0 * [f * e^{-b ADC_{r}} + (1-f) * e^{-b ADC_{h}]\)</span>,
where <span class="math notranslate nohighlight">\(ADC_{r}\)</span> and <span class="math notranslate nohighlight">\(ADC_{h}\)</span> are the apparent diffusion coefficients
of the diffusion hindered and restricted compartment for a given
direction <span class="math notranslate nohighlight">\(\theta\)</span>, <span class="math notranslate nohighlight">\(b\)</span> is the b value provided in the GradientTable
input for that direction, <span class="math notranslate nohighlight">\(f\)</span> is the volume fraction of the restricted
diffusion compartment (also known as the axonal water fraction).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">restricted_evals</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the eigenvalues of the restricted diffusion compartment.</p>
<section id="id361">
<h4>Notes<a class="headerlink" href="#id361" title="Permalink to this heading">#</a></h4>
<p>The restricted diffusion tensor can be seem as the tissue’s
intra-cellular diffusion compartment <a href="#id1476"><span class="problematic" id="id362">[1]_</span></a>.</p>
</section>
<section id="id363">
<h4>References<a class="headerlink" href="#id363" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id364" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tortuosity</span></span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the tortuosity of the hindered diffusion which is defined
by ADe / RDe, where ADe and RDe are the axial and radial diffusivities
of the hindered compartment <a href="#id1477"><span class="problematic" id="id365">[1]_</span></a>.</p>
<section id="id366">
<h4>Notes<a class="headerlink" href="#id366" title="Permalink to this heading">#</a></h4>
<p>The hindered diffusion tensor can be seem as the tissue’s
extra-cellular diffusion compartment <a href="#id1478"><span class="problematic" id="id367">[1]_</span></a>.</p>
</section>
<section id="id368">
<h4>References<a class="headerlink" href="#id368" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id369" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="axonal-water-fraction">
<h3>axonal_water_fraction<a class="headerlink" href="#axonal-water-fraction" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.axonal_water_fraction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">axonal_water_fraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.axonal_water_fraction" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the axonal water fraction from DKI <a href="#id1479"><span class="problematic" id="id370">[1]_</span></a>.</p>
<section id="id371">
<h4>Parameters<a class="headerlink" href="#id371" title="Permalink to this heading">#</a></h4>
<dl>
<dt>dki_params<span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt>sphere<span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of the
maximal value of kurtosis.</p>
</dd>
<dt>gtol<span class="classifier">float, optional</span></dt><dd><p>This input is to refine kurtosis maxima under the precision of the
directions sampled on the sphere class instance. The gradient of the
convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken from
the initial sampled directions of the given sphere object</p>
</dd>
<dt>mask<span class="classifier">ndarray</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</section>
<section id="id372">
<h4>Returns<a class="headerlink" href="#id372" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>awf<span class="classifier">ndarray (x, y, z) or (n)</span></dt><dd><p>Axonal Water Fraction</p>
</dd>
</dl>
</section>
<section id="id373">
<h4>References<a class="headerlink" href="#id373" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id374" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans E, Jensen JH, Helpern JA, 2011. White matter
characterization with diffusional kurtosis imaging.
Neuroimage 58(1):177-88. doi: 10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="diffusion-components">
<h3>diffusion_components<a class="headerlink" href="#diffusion-components" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.diffusion_components">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">diffusion_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repulsion100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">awf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.diffusion_components" title="Permalink to this definition">#</a></dt>
<dd><p>Extracts the restricted and hindered diffusion tensors of well aligned
fibers from diffusion kurtosis imaging parameters <a href="#id1480"><span class="problematic" id="id375">[1]_</span></a>.</p>
<section id="id376">
<h4>Parameters<a class="headerlink" href="#id376" title="Permalink to this heading">#</a></h4>
<dl>
<dt>dki_params<span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</p></li>
<li><p>Fifteen elements of the kurtosis tensor</p></li>
</ol>
</div></blockquote>
</dd>
<dt>sphere<span class="classifier">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions to sample the restricted and
hindered cellular diffusion tensors. For more details see Fieremans
et al., 2011.</p>
</dd>
<dt>awf<span class="classifier">ndarray (optional)</span></dt><dd><p>Array containing values of the axonal water fraction that has the shape
dki_params.shape[:-1]. If not given this will be automatically computed
using <a class="reference internal" href="#dipy.reconst.dki_micro.axonal_water_fraction" title="dipy.reconst.dki_micro.axonal_water_fraction"><code class="xref py py-func docutils literal notranslate"><span class="pre">axonal_water_fraction()</span></code></a>” with function’s default precision.</p>
</dd>
<dt>mask<span class="classifier">ndarray (optional)</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</section>
<section id="id377">
<h4>Returns<a class="headerlink" href="#id377" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>edt<span class="classifier">ndarray (x, y, z, 6) or (n, 6)</span></dt><dd><p>Parameters of the hindered diffusion tensor.</p>
</dd>
<dt>idt<span class="classifier">ndarray (x, y, z, 6) or (n, 6)</span></dt><dd><p>Parameters of the restricted diffusion tensor.</p>
</dd>
</dl>
</section>
<section id="id378">
<h4>Notes<a class="headerlink" href="#id378" title="Permalink to this heading">#</a></h4>
<p>In the original article of DKI microstructural model <a href="#id1481"><span class="problematic" id="id379">[1]_</span></a>, the hindered and
restricted tensors were defined as the intra-cellular and extra-cellular
diffusion compartments respectively.</p>
</section>
<section id="id380">
<h4>References<a class="headerlink" href="#id380" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id381" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fieremans E, Jensen JH, Helpern JA, 2011. White matter
characterization with diffusional kurtosis imaging.
Neuroimage 58(1):177-88. doi: 10.1016/j.neuroimage.2011.06.006</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="dkimicro-prediction">
<h3>dkimicro_prediction<a class="headerlink" href="#dkimicro-prediction" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.dkimicro_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">dkimicro_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.dkimicro_prediction" title="Permalink to this definition">#</a></dt>
<dd><p>Signal prediction given the DKI microstructure model parameters.

Parameters
———-
params : ndarray (x, y, z, 40) or (n, 40)
All parameters estimated from the diffusion kurtosis microstructure model.
    Parameters are ordered as follows:
        1) Three diffusion tensor’s eigenvalues
        2) Three lines of the eigenvector matrix each containing the
           first, second and third coordinates of the eigenvector
        3) Fifteen elements of the kurtosis tensor
        4) Six elements of the hindered diffusion tensor
        5) Six elements of the restricted diffusion tensor
        6) Axonal water fraction
gtab : a GradientTable class instance
    The gradient table for this prediction
S0 : float or ndarray
    The non diffusion-weighted signal in every voxel, or across all
    voxels. Default: 1

Returns
——-
S : (…, N) ndarray
    Simulated signal based on the DKI microstructure model

Notes
—–
1) The predicted signal is given by:
<span class="math notranslate nohighlight">\(S(\theta, b) = S_0 * [f * e^{-b ADC_{r}} + (1-f) * e^{-b ADC_{h}]\)</span>, where
:math:` ADC_{r} and ADC_{h} are the apparent diffusion coefficients of the
diffusion hindered and restricted compartment for a given direction
<cite>theta:math:</cite>, <cite>b:math:</cite> is the b value provided in the GradientTable input for that
direction, <a href="#id382"><span class="problematic" id="id383">`</span></a>f$ is the volume fraction of the restricted diffusion
compartment (also known as the axonal water fraction).

2) In the original article of DKI microstructural model <a href="#id1482"><span class="problematic" id="id384">[1]_</span></a>, the hindered
and restricted tensors were defined as the intra-cellular and
extra-cellular diffusion compartments respectively.</p>
</dd></dl>

</section>
<section id="tortuosity">
<h3>tortuosity<a class="headerlink" href="#tortuosity" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dki_micro.tortuosity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dki_micro.</span></span><span class="sig-name descname"><span class="pre">tortuosity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hindered_ad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hindered_rd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.tortuosity" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the tortuosity of the hindered diffusion compartment given
its axial and radial diffusivities</p>
<section id="id385">
<h4>Parameters<a class="headerlink" href="#id385" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>hindered_ad: ndarray</dt><dd><p>Array containing the values of the hindered axial diffusivity.</p>
</dd>
<dt>hindered_rd: ndarray</dt><dd><p>Array containing the values of the hindered radial diffusivity.</p>
</dd>
</dl>
</section>
<section id="id386">
<h4>Returns<a class="headerlink" href="#id386" title="Permalink to this heading">#</a></h4>
<p>Tortuosity of the hindered diffusion compartment</p>
</section>
</dd></dl>

</section>
<section id="diffusionspectrummodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a><a class="headerlink" href="#diffusionspectrummodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">DiffusionSpectrumModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qgrid_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">17</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qgrid_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">17</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Diffusion Spectrum Imaging

The theoretical idea underlying this method is that the diffusion
propagator <span class="math notranslate nohighlight">\(P(\mathbf{r})\)</span> (probability density function of the average
spin displacements) can be estimated by applying 3D FFT to the signal
values <span class="math notranslate nohighlight">\(S(\mathbf{q})\)</span>

..math::
    :nowrap:
        begin{eqnarray}
            P(mathbf{r}) &amp; = &amp; S_{0}^{-1}int S(mathbf{q})exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{r}
        end{eqnarray}

where <span class="math notranslate nohighlight">\(\mathbf{r}\)</span> is the displacement vector and <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> is the
wave vector which corresponds to different gradient directions. Method
used to calculate the ODFs. Here we implement the method proposed by
Wedeen et al. <a href="#id1483"><span class="problematic" id="id387">[1]_</span></a>.

The main assumption for this model is fast gradient switching and that
the acquisition gradients will sit on a keyhole Cartesian grid in
q_space <a href="#id1484"><span class="problematic" id="id388">[3]_</span></a>.

Parameters
———-
gtab : GradientTable,
    Gradient directions and bvalues container class
qgrid_size : int,
    has to be an odd number. Sets the size of the q_space grid.
    For example if qgrid_size is 17 then the shape of the grid will be
    <code class="docutils literal notranslate"><span class="pre">(17,</span> <span class="pre">17,</span> <span class="pre">17)</span></code>.
r_start : float,
    ODF is sampled radially in the PDF. This parameters shows where the
    sampling should start.
r_end : float,
    Radial endpoint of ODF sampling
r_step : float,
    Step size of the ODf sampling from r_start to r_end
filter_width : float,
    Strength of the hanning filter

References
———-
.. [1]  Wedeen V.J et al., “Mapping Complex Tissue Architecture With
Diffusion Spectrum Magnetic Resonance Imaging”, MRM 2005.

.. [2] Canales-Rodriguez E.J et al., “Deconvolution in Diffusion
Spectrum Imaging”, Neuroimage, 2010.

.. [3] Garyfallidis E, “Towards an accurate brain tractography”, PhD
thesis, University of Cambridge, 2012.

Examples
——–
In this example where we provide the data, a gradient table
and a reconstruction sphere, we calculate generalized FA for the first
voxel in the data with the reconstruction performed using DSI.

&gt;&gt;&gt; import warnings
&gt;&gt;&gt; from dipy.data import dsi_voxels, default_sphere
&gt;&gt;&gt; data, gtab = dsi_voxels()
&gt;&gt;&gt; from dipy.reconst.dsi import DiffusionSpectrumModel
&gt;&gt;&gt; ds = DiffusionSpectrumModel(gtab)
&gt;&gt;&gt; dsfit = ds.fit(data)
&gt;&gt;&gt; from dipy.reconst.odf import gfa
&gt;&gt;&gt; np.round(gfa(dsfit.odf(default_sphere))[0, 0, 0], 2)
0.11

Notes
—–
A. Have in mind that DSI expects gradients on both hemispheres. If your
gradients span only one hemisphere you need to duplicate the data and
project them to the other hemisphere before calling this class. The
function dipy.reconst.dsi.half_to_full_qspace can be used for this
purpose.

B. If you increase the size of the grid (parameter qgrid_size) you will
most likely also need to update the r_* parameters. This is because
the added zero padding from the increase of gqrid_size also introduces
a scaling of the PDF.

C. We assume that data only one b0 volume is provided.

See Also
——–
dipy.reconst.gqi.GeneralizedQSampling</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="diffusionspectrumfit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a><a class="headerlink" href="#diffusionspectrumfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">DiffusionSpectrumFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates PDF and ODF and other properties for a single voxel</p>
<section id="id389">
<h4>Parameters<a class="headerlink" href="#id389" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">object,</span></dt><dd><p>DiffusionSpectrumModel</p>
</dd>
<dt>data<span class="classifier">1d ndarray,</span></dt><dd><p>signal values</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete">
<span class="sig-name descname"><span class="pre">msd_discrete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the mean squared displacement on the discrete propagator

..math::
    :nowrap:
        begin{equation}
            MSD:{DSI}=int_{-infty}^{infty}int_{-infty}^{infty}int_{-infty}^{infty} P(hat{mathbf{r}}) cdot hat{mathbf{r}}^{2} dr_x dr_y dr_z
        end{equation}

where <span class="math notranslate nohighlight">\(\hat{\mathbf{r}}\)</span> is a point in the 3D Propagator space
(see Wu et al. <a href="#id1485"><span class="problematic" id="id390">[1]_</span></a>).

Parameters
———-
normalized : boolean, optional
    Whether to normalize the propagator by its sum in order to obtain a
    pdf. Default: True

Returns
——-
msd : float
    the mean square displacement

References
———-
.. [1] Wu Y. et al., “Hybrid diffusion imaging”, NeuroImage, vol 36,
p. 617-629, 2007.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the real discrete odf for a given discrete sphere

..math::
    :nowrap:
        begin{equation}
            psi_{DSI}(hat{mathbf{u}})=int_{0}^{infty}P(rhat{mathbf{u}})r^{2}dr
        end{equation}

where <span class="math notranslate nohighlight">\(\hat{\mathbf{u}}\)</span> is the unit vector which corresponds to a
sphere point.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.pdf" title="Permalink to this definition">#</a></dt>
<dd><p>Applies the 3D FFT in the q-space grid to generate
the diffusion propagator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf">
<span class="sig-name descname"><span class="pre">rtop_pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the return to origin probability from the propagator, which is
the propagator evaluated at zero (see Descoteaux et Al. <a href="#id1486"><span class="problematic" id="id391">[1]_</span></a>,
Tuch <a href="#id1487"><span class="problematic" id="id392">[2]_</span></a>, Wu et al. <a href="#id1488"><span class="problematic" id="id393">[3]_</span></a>)
rtop = P(0)</p>
<section id="id394">
<h4>Parameters<a class="headerlink" href="#id394" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>normalized<span class="classifier">boolean, optional</span></dt><dd><p>Whether to normalize the propagator by its sum in order to obtain a
pdf. Default: True.</p>
</dd>
</dl>
</section>
<section id="id395">
<h4>Returns<a class="headerlink" href="#id395" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>rtop<span class="classifier">float</span></dt><dd><p>the return to origin probability</p>
</dd>
</dl>
</section>
<section id="id396">
<h4>References<a class="headerlink" href="#id396" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id397" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Descoteaux M. et al., “Multiple q-shell diffusion propagator</p>
</aside>
</aside>
<p>imaging”, Medical Image Analysis, vol 15, No. 4, p. 603-621, 2011.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id398" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tuch D.S., “Diffusion MRI of Complex Tissue Structure”,
PhD Thesis, 2002.</p>
</aside>
<aside class="footnote brackets" id="id399" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Wu Y. et al., “Computation of Diffusion Function Measures</p>
</aside>
</aside>
<p>in q -Space Using Magnetic Resonance Hybrid Diffusion Imaging”,
IEEE TRANSACTIONS ON MEDICAL IMAGING, vol. 27, No. 6, p. 858-865, 2008</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal">
<span class="sig-name descname"><span class="pre">rtop_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filtering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the return to origin probability (rtop) from the signal
rtop equals to the sum of all signal values</p>
<section id="id400">
<h4>Parameters<a class="headerlink" href="#id400" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>filtering<span class="classifier">boolean, optional</span></dt><dd><p>Whether to perform Hanning filtering. Default: True</p>
</dd>
</dl>
</section>
<section id="id401">
<h4>Returns<a class="headerlink" href="#id401" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>rtop<span class="classifier">float</span></dt><dd><p>the return to origin probability</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="diffusionspectrumdeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a><a class="headerlink" href="#diffusionspectrumdeconvmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">DiffusionSpectrumDeconvModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qgrid_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">35</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">13.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qgrid_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">35</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">13.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Diffusion Spectrum Deconvolution

The idea is to remove the convolution on the DSI propagator that is
caused by the truncation of the q-space in the DSI sampling.

..math::
    :nowrap:
        begin{eqnarray*}
            P_{dsi}(mathbf{r}) &amp; = &amp; S_{0}^{-1}iiintlimits_{| mathbf{q} | le mathbf{q_{max}}} S(mathbf{q})exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} \
            &amp; = &amp; S_{0}^{-1}iiintlimits_{mathbf{q}} left( S(mathbf{q}) cdot M(mathbf{q}) right) exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} \
            &amp; = &amp; P(mathbf{r}) otimes left( S_{0}^{-1}iiintlimits_{mathbf{q}}  M(mathbf{q}) exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} right) \
        end{eqnarray*}

where <span class="math notranslate nohighlight">\(\mathbf{r}\)</span> is the displacement vector and <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> is the
wave vector which corresponds to different gradient directions,
<span class="math notranslate nohighlight">\(M(\mathbf{q})\)</span> is a mask corresponding to your q-space sampling and
<span class="math notranslate nohighlight">\(\otimes\)</span> is the convolution operator <a href="#id1489"><span class="problematic" id="id402">[1]_</span></a>.


Parameters
———-
gtab : GradientTable,
    Gradient directions and bvalues container class
qgrid_size : int,
    has to be an odd number. Sets the size of the q_space grid.
    For example if qgrid_size is 35 then the shape of the grid will be
    <code class="docutils literal notranslate"><span class="pre">(35,</span> <span class="pre">35,</span> <span class="pre">35)</span></code>.
r_start : float,
    ODF is sampled radially in the PDF. This parameters shows where the
    sampling should start.
r_end : float,
    Radial endpoint of ODF sampling
r_step : float,
    Step size of the ODf sampling from r_start to r_end
filter_width : float,
    Strength of the hanning filter

References
———-
.. [1] Canales-Rodriguez E.J et al., “Deconvolution in Diffusion
Spectrum Imaging”, Neuroimage, 2010.

.. [2] Biggs David S.C. et al., “Acceleration of Iterative Image
Restoration Algorithms”, Applied Optics, vol. 36, No. 8, p. 1766-1775,
1997.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="diffusionspectrumdeconvfit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a><a class="headerlink" href="#diffusionspectrumdeconvfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">DiffusionSpectrumDeconvFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates PDF and ODF and other properties for a single voxel</p>
<section id="id403">
<h4>Parameters<a class="headerlink" href="#id403" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">object,</span></dt><dd><p>DiffusionSpectrumModel</p>
</dd>
<dt>data<span class="classifier">1d ndarray,</span></dt><dd><p>signal values</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf" title="Permalink to this definition">#</a></dt>
<dd><p>Applies the 3D FFT in the q-space grid to generate
the DSI diffusion propagator, remove the background noise with a
hard threshold and then deconvolve the propagator with the
Lucy-Richardson deconvolution algorithm</p>
</dd></dl>

</dd></dl>

</section>
<section id="create-qspace">
<h3>create_qspace<a class="headerlink" href="#create-qspace" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.create_qspace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">create_qspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.create_qspace" title="Permalink to this definition">#</a></dt>
<dd><p>create the 3D grid which holds the signal values (q-space)</p>
<section id="id404">
<h4>Parameters<a class="headerlink" href="#id404" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
origin : (3,) ndarray</p>
<blockquote>
<div><p>center of qspace</p>
</div></blockquote>
</section>
<section id="id405">
<h4>Returns<a class="headerlink" href="#id405" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>qgrid<span class="classifier">ndarray</span></dt><dd><p>qspace coordinates</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="create-qtable">
<h3>create_qtable<a class="headerlink" href="#create-qtable" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.create_qtable">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">create_qtable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.create_qtable" title="Permalink to this definition">#</a></dt>
<dd><p>create a normalized version of gradients</p>
<section id="id406">
<h4>Parameters<a class="headerlink" href="#id406" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
origin : (3,) ndarray</p>
<blockquote>
<div><p>center of qspace</p>
</div></blockquote>
</section>
<section id="id407">
<h4>Returns<a class="headerlink" href="#id407" title="Permalink to this heading">#</a></h4>
<p>qtable : ndarray</p>
</section>
</dd></dl>

</section>
<section id="hanning-filter">
<h3>hanning_filter<a class="headerlink" href="#hanning-filter" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.hanning_filter">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">hanning_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.hanning_filter" title="Permalink to this definition">#</a></dt>
<dd><p>create a hanning window</p>
<p>The signal is premultiplied by a Hanning window before
Fourier transform in order to ensure a smooth attenuation
of the signal at high q values.</p>
<section id="id408">
<h4>Parameters<a class="headerlink" href="#id408" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
filter_width : int
origin : (3,) ndarray</p>
<blockquote>
<div><p>center of qspace</p>
</div></blockquote>
</section>
<section id="id409">
<h4>Returns<a class="headerlink" href="#id409" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>filter<span class="classifier">(N,) ndarray</span></dt><dd><p>where N is the number of non-b0 gradient directions</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="pdf-interp-coords">
<h3>pdf_interp_coords<a class="headerlink" href="#pdf-interp-coords" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.pdf_interp_coords">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">pdf_interp_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rradius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.pdf_interp_coords" title="Permalink to this definition">#</a></dt>
<dd><p>Precompute coordinates for ODF calculation from the PDF</p>
<section id="id410">
<h4>Parameters<a class="headerlink" href="#id410" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">object,</span></dt><dd><p>Sphere</p>
</dd>
<dt>rradius<span class="classifier">array, shape (N,)</span></dt><dd><p>line interpolation points</p>
</dd>
<dt>origin<span class="classifier">array, shape (3,)</span></dt><dd><p>center of the grid</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="pdf-odf">
<h3>pdf_odf<a class="headerlink" href="#pdf-odf" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.pdf_odf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">pdf_odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Pr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rradius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.pdf_odf" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the real ODF from the diffusion propagator(PDF) Pr</p>
<section id="id411">
<h4>Parameters<a class="headerlink" href="#id411" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>Pr<span class="classifier">array, shape (X, X, X)</span></dt><dd><p>probability density function</p>
</dd>
<dt>rradius<span class="classifier">array, shape (N,)</span></dt><dd><p>interpolation range on the radius</p>
</dd>
<dt>interp_coords<span class="classifier">array, shape (3, M, N)</span></dt><dd><p>coordinates in the pdf for interpolating the odf</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="half-to-full-qspace">
<h3>half_to_full_qspace<a class="headerlink" href="#half-to-full-qspace" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.half_to_full_qspace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">half_to_full_qspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.half_to_full_qspace" title="Permalink to this definition">#</a></dt>
<dd><p>Half to full Cartesian grid mapping</p>
<p>Useful when dMRI data are provided in one qspace hemisphere as
DiffusionSpectrum expects data to be in full qspace.</p>
<section id="id412">
<h4>Parameters<a class="headerlink" href="#id412" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">array, shape (X, Y, Z, W)</span></dt><dd><p>where (X, Y, Z) volume size and W number of gradient directions</p>
</dd>
<dt>gtab<span class="classifier">GradientTable</span></dt><dd><p>container for b-values and b-vectors (gradient directions)</p>
</dd>
</dl>
</section>
<section id="id413">
<h4>Returns<a class="headerlink" href="#id413" title="Permalink to this heading">#</a></h4>
<p>new_data : array, shape (X, Y, Z, 2 * W -1)
new_gtab : GradientTable</p>
</section>
<section id="id414">
<h4>Notes<a class="headerlink" href="#id414" title="Permalink to this heading">#</a></h4>
<p>We assume here that only on b0 is provided with the initial data. If that
is not the case then you will need to write your own preparation function
before providing the gradients and the data to the DiffusionSpectrumModel
class.</p>
</section>
</dd></dl>

</section>
<section id="project-hemisph-bvecs">
<h3>project_hemisph_bvecs<a class="headerlink" href="#project-hemisph-bvecs" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.project_hemisph_bvecs">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">project_hemisph_bvecs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.project_hemisph_bvecs" title="Permalink to this definition">#</a></dt>
<dd><p>Project any near identical bvecs to the other hemisphere</p>
<section id="id415">
<h4>Parameters<a class="headerlink" href="#id415" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">object,</span></dt><dd><p>GradientTable</p>
</dd>
</dl>
</section>
<section id="id416">
<h4>Notes<a class="headerlink" href="#id416" title="Permalink to this heading">#</a></h4>
<p>Useful only when working with some types of dsi data.</p>
</section>
</dd></dl>

</section>
<section id="threshold-propagator">
<h3>threshold_propagator<a class="headerlink" href="#threshold-propagator" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.threshold_propagator">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">threshold_propagator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimated_snr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.threshold_propagator" title="Permalink to this definition">#</a></dt>
<dd><p>Applies hard threshold on the propagator to remove background noise for the
deconvolution.</p>
</dd></dl>

</section>
<section id="gen-psf">
<h3>gen_PSF<a class="headerlink" href="#gen-psf" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.gen_PSF">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">gen_PSF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qgrid_sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">siz_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">siz_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">siz_z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.gen_PSF" title="Permalink to this definition">#</a></dt>
<dd><p>Generate a PSF for DSI Deconvolution by taking the ifft of the binary
q-space sampling mask and truncating it to keep only the center.</p>
</dd></dl>

</section>
<section id="lr-deconv">
<h3>LR_deconv<a class="headerlink" href="#lr-deconv" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dsi.LR_deconv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dsi.</span></span><span class="sig-name descname"><span class="pre">LR_deconv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.LR_deconv" title="Permalink to this definition">#</a></dt>
<dd><p>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</p>
<section id="id417">
<h4>Parameters<a class="headerlink" href="#id417" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>prop<span class="classifier">3-D ndarray of dtype float</span></dt><dd><p>The 3D volume to be deconvolve</p>
</dd>
<dt>psf<span class="classifier">3-D ndarray of dtype float</span></dt><dd><p>The filter that will be used for the deconvolution.</p>
</dd>
<dt>numit<span class="classifier">int</span></dt><dd><p>Number of Lucy-Richardson iteration to perform.</p>
</dd>
<dt>acc_factor<span class="classifier">float</span></dt><dd><p>Exponential acceleration factor as in <a href="#id1490"><span class="problematic" id="id418">[1]_</span></a>.</p>
</dd>
</dl>
</section>
<section id="id419">
<h4>References<a class="headerlink" href="#id419" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id420" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Biggs David S.C. et al., “Acceleration of Iterative Image
Restoration Algorithms”, Applied Optics, vol. 36, No. 8, p. 1766-1775,
1997.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="tensormodel">
<h3><a class="reference internal" href="#dipy.reconst.dti.TensorModel" title="dipy.reconst.dti.TensorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorModel</span></code></a><a class="headerlink" href="#tensormodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">TensorModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Diffusion Tensor</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>A Diffusion Tensor Model <a href="#id1491"><span class="problematic" id="id421">[1]_</span></a>, <a href="#id1492"><span class="problematic" id="id422">[2]_</span></a>.</p>
<section id="id423">
<h4>Parameters<a class="headerlink" href="#id423" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable class instance</p>
<dl>
<dt>fit_method<span class="classifier">str or callable</span></dt><dd><p>str can be one of the following:</p>
<dl class="simple">
<dt>‘WLS’ for weighted least squares</dt><dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">dti.wls_fit_tensor()</span></code></p>
</dd>
<dt>‘LS’ or ‘OLS’ for ordinary least squares</dt><dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">dti.ols_fit_tensor()</span></code></p>
</dd>
<dt>‘NLLS’ for non-linear least-squares</dt><dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">dti.nlls_fit_tensor()</span></code></p>
</dd>
<dt>‘RT’ or ‘restore’ or ‘RESTORE’ for RESTORE robust tensor</dt><dd><p>fitting <a href="#id1493"><span class="problematic" id="id424">[3]_</span></a>
<code class="xref py py-func docutils literal notranslate"><span class="pre">dti.restore_fit_tensor()</span></code></p>
</dd>
<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href="#id425"><span class="problematic" id="id426">*</span></a>args, <a href="#id427"><span class="problematic" id="id428">**</span></a>kwargs)</p>
</dd>
</dl>
</dd>
<dt>return_S0_hat<span class="classifier">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt>args, kwargs<span class="classifier">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See dti.wls_fit_tensor, dti.ols_fit_tensor for details</p>
</dd>
<dt>min_signal<span class="classifier">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive
number. Default: minimal signal in the data provided to <cite>fit</cite>.</p>
</dd>
</dl>
</section>
<section id="id429">
<h4>Notes<a class="headerlink" href="#id429" title="Permalink to this heading">#</a></h4>
<p>In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. Many fit_methods use the ‘step’
parameter to set the number of voxels that will be fit at once in each
iteration. This is the chunk size as a number of voxels. A larger step
value should speed things up, but it will also take up more memory. It
is advisable to keep an eye on memory consumption as this value is
increased.</p>
<p>E.g., in <a class="reference internal" href="#dipy.reconst.dti.iter_fit_tensor" title="dipy.reconst.dti.iter_fit_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter_fit_tensor()</span></code></a> we have a default step value of
1e4</p>
</section>
<section id="id430">
<h4>References<a class="headerlink" href="#id430" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id431" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Basser, P.J., Mattiello, J., LeBihan, D., 1994. Estimation of
the effective self-diffusion tensor from the NMR spin echo. J Magn
Reson B 103, 247-254.</p>
</aside>
<aside class="footnote brackets" id="id432" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Basser, P., Pierpaoli, C., 1996. Microstructural and
physiological features of tissues elucidated by quantitative
diffusion-tensor MRI.  Journal of Magnetic Resonance 111, 209-219.</p>
</aside>
<aside class="footnote brackets" id="id433" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Lin-Ching C., Jones D.K., Pierpaoli, C. 2005. RESTORE: Robust
estimation of tensors by outlier rejection. MRM 53: 1088-1095</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method of the DTI model class</p>
<section id="id434">
<h4>Parameters<a class="headerlink" href="#id434" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">array</span></dt><dd><p>The measured signal from one voxel.</p>
</dd>
<dt>mask<span class="classifier">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</dd>
<dt>adjacency<span class="classifier">float, optional</span></dt><dd><p>Calculate voxel adjacency accounting for mask, using this
value as cutoff distance (measured in voxel coordinates)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dti_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorModel.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal for this TensorModel class instance given parameters.</p>
<section id="id435">
<h4>Parameters<a class="headerlink" href="#id435" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>dti_params<span class="classifier">ndarray</span></dt><dd><p>The last dimension should have 12 tensor parameters: 3
eigenvalues, followed by the 3 eigenvectors</p>
</dd>
<dt>S0<span class="classifier">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="tensorfit">
<h3><a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a><a class="headerlink" href="#tensorfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">TensorFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a TensorFit class instance.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.S0_hat">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">S0_hat</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.S0_hat" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.ad">
<span class="sig-name descname"><span class="pre">ad</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.ad" title="Permalink to this definition">#</a></dt>
<dd><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p>
<section id="id436">
<h4>Returns<a class="headerlink" href="#id436" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ad<span class="classifier">array (V, 1)</span></dt><dd><p>Calculated AD.</p>
</dd>
</dl>
</section>
<section id="id437">
<h4>Notes<a class="headerlink" href="#id437" title="Permalink to this heading">#</a></h4>
<p>RD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[AD = \lambda_1\]</div>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.adc">
<span class="sig-name descname"><span class="pre">adc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.adc" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Calculate the apparent diffusion coefficient (ADC) in each direction on
the sphere for each voxel in the data</p>
<p>sphere : Sphere class instance</p>
<dl class="simple">
<dt>adc<span class="classifier">ndarray</span></dt><dd><p>The estimates of the apparent diffusion coefficient in every
direction on the input sphere</p>
</dd>
</dl>
<p>The calculation of ADC, relies on the following relationship:</p>
<div class="math notranslate nohighlight">
\[ADC = \]</div>
</div></blockquote>
<p>ec{b} Q 
ec{b}^T</p>
<blockquote>
<div><p>Where Q is the quadratic form of the tensor.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.color_fa">
<span class="sig-name descname"><span class="pre">color_fa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.color_fa" title="Permalink to this definition">#</a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.directions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">directions</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.directions" title="Permalink to this definition">#</a></dt>
<dd><p>For tracking - return the primary direction in each voxel</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.evals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">evals</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.evals" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.evecs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">evecs</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.evecs" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.fa">
<span class="sig-name descname"><span class="pre">fa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.fa" title="Permalink to this definition">#</a></dt>
<dd><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.ga">
<span class="sig-name descname"><span class="pre">ga</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.ga" title="Permalink to this definition">#</a></dt>
<dd><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.linearity">
<span class="sig-name descname"><span class="pre">linearity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.linearity" title="Permalink to this definition">#</a></dt>
<dd><section id="id438">
<h4>Returns<a class="headerlink" href="#id438" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>linearity<span class="classifier">array</span></dt><dd><p>Calculated linearity of the diffusion tensor <a href="#id1494"><span class="problematic" id="id439">[1]_</span></a>.</p>
</dd>
</dl>
</section>
<section id="id440">
<h4>Notes<a class="headerlink" href="#id440" title="Permalink to this heading">#</a></h4>
<p>Linearity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Linearity =
\frac{\lambda_1-\lambda_2}{\lambda_1+\lambda_2+\lambda_3}\]</div>
</section>
<section id="id441">
<h4>References<a class="headerlink" href="#id441" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id442" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz
F., “Geometrical diffusion measures for MRI from tensor basis
analysis” in Proc. 5th Annual ISMRM, 1997.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.lower_triangular">
<span class="sig-name descname"><span class="pre">lower_triangular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.lower_triangular" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.md">
<span class="sig-name descname"><span class="pre">md</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.md" title="Permalink to this definition">#</a></dt>
<dd><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p>
<section id="id443">
<h4>Returns<a class="headerlink" href="#id443" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>md<span class="classifier">array (V, 1)</span></dt><dd><p>Calculated MD.</p>
</dd>
</dl>
</section>
<section id="id444">
<h4>Notes<a class="headerlink" href="#id444" title="Permalink to this heading">#</a></h4>
<p>MD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[MD = \frac{\lambda_1+\lambda_2+\lambda_3}{3}\]</div>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.mode">
<span class="sig-name descname"><span class="pre">mode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.mode" title="Permalink to this definition">#</a></dt>
<dd><p>Tensor mode calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>The diffusion orientation distribution function (dODF). This is an
estimate of the diffusion distance in each direction

Parameters
———-
sphere : Sphere class instance.
    The dODF is calculated in the vertices of this input.

Returns
——-
odf : ndarray
    The diffusion distance in every direction of the sphere in every
    voxel in the input data.

Notes
—–
This is based on equation 3 in <a href="#id1495"><span class="problematic" id="id445">[1]_</span></a>. To re-derive it from
scratch, follow steps in <a href="#id1496"><span class="problematic" id="id446">[2]_</span></a>, Section 7.9 Equation
7.24 but with an <span class="math notranslate nohighlight">\(r^2\)</span> term in the integral.

References
———-
.. [1] Aganj, I., Lenglet, C., Sapiro, G., Yacoub, E., Ugurbil,
    K., &amp; Harel, N. (2010). Reconstruction of the orientation
    distribution function in single- and multiple-shell q-ball imaging
    within constant solid angle. Magnetic Resonance in Medicine, 64(2),
    554-566. doi:DOI: 10.1002/mrm.22365

.. [2] Descoteaux, M. (2008). PhD Thesis: High Angular
   Resolution Diffusion MRI: from Local Estimation to Segmentation and
   Tractography.
   ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.planarity">
<span class="sig-name descname"><span class="pre">planarity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.planarity" title="Permalink to this definition">#</a></dt>
<dd><section id="id447">
<h4>Returns<a class="headerlink" href="#id447" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphericity<span class="classifier">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor <a href="#id1497"><span class="problematic" id="id448">[1]_</span></a>.</p>
</dd>
</dl>
</section>
<section id="id449">
<h4>Notes<a class="headerlink" href="#id449" title="Permalink to this heading">#</a></h4>
<p>Sphericity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Sphericity =
\frac{2 (\lambda_2 - \lambda_3)}{\lambda_1+\lambda_2+\lambda_3}\]</div>
</section>
<section id="id450">
<h4>References<a class="headerlink" href="#id450" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id451" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz
F., “Geometrical diffusion measures for MRI from tensor basis
analysis” in Proc. 5th Annual ISMRM, 1997.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Given a model fit, predict the signal on the vertices of a sphere

Parameters
———-
gtab : a GradientTable class instance
    This encodes the directions for which a prediction is made

S0 : float array
   The mean non-diffusion weighted signal in each voxel. Default:
   The fitted S0 value in all voxels if it was fitted. Otherwise 1 in
   all voxels.

step : int
    The chunk size as a number of voxels. Optional parameter with
    default value 10,000.

    In order to increase speed of processing, tensor fitting is done
    simultaneously over many voxels. This parameter sets the number of
    voxels that will be fit at once in each iteration. A larger step
    value should speed things up, but it will also take up more memory.
    It is advisable to keep an eye on memory consumption as this value
    is increased.

Notes
—–
The predicted signal is given by:

.. math ::

    S(  heta, b) = S_0 * e^{-b ADC}

Where:
.. math ::
    ADC =       heta Q  heta^T

:math:`       heta` is a unit vector pointing at any direction on the sphere for
which a signal is to be predicted and <span class="math notranslate nohighlight">\(b\)</span> is the b value provided in
the GradientTable input for that direction</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.quadratic_form">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">quadratic_form</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.quadratic_form" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.rd">
<span class="sig-name descname"><span class="pre">rd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.rd" title="Permalink to this definition">#</a></dt>
<dd><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p>
<section id="id452">
<h4>Returns<a class="headerlink" href="#id452" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>rd<span class="classifier">array (V, 1)</span></dt><dd><p>Calculated RD.</p>
</dd>
</dl>
</section>
<section id="id453">
<h4>Notes<a class="headerlink" href="#id453" title="Permalink to this heading">#</a></h4>
<p>RD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[RD = \frac{\lambda_2 + \lambda_3}{2}\]</div>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.shape" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.sphericity">
<span class="sig-name descname"><span class="pre">sphericity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.sphericity" title="Permalink to this definition">#</a></dt>
<dd><section id="id454">
<h4>Returns<a class="headerlink" href="#id454" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphericity<span class="classifier">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor <a href="#id1498"><span class="problematic" id="id455">[1]_</span></a>.</p>
</dd>
</dl>
</section>
<section id="id456">
<h4>Notes<a class="headerlink" href="#id456" title="Permalink to this heading">#</a></h4>
<p>Sphericity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Sphericity = \frac{3 \lambda_3}{\lambda_1+\lambda_2+\lambda_3}\]</div>
</section>
<section id="id457">
<h4>References<a class="headerlink" href="#id457" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id458" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz
F., “Geometrical diffusion measures for MRI from tensor basis
analysis” in Proc. 5th Annual ISMRM, 1997.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.dti.TensorFit.trace">
<span class="sig-name descname"><span class="pre">trace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.trace" title="Permalink to this definition">#</a></dt>
<dd><p>Trace of the tensor calculated from cached eigenvalues.</p>
<section id="id459">
<h4>Returns<a class="headerlink" href="#id459" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>trace<span class="classifier">array (V, 1)</span></dt><dd><p>Calculated trace.</p>
</dd>
</dl>
</section>
<section id="id460">
<h4>Notes<a class="headerlink" href="#id460" title="Permalink to this heading">#</a></h4>
<p>The trace is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[trace = \lambda_1 + \lambda_2 + \lambda_3\]</div>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="fractional-anisotropy">
<h3>fractional_anisotropy<a class="headerlink" href="#fractional-anisotropy" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.fractional_anisotropy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">fractional_anisotropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.fractional_anisotropy" title="Permalink to this definition">#</a></dt>
<dd><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p>
<section id="id461">
<h4>Parameters<a class="headerlink" href="#id461" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>evals<span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</section>
<section id="id462">
<h4>Returns<a class="headerlink" href="#id462" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>fa<span class="classifier">array</span></dt><dd><p>Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>
</dd>
</dl>
</section>
<section id="id463">
<h4>Notes<a class="headerlink" href="#id463" title="Permalink to this heading">#</a></h4>
<p>FA is calculated using the following equation:</p>
<div class="math notranslate nohighlight">
\[FA = \sqrt{\frac{1}{2}\frac{(\lambda_1-\lambda_2)^2+(\lambda_1-
            \lambda_3)^2+(\lambda_2-\lambda_3)^2}{\lambda_1^2+
            \lambda_2^2+\lambda_3^2}}\]</div>
</section>
</dd></dl>

</section>
<section id="geodesic-anisotropy">
<h3>geodesic_anisotropy<a class="headerlink" href="#geodesic-anisotropy" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.geodesic_anisotropy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">geodesic_anisotropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.geodesic_anisotropy" title="Permalink to this definition">#</a></dt>
<dd><p>Geodesic anisotropy (GA) of a diffusion tensor.

Parameters
———-
evals : array-like
    Eigenvalues of a diffusion tensor.
axis : int
    Axis of <cite>evals</cite> which contains 3 eigenvalues.

Returns
——-
ga : array
    Calculated GA. In the range 0 to +infinity

Notes
—–
GA is calculated using the following equation given in <a href="#id1499"><span class="problematic" id="id464">[1]_</span></a>:

.. math::

    GA = sqrt{sum_{i=1}^3
    log^2{left ( lambda_i/&lt;mathbf{D}&gt; right )}},
    quad textrm{where} quad &lt;mathbf{D}&gt; =
    (lambda_1lambda_2lambda_3)^{1/3}

Note that the notation, <span class="math notranslate nohighlight">\(&lt;D&gt;\)</span>, is often used as the mean diffusivity (MD)
of the diffusion tensor and can lead to confusions in the literature
(see <a href="#id1500"><span class="problematic" id="id465">[1]_</span></a> versus <a href="#id1501"><span class="problematic" id="id466">[2]_</span></a> versus <a href="#id1502"><span class="problematic" id="id467">[3]_</span></a> for example). Reference <a href="#id1503"><span class="problematic" id="id468">[2]_</span></a> defines
geodesic anisotropy (GA) with <span class="math notranslate nohighlight">\(&lt;D&gt;\)</span> as the MD in the denominator of the
sum. This is wrong. The original paper <a href="#id1504"><span class="problematic" id="id469">[1]_</span></a> defines GA with
<span class="math notranslate nohighlight">\(&lt;D&gt; = det(D)^{1/3}\)</span>, as the isotropic part of the distance. This might be
an explanation for the confusion. The isotropic part of the diffusion
tensor in Euclidean space is the MD whereas the isotropic part of the
tensor in log-Euclidean space is <span class="math notranslate nohighlight">\(det(D)^{1/3}\)</span>. The Appendix of <a href="#id1505"><span class="problematic" id="id470">[1]_</span></a> and
log-Euclidean derivations from <a href="#id1506"><span class="problematic" id="id471">[3]_</span></a> are clear on this. Hence, all that to
say that <span class="math notranslate nohighlight">\(&lt;D&gt; = det(D)^{1/3}\)</span> here for the GA definition and not MD.

References
———-

.. [1] P. G. Batchelor, M. Moakher, D. Atkinson, F. Calamante,
    A. Connelly, “A rigorous framework for diffusion tensor calculus”,
    Magnetic Resonance in Medicine, vol. 53, pp. 221-225, 2005.

.. [2] M. M. Correia, V. F. Newcombe, G.B. Williams.
    “Contrast-to-noise ratios for indices of anisotropy obtained from
    diffusion MRI: a study with standard clinical b-values at 3T”.
    NeuroImage, vol. 57, pp. 1103-1115, 2011.

.. [3] A. D. Lee, etal, P. M. Thompson.
    “Comparison of fractional and geodesic anisotropy in diffusion tensor
    images of 90 monozygotic and dizygotic twins”. 5th IEEE International
    Symposium on Biomedical Imaging (ISBI), pp. 943-946, May 2008.

.. [4] V. Arsigny, P. Fillard, X. Pennec, N. Ayache.
    “Log-Euclidean metrics for fast and simple calculus on diffusion
    tensors.” Magnetic Resonance in Medecine, vol 56, pp. 411-421, 2006.</p>
</dd></dl>

</section>
<section id="mean-diffusivity">
<h3>mean_diffusivity<a class="headerlink" href="#mean-diffusivity" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.mean_diffusivity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">mean_diffusivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.mean_diffusivity" title="Permalink to this definition">#</a></dt>
<dd><p>Mean Diffusivity (MD) of a diffusion tensor.</p>
<section id="id472">
<h4>Parameters<a class="headerlink" href="#id472" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>evals<span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</section>
<section id="id473">
<h4>Returns<a class="headerlink" href="#id473" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>md<span class="classifier">array</span></dt><dd><p>Calculated MD.</p>
</dd>
</dl>
</section>
<section id="id474">
<h4>Notes<a class="headerlink" href="#id474" title="Permalink to this heading">#</a></h4>
<p>MD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[MD = \frac{\lambda_1 + \lambda_2 + \lambda_3}{3}\]</div>
</section>
</dd></dl>

</section>
<section id="axial-diffusivity">
<h3>axial_diffusivity<a class="headerlink" href="#axial-diffusivity" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.axial_diffusivity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">axial_diffusivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.axial_diffusivity" title="Permalink to this definition">#</a></dt>
<dd><p>Axial Diffusivity (AD) of a diffusion tensor.
Also called parallel diffusivity.</p>
<section id="id475">
<h4>Parameters<a class="headerlink" href="#id475" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>evals<span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</section>
<section id="id476">
<h4>Returns<a class="headerlink" href="#id476" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ad<span class="classifier">array</span></dt><dd><p>Calculated AD.</p>
</dd>
</dl>
</section>
<section id="id477">
<h4>Notes<a class="headerlink" href="#id477" title="Permalink to this heading">#</a></h4>
<p>AD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[AD = \lambda_1\]</div>
</section>
</dd></dl>

</section>
<section id="radial-diffusivity">
<h3>radial_diffusivity<a class="headerlink" href="#radial-diffusivity" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.radial_diffusivity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">radial_diffusivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.radial_diffusivity" title="Permalink to this definition">#</a></dt>
<dd><p>Radial Diffusivity (RD) of a diffusion tensor.
Also called perpendicular diffusivity.</p>
<section id="id478">
<h4>Parameters<a class="headerlink" href="#id478" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>evals<span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</section>
<section id="id479">
<h4>Returns<a class="headerlink" href="#id479" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>rd<span class="classifier">array</span></dt><dd><p>Calculated RD.</p>
</dd>
</dl>
</section>
<section id="id480">
<h4>Notes<a class="headerlink" href="#id480" title="Permalink to this heading">#</a></h4>
<p>RD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[RD = \frac{\lambda_2 + \lambda_3}{2}\]</div>
</section>
</dd></dl>

</section>
<section id="trace">
<h3>trace<a class="headerlink" href="#trace" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.trace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.trace" title="Permalink to this definition">#</a></dt>
<dd><p>Trace of a diffusion tensor.</p>
<section id="id481">
<h4>Parameters<a class="headerlink" href="#id481" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>evals<span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</section>
<section id="id482">
<h4>Returns<a class="headerlink" href="#id482" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>trace<span class="classifier">array</span></dt><dd><p>Calculated trace of the diffusion tensor.</p>
</dd>
</dl>
</section>
<section id="id483">
<h4>Notes<a class="headerlink" href="#id483" title="Permalink to this heading">#</a></h4>
<p>Trace is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Trace = \lambda_1 + \lambda_2 + \lambda_3\]</div>
</section>
</dd></dl>

</section>
<section id="color-fa">
<h3>color_fa<a class="headerlink" href="#color-fa" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.color_fa">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">color_fa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evecs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.color_fa" title="Permalink to this definition">#</a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
<section id="id484">
<h4>Parameters<a class="headerlink" href="#id484" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>fa<span class="classifier">array-like</span></dt><dd><p>Array of the fractional anisotropy (can be 1D, 2D or 3D)</p>
</dd>
<dt>evecs<span class="classifier">array-like</span></dt><dd><p>eigen vectors from the tensor model</p>
</dd>
</dl>
</section>
<section id="id485">
<h4>Returns<a class="headerlink" href="#id485" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>rgb<span class="classifier">Array with 3 channels for each color as the last dimension.</span></dt><dd><p>Colormap of the FA with red for the x value, y for the green
value and z for the blue value.</p>
</dd>
</dl>
</section>
<section id="id486">
<h4>Notes<a class="headerlink" href="#id486" title="Permalink to this heading">#</a></h4>
<p>It is computed from the clipped FA between 0 and 1 using the following
formula</p>
<div class="math notranslate nohighlight">
\[rgb = abs(max(\vec{e})) \times fa\]</div>
</section>
</dd></dl>

</section>
<section id="determinant">
<h3>determinant<a class="headerlink" href="#determinant" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.determinant">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">determinant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.determinant" title="Permalink to this definition">#</a></dt>
<dd><p>The determinant of a tensor, given in quadratic form</p>
<section id="id487">
<h4>Parameters<a class="headerlink" href="#id487" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>q_form<span class="classifier">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</p>
</dd>
</dl>
</section>
<section id="id488">
<h4>Returns<a class="headerlink" href="#id488" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>det<span class="classifier">array</span></dt><dd><p>The determinant of the tensor in each spatial coordinate</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="isotropic">
<h3>isotropic<a class="headerlink" href="#isotropic" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.isotropic">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">isotropic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.isotropic" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the isotropic part of the tensor <a href="#id1507"><span class="problematic" id="id489">[1]_</span></a>.</p>
<section id="id490">
<h4>Parameters<a class="headerlink" href="#id490" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>q_form<span class="classifier">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</dd>
</dl>
</section>
<section id="id491">
<h4>Returns<a class="headerlink" href="#id491" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>A_hat: ndarray</dt><dd><p>The isotropic part of the tensor in each spatial coordinate</p>
</dd>
</dl>
</section>
<section id="id492">
<h4>Notes<a class="headerlink" href="#id492" title="Permalink to this heading">#</a></h4>
<p>The isotropic part of a tensor is defined as (equations 3-5 of <a href="#id1508"><span class="problematic" id="id493">[1]_</span></a>):</p>
<div class="math notranslate nohighlight">
\[\bar{A} = \frac{1}{2} tr(A) I\]</div>
</section>
<section id="id494">
<h4>References<a class="headerlink" href="#id494" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id495" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Daniel B. Ennis and G. Kindlmann, “Orthogonal Tensor
Invariants and the Analysis of Diffusion Tensor Magnetic Resonance
Images”, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,
2006.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="deviatoric">
<h3>deviatoric<a class="headerlink" href="#deviatoric" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.deviatoric">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">deviatoric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.deviatoric" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the deviatoric (anisotropic) part of the tensor <a href="#id1509"><span class="problematic" id="id496">[1]_</span></a>.

Parameters
———-
q_form : ndarray
    The quadratic form of a tensor, or an array with quadratic forms of
    tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).

Returns
——-
A_squiggle : ndarray
    The deviatoric part of the tensor in each spatial coordinate.

Notes
—–
The deviatoric part of the tensor is defined as (equations 3-5 in <a href="#id1510"><span class="problematic" id="id497">[1]_</span></a>):

.. math ::
     widetilde{A} = A - bar{A}

Where <span class="math notranslate nohighlight">\(A\)</span> is the tensor quadratic form and <span class="math notranslate nohighlight">\(\bar{A}\)</span> is the anisotropic
part of the tensor.

References
———-
.. [1] Daniel B. Ennis and G. Kindlmann, “Orthogonal Tensor
    Invariants and the Analysis of Diffusion Tensor Magnetic Resonance
    Images”, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,
    2006.</p>
</dd></dl>

</section>
<section id="norm">
<h3>norm<a class="headerlink" href="#norm" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.norm">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.norm" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the Frobenius norm of a tensor quadratic form</p>
<section id="id498">
<h4>Parameters<a class="headerlink" href="#id498" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>q_form: ndarray</dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</dd>
</dl>
</section>
<section id="id499">
<h4>Returns<a class="headerlink" href="#id499" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>norm<span class="classifier">ndarray</span></dt><dd><p>The Frobenius norm of the 3,3 tensor q_form in each spatial
coordinate.</p>
</dd>
</dl>
</section>
<section id="id500">
<h4>Notes<a class="headerlink" href="#id500" title="Permalink to this heading">#</a></h4>
<p>The Frobenius norm is defined as:</p>
<dl class="field-list simple">
<dt class="field-odd">math<span class="colon">:</span></dt>
<dd class="field-odd"><p>||A||_F = [sum_{i,j} abs(a_{i,j})^2]^{1/2}</p>
</dd>
</dl>
</section>
<section id="see-also">
<h4>See Also<a class="headerlink" href="#see-also" title="Permalink to this heading">#</a></h4>
<p>np.linalg.norm</p>
</section>
</dd></dl>

</section>
<section id="mode">
<h3>mode<a class="headerlink" href="#mode" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.mode">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.mode" title="Permalink to this definition">#</a></dt>
<dd><p>Mode (MO) of a diffusion tensor <a href="#id1511"><span class="problematic" id="id501">[1]_</span></a>.

Parameters
———-
q_form : ndarray
    The quadratic form of a tensor, or an array with quadratic forms of
    tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).

Returns
——-
mode : array
    Calculated tensor mode in each spatial coordinate.

Notes
—–
Mode ranges between -1 (planar anisotropy) and +1 (linear anisotropy)
with 0 representing orthotropy. Mode is calculated with the
following equation (equation 9 in <a href="#id1512"><span class="problematic" id="id502">[1]_</span></a>):

.. math::

    Mode = 3*sqrt{6}*det(widetilde{A}/norm(widetilde{A}))

Where <span class="math notranslate nohighlight">\(\widetilde{A}\)</span> is the deviatoric part of the tensor quadratic form.

References
———-

.. [1] Daniel B. Ennis and G. Kindlmann, “Orthogonal Tensor
    Invariants and the Analysis of Diffusion Tensor Magnetic Resonance
    Images”, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,
    2006.</p>
</dd></dl>

</section>
<section id="linearity">
<h3>linearity<a class="headerlink" href="#linearity" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.linearity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">linearity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.linearity" title="Permalink to this definition">#</a></dt>
<dd><p>The linearity of the tensor <a href="#id1513"><span class="problematic" id="id503">[1]_</span></a></p>
<section id="id504">
<h4>Parameters<a class="headerlink" href="#id504" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>evals<span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</section>
<section id="id505">
<h4>Returns<a class="headerlink" href="#id505" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>linearity<span class="classifier">array</span></dt><dd><p>Calculated linearity of the diffusion tensor.</p>
</dd>
</dl>
</section>
<section id="id506">
<h4>Notes<a class="headerlink" href="#id506" title="Permalink to this heading">#</a></h4>
<p>Linearity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Linearity = \frac{\lambda_1-\lambda_2}{\lambda_1+\lambda_2+\lambda_3}\]</div>
</section>
<section id="id507">
<h4>References<a class="headerlink" href="#id507" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id508" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz F.,
“Geometrical diffusion measures for MRI from tensor basis analysis” in
Proc. 5th Annual ISMRM, 1997.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="planarity">
<h3>planarity<a class="headerlink" href="#planarity" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.planarity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">planarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.planarity" title="Permalink to this definition">#</a></dt>
<dd><p>The planarity of the tensor <a href="#id1514"><span class="problematic" id="id509">[1]_</span></a></p>
<section id="id510">
<h4>Parameters<a class="headerlink" href="#id510" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>evals<span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</section>
<section id="id511">
<h4>Returns<a class="headerlink" href="#id511" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>linearity<span class="classifier">array</span></dt><dd><p>Calculated linearity of the diffusion tensor.</p>
</dd>
</dl>
</section>
<section id="id512">
<h4>Notes<a class="headerlink" href="#id512" title="Permalink to this heading">#</a></h4>
<p>Planarity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Planarity =
\frac{2 (\lambda_2-\lambda_3)}{\lambda_1+\lambda_2+\lambda_3}\]</div>
</section>
<section id="id513">
<h4>References<a class="headerlink" href="#id513" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id514" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz F.,
“Geometrical diffusion measures for MRI from tensor basis analysis” in
Proc. 5th Annual ISMRM, 1997.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="sphericity">
<h3>sphericity<a class="headerlink" href="#sphericity" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.sphericity">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">sphericity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.sphericity" title="Permalink to this definition">#</a></dt>
<dd><p>The sphericity of the tensor <a href="#id1515"><span class="problematic" id="id515">[1]_</span></a></p>
<section id="id516">
<h4>Parameters<a class="headerlink" href="#id516" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>evals<span class="classifier">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</section>
<section id="id517">
<h4>Returns<a class="headerlink" href="#id517" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphericity<span class="classifier">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor.</p>
</dd>
</dl>
</section>
<section id="id518">
<h4>Notes<a class="headerlink" href="#id518" title="Permalink to this heading">#</a></h4>
<p>Sphericity is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Sphericity = \frac{3 \lambda_3)}{\lambda_1+\lambda_2+\lambda_3}\]</div>
</section>
<section id="id519">
<h4>References<a class="headerlink" href="#id519" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id520" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz F.,
“Geometrical diffusion measures for MRI from tensor basis analysis” in
Proc. 5th Annual ISMRM, 1997.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="apparent-diffusion-coef">
<h3>apparent_diffusion_coef<a class="headerlink" href="#apparent-diffusion-coef" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.apparent_diffusion_coef">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">apparent_diffusion_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_form</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.apparent_diffusion_coef" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the apparent diffusion coefficient (ADC) in each direction of a
sphere.</p>
<section id="id521">
<h4>Parameters<a class="headerlink" href="#id521" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>q_form<span class="classifier">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (…, 3, 3)</p>
</dd>
<dt>sphere<span class="classifier">a Sphere class instance</span></dt><dd><p>The ADC will be calculated for each of the vertices in the sphere</p>
</dd>
</dl>
</section>
<section id="id522">
<h4>Notes<a class="headerlink" href="#id522" title="Permalink to this heading">#</a></h4>
<p>The calculation of ADC, relies on the following relationship:</p>
<div class="math notranslate nohighlight">
\[ADC = \vec{b} Q \vec{b}^T\]</div>
<p>Where Q is the quadratic form of the tensor.</p>
</section>
</dd></dl>

</section>
<section id="tensor-prediction">
<h3>tensor_prediction<a class="headerlink" href="#tensor-prediction" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.tensor_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">tensor_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dti_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.tensor_prediction" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal given tensor parameters.

Parameters
———-
dti_params : ndarray
    Tensor parameters. The last dimension should have 12 tensor
    parameters: 3 eigenvalues, followed by the 3 corresponding
    eigenvectors.

gtab : a GradientTable class instance
    The gradient table for this prediction

S0 : float or ndarray
    The non diffusion-weighted signal in every voxel, or across all
    voxels. Default: 1

Notes
—–
The predicted signal is given by: <span class="math notranslate nohighlight">\(S(       heta, b) = S_0 * e^{-b ADC}\)</span>, where
<span class="math notranslate nohighlight">\(ADC =      heta Q  heta^T\)</span>, :math:`      heta` is a unit vector pointing at any
direction on the sphere for which a signal is to be predicted, <span class="math notranslate nohighlight">\(b\)</span> is the b
value provided in the GradientTable input for that direction, <span class="math notranslate nohighlight">\(Q\)</span> is the
quadratic form of the tensor determined by the input parameters.</p>
</dd></dl>

</section>
<section id="iter-fit-tensor">
<h3>iter_fit_tensor<a class="headerlink" href="#iter-fit-tensor" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.iter_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">iter_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.iter_fit_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Wrap a fit_tensor func and iterate over chunks of data with given length</p>
<p>Splits data into a number of chunks of specified size and iterates the
decorated fit_tensor function over them. This is useful to counteract the
temporary but significant memory usage increase in fit_tensor functions
that use vectorized operations and need to store large temporary arrays for
their vectorized operations.</p>
<section id="id523">
<h4>Parameters<a class="headerlink" href="#id523" title="Permalink to this heading">#</a></h4>
<dl>
<dt>step<span class="classifier">int</span></dt><dd><p>The chunk size as a number of voxels. Optional parameter with default
value 10,000.</p>
<p>In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. This parameter sets the number of
voxels that will be fit at once in each iteration. A larger step value
should speed things up, but it will also take up more memory. It is
advisable to keep an eye on memory consumption as this value is
increased.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="wls-fit-tensor">
<h3>wls_fit_tensor<a class="headerlink" href="#wls-fit-tensor" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.wls_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">wls_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.wls_fit_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Computes weighted least squares (WLS) fit to calculate self-diffusion
tensor using a linear regression model <a href="#id1516"><span class="problematic" id="id524">[1]_</span></a>.</p>
<section id="id525">
<h4>Parameters<a class="headerlink" href="#id525" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt>data<span class="classifier">array ([X, Y, Z, …], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt>return_S0_hat<span class="classifier">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
</dl>
</section>
<section id="id526">
<h4>Returns<a class="headerlink" href="#id526" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>eigvals<span class="classifier">array (…, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt>eigvecs<span class="classifier">array (…, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
</dl>
</section>
<section id="id527">
<h4>See Also<a class="headerlink" href="#id527" title="Permalink to this heading">#</a></h4>
<p>decompose_tensor</p>
</section>
<section id="id528">
<h4>Notes<a class="headerlink" href="#id528" title="Permalink to this heading">#</a></h4>
<p>In Chung, et al. 2006, the regression of the WLS fit needed an unbiased
preliminary estimate of the weights and therefore the ordinary least
squares (OLS) estimates were used. A “two pass” method was implemented:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>calculate OLS estimates of the data</p></li>
<li><p>apply the OLS estimates as weights to the WLS fit of the data</p></li>
</ol>
</div></blockquote>
<p>This ensured heteroscedasticity could be properly modeled for various
types of bootstrap resampling (namely residual bootstrap).</p>
<div class="math notranslate nohighlight">
\[\begin{split}y = \mathrm{data} \\
X = \mathrm{design matrix} \\
\hat{\beta}_\mathrm{WLS} =
\mathrm{desired regression coefficients (e.g. tensor)}\\
\\
\hat{\beta}_\mathrm{WLS} = (X^T W X)^{-1} X^T W y \\
\\
W = \mathrm{diag}((X \hat{\beta}_\mathrm{OLS})^2),
\mathrm{where} \hat{\beta}_\mathrm{OLS} = (X^T X)^{-1} X^T y\end{split}\]</div>
</section>
<section id="id529">
<h4>References<a class="headerlink" href="#id529" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id530" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Chung, SW., Lu, Y., Henry, R.G., 2006. Comparison of bootstrap
approaches for estimation of uncertainties of DTI parameters.
NeuroImage 33, 531-541.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="ols-fit-tensor">
<h3>ols_fit_tensor<a class="headerlink" href="#ols-fit-tensor" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.ols_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">ols_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_lower_triangular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.ols_fit_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Computes ordinary least squares (OLS) fit to calculate self-diffusion
tensor using a linear regression model <a href="#id1517"><span class="problematic" id="id531">[1]_</span></a>.</p>
<section id="id532">
<h4>Parameters<a class="headerlink" href="#id532" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt>data<span class="classifier">array ([X, Y, Z, …], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt>return_S0_hat<span class="classifier">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt>return_lower_triangular<span class="classifier">bool</span></dt><dd><p>Boolean to return (True) or not (False) the coefficients of the fit.</p>
</dd>
</dl>
</section>
<section id="id533">
<h4>Returns<a class="headerlink" href="#id533" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>eigvals<span class="classifier">array (…, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt>eigvecs<span class="classifier">array (…, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
</dl>
</section>
<section id="id534">
<h4>See Also<a class="headerlink" href="#id534" title="Permalink to this heading">#</a></h4>
<p>WLS_fit_tensor, decompose_tensor, design_matrix</p>
</section>
<section id="id535">
<h4>Notes<a class="headerlink" href="#id535" title="Permalink to this heading">#</a></h4>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}y = \mathrm{data} \\
X = \mathrm{design matrix} \\\end{split}\\\hat{\beta}_\mathrm{OLS} = (X^T X)^{-1} X^T y\end{aligned}\end{align} \]</div>
</section>
<section id="id536">
<h4>References<a class="headerlink" href="#id536" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id537" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Chung, SW., Lu, Y., Henry, R.G., 2006. Comparison of bootstrap
approaches for estimation of uncertainties of DTI parameters.
NeuroImage 33, 531-541.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="nlls-fit-tensor">
<h3>nlls_fit_tensor<a class="headerlink" href="#nlls-fit-tensor" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.nlls_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">nlls_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fail_is_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.nlls_fit_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Fit the cumulant expansion params (e.g. DTI, DKI) using non-linear
least-squares.</p>
<section id="id538">
<h4>Parameters<a class="headerlink" href="#id538" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (g, Npar)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients. First six parameters of design matrix should correspond
to the six unique diffusion tensor elements in the lower triangular
order (Dxx, Dxy, Dyy, Dxz, Dyz, Dzz), while last parameter to -log(S0)</p>
</dd>
<dt>data<span class="classifier">array ([X, Y, Z, …], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt>weighting: str</dt><dd><p>the weighting scheme to use in considering the
squared-error. Default behavior is to use uniform weighting. Other
options: ‘sigma’ ‘gmm’</p>
</dd>
<dt>sigma<span class="classifier">array (optional)</span></dt><dd><p>If ‘sigma’ weighting is used, we will weight the error function
according to 1/sigma^2. If ‘gmm’, the Geman-Mclure
M-estimator is used for weighting (see below).</p>
</dd>
<dt>jac<span class="classifier">bool</span></dt><dd><p>Use the Jacobian? Default: True</p>
</dd>
<dt>return_S0_hat<span class="classifier">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt>fail_is_nan<span class="classifier">bool</span></dt><dd><p>Boolean to set failed NL fitting to NaN (True) or LS (False, default).</p>
</dd>
</dl>
</section>
<section id="id539">
<h4>Returns<a class="headerlink" href="#id539" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>nlls_params: the eigen-values and eigen-vectors of the tensor in each</dt><dd><p>voxel.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="restore-fit-tensor">
<h3>restore_fit_tensor<a class="headerlink" href="#restore-fit-tensor" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.restore_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">restore_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fail_is_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.restore_fit_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Use the RESTORE algorithm <a href="#id1518"><span class="problematic" id="id540">[1]_</span></a> to calculate a robust tensor fit</p>
<section id="id541">
<h4>Parameters<a class="headerlink" href="#id541" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array of shape (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt>data<span class="classifier">array of shape ([X, Y, Z, n_directions], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt>sigma<span class="classifier">float, array of shape [n_directions], array of shape [X, Y, Z]</span></dt><dd><p>An estimate of the variance. <a href="#id1519"><span class="problematic" id="id542">[1]_</span></a> recommend to use
1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).
Array with ndim &gt; 1 corresponds to spatially varying sigma, so if
providing spatially-flattened data and spatially-varying sigma,
provide array with shape [num_vox, 1].</p>
</dd>
<dt>jac<span class="classifier">bool, optional</span></dt><dd><p>Whether to use the Jacobian of the tensor to speed the non-linear
optimization procedure used to fit the tensor parameters (see also
<a class="reference internal" href="#dipy.reconst.dti.nlls_fit_tensor" title="dipy.reconst.dti.nlls_fit_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">nlls_fit_tensor()</span></code></a>). Default: True</p>
</dd>
<dt>return_S0_hat<span class="classifier">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt>fail_is_nan<span class="classifier">bool</span></dt><dd><p>Boolean to set failed NL fitting to NaN (True) or LS (False, default).</p>
</dd>
</dl>
</section>
<section id="id543">
<h4>Returns<a class="headerlink" href="#id543" title="Permalink to this heading">#</a></h4>
<p>restore_params : an estimate of the tensor parameters in each voxel.</p>
</section>
<section id="id544">
<h4>References<a class="headerlink" href="#id544" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id545" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Chang, L-C, Jones, DK and Pierpaoli, C (2005). RESTORE: robust</p>
</aside>
</aside>
<p>estimation of tensors by outlier rejection. MRM, 53: 1088-95.</p>
</section>
</dd></dl>

</section>
<section id="lt-indices">
<h3>_lt_indices<a class="headerlink" href="#lt-indices" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti._lt_indices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">_lt_indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti._lt_indices" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>ndarray(shape, dtype=float, buffer=None, offset=0,</dt><dd><p>strides=None, order=None)</p>
</dd>
</dl>
<p>An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)</p>
<p>Arrays should be constructed using <cite>array</cite>, <cite>zeros</cite> or <cite>empty</cite> (refer
to the See Also section below).  The parameters given here refer to
a low-level method (<cite>ndarray(…)</cite>) for instantiating an array.</p>
<p>For more information, refer to the <cite>numpy</cite> module and examine the
methods and attributes of an array.</p>
<section id="id546">
<h4>Parameters<a class="headerlink" href="#id546" title="Permalink to this heading">#</a></h4>
<p>(for the __new__ method; see Notes below)</p>
<dl class="simple">
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of created array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Any object that can be interpreted as a numpy data type.</p>
</dd>
<dt>buffer<span class="classifier">object exposing buffer interface, optional</span></dt><dd><p>Used to fill the array with data.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Offset of array data in buffer.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints, optional</span></dt><dd><p>Strides of data in memory.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Row-major (C-style) or column-major (Fortran-style) order.</p>
</dd>
</dl>
</section>
<section id="attributes">
<h4>Attributes<a class="headerlink" href="#attributes" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">ndarray</span></dt><dd><p>Transpose of the array.</p>
</dd>
<dt>data<span class="classifier">buffer</span></dt><dd><p>The array’s elements, in memory.</p>
</dd>
<dt>dtype<span class="classifier">dtype object</span></dt><dd><p>Describes the format of the elements in the array.</p>
</dd>
<dt>flags<span class="classifier">dict</span></dt><dd><p>Dictionary containing information related to memory use, e.g.,
‘C_CONTIGUOUS’, ‘OWNDATA’, ‘WRITEABLE’, etc.</p>
</dd>
<dt>flat<span class="classifier">numpy.flatiter object</span></dt><dd><p>Flattened version of the array as an iterator.  The iterator
allows assignments, e.g., <code class="docutils literal notranslate"><span class="pre">x.flat</span> <span class="pre">=</span> <span class="pre">3</span></code> (See <cite>ndarray.flat</cite> for
assignment examples; TODO).</p>
</dd>
<dt>imag<span class="classifier">ndarray</span></dt><dd><p>Imaginary part of the array.</p>
</dd>
<dt>real<span class="classifier">ndarray</span></dt><dd><p>Real part of the array.</p>
</dd>
<dt>size<span class="classifier">int</span></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt>itemsize<span class="classifier">int</span></dt><dd><p>The memory use of each array element in bytes.</p>
</dd>
<dt>nbytes<span class="classifier">int</span></dt><dd><p>The total number of bytes required to store the array data,
i.e., <code class="docutils literal notranslate"><span class="pre">itemsize</span> <span class="pre">*</span> <span class="pre">size</span></code>.</p>
</dd>
<dt>ndim<span class="classifier">int</span></dt><dd><p>The array’s number of dimensions.</p>
</dd>
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of the array.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints</span></dt><dd><p>The step-size required to move from one element to the next in
memory. For example, a contiguous <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code> array of type
<code class="docutils literal notranslate"><span class="pre">int16</span></code> in C-order has strides <code class="docutils literal notranslate"><span class="pre">(8,</span> <span class="pre">2)</span></code>.  This implies that
to move from element to element in memory requires jumps of 2 bytes.
To move from row-to-row, one needs to jump 8 bytes at a time
(<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4</span></code>).</p>
</dd>
<dt>ctypes<span class="classifier">ctypes object</span></dt><dd><p>Class containing properties of the array needed for interaction
with ctypes.</p>
</dd>
<dt>base<span class="classifier">ndarray</span></dt><dd><p>If the array is a view into another array, that array is its <cite>base</cite>
(unless that array is also a view).  The <cite>base</cite> array is where the
array data is actually stored.</p>
</dd>
</dl>
</section>
<section id="id547">
<h4>See Also<a class="headerlink" href="#id547" title="Permalink to this heading">#</a></h4>
<p>array : Construct an array.
zeros : Create an array, each element of which is zero.
empty : Create an array, but leave its allocated memory unchanged (i.e.,</p>
<blockquote>
<div><p>it contains “garbage”).</p>
</div></blockquote>
<p>dtype : Create a data-type.
numpy.typing.NDArray : An ndarray alias <a class="reference external" href="https://docs.python.org/3/glossary.html#term-generic-type" title="(in Python v3.11)"><span class="xref std std-term">generic</span></a></p>
<blockquote>
<div><p>w.r.t. its <cite>dtype.type &lt;numpy.dtype.type&gt;</cite>.</p>
</div></blockquote>
</section>
<section id="id548">
<h4>Notes<a class="headerlink" href="#id548" title="Permalink to this heading">#</a></h4>
<p>There are two modes of creating an array using <code class="docutils literal notranslate"><span class="pre">__new__</span></code>:</p>
<ol class="arabic simple">
<li><p>If <cite>buffer</cite> is None, then only <cite>shape</cite>, <cite>dtype</cite>, and <cite>order</cite>
are used.</p></li>
<li><p>If <cite>buffer</cite> is an object exposing the buffer interface, then
all keywords are interpreted.</p></li>
</ol>
<p>No <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method is needed because the array is fully initialized
after the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method.</p>
</section>
<section id="id549">
<h4>Examples<a class="headerlink" href="#id549" title="Permalink to this heading">#</a></h4>
<p>These examples illustrate the low-level <cite>ndarray</cite> constructor.  Refer
to the <cite>See Also</cite> section above for easier ways of constructing an
ndarray.</p>
<p>First mode, <cite>buffer</cite> is None:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0.0e+000, 0.0e+000], # random</span>
<span class="go">       [     nan, 2.5e-323]])</span>
</pre></div>
</div>
<p>Second mode:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span>
<span class="gp">... </span>           <span class="n">offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># offset = 1*itemsize, i.e. skip first element</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="from-lower-triangular">
<h3>from_lower_triangular<a class="headerlink" href="#from-lower-triangular" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.from_lower_triangular">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">from_lower_triangular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.from_lower_triangular" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a tensor given the six unique tensor elements</p>
<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,
Dyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are
ignored.</p>
<section id="id550">
<h4>Parameters<a class="headerlink" href="#id550" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>D<span class="classifier">array_like, (…, &gt;6)</span></dt><dd><p>Unique elements of the tensors</p>
</dd>
</dl>
</section>
<section id="id551">
<h4>Returns<a class="headerlink" href="#id551" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tensor<span class="classifier">ndarray (…, 3, 3)</span></dt><dd><p>3 by 3 tensors</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="lt-rows">
<h3>_lt_rows<a class="headerlink" href="#lt-rows" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti._lt_rows">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">_lt_rows</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti._lt_rows" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>ndarray(shape, dtype=float, buffer=None, offset=0,</dt><dd><p>strides=None, order=None)</p>
</dd>
</dl>
<p>An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)</p>
<p>Arrays should be constructed using <cite>array</cite>, <cite>zeros</cite> or <cite>empty</cite> (refer
to the See Also section below).  The parameters given here refer to
a low-level method (<cite>ndarray(…)</cite>) for instantiating an array.</p>
<p>For more information, refer to the <cite>numpy</cite> module and examine the
methods and attributes of an array.</p>
<section id="id552">
<h4>Parameters<a class="headerlink" href="#id552" title="Permalink to this heading">#</a></h4>
<p>(for the __new__ method; see Notes below)</p>
<dl class="simple">
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of created array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Any object that can be interpreted as a numpy data type.</p>
</dd>
<dt>buffer<span class="classifier">object exposing buffer interface, optional</span></dt><dd><p>Used to fill the array with data.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Offset of array data in buffer.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints, optional</span></dt><dd><p>Strides of data in memory.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Row-major (C-style) or column-major (Fortran-style) order.</p>
</dd>
</dl>
</section>
<section id="id553">
<h4>Attributes<a class="headerlink" href="#id553" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">ndarray</span></dt><dd><p>Transpose of the array.</p>
</dd>
<dt>data<span class="classifier">buffer</span></dt><dd><p>The array’s elements, in memory.</p>
</dd>
<dt>dtype<span class="classifier">dtype object</span></dt><dd><p>Describes the format of the elements in the array.</p>
</dd>
<dt>flags<span class="classifier">dict</span></dt><dd><p>Dictionary containing information related to memory use, e.g.,
‘C_CONTIGUOUS’, ‘OWNDATA’, ‘WRITEABLE’, etc.</p>
</dd>
<dt>flat<span class="classifier">numpy.flatiter object</span></dt><dd><p>Flattened version of the array as an iterator.  The iterator
allows assignments, e.g., <code class="docutils literal notranslate"><span class="pre">x.flat</span> <span class="pre">=</span> <span class="pre">3</span></code> (See <cite>ndarray.flat</cite> for
assignment examples; TODO).</p>
</dd>
<dt>imag<span class="classifier">ndarray</span></dt><dd><p>Imaginary part of the array.</p>
</dd>
<dt>real<span class="classifier">ndarray</span></dt><dd><p>Real part of the array.</p>
</dd>
<dt>size<span class="classifier">int</span></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt>itemsize<span class="classifier">int</span></dt><dd><p>The memory use of each array element in bytes.</p>
</dd>
<dt>nbytes<span class="classifier">int</span></dt><dd><p>The total number of bytes required to store the array data,
i.e., <code class="docutils literal notranslate"><span class="pre">itemsize</span> <span class="pre">*</span> <span class="pre">size</span></code>.</p>
</dd>
<dt>ndim<span class="classifier">int</span></dt><dd><p>The array’s number of dimensions.</p>
</dd>
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of the array.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints</span></dt><dd><p>The step-size required to move from one element to the next in
memory. For example, a contiguous <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code> array of type
<code class="docutils literal notranslate"><span class="pre">int16</span></code> in C-order has strides <code class="docutils literal notranslate"><span class="pre">(8,</span> <span class="pre">2)</span></code>.  This implies that
to move from element to element in memory requires jumps of 2 bytes.
To move from row-to-row, one needs to jump 8 bytes at a time
(<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4</span></code>).</p>
</dd>
<dt>ctypes<span class="classifier">ctypes object</span></dt><dd><p>Class containing properties of the array needed for interaction
with ctypes.</p>
</dd>
<dt>base<span class="classifier">ndarray</span></dt><dd><p>If the array is a view into another array, that array is its <cite>base</cite>
(unless that array is also a view).  The <cite>base</cite> array is where the
array data is actually stored.</p>
</dd>
</dl>
</section>
<section id="id554">
<h4>See Also<a class="headerlink" href="#id554" title="Permalink to this heading">#</a></h4>
<p>array : Construct an array.
zeros : Create an array, each element of which is zero.
empty : Create an array, but leave its allocated memory unchanged (i.e.,</p>
<blockquote>
<div><p>it contains “garbage”).</p>
</div></blockquote>
<p>dtype : Create a data-type.
numpy.typing.NDArray : An ndarray alias <a class="reference external" href="https://docs.python.org/3/glossary.html#term-generic-type" title="(in Python v3.11)"><span class="xref std std-term">generic</span></a></p>
<blockquote>
<div><p>w.r.t. its <cite>dtype.type &lt;numpy.dtype.type&gt;</cite>.</p>
</div></blockquote>
</section>
<section id="id555">
<h4>Notes<a class="headerlink" href="#id555" title="Permalink to this heading">#</a></h4>
<p>There are two modes of creating an array using <code class="docutils literal notranslate"><span class="pre">__new__</span></code>:</p>
<ol class="arabic simple">
<li><p>If <cite>buffer</cite> is None, then only <cite>shape</cite>, <cite>dtype</cite>, and <cite>order</cite>
are used.</p></li>
<li><p>If <cite>buffer</cite> is an object exposing the buffer interface, then
all keywords are interpreted.</p></li>
</ol>
<p>No <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method is needed because the array is fully initialized
after the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method.</p>
</section>
<section id="id556">
<h4>Examples<a class="headerlink" href="#id556" title="Permalink to this heading">#</a></h4>
<p>These examples illustrate the low-level <cite>ndarray</cite> constructor.  Refer
to the <cite>See Also</cite> section above for easier ways of constructing an
ndarray.</p>
<p>First mode, <cite>buffer</cite> is None:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0.0e+000, 0.0e+000], # random</span>
<span class="go">       [     nan, 2.5e-323]])</span>
</pre></div>
</div>
<p>Second mode:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span>
<span class="gp">... </span>           <span class="n">offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># offset = 1*itemsize, i.e. skip first element</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="lt-cols">
<h3>_lt_cols<a class="headerlink" href="#lt-cols" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti._lt_cols">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">_lt_cols</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti._lt_cols" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>ndarray(shape, dtype=float, buffer=None, offset=0,</dt><dd><p>strides=None, order=None)</p>
</dd>
</dl>
<p>An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)</p>
<p>Arrays should be constructed using <cite>array</cite>, <cite>zeros</cite> or <cite>empty</cite> (refer
to the See Also section below).  The parameters given here refer to
a low-level method (<cite>ndarray(…)</cite>) for instantiating an array.</p>
<p>For more information, refer to the <cite>numpy</cite> module and examine the
methods and attributes of an array.</p>
<section id="id557">
<h4>Parameters<a class="headerlink" href="#id557" title="Permalink to this heading">#</a></h4>
<p>(for the __new__ method; see Notes below)</p>
<dl class="simple">
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of created array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Any object that can be interpreted as a numpy data type.</p>
</dd>
<dt>buffer<span class="classifier">object exposing buffer interface, optional</span></dt><dd><p>Used to fill the array with data.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Offset of array data in buffer.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints, optional</span></dt><dd><p>Strides of data in memory.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Row-major (C-style) or column-major (Fortran-style) order.</p>
</dd>
</dl>
</section>
<section id="id558">
<h4>Attributes<a class="headerlink" href="#id558" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">ndarray</span></dt><dd><p>Transpose of the array.</p>
</dd>
<dt>data<span class="classifier">buffer</span></dt><dd><p>The array’s elements, in memory.</p>
</dd>
<dt>dtype<span class="classifier">dtype object</span></dt><dd><p>Describes the format of the elements in the array.</p>
</dd>
<dt>flags<span class="classifier">dict</span></dt><dd><p>Dictionary containing information related to memory use, e.g.,
‘C_CONTIGUOUS’, ‘OWNDATA’, ‘WRITEABLE’, etc.</p>
</dd>
<dt>flat<span class="classifier">numpy.flatiter object</span></dt><dd><p>Flattened version of the array as an iterator.  The iterator
allows assignments, e.g., <code class="docutils literal notranslate"><span class="pre">x.flat</span> <span class="pre">=</span> <span class="pre">3</span></code> (See <cite>ndarray.flat</cite> for
assignment examples; TODO).</p>
</dd>
<dt>imag<span class="classifier">ndarray</span></dt><dd><p>Imaginary part of the array.</p>
</dd>
<dt>real<span class="classifier">ndarray</span></dt><dd><p>Real part of the array.</p>
</dd>
<dt>size<span class="classifier">int</span></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt>itemsize<span class="classifier">int</span></dt><dd><p>The memory use of each array element in bytes.</p>
</dd>
<dt>nbytes<span class="classifier">int</span></dt><dd><p>The total number of bytes required to store the array data,
i.e., <code class="docutils literal notranslate"><span class="pre">itemsize</span> <span class="pre">*</span> <span class="pre">size</span></code>.</p>
</dd>
<dt>ndim<span class="classifier">int</span></dt><dd><p>The array’s number of dimensions.</p>
</dd>
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of the array.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints</span></dt><dd><p>The step-size required to move from one element to the next in
memory. For example, a contiguous <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code> array of type
<code class="docutils literal notranslate"><span class="pre">int16</span></code> in C-order has strides <code class="docutils literal notranslate"><span class="pre">(8,</span> <span class="pre">2)</span></code>.  This implies that
to move from element to element in memory requires jumps of 2 bytes.
To move from row-to-row, one needs to jump 8 bytes at a time
(<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4</span></code>).</p>
</dd>
<dt>ctypes<span class="classifier">ctypes object</span></dt><dd><p>Class containing properties of the array needed for interaction
with ctypes.</p>
</dd>
<dt>base<span class="classifier">ndarray</span></dt><dd><p>If the array is a view into another array, that array is its <cite>base</cite>
(unless that array is also a view).  The <cite>base</cite> array is where the
array data is actually stored.</p>
</dd>
</dl>
</section>
<section id="id559">
<h4>See Also<a class="headerlink" href="#id559" title="Permalink to this heading">#</a></h4>
<p>array : Construct an array.
zeros : Create an array, each element of which is zero.
empty : Create an array, but leave its allocated memory unchanged (i.e.,</p>
<blockquote>
<div><p>it contains “garbage”).</p>
</div></blockquote>
<p>dtype : Create a data-type.
numpy.typing.NDArray : An ndarray alias <a class="reference external" href="https://docs.python.org/3/glossary.html#term-generic-type" title="(in Python v3.11)"><span class="xref std std-term">generic</span></a></p>
<blockquote>
<div><p>w.r.t. its <cite>dtype.type &lt;numpy.dtype.type&gt;</cite>.</p>
</div></blockquote>
</section>
<section id="id560">
<h4>Notes<a class="headerlink" href="#id560" title="Permalink to this heading">#</a></h4>
<p>There are two modes of creating an array using <code class="docutils literal notranslate"><span class="pre">__new__</span></code>:</p>
<ol class="arabic simple">
<li><p>If <cite>buffer</cite> is None, then only <cite>shape</cite>, <cite>dtype</cite>, and <cite>order</cite>
are used.</p></li>
<li><p>If <cite>buffer</cite> is an object exposing the buffer interface, then
all keywords are interpreted.</p></li>
</ol>
<p>No <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method is needed because the array is fully initialized
after the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method.</p>
</section>
<section id="id561">
<h4>Examples<a class="headerlink" href="#id561" title="Permalink to this heading">#</a></h4>
<p>These examples illustrate the low-level <cite>ndarray</cite> constructor.  Refer
to the <cite>See Also</cite> section above for easier ways of constructing an
ndarray.</p>
<p>First mode, <cite>buffer</cite> is None:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0.0e+000, 0.0e+000], # random</span>
<span class="go">       [     nan, 2.5e-323]])</span>
</pre></div>
</div>
<p>Second mode:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span>
<span class="gp">... </span>           <span class="n">offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># offset = 1*itemsize, i.e. skip first element</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="lower-triangular">
<h3>lower_triangular<a class="headerlink" href="#lower-triangular" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.lower_triangular">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">lower_triangular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.lower_triangular" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the six lower triangular values of the tensor ordered as
(Dxx, Dxy, Dyy, Dxz, Dyz, Dzz) and a dummy variable if b0 is not None.</p>
<section id="id562">
<h4>Parameters<a class="headerlink" href="#id562" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tensor<span class="classifier">array_like (…, 3, 3)</span></dt><dd><p>a collection of 3, 3 diffusion tensors</p>
</dd>
<dt>b0<span class="classifier">float</span></dt><dd><p>if b0 is not none log(b0) is returned as the dummy variable</p>
</dd>
</dl>
</section>
<section id="id563">
<h4>Returns<a class="headerlink" href="#id563" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>D<span class="classifier">ndarray</span></dt><dd><p>If b0 is none, then the shape will be (…, 6) otherwise (…, 7)</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="decompose-tensor">
<h3>decompose_tensor<a class="headerlink" href="#decompose-tensor" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.decompose_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">decompose_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.decompose_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>
<p>Computes tensor eigen decomposition to calculate eigenvalues and
eigenvectors (Basser et al., 1994a).</p>
<section id="id564">
<h4>Parameters<a class="headerlink" href="#id564" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tensor<span class="classifier">array (…, 3, 3)</span></dt><dd><p>Hermitian matrix representing a diffusion tensor.</p>
</dd>
<dt>min_diffusivity<span class="classifier">float</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</section>
<section id="id565">
<h4>Returns<a class="headerlink" href="#id565" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>eigvals<span class="classifier">array (…, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor. Negative
eigenvalues are replaced by zero. Sorted from largest to smallest.</p>
</dd>
<dt>eigvecs<span class="classifier">array (…, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[…, :, j] is associated with
eigvals[…, j])</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="design-matrix">
<h3>design_matrix<a class="headerlink" href="#design-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.design_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs design matrix for DTI weighted least squares or
least squares fitting. (Basser et al., 1994a)</p>
<section id="id566">
<h4>Parameters<a class="headerlink" href="#id566" title="Permalink to this heading">#</a></h4>
<p>gtab : A GradientTable class instance</p>
<dl class="simple">
<dt>dtype<span class="classifier">string</span></dt><dd><p>Parameter to control the dtype of returned designed matrix</p>
</dd>
</dl>
</section>
<section id="id567">
<h4>Returns<a class="headerlink" href="#id567" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (g,7)</span></dt><dd><p>Design matrix or B matrix assuming Gaussian distributed tensor model
design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="quantize-evecs">
<h3>quantize_evecs<a class="headerlink" href="#quantize-evecs" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.quantize_evecs">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">quantize_evecs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.quantize_evecs" title="Permalink to this definition">#</a></dt>
<dd><p>Find the closest orientation of an evenly distributed sphere</p>
<section id="id568">
<h4>Parameters<a class="headerlink" href="#id568" title="Permalink to this heading">#</a></h4>
<p>evecs : ndarray
odf_vertices : None or ndarray</p>
<blockquote>
<div><p>If None, then set vertices from symmetric362 sphere.  Otherwise use
passed ndarray as vertices</p>
</div></blockquote>
</section>
<section id="id569">
<h4>Returns<a class="headerlink" href="#id569" title="Permalink to this heading">#</a></h4>
<p>IN : ndarray</p>
</section>
</dd></dl>

</section>
<section id="eig-from-lo-tri">
<h3>eig_from_lo_tri<a class="headerlink" href="#eig-from-lo-tri" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.dti.eig_from_lo_tri">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.dti.</span></span><span class="sig-name descname"><span class="pre">eig_from_lo_tri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.eig_from_lo_tri" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates tensor eigenvalues/eigenvectors from an array containing the
lower diagonal form of the six unique tensor elements.</p>
<section id="id570">
<h4>Parameters<a class="headerlink" href="#id570" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">array_like (…, 6)</span></dt><dd><p>diffusion tensors elements stored in lower triangular order</p>
</dd>
<dt>min_diffusivity<span class="classifier">float</span></dt><dd><p>See decompose_tensor()</p>
</dd>
</dl>
</section>
<section id="id571">
<h4>Returns<a class="headerlink" href="#id571" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>dti_params<span class="classifier">array (…, 12)</span></dt><dd><p>Eigen-values and eigen-vectors of the same array.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="eudxdirectiongetter">
<h3><a class="reference internal" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter" title="dipy.reconst.eudx_direction_getter.EuDXDirectionGetter"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuDXDirectionGetter</span></code></a><a class="headerlink" href="#eudxdirectiongetter" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.eudx_direction_getter.EuDXDirectionGetter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.eudx_direction_getter.</span></span><span class="sig-name descname"><span class="pre">EuDXDirectionGetter</span></span><a class="headerlink" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="dipy.tracking.html#dipy.tracking.direction_getter.DirectionGetter" title="dipy.tracking.direction_getter.DirectionGetter"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirectionGetter</span></code></a></p>
<p>Deterministic Direction Getter based on peak directions.</p>
<p>This class contains the cython portion of the code for PeaksAndMetrics and
is not meant to be used on its own.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.ang_thr">
<span class="sig-name descname"><span class="pre">ang_thr</span></span><a class="headerlink" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.ang_thr" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.initial_direction">
<span class="sig-name descname"><span class="pre">initial_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.initial_direction" title="Permalink to this definition">#</a></dt>
<dd><p>The best starting directions for fiber tracking from point</p>
<p>All the valid peaks in the voxel closest to point are returned as
initial directions.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.qa_thr">
<span class="sig-name descname"><span class="pre">qa_thr</span></span><a class="headerlink" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.qa_thr" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.total_weight">
<span class="sig-name descname"><span class="pre">total_weight</span></span><a class="headerlink" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.total_weight" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="forecastmodel">
<h3><a class="reference internal" href="#dipy.reconst.forecast.ForecastModel" title="dipy.reconst.forecast.ForecastModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastModel</span></code></a><a class="headerlink" href="#forecastmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">ForecastModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_lb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dec_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CSD'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_csd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>Fiber ORientation Estimated using Continuous Axially Symmetric Tensors
(FORECAST) [1,2,3]_. FORECAST is a Spherical Deconvolution reconstruction
model for multi-shell diffusion data which enables the calculation of a
voxel adaptive response function using the Spherical Mean Technique (SMT)
[2,3]_.</p>
<p>With FORECAST it is possible to calculate crossing invariant parallel
diffusivity, perpendicular diffusivity, mean diffusivity, and fractional
anisotropy <a href="#id1520"><span class="problematic" id="id572">[2]_</span></a></p>
<section id="id573">
<h4>References<a class="headerlink" href="#id573" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id574" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Anderson A. W., “Measurement of Fiber Orientation Distributions
Using High Angular Resolution Diffusion Imaging”, Magnetic
Resonance in Medicine, 2005.</p>
</aside>
<aside class="footnote brackets" id="id575" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Kaden E. et al., “Quantitative Mapping of the Per-Axon Diffusion
Coefficients in Brain White Matter”, Magnetic Resonance in
Medicine, 2016.</p>
</aside>
<aside class="footnote brackets" id="id576" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Zucchelli E. et al., “A generalized SMT-based framework for
Diffusion MRI microstructural model estimation”, MICCAI Workshop
on Computational DIFFUSION MRI (CDMRI), 2017.</p>
</aside>
</aside>
</section>
<section id="id577">
<h4>Notes<a class="headerlink" href="#id577" title="Permalink to this heading">#</a></h4>
<p>The implementation of FORECAST may require CVXPY (<a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a>).</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_lb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dec_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CSD'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_csd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Analytical and continuous modeling of the diffusion signal with
respect to the FORECAST basis [1,2,3]_.
This implementation is a modification of the original FORECAST
model presented in <a href="#id1521"><span class="problematic" id="id578">[1]_</span></a> adapted for multi-shell data as in [2,3]_ .

The main idea is to model the diffusion signal as the combination of a
single fiber response function <span class="math notranslate nohighlight">\(F(\mathbf{b})\)</span> times the fODF
<span class="math notranslate nohighlight">\(\rho(\mathbf{v})\)</span>

..math::
    :nowrap:
        begin{equation}
            E(mathbf{b}) = int_{mathbf{v} in mathcal{S}^2} rho(mathbf{v}) F({mathbf{b}} | mathbf{v}) d mathbf{v}
        end{equation}

where <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is the b-vector (b-value times gradient direction)
and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is an unit vector representing a fiber direction.

In FORECAST <span class="math notranslate nohighlight">\(\rho\)</span> is modeled using real symmetric Spherical Harmonics
(SH) and <span class="math notranslate nohighlight">\(F(\mathbf(b))\)</span> is an axially symmetric tensor.


Parameters
———-
gtab : GradientTable,
    gradient directions and bvalues container class.
sh_order : unsigned int,
    an even integer that represent the SH order of the basis (max 12)
lambda_lb: float,
    Laplace-Beltrami regularization weight.
dec_alg : str,
    Spherical deconvolution algorithm. The possible values are Weighted Least Squares (‘WLS’),
    Positivity Constraints using CVXPY (‘POS’) and the Constraint
    Spherical Deconvolution algorithm (‘CSD’). Default is ‘CSD’.
sphere : array, shape (N,3),
    sphere points where to enforce positivity when ‘POS’ or ‘CSD’
    dec_alg are selected.
lambda_csd : float,
    CSD regularization weight.

References
———-
.. [1] Anderson A. W., “Measurement of Fiber Orientation Distributions
       Using High Angular Resolution Diffusion Imaging”, Magnetic
       Resonance in Medicine, 2005.

.. [2] Kaden E. et al., “Quantitative Mapping of the Per-Axon Diffusion
       Coefficients in Brain White Matter”, Magnetic Resonance in
       Medicine, 2016.

.. [3] Zucchelli M. et al., “A generalized SMT-based framework for
       Diffusion MRI microstructural model estimation”, MICCAI Workshop
       on Computational DIFFUSION MRI (CDMRI), 2017.

Examples
——–
In this example, where the data, gradient table and sphere tessellation
used for reconstruction are provided, we model the diffusion signal
with respect to the FORECAST and compute the fODF, parallel and
perpendicular diffusivity.

&gt;&gt;&gt; import warnings
&gt;&gt;&gt; from dipy.data import default_sphere, get_3shell_gtab
&gt;&gt;&gt; gtab = get_3shell_gtab()
&gt;&gt;&gt; from dipy.sims.voxel import multi_tensor
&gt;&gt;&gt; mevals = np.array(([0.0017, 0.0003, 0.0003],
…                    [0.0017, 0.0003, 0.0003]))
&gt;&gt;&gt; angl = [(0, 0), (60, 0)]
&gt;&gt;&gt; data, sticks = multi_tensor(gtab,
…                             mevals,
…                             S0=100.0,
…                             angles=angl,
…                             fractions=[50, 50],
…                             snr=None)
&gt;&gt;&gt; from dipy.reconst.forecast import ForecastModel
&gt;&gt;&gt; from dipy.reconst.shm import descoteaux07_legacy_msg
&gt;&gt;&gt; with warnings.catch_warnings():
…     warnings.filterwarnings(
…         “ignore”, message=descoteaux07_legacy_msg,
…         category=PendingDeprecationWarning)
…     fm = ForecastModel(gtab, sh_order=6)
&gt;&gt;&gt; f_fit = fm.fit(data)
&gt;&gt;&gt; d_par = f_fit.dpar
&gt;&gt;&gt; d_perp = f_fit.dperp
&gt;&gt;&gt; with warnings.catch_warnings():
…     warnings.filterwarnings(
…         “ignore”, message=descoteaux07_legacy_msg,
…         category=PendingDeprecationWarning)
…     fodf = f_fit.odf(default_sphere)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="forecastfit">
<h3><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit" title="dipy.reconst.forecast.ForecastFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastFit</span></code></a><a class="headerlink" href="#forecastfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">ForecastFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_par</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_perp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_par</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_perp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates diffusion properties for a single voxel</p>
<section id="id579">
<h4>Parameters<a class="headerlink" href="#id579" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">object,</span></dt><dd><p>AnalyticalModel</p>
</dd>
<dt>data<span class="classifier">1d ndarray,</span></dt><dd><p>fitted data</p>
</dd>
<dt>sh_coef<span class="classifier">1d ndarray,</span></dt><dd><p>forecast sh coefficients</p>
</dd>
<dt>d_par<span class="classifier">float,</span></dt><dd><p>parallel diffusivity</p>
</dd>
<dt>d_perp<span class="classifier">float,</span></dt><dd><p>perpendicular diffusivity</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.dpar">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dpar</span></span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.dpar" title="Permalink to this definition">#</a></dt>
<dd><p>The parallel diffusivity</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.dperp">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dperp</span></span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.dperp" title="Permalink to this definition">#</a></dt>
<dd><p>The perpendicular diffusivity</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.fractional_anisotropy">
<span class="sig-name descname"><span class="pre">fractional_anisotropy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.fractional_anisotropy" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the fractional anisotropy.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.mean_diffusivity">
<span class="sig-name descname"><span class="pre">mean_diffusivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.mean_diffusivity" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the mean diffusivity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the fODF for a given discrete sphere.</p>
<section id="id580">
<h4>Parameters<a class="headerlink" href="#id580" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere,</span></dt><dd><p>the odf sphere</p>
</dd>
<dt>clip_negative<span class="classifier">boolean, optional</span></dt><dd><p>if True clip the negative odf values to 0, default True</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the fODF for a given discrete sphere.</p>
<section id="id581">
<h4>Parameters<a class="headerlink" href="#id581" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable, optional</span></dt><dd><p>gradient directions and bvalues container class.</p>
</dd>
<dt>S0<span class="classifier">float, optional</span></dt><dd><p>the signal at b-value=0</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.forecast.ForecastFit.sh_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sh_coeff</span></span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.sh_coeff" title="Permalink to this definition">#</a></dt>
<dd><p>The FORECAST SH coefficients</p>
</dd></dl>

</dd></dl>

</section>
<section id="find-signal-means">
<h3>find_signal_means<a class="headerlink" href="#find-signal-means" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.find_signal_means">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">find_signal_means</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b_unique</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.find_signal_means" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the mean signal for each shell.</p>
<section id="id582">
<h4>Parameters<a class="headerlink" href="#id582" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>b_unique<span class="classifier">1d ndarray,</span></dt><dd><p>unique b-values in a vector excluding zero</p>
</dd>
<dt>data_norm<span class="classifier">1d ndarray,</span></dt><dd><p>normalized diffusion signal</p>
</dd>
<dt>bvals<span class="classifier">1d ndarray,</span></dt><dd><p>the b-values</p>
</dd>
<dt>rho<span class="classifier">2d ndarray,</span></dt><dd><p>SH basis matrix for fitting the signal on each shell</p>
</dd>
<dt>lb_matrix<span class="classifier">2d ndarray,</span></dt><dd><p>Laplace-Beltrami regularization matrix</p>
</dd>
<dt>w<span class="classifier">float,</span></dt><dd><p>weight for the Laplace-Beltrami regularization</p>
</dd>
</dl>
</section>
<section id="id583">
<h4>Returns<a class="headerlink" href="#id583" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>means<span class="classifier">1d ndarray</span></dt><dd><p>the average of the signal for each b-values</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="forecast-error-func">
<h3>forecast_error_func<a class="headerlink" href="#forecast-error-func" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.forecast_error_func">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">forecast_error_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_unique</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.forecast_error_func" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the difference between the mean signal calculated using
the parameter vector x and the average signal E using FORECAST and SMT</p>
</dd></dl>

</section>
<section id="psi-l">
<h3>psi_l<a class="headerlink" href="#psi-l" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.psi_l">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">psi_l</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.psi_l" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="forecast-matrix">
<h3>forecast_matrix<a class="headerlink" href="#forecast-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.forecast_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">forecast_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_par</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_perp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.forecast_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the FORECAST radial matrix</p>
</dd></dl>

</section>
<section id="rho-matrix">
<h3>rho_matrix<a class="headerlink" href="#rho-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.rho_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">rho_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vecs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.rho_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the SH matrix <span class="math notranslate nohighlight">\(\rho\)</span></p>
</dd></dl>

</section>
<section id="lb-forecast">
<h3>lb_forecast<a class="headerlink" href="#lb-forecast" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.forecast.lb_forecast">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.forecast.</span></span><span class="sig-name descname"><span class="pre">lb_forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.lb_forecast" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Laplace-Beltrami regularization matrix for FORECAST</p>
</dd></dl>

</section>
<section id="freewatertensormodel">
<h3><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel" title="dipy.reconst.fwdti.FreeWaterTensorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a><a class="headerlink" href="#freewatertensormodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">FreeWaterTensorModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'NLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Class for the Free Water Elimination Diffusion Tensor Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'NLS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Free Water Diffusion Tensor Model <a href="#id1522"><span class="problematic" id="id584">[1]_</span></a>.</p>
<section id="id585">
<h4>Parameters<a class="headerlink" href="#id585" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable class instance
fit_method : str or callable</p>
<blockquote>
<div><p>str can be one of the following:</p>
<dl class="simple">
<dt>‘WLS’ for weighted linear least square fit according to <a href="#id1523"><span class="problematic" id="id586">[1]_</span></a></dt><dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">fwdti.wls_iter()</span></code></p>
</dd>
<dt>‘NLS’ for non-linear least square fit according to <a href="#id1524"><span class="problematic" id="id587">[1]_</span></a></dt><dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">fwdti.nls_iter()</span></code></p>
</dd>
<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href="#id588"><span class="problematic" id="id589">*</span></a>args, <a href="#id590"><span class="problematic" id="id591">**</span></a>kwargs)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>args, kwargs<span class="classifier">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See fwdti.wls_iter, fwdti.nls_iter for
details</p>
</dd>
</dl>
</section>
<section id="id592">
<h4>References<a class="headerlink" href="#id592" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id593" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Henriques, R.N., Rokem, A., Garyfallidis, E., St-Jean, S.,
Peterson E.T., Correia, M.M., 2017. [Re] Optimization of a free
water elimination two-compartment model for diffusion tensor
imaging. ReScience volume 3, issue 1, article number 2</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwdti_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal for this TensorModel class instance given
parameters.</p>
<section id="id594">
<h4>Parameters<a class="headerlink" href="#id594" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>fwdti_params<span class="classifier">(…, 13) ndarray</span></dt><dd><p>The last dimension should have 13 parameters: the 12 tensor
parameters (3 eigenvalues, followed by the 3 corresponding
eigenvectors) and the free water volume fraction.</p>
</dd>
<dt>S0<span class="classifier">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</section>
<section id="id595">
<h4>Returns<a class="headerlink" href="#id595" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated signal based on the free water DTI model</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="freewatertensorfit">
<h3><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit" title="dipy.reconst.fwdti.FreeWaterTensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a><a class="headerlink" href="#freewatertensorfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">FreeWaterTensorFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a></p>
<p>Class for fitting the Free Water Tensor Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a FreeWaterTensorFit class instance.
Since the free water tensor model is an extension of DTI, class
instance is defined as subclass of the TensorFit from dti.py</p>
<section id="id596">
<h4>Parameters<a class="headerlink" href="#id596" title="Permalink to this heading">#</a></h4>
<dl>
<dt>model<span class="classifier">FreeWaterTensorModel Class instance</span></dt><dd><p>Class instance containing the free water tensor model for the fit</p>
</dd>
<dt>model_params<span class="classifier">ndarray (x, y, z, 13) or (n, 13)</span></dt><dd><p>All parameters estimated from the free water tensor model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Three diffusion tensor’s eigenvalues</p></li>
<li><p>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</p></li>
<li><p>The volume fraction of the free water compartment</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</section>
<section id="id597">
<h4>References<a class="headerlink" href="#id597" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id598" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Henriques, R.N., Rokem, A., Garyfallidis, E., St-Jean, S.,
Peterson E.T., Correia, M.M., 2017. [Re] Optimization of a free
water elimination two-compartment model for diffusion tensor
imaging. ReScience volume 3, issue 1, article number 2</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorFit.f">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">f</span></span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit.f" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the free water diffusion volume fraction f</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.FreeWaterTensorFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Given a free water tensor model fit, predict the signal on the
vertices of a gradient table</p>
<section id="id599">
<h4>Parameters<a class="headerlink" href="#id599" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>
</dd>
<dt>S0<span class="classifier">float array</span></dt><dd><p>The mean non-diffusion weighted signal in each voxel. Default: 1 in
all voxels.</p>
</dd>
</dl>
</section>
<section id="id600">
<h4>Returns<a class="headerlink" href="#id600" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">(…, N) ndarray</span></dt><dd><p>Simulated signal based on the free water DTI model</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="fwdti-prediction">
<h3>fwdti_prediction<a class="headerlink" href="#fwdti-prediction" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.fwdti_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">fwdti_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.fwdti_prediction" title="Permalink to this definition">#</a></dt>
<dd><p>Signal prediction given the free water DTI model parameters.

Parameters
———-
params : (…, 13) ndarray
    Model parameters. The last dimension should have the 12 tensor
    parameters (3 eigenvalues, followed by the 3 corresponding
    eigenvectors) and the volume fraction of the free water compartment.
gtab : a GradientTable class instance
    The gradient table for this prediction
S0 : float or ndarray
    The non diffusion-weighted signal in every voxel, or across all
    voxels. Default: 1
Diso : float, optional
    Value of the free water isotropic diffusion. Default is set to 3e-3
    <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
    units of diffusion.

Returns
——-
S : (…, N) ndarray
    Simulated signal based on the free water DTI model

Notes
—–
The predicted signal is given by:
<span class="math notranslate nohighlight">\(S(\theta, b) = S_0 * [(1-f) * e^{-b ADC} + f * e^{-b D_{iso}]\)</span>, where
<span class="math notranslate nohighlight">\(ADC = \theta Q \theta^T\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span> is a unit vector pointing at any
direction on the sphere for which a signal is to be predicted, <span class="math notranslate nohighlight">\(b\)</span> is the b
value provided in the GradientTable input for that direction, <span class="math notranslate nohighlight">\(Q\)</span> is the
quadratic form of the tensor determined by the input parameters, <span class="math notranslate nohighlight">\(f\)</span> is the
free water diffusion compartment, <span class="math notranslate nohighlight">\(D_{iso}\)</span> is the free water diffusivity
which is equal to $3 * 10^{-3} mm^{2}s^{-1} <a href="#id1525"><span class="problematic" id="id601">[1]_</span></a>.

References
———-
.. [1] Henriques, R.N., Rokem, A., Garyfallidis, E., St-Jean, S.,
       Peterson E.T., Correia, M.M., 2017. [Re] Optimization of a free
       water elimination two-compartment model for diffusion tensor
       imaging. ReScience volume 3, issue 1, article number 2</p>
</dd></dl>

</section>
<section id="wls-iter">
<h3>wls_iter<a class="headerlink" href="#wls-iter" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.wls_iter">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">wls_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mdreg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0027</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">piterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.wls_iter" title="Permalink to this definition">#</a></dt>
<dd><p>Applies weighted linear least squares fit of the water free elimination
model to single voxel signals.

Parameters
———-
design_matrix : array (g, 7)
    Design matrix holding the covariants used to solve for the regression
    coefficients.
sig : array (g, )
    Diffusion-weighted signal for a single voxel data.
S0 : float
    Non diffusion weighted signal (i.e. signal for b-value=0).
Diso : float, optional
    Value of the free water isotropic diffusion. Default is set to 3e-3
    <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
    units of diffusion.
 mdreg : float, optimal
    DTI’s mean diffusivity regularization threshold. If standard DTI
    diffusion tensor’s mean diffusivity is almost near the free water
    diffusion value, the diffusion signal is assumed to be only free water
    diffusion (i.e. volume fraction will be set to 1 and tissue’s diffusion
    parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
    (corresponding to 90% of the free water diffusion value).
min_signal : float
    The minimum signal value. Needs to be a strictly positive
    number. Default: minimal signal in the data provided to <cite>fit</cite>.
piterations : inter, optional
    Number of iterations used to refine the precision of f. Default is set
    to 3 corresponding to a precision of 0.01.

Returns
——-
All parameters estimated from the free water tensor model.
Parameters are ordered as follows:
    1) Three diffusion tensor’s eigenvalues
    2) Three lines of the eigenvector matrix each containing the
       first, second and third coordinates of the eigenvector
    3) The volume fraction of the free water compartment</p>
</dd></dl>

</section>
<section id="id602">
<h3>wls_fit_tensor<a class="headerlink" href="#id602" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.wls_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">wls_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">piterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mdreg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0027</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.wls_fit_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Computes weighted least squares (WLS) fit to calculate self-diffusion
tensor using a linear regression model <a href="#id1526"><span class="problematic" id="id603">[1]_</span></a>.

Parameters
———-
gtab : a GradientTable class instance
    The gradient table containing diffusion acquisition parameters.
data : ndarray ([X, Y, Z, …], g)
    Data or response variables holding the data. Note that the last
    dimension should contain the data. It makes no copies of data.
Diso : float, optional
    Value of the free water isotropic diffusion. Default is set to 3e-3
    <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
    units of diffusion.
mask : array, optional
    A boolean array used to mark the coordinates in the data that should
    be analyzed that has the shape data.shape[:-1]
min_signal : float
    The minimum signal value. Needs to be a strictly positive
    number. Default: 1.0e-6.
piterations : inter, optional
    Number of iterations used to refine the precision of f. Default is set
    to 3 corresponding to a precision of 0.01.
mdreg : float, optimal
    DTI’s mean diffusivity regularization threshold. If standard DTI
    diffusion tensor’s mean diffusivity is almost near the free water
    diffusion value, the diffusion signal is assumed to be only free water
    diffusion (i.e. volume fraction will be set to 1 and tissue’s diffusion
    parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
    (corresponding to 90% of the free water diffusion value).

Returns
——-
fw_params : ndarray (x, y, z, 13)
    Matrix containing in the last dimension the free water model parameters
    in the following order:
        1) Three diffusion tensor’s eigenvalues
        2) Three lines of the eigenvector matrix each containing the
           first, second and third coordinates of the eigenvector
        3) The volume fraction of the free water compartment.

References
———-
.. [1] Henriques, R.N., Rokem, A., Garyfallidis, E., St-Jean, S.,
       Peterson E.T., Correia, M.M., 2017. [Re] Optimization of a free
       water elimination two-compartment model for diffusion tensor
       imaging. ReScience volume 3, issue 1, article number 2</p>
</dd></dl>

</section>
<section id="nls-iter">
<h3>nls_iter<a class="headerlink" href="#nls-iter" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.nls_iter">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">nls_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mdreg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0027</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.nls_iter" title="Permalink to this definition">#</a></dt>
<dd><p>Applies non linear least squares fit of the water free elimination
model to single voxel signals.

Parameters
———-
design_matrix : array (g, 7)
    Design matrix holding the covariants used to solve for the regression
    coefficients.
sig : array (g, )
    Diffusion-weighted signal for a single voxel data.
S0 : float
    Non diffusion weighted signal (i.e. signal for b-value=0).
Diso : float, optional
    Value of the free water isotropic diffusion. Default is set to 3e-3
    <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
    units of diffusion.
mdreg : float, optimal
    DTI’s mean diffusivity regularization threshold. If standard DTI
    diffusion tensor’s mean diffusivity is almost near the free water
    diffusion value, the diffusion signal is assumed to be only free water
    diffusion (i.e. volume fraction will be set to 1 and tissue’s diffusion
    parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
    (corresponding to 90% of the free water diffusion value).
min_signal : float
    The minimum signal value. Needs to be a strictly positive
    number.
cholesky : bool, optional
    If true it uses Cholesky decomposition to insure that diffusion tensor
    is positive define.
    Default: False
f_transform : bool, optional
    If true, the water volume fractions is converted during the convergence
    procedure to ft = arcsin(2*f - 1) + pi/2, insuring f estimates between
    0 and 1.
    Default: True
jac : bool
    Use the Jacobian? Default: False
weighting: str, optional
    the weighting scheme to use in considering the
    squared-error. Default behavior is to use uniform weighting. Other
    options: ‘sigma’ ‘gmm’
sigma: float, optional
    If the ‘sigma’ weighting scheme is used, a value of sigma needs to be
    provided here. According to <a class="reference internal" href="../examples_built/reconstruction/restore_dti.html#chang2005" id="id604"><span>[Chang2005]</span></a>, a good value to use is
    1.5267 * std(background_noise), where background_noise is estimated
    from some part of the image known to contain no signal (only noise).

Returns
——-
All parameters estimated from the free water tensor model.
Parameters are ordered as follows:
    1) Three diffusion tensor’s eigenvalues
    2) Three lines of the eigenvector matrix each containing the
       first, second and third coordinates of the eigenvector
    3) The volume fraction of the free water compartment.</p>
</dd></dl>

</section>
<section id="nls-fit-tensor">
<h3>nls_fit_tensor<a class="headerlink" href="#nls-fit-tensor" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.nls_fit_tensor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">nls_fit_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Diso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mdreg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0027</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.nls_fit_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Fit the water elimination tensor model using the non-linear least-squares.

Parameters
———-
gtab : a GradientTable class instance
    The gradient table containing diffusion acquisition parameters.
data : ndarray ([X, Y, Z, …], g)
    Data or response variables holding the data. Note that the last
    dimension should contain the data. It makes no copies of data.
mask : array, optional
    A boolean array used to mark the coordinates in the data that should
    be analyzed that has the shape data.shape[:-1]
Diso : float, optional
    Value of the free water isotropic diffusion. Default is set to 3e-3
    <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
    units of diffusion.
mdreg : float, optimal
    DTI’s mean diffusivity regularization threshold. If standard DTI
    diffusion tensor’s mean diffusivity is almost near the free water
    diffusion value, the diffusion signal is assumed to be only free water
    diffusion (i.e. volume fraction will be set to 1 and tissue’s diffusion
    parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
    (corresponding to 90% of the free water diffusion value).
min_signal : float
    The minimum signal value. Needs to be a strictly positive
    number. Default: 1.0e-6.
f_transform : bool, optional
    If true, the water volume fractions is converted during the convergence
    procedure to ft = arcsin(2*f - 1) + pi/2, insuring f estimates between
    0 and 1.
    Default: True
cholesky : bool, optional
    If true it uses Cholesky decomposition to insure that diffusion tensor
    is positive define.
    Default: False
jac : bool
    Use the Jacobian? Default: False
weighting: str, optional
    the weighting scheme to use in considering the
    squared-error. Default behavior is to use uniform weighting. Other
    options: ‘sigma’ ‘gmm’
sigma: float, optional
    If the ‘sigma’ weighting scheme is used, a value of sigma needs to be
    provided here. According to <a class="reference internal" href="../examples_built/reconstruction/restore_dti.html#chang2005" id="id605"><span>[Chang2005]</span></a>, a good value to use is
    1.5267 * std(background_noise), where background_noise is estimated
    from some part of the image known to contain no signal (only noise).

Returns
——-
fw_params : ndarray (x, y, z, 13)
    Matrix containing in the dimension the free water model parameters in
    the following order:
        1) Three diffusion tensor’s eigenvalues
        2) Three lines of the eigenvector matrix each containing the
           first, second and third coordinates of the eigenvector
        3) The volume fraction of the free water compartment</p>
</dd></dl>

</section>
<section id="lower-triangular-to-cholesky">
<h3>lower_triangular_to_cholesky<a class="headerlink" href="#lower-triangular-to-cholesky" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.lower_triangular_to_cholesky">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">lower_triangular_to_cholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor_elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.lower_triangular_to_cholesky" title="Permalink to this definition">#</a></dt>
<dd><p>Performs Cholesky decomposition of the diffusion tensor</p>
<section id="id606">
<h4>Parameters<a class="headerlink" href="#id606" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tensor_elements<span class="classifier">array (6,)</span></dt><dd><p>Array containing the six elements of diffusion tensor’s lower
triangular.</p>
</dd>
</dl>
</section>
<section id="id607">
<h4>Returns<a class="headerlink" href="#id607" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>cholesky_elements<span class="classifier">array (6,)</span></dt><dd><p>Array containing the six Cholesky’s decomposition elements
(R0, R1, R2, R3, R4, R5) <a href="#id1527"><span class="problematic" id="id608">[1]_</span></a>.</p>
</dd>
</dl>
</section>
<section id="id609">
<h4>References<a class="headerlink" href="#id609" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id610" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Koay, C.G., Carew, J.D., Alexander, A.L., Basser, P.J.,
Meyerand, M.E., 2006. Investigation of anomalous estimates of
tensor-derived quantities in diffusion tensor imaging. Magnetic
Resonance in Medicine, 55(4), 930-936. doi:10.1002/mrm.20832</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="cholesky-to-lower-triangular">
<h3>cholesky_to_lower_triangular<a class="headerlink" href="#cholesky-to-lower-triangular" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.fwdti.cholesky_to_lower_triangular">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.fwdti.</span></span><span class="sig-name descname"><span class="pre">cholesky_to_lower_triangular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.cholesky_to_lower_triangular" title="Permalink to this definition">#</a></dt>
<dd><p>Convert Cholesky decomposition elements to the diffusion tensor elements</p>
<section id="id611">
<h4>Parameters<a class="headerlink" href="#id611" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>R<span class="classifier">array (6,)</span></dt><dd><p>Array containing the six Cholesky’s decomposition elements
(R0, R1, R2, R3, R4, R5) <a href="#id1528"><span class="problematic" id="id612">[1]_</span></a>.</p>
</dd>
</dl>
</section>
<section id="id613">
<h4>Returns<a class="headerlink" href="#id613" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tensor_elements<span class="classifier">array (6,)</span></dt><dd><p>Array containing the six elements of diffusion tensor’s lower
triangular.</p>
</dd>
</dl>
</section>
<section id="id614">
<h4>References<a class="headerlink" href="#id614" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id615" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Koay, C.G., Carew, J.D., Alexander, A.L., Basser, P.J.,
Meyerand, M.E., 2006. Investigation of anomalous estimates of
tensor-derived quantities in diffusion tensor imaging. Magnetic
Resonance in Medicine, 55(4), 930-936. doi:10.1002/mrm.20832</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="generalizedqsamplingmodel">
<h3><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="dipy.reconst.gqi.GeneralizedQSamplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a><a class="headerlink" href="#generalizedqsamplingmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">GeneralizedQSamplingModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gqi2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gqi2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Generalized Q-Sampling Imaging <a href="#id1529"><span class="problematic" id="id616">[1]_</span></a></p>
<p>This model has the same assumptions as the DSI method i.e. Cartesian
grid sampling in q-space and fast gradient switching.</p>
<p>Implements equations 2.14 from <a href="#id1530"><span class="problematic" id="id617">[2]_</span></a> for standard GQI and equation 2.16
from <a href="#id1531"><span class="problematic" id="id618">[2]_</span></a> for GQI2. You can think of GQI2 as an analytical solution of
the DSI ODF.</p>
<section id="id619">
<h4>Parameters<a class="headerlink" href="#id619" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">object,</span></dt><dd><p>GradientTable</p>
</dd>
<dt>method<span class="classifier">str,</span></dt><dd><p>‘standard’ or ‘gqi2’</p>
</dd>
<dt>sampling_length<span class="classifier">float,</span></dt><dd><p>diffusion sampling length (lambda in eq. 2.14 and 2.16)</p>
</dd>
</dl>
</section>
<section id="id620">
<h4>References<a class="headerlink" href="#id620" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id621" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Yeh F-C et al., “Generalized Q-Sampling Imaging”, IEEE TMI, 2010</p>
</aside>
<aside class="footnote brackets" id="id622" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Garyfallidis E, “Towards an accurate brain tractography”, PhD</p>
</aside>
</aside>
<p>thesis, University of Cambridge, 2012.</p>
</section>
<section id="id623">
<h4>Notes<a class="headerlink" href="#id623" title="Permalink to this heading">#</a></h4>
<p>As of version 0.9, range of the sampling length in GQI2 has changed
to match the same scale used in the ‘standard’ method <a href="#id1532"><span class="problematic" id="id624">[1]_</span></a>. This
means that the value of <cite>sampling_length</cite> should be approximately
1 - 1.3 (see <a href="#id1533"><span class="problematic" id="id625">[1]_</span></a>, pg. 1628).</p>
</section>
<section id="id626">
<h4>Examples<a class="headerlink" href="#id626" title="Permalink to this heading">#</a></h4>
<p>Here we create an example where we provide the data, a gradient table
and a reconstruction sphere and calculate the ODF for the first
voxel in the data.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="kn">import</span> <span class="n">dsi_voxels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">gtab</span> <span class="o">=</span> <span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.subdivide_octahedron</span> <span class="kn">import</span> <span class="n">create_unit_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">create_unit_sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.gqi</span> <span class="kn">import</span> <span class="n">GeneralizedQSamplingModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gq</span> <span class="o">=</span> <span class="n">GeneralizedQSamplingModel</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="s1">&#39;gqi2&#39;</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">voxel_signal</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf</span> <span class="o">=</span> <span class="n">gq</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">voxel_signal</span><span class="p">)</span><span class="o">.</span><span class="n">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id627">
<h4>See Also<a class="headerlink" href="#id627" title="Permalink to this heading">#</a></h4>
<p>dipy.reconst.dsi.DiffusionSpectrumModel</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="generalizedqsamplingfit">
<h3><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="dipy.reconst.gqi.GeneralizedQSamplingFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a><a class="headerlink" href="#generalizedqsamplingfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">GeneralizedQSamplingFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates PDF and ODF for a single voxel</p>
<section id="id628">
<h4>Parameters<a class="headerlink" href="#id628" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">object,</span></dt><dd><p>DiffusionSpectrumModel</p>
</dd>
<dt>data<span class="classifier">1d ndarray,</span></dt><dd><p>signal values</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.gqi.GeneralizedQSamplingFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the discrete ODF for a given discrete sphere.</p>
</dd></dl>

</dd></dl>

</section>
<section id="normalize-qa">
<h3>normalize_qa<a class="headerlink" href="#normalize-qa" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.normalize_qa">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">normalize_qa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_qa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.normalize_qa" title="Permalink to this definition">#</a></dt>
<dd><p>Normalize quantitative anisotropy.</p>
<p>Used mostly with GQI rather than GQI2.</p>
<section id="id629">
<h4>Parameters<a class="headerlink" href="#id629" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>qa<span class="classifier">array, shape (X, Y, Z, N)</span></dt><dd><p>where N is the maximum number of peaks stored</p>
</dd>
<dt>max_qa<span class="classifier">float,</span></dt><dd><p>maximum qa value. Usually found in the CSF (corticospinal fluid).</p>
</dd>
</dl>
</section>
<section id="id630">
<h4>Returns<a class="headerlink" href="#id630" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>nqa<span class="classifier">array, shape (x, Y, Z, N)</span></dt><dd><p>normalized quantitative anisotropy</p>
</dd>
</dl>
</section>
<section id="id631">
<h4>Notes<a class="headerlink" href="#id631" title="Permalink to this heading">#</a></h4>
<p>Normalized quantitative anisotropy has the very useful property
to be very small near gray matter and background areas. Therefore,
it can be used to mask out white matter areas.</p>
</section>
</dd></dl>

</section>
<section id="squared-radial-component">
<h3>squared_radial_component<a class="headerlink" href="#squared-radial-component" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.squared_radial_component">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">squared_radial_component</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.squared_radial_component" title="Permalink to this definition">#</a></dt>
<dd><p>Part of the GQI2 integral</p>
<p>Eq.8 in the referenced paper by Yeh et al. 2010</p>
</dd></dl>

</section>
<section id="npa">
<h3>npa<a class="headerlink" href="#npa" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.npa">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">npa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.npa" title="Permalink to this definition">#</a></dt>
<dd><p>non-parametric anisotropy</p>
<p>Nimmo-Smith et al.  ISMRM 2011</p>
</dd></dl>

</section>
<section id="equatorial-zone-vertices">
<h3>equatorial_zone_vertices<a class="headerlink" href="#equatorial-zone-vertices" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.equatorial_zone_vertices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">equatorial_zone_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.equatorial_zone_vertices" title="Permalink to this definition">#</a></dt>
<dd><p>finds the ‘vertices’ in the equatorial zone conjugate
to ‘pole’ with width half ‘width’ degrees</p>
</dd></dl>

</section>
<section id="polar-zone-vertices">
<h3>polar_zone_vertices<a class="headerlink" href="#polar-zone-vertices" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.polar_zone_vertices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">polar_zone_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.polar_zone_vertices" title="Permalink to this definition">#</a></dt>
<dd><p>finds the ‘vertices’ in the equatorial band around
the ‘pole’ of radius ‘width’ degrees</p>
</dd></dl>

</section>
<section id="upper-hemi-map">
<h3>upper_hemi_map<a class="headerlink" href="#upper-hemi-map" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.upper_hemi_map">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">upper_hemi_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.upper_hemi_map" title="Permalink to this definition">#</a></dt>
<dd><p>maps a 3-vector into the z-upper hemisphere</p>
</dd></dl>

</section>
<section id="equatorial-maximum">
<h3>equatorial_maximum<a class="headerlink" href="#equatorial-maximum" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.equatorial_maximum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">equatorial_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.equatorial_maximum" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="patch-vertices">
<h3>patch_vertices<a class="headerlink" href="#patch-vertices" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.patch_vertices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">patch_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.patch_vertices" title="Permalink to this definition">#</a></dt>
<dd><p>find ‘vertices’ within the cone of ‘width’ degrees around ‘pole’</p>
</dd></dl>

</section>
<section id="patch-maximum">
<h3>patch_maximum<a class="headerlink" href="#patch-maximum" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.patch_maximum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">patch_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.patch_maximum" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="odf-sum">
<h3>odf_sum<a class="headerlink" href="#odf-sum" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.odf_sum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">odf_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.odf_sum" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="patch-sum">
<h3>patch_sum<a class="headerlink" href="#patch-sum" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.patch_sum">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">patch_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.patch_sum" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="triple-odf-maxima">
<h3>triple_odf_maxima<a class="headerlink" href="#triple-odf-maxima" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.gqi.triple_odf_maxima">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.gqi.</span></span><span class="sig-name descname"><span class="pre">triple_odf_maxima</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.triple_odf_maxima" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="ivimmodeltrr">
<h3><a class="reference internal" href="#dipy.reconst.ivim.IvimModelTRR" title="dipy.reconst.ivim.IvimModelTRR"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimModelTRR</span></code></a><a class="headerlink" href="#ivimmodeltrr" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">IvimModelTRR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_b_D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">400.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_b_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1000.0,</span> <span class="pre">0.1,</span> <span class="pre">0.001,</span> <span class="pre">0.0001)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ftol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Ivim model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_b_D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">400.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_b_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1000.0,</span> <span class="pre">0.1,</span> <span class="pre">0.001,</span> <span class="pre">0.0001)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ftol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize an IVIM model.</p>
<p>The IVIM model assumes that biological tissue includes a volume
fraction ‘f’ of water flowing with a pseudo-diffusion coefficient
D* and a fraction (1-f) of static (diffusion only), intra and
extracellular water, with a diffusion coefficient D. In this model
the echo attenuation of a signal in a single voxel can be written as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\]</div>
<p>S(b) = S_0[f*e^{(-b*D*)} + (1-f)e^{(-b*D)}]</p>
<p>Where:
.. math:</p>
<p>S_0, f, D* and D are the IVIM parameters.</p>
</div></blockquote>
<section id="id632">
<h4>Parameters<a class="headerlink" href="#id632" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues</p>
</dd>
<dt>split_b_D<span class="classifier">float, optional</span></dt><dd><p>The b-value to split the data on for two-stage fit. This will be
used while estimating the value of D. The assumption is that at
higher b values the effects of perfusion is less and hence the
signal can be approximated as a mono-exponential decay.
default : 400.</p>
</dd>
<dt>split_b_S0<span class="classifier">float, optional</span></dt><dd><p>The b-value to split the data on for two-stage fit for estimation
of S0 and initial guess for D_star. The assumption here is that
at low bvalues the effects of perfusion are more.
default : 200.</p>
</dd>
<dt>bounds<span class="classifier">tuple of arrays with 4 elements, optional</span></dt><dd><p>Bounds to constrain the fitted model parameters. This is only
supported for Scipy version &gt; 0.17. When using a older Scipy
version, this function will raise an error if bounds are different
from None. This parameter is also used to fill nan values for out
of bounds parameters in the <cite>IvimFit</cite> class using the method
fill_na. default : ([0., 0., 0., 0.], [np.inf, .3, 1., 1.])</p>
</dd>
<dt>two_stage<span class="classifier">bool</span></dt><dd><p>Argument to specify whether to perform a non-linear fitting of all
parameters after the linear fitting by splitting the data based on
bvalues. This gives more accurate parameters but takes more time.
The linear fit can be used to get a quick estimation of the
parameters. default : False</p>
</dd>
<dt>tol<span class="classifier">float, optional</span></dt><dd><p>Tolerance for convergence of minimization.
default : 1e-15</p>
</dd>
<dt>x_scale<span class="classifier">array-like, optional</span></dt><dd><p>Scaling for the parameters. This is passed to <cite>least_squares</cite> which
is only available for Scipy version &gt; 0.17.
default: [1000, 0.01, 0.001, 0.0001]</p>
</dd>
<dt>gtol<span class="classifier">float, optional</span></dt><dd><p>Tolerance for termination by the norm of the gradient.
default : 1e-15</p>
</dd>
<dt>ftol<span class="classifier">float, optional</span></dt><dd><p>Tolerance for termination by the change of the cost function.
default : 1e-15</p>
</dd>
<dt>eps<span class="classifier">float, optional</span></dt><dd><p>Step size used for numerical approximation of the jacobian.
default : 1e-15</p>
</dd>
<dt>maxiter<span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations to perform.
default : 1000</p>
</dd>
</dl>
</section>
<section id="id633">
<h4>References<a class="headerlink" href="#id633" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id634" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Le Bihan, Denis, et al. “Separation of diffusion and perfusion
in intravoxel incoherent motion MR imaging.” Radiology 168.2
(1988): 497-505.</p>
</aside>
<aside class="footnote brackets" id="id635" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Federau, Christian, et al. “Quantitative measurement of brain
perfusion with intravoxel incoherent motion MR imaging.”
Radiology 265.3 (2012): 874-881.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star">
<span class="sig-name descname"><span class="pre">estimate_f_D_star</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params_f_D_star</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate f and D_star using the values of all the other parameters
obtained from a linear fit.</p>
<section id="id636">
<h4>Parameters<a class="headerlink" href="#id636" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>params_f_D_star: array</dt><dd><p>An array containing the value of f and D_star.</p>
</dd>
<dt>data<span class="classifier">array</span></dt><dd><p>Array containing the actual signal values.</p>
</dd>
<dt>S0<span class="classifier">float</span></dt><dd><p>The parameters S0 obtained from a linear fit.</p>
</dd>
<dt>D<span class="classifier">float</span></dt><dd><p>The parameters D obtained from a linear fit.</p>
</dd>
</dl>
</section>
<section id="id637">
<h4>Returns<a class="headerlink" href="#id637" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>f<span class="classifier">float</span></dt><dd><p>Perfusion fraction estimated from the fit.</p>
</dd>
<dt>D_star :</dt><dd><p>The value of D_star estimated from the fit.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit">
<span class="sig-name descname"><span class="pre">estimate_linear_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">less_than</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate a linear fit by taking log of data.</p>
<section id="id638">
<h4>Parameters<a class="headerlink" href="#id638" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">array</span></dt><dd><p>An array containing the data to be fit</p>
</dd>
<dt>split_b<span class="classifier">float</span></dt><dd><p>The b value to split the data</p>
</dd>
<dt>less_than<span class="classifier">bool</span></dt><dd><p>If True, splitting occurs for bvalues less than split_b</p>
</dd>
</dl>
</section>
<section id="id639">
<h4>Returns<a class="headerlink" href="#id639" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S0<span class="classifier">float</span></dt><dd><p>The estimated S0 value. (intercept)</p>
</dd>
<dt>D<span class="classifier">float</span></dt><dd><p>The estimated value of D.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelTRR.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ivim_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelTRR.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal for this IvimModel class instance given parameters.</p>
<section id="id640">
<h4>Parameters<a class="headerlink" href="#id640" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ivim_params<span class="classifier">array</span></dt><dd><p>The ivim parameters as an array [S0, f, D_star and D]</p>
</dd>
<dt>gtab<span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>
</dd>
<dt>S0<span class="classifier">float, optional</span></dt><dd><p>This has been added just for consistency with the existing
API. Unlike other models, IVIM predicts S0 and this is over written
by the S0 value in params.</p>
</dd>
</dl>
</section>
<section id="id641">
<h4>Returns<a class="headerlink" href="#id641" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ivim_signal<span class="classifier">array</span></dt><dd><p>The predicted IVIM signal using given parameters.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="ivimmodelvp">
<h3><a class="reference internal" href="#dipy.reconst.ivim.IvimModelVP" title="dipy.reconst.ivim.IvimModelVP"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimModelVP</span></code></a><a class="headerlink" href="#ivimmodelvp" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">IvimModelVP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize an IvimModelVP class.</p>
<p>The IVIM model assumes that biological tissue includes a volume
fraction ‘f’ of water flowing with a pseudo-diffusion coefficient
D* and a fraction (1-f: treated as a separate fraction in the variable
projection method) of static (diffusion only), intra and
extracellular water, with a diffusion coefficient D. In this model
the echo attenuation of a signal in a single voxel can be written as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\]</div>
<p>S(b) = S_0*[f*e^{(-b*D*)} + (1-f)e^{(-b*D)}]</p>
<p>Where:
.. math:</p>
<p>S_0, f, D* and D are the IVIM parameters.</p>
</div></blockquote>
<dl class="simple">
<dt>maxiter: int, optional</dt><dd><p>Maximum number of iterations for the Differential Evolution in
SciPy.
default : 10</p>
</dd>
<dt>xtol<span class="classifier">float, optional</span></dt><dd><p>Tolerance for convergence of minimization.
default : 1e-8</p>
</dd>
</dl>
<section id="id642">
<h4>References<a class="headerlink" href="#id642" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id643" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Le Bihan, Denis, et al. “Separation of diffusion and perfusion
in intravoxel incoherent motion MR imaging.” Radiology 168.2
(1988): 497-505.</p>
</aside>
<aside class="footnote brackets" id="id644" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Federau, Christian, et al. “Quantitative measurement of brain
perfusion with intravoxel incoherent motion MR imaging.”
Radiology 265.3 (2012): 874-881.</p>
</aside>
<aside class="footnote brackets" id="id645" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Fadnavis, Shreyas et.al. “MicroLearn: Framework for machine
learning, reconstruction, optimization and microstructure
modeling, Proceedings of: International Society of Magnetic
Resonance in Medicine (ISMRM), Montreal, Canada, 2019.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.cvx_fit">
<span class="sig-name descname"><span class="pre">cvx_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.cvx_fit" title="Permalink to this definition">#</a></dt>
<dd><p>Performs the constrained search for the linear parameters <cite>f</cite> after
the estimation of <cite>x</cite> is done. Estimation of the linear parameters <cite>f</cite>
is a constrained linear least-squares optimization problem solved by
using a convex optimizer from cvxpy. The IVIM equation contains two
parameters that depend on the same volume fraction. Both are estimated
as separately in the convex optimizer.</p>
<section id="id646">
<h4>Parameters<a class="headerlink" href="#id646" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>phi<span class="classifier">array</span></dt><dd><p>Returns an array calculated from :func: <cite>phi</cite>.</p>
</dd>
<dt>signal<span class="classifier">array</span></dt><dd><p>The signal values measured for this model.</p>
</dd>
</dl>
</section>
<section id="id647">
<h4>Returns<a class="headerlink" href="#id647" title="Permalink to this heading">#</a></h4>
<p>f1, f2 (volume fractions)</p>
</section>
<section id="id648">
<h4>Notes<a class="headerlink" href="#id648" title="Permalink to this heading">#</a></h4>
<p>cost function for differential evolution algorithm:</p>
<div class="math notranslate nohighlight">
\[minimize(norm((signal)- (phi*f)))\]</div>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one">
<span class="sig-name descname"><span class="pre">ivim_mix_cost_one</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs the objective for the :func: <cite>stoc_search_cost</cite>.</p>
<p>First calculates the Moore-Penrose inverse of the input <cite>phi</cite> and takes
a dot product with the measured signal. The result obtained is again
multiplied with <cite>phi</cite> to complete the projection of the variable into
a transformed space. (see <a href="#id1534"><span class="problematic" id="id649">[1]_</span></a> and <a href="#id1535"><span class="problematic" id="id650">[2]_</span></a> for thorough discussion on
Variable Projections and relevant cost functions).</p>
<section id="id651">
<h4>Parameters<a class="headerlink" href="#id651" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>phi<span class="classifier">array</span></dt><dd><p>Returns an array calculated from :func: <cite>Phi</cite>.</p>
</dd>
<dt>signal<span class="classifier">array</span></dt><dd><p>The signal values measured for this model.</p>
</dd>
</dl>
</section>
<section id="id652">
<h4>Returns<a class="headerlink" href="#id652" title="Permalink to this heading">#</a></h4>
<p>(signal -  S)^T(signal -  S)</p>
</section>
<section id="id653">
<h4>Notes<a class="headerlink" href="#id653" title="Permalink to this heading">#</a></h4>
<p>to make cost function for Differential Evolution algorithm:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">signal</span> <span class="o">-</span>  <span class="n">S</span><span class="p">)</span><span class="o">^</span><span class="n">T</span><span class="p">(</span><span class="n">signal</span> <span class="o">-</span>  <span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id654">
<h4>References<a class="headerlink" href="#id654" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id655" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fadnavis, Shreyas et.al. “MicroLearn: Framework for machine
learning, reconstruction, optimization and microstructure
modeling, Proceedings of: International Society of Magnetic
Resonance in Medicine (ISMRM), Montreal, Canada, 2019.</p>
</aside>
<aside class="footnote brackets" id="id656" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Farooq, Hamza, et al. “Microstructure Imaging of Crossing (MIX)
White Matter Fibers from diffusion MRI.” Scientific reports 6
(2016).</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.nlls_cost">
<span class="sig-name descname"><span class="pre">nlls_cost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.nlls_cost" title="Permalink to this definition">#</a></dt>
<dd><p>Cost function for the least square problem. The cost function is used
in the Least Squares function of SciPy in :func: <cite>fit</cite>. It guarantees
that stopping point of the algorithm is at least a stationary point
with reduction in the the number of iterations required by the
differential evolution optimizer.</p>
<section id="id657">
<h4>Parameters<a class="headerlink" href="#id657" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>x_f<span class="classifier">array</span></dt><dd><p>Contains the parameters ‘x’ and ‘f’ combines in the same array.</p>
</dd>
<dt>signal<span class="classifier">array</span></dt><dd><p>The signal values measured for this model.</p>
</dd>
</dl>
</section>
<section id="id658">
<h4>Returns<a class="headerlink" href="#id658" title="Permalink to this heading">#</a></h4>
<p>sum{(signal -  phi*f)^2}</p>
</section>
<section id="id659">
<h4>Notes<a class="headerlink" href="#id659" title="Permalink to this heading">#</a></h4>
<p>cost function for the least square problem.</p>
<div class="math notranslate nohighlight">
\[sum{(signal -  phi*f)^2}\]</div>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.phi">
<span class="sig-name descname"><span class="pre">phi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.phi" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a structure for the combining the diffusion and pseudo-
diffusion by multiplying with the bvals and then exponentiating each of
the two components for fitting as per the IVIM- two compartment model.</p>
<section id="id660">
<h4>Parameters<a class="headerlink" href="#id660" title="Permalink to this heading">#</a></h4>
<blockquote>
<div><dl class="simple">
<dt>x<span class="classifier">array</span></dt><dd><p>input from the Differential Evolution optimizer.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id661">
<h4>Returns<a class="headerlink" href="#id661" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>exp_phi1<span class="classifier">array</span></dt><dd><p>Combined array of parameters perfusion/pseudo-diffusion
and diffusion parameters.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.stoc_search_cost">
<span class="sig-name descname"><span class="pre">stoc_search_cost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.stoc_search_cost" title="Permalink to this definition">#</a></dt>
<dd><p>Cost function for differential evolution algorithm. Performs a
stochastic search for the non-linear parameters ‘x’. The objective
function is calculated in the :func: <cite>ivim_mix_cost_one</cite>. The function
constructs the parameters using :func: <cite>phi</cite>.</p>
<section id="id662">
<h4>Parameters<a class="headerlink" href="#id662" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>x<span class="classifier">array</span></dt><dd><p>input from the Differential Evolution optimizer.</p>
</dd>
<dt>signal<span class="classifier">array</span></dt><dd><p>The signal values measured for this model.</p>
</dd>
</dl>
</section>
<section id="id663">
<h4>Returns<a class="headerlink" href="#id663" title="Permalink to this heading">#</a></h4>
<dl class="field-list simple">
<dt class="field-odd">func<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>ivim_mix_cost_one</cite></p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f">
<span class="sig-name descname"><span class="pre">x_and_f_to_x_f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f" title="Permalink to this definition">#</a></dt>
<dd><p>Combines the array of parameters ‘x’ and ‘f’ into x_f for performing
NLLS on the final stage of optimization.</p>
<section id="id664">
<h4>Parameters<a class="headerlink" href="#id664" title="Permalink to this heading">#</a></h4>
<blockquote>
<div><dl class="simple">
<dt>x, f<span class="classifier">array</span></dt><dd><p>Split parameters into two separate arrays</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id665">
<h4>Returns<a class="headerlink" href="#id665" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>x_f<span class="classifier">array</span></dt><dd><p>Combined array of parameters ‘x’ and ‘f’ parameters.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f">
<span class="sig-name descname"><span class="pre">x_f_to_x_and_f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f" title="Permalink to this definition">#</a></dt>
<dd><p>Splits the array of parameters in x_f to ‘x’ and ‘f’ for performing
a search on the both of them independently using the Trust Region
Method.</p>
<section id="id666">
<h4>Parameters<a class="headerlink" href="#id666" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>x_f<span class="classifier">array</span></dt><dd><p>Combined array of parameters ‘x’ and ‘f’ parameters.</p>
</dd>
</dl>
</section>
<section id="id667">
<h4>Returns<a class="headerlink" href="#id667" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>x, f<span class="classifier">array</span></dt><dd><p>Split parameters into two separate arrays</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="ivimfit">
<h3><a class="reference internal" href="#dipy.reconst.ivim.IvimFit" title="dipy.reconst.ivim.IvimFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimFit</span></code></a><a class="headerlink" href="#ivimfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">IvimFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a IvimFit class instance.</p>
<section id="id668">
<h4>Parameters<a class="headerlink" href="#id668" title="Permalink to this heading">#</a></h4>
<p>model : Model class</p>
<dl class="simple">
<dt>model_params<span class="classifier">array</span></dt><dd><p>The parameters of the model. In this case it is an
array of ivim parameters. If the fitting is done
for multi_voxel data, the multi_voxel decorator will
run the fitting on all the voxels and model_params
will be an array of the dimensions (data[:-1], 4),
i.e., there will be 4 parameters for each of the voxels.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.D">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">D</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.D" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.D_star">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">D_star</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.D_star" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.S0_predicted">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">S0_predicted</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.S0_predicted" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.perfusion_fraction">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">perfusion_fraction</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.perfusion_fraction" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Given a model fit, predict the signal.</p>
<section id="id669">
<h4>Parameters<a class="headerlink" href="#id669" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues</p>
</dd>
<dt>S0<span class="classifier">float</span></dt><dd><p>S0 value here is not necessary and will not be used to predict the
signal. It has been added to conform to the structure of the
predict method in multi_voxel which requires a keyword argument S0.</p>
</dd>
</dl>
</section>
<section id="id670">
<h4>Returns<a class="headerlink" href="#id670" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>signal<span class="classifier">array</span></dt><dd><p>The signal values predicted for this model using its parameters.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.ivim.IvimFit.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.shape" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="ivim-prediction">
<h3>ivim_prediction<a class="headerlink" href="#ivim-prediction" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.ivim.ivim_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">ivim_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.ivim_prediction" title="Permalink to this definition">#</a></dt>
<dd><p>The Intravoxel incoherent motion (IVIM) model function.</p>
<section id="id671">
<h4>Parameters<a class="headerlink" href="#id671" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">array</span></dt><dd><p>An array of IVIM parameters - [S0, f, D_star, D].</p>
</dd>
<dt>gtab<span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>
</dd>
<dt>S0<span class="classifier">float, optional</span></dt><dd><p>This has been added just for consistency with the existing
API. Unlike other models, IVIM predicts S0 and this is over written
by the S0 value in params.</p>
</dd>
</dl>
</section>
<section id="id672">
<h4>Returns<a class="headerlink" href="#id672" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">array</span></dt><dd><p>An array containing the IVIM signal estimated using given parameters.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="f-d-star-prediction">
<h3>f_D_star_prediction<a class="headerlink" href="#f-d-star-prediction" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.ivim.f_D_star_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">f_D_star_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.f_D_star_prediction" title="Permalink to this definition">#</a></dt>
<dd><p>Function used to predict IVIM signal when S0 and D are known
by considering f and D_star as the unknown parameters.</p>
<section id="id673">
<h4>Parameters<a class="headerlink" href="#id673" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">array</span></dt><dd><p>The value of f and D_star.</p>
</dd>
<dt>gtab<span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>
</dd>
<dt>S0<span class="classifier">float</span></dt><dd><p>The parameters S0 obtained from a linear fit.</p>
</dd>
<dt>D<span class="classifier">float</span></dt><dd><p>The parameters D obtained from a linear fit.</p>
</dd>
</dl>
</section>
<section id="id674">
<h4>Returns<a class="headerlink" href="#id674" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">array</span></dt><dd><p>An array containing the IVIM signal estimated using given parameters.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="f-d-star-error">
<h3>f_D_star_error<a class="headerlink" href="#f-d-star-error" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.ivim.f_D_star_error">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">f_D_star_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.f_D_star_error" title="Permalink to this definition">#</a></dt>
<dd><p>Error function used to fit f and D_star keeping S0 and D fixed</p>
<section id="id675">
<h4>Parameters<a class="headerlink" href="#id675" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">array</span></dt><dd><p>The value of f and D_star.</p>
</dd>
<dt>gtab<span class="classifier">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>
</dd>
<dt>signal<span class="classifier">array</span></dt><dd><p>Array containing the actual signal values.</p>
</dd>
<dt>S0<span class="classifier">float</span></dt><dd><p>The parameters S0 obtained from a linear fit.</p>
</dd>
<dt>D<span class="classifier">float</span></dt><dd><p>The parameters D obtained from a linear fit.</p>
</dd>
</dl>
</section>
<section id="id676">
<h4>Returns<a class="headerlink" href="#id676" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>residual<span class="classifier">array</span></dt><dd><p>An array containing the difference of actual and estimated signal.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="ivim-model-selector">
<h3>ivim_model_selector<a class="headerlink" href="#ivim-model-selector" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.ivim.ivim_model_selector">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.ivim.</span></span><span class="sig-name descname"><span class="pre">ivim_model_selector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trr'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.ivim_model_selector" title="Permalink to this definition">#</a></dt>
<dd><p>Selector function to switch between the 2-stage Trust-Region Reflective
based NLLS fitting method (also containing the linear fit): <cite>trr</cite> and the
Variable Projections based fitting method: <cite>varpro</cite>.</p>
<section id="id677">
<h4>Parameters<a class="headerlink" href="#id677" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>fit_method<span class="classifier">string, optional</span></dt><dd><p>The value fit_method can either be ‘trr’ or ‘varpro’.
default : trr</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="mapmrimodel">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.MapmriModel" title="dipy.reconst.mapmri.MapmriModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriModel</span></code></a><a class="headerlink" href="#mapmrimodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">MapmriModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positivity_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'adaptive'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anisotropic_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bval_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dti_scale_estimation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0007</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>Mean Apparent Propagator MRI (MAPMRI) <a href="#id1536"><span class="problematic" id="id678">[1]_</span></a> of the diffusion signal.</p>
<p>The main idea is to model the diffusion signal as a linear combination of
the continuous functions presented in <a href="#id1537"><span class="problematic" id="id679">[2]_</span></a> but extending it in three
dimensions.
The main difference with the SHORE proposed in <a href="#id1538"><span class="problematic" id="id680">[3]_</span></a> is that MAPMRI 3D
extension is provided using a set of three basis functions for the radial
part, one for the signal along x, one for y and one for z, while <a href="#id1539"><span class="problematic" id="id681">[3]_</span></a>
uses one basis function to model the radial part and real Spherical
Harmonics to model the angular part.
From the MAPMRI coefficients is possible to use the analytical formulae
to estimate the ODF.</p>
<section id="id682">
<h4>References<a class="headerlink" href="#id682" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id683" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</aside>
<aside class="footnote brackets" id="id684" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Simple harmonic oscillator based reconstruction
and estimation for one-dimensional q-space magnetic resonance
1D-SHORE)”, eapoc Intl Soc Mag Reson Med, vol. 16, p. 35., 2008.</p>
</aside>
<aside class="footnote brackets" id="id685" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Merlet S. et al., “Continuous diffusion signal, EAP and ODF
estimation via Compressive Sensing in diffusion MRI”, Medical
Image Analysis, 2013.</p>
</aside>
<aside class="footnote brackets" id="id686" role="note">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation
using Laplacian-regularized MAP-MRI and its application to HCP
data.” NeuroImage (2016).</p>
</aside>
<aside class="footnote brackets" id="id687" role="note">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>Cheng, J., 2014. Estimation and Processing of Ensemble Average
Propagator and Its Features in Diffusion MRI. Ph.D. Thesis.</p>
</aside>
<aside class="footnote brackets" id="id688" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Hosseinbor et al. “Bessel fourier orientation reconstruction
(bfor): An analytical diffusion propagator reconstruction for hybrid
diffusion imaging and computation of q-space indices”. NeuroImage
64, 2013, 650-670.</p>
</aside>
<aside class="footnote brackets" id="id689" role="note">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Craven et al. “Smoothing Noisy Data with Spline Functions.”
NUMER MATH 31.4 (1978): 377-403.</p>
</aside>
<aside class="footnote brackets" id="id690" role="note">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<p>Avram et al. “Clinical feasibility of using mean apparent
propagator (MAP) MRI to characterize brain tissue microstructure”.
NeuroImage 2015, in press.</p>
</aside>
<aside class="footnote brackets" id="id691" role="note">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<p>Dela Haije et al. “Enforcing necessary non-negativity constraints
for common diffusion MRI models using sum of squares programming”.
NeuroImage 209, 2020, 116405.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positivity_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'adaptive'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anisotropic_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bval_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dti_scale_estimation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_diffusivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0007</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Analytical and continuous modeling of the diffusion signal with
respect to the MAPMRI basis <a href="#id1540"><span class="problematic" id="id692">[1]_</span></a>.</p>
<p>The main idea is to model the diffusion signal as a linear combination
of the continuous functions presented in <a href="#id1541"><span class="problematic" id="id693">[2]_</span></a> but extending it in three
dimensions.</p>
<p>The main difference with the SHORE proposed in <a href="#id1542"><span class="problematic" id="id694">[3]_</span></a> is that MAPMRI 3D
extension is provided using a set of three basis functions for the
radial part, one for the signal along x, one for y and one for z, while
<a href="#id1543"><span class="problematic" id="id695">[3]_</span></a> uses one basis function to model the radial part and real
Spherical Harmonics to model the angular part.</p>
<p>From the MAPMRI coefficients it is possible to estimate various
q-space indices, the PDF and the ODF.</p>
<p>The fitting procedure can be constrained using the positivity
constraint proposed in <a href="#id1544"><span class="problematic" id="id696">[1]_</span></a> or <a href="#id1545"><span class="problematic" id="id697">[4]_</span></a> and/or the laplacian regularization
proposed in <a href="#id1546"><span class="problematic" id="id698">[5]_</span></a>.</p>
<p>For the estimation of q-space indices we recommend using the ‘regular’
anisotropic implementation of MAPMRI. However, it has been shown that
the ODF estimation in this implementation has a bias which
‘squeezes together’ the ODF peaks when there is a crossing at an angle
smaller than 90 degrees <a href="#id1547"><span class="problematic" id="id699">[5]_</span></a>. When you want to estimate ODFs for
tractography we therefore recommend using the isotropic implementation
(which is equivalent to <a href="#id1548"><span class="problematic" id="id700">[3]_</span></a>).</p>
<p>The switch between isotropic and anisotropic can be easily made through
the anisotropic_scaling option.</p>
<section id="id701">
<h5>Parameters<a class="headerlink" href="#id701" title="Permalink to this heading">#</a></h5>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable,</span></dt><dd><p>gradient directions and bvalues container class.
the gradient table has to include b0-images.</p>
</dd>
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt>laplacian_regularization: bool,</dt><dd><p>Regularize using the Laplacian of the MAP-MRI basis.</p>
</dd>
<dt>laplacian_weighting: string or scalar,</dt><dd><p>The string ‘GCV’ makes it use generalized cross-validation to find
the regularization weight [4]. A scalar sets the regularization
weight to that value and an array will make it selected the
optimal weight from the values in the array.</p>
</dd>
<dt>positivity_constraint<span class="classifier">bool,</span></dt><dd><p>Constrain the propagator to be positive.</p>
</dd>
<dt>global_constraints<span class="classifier">bool, optional</span></dt><dd><p>If set to False, positivity is enforced on a grid determined by
pos_grid and pos_radius. If set to True, positivity is enforced
everywhere using the constraints of <a href="#id1549"><span class="problematic" id="id702">[6]_</span></a>. Global constraints are
currently supported for anisotropic_scaling=True and for
radial_order &lt;= 10. Default: False.</p>
</dd>
<dt>pos_grid<span class="classifier">integer,</span></dt><dd><p>The number of points in the grid that is used in the local
positivity constraint.</p>
</dd>
<dt>pos_radius<span class="classifier">float or string,</span></dt><dd><p>If set to a float, the maximum distance the local positivity
constraint constrains to posivity is that value. If set to
‘adaptive’, the maximum distance is dependent on the estimated
tissue diffusivity.</p>
</dd>
<dt>anisotropic_scaling<span class="classifier">bool,</span></dt><dd><p>If True, uses the standard anisotropic MAP-MRI basis. If False,
uses the isotropic MAP-MRI basis (equal to 3D-SHORE).</p>
</dd>
<dt>eigenvalue_threshold<span class="classifier">float,</span></dt><dd><p>Sets the minimum of the tensor eigenvalues in order to avoid
stability problem.</p>
</dd>
<dt>bval_threshold<span class="classifier">float,</span></dt><dd><p>Sets the b-value threshold to be used in the scale factor
estimation. In order for the estimated non-Gaussianity to have
meaning this value should set to a lower value (b&lt;2000 s/mm^2)
such that the scale factors are estimated on signal points that
reasonably represent the spins at Gaussian diffusion.</p>
</dd>
<dt>dti_scale_estimation<span class="classifier">bool,</span></dt><dd><p>Whether or not DTI fitting is used to estimate the isotropic scale
factor for isotropic MAP-MRI.
When set to False the algorithm presets the isotropic tissue
diffusivity to static_diffusivity. This vastly increases fitting
speed but at the cost of slightly reduced fitting quality. Can
still be used in combination with regularization and constraints.</p>
</dd>
<dt>static_diffusivity<span class="classifier">float,</span></dt><dd><p>the tissue diffusivity that is used when dti_scale_estimation is
set to False. The default is that of typical white matter
D=0.7e-3 _[5].</p>
</dd>
<dt>cvxpy_solver<span class="classifier">str, optional</span></dt><dd><p>cvxpy solver name. Optionally optimize the positivity constraint
with a particular cvxpy solver. See <a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a> for
details.
Default: None (cvxpy chooses its own solver)</p>
</dd>
</dl>
</section>
<section id="id703">
<h5>References<a class="headerlink" href="#id703" title="Permalink to this heading">#</a></h5>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id704" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</aside>
<aside class="footnote brackets" id="id705" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Simple harmonic oscillator based
reconstruction and estimation for one-dimensional q-space
magnetic resonance 1D-SHORE)”, Proc Intl Soc Mag Reson Med,
vol. 16, p. 35., 2008.</p>
</aside>
<aside class="footnote brackets" id="id706" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Simple harmonic oscillator based
reconstruction and estimation for three-dimensional q-space
mri”, ISMRM 2009.</p>
</aside>
<aside class="footnote brackets" id="id707" role="note">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Dela Haije et al. “Enforcing necessary non-negativity
constraints for common diffusion MRI models using sum of squares
programming”. NeuroImage 209, 2020, 116405.</p>
</aside>
<aside class="footnote brackets" id="id708" role="note">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation
using Laplacian-regularized MAP-MRI and its application to HCP
data.” NeuroImage (2016).</p>
</aside>
<aside class="footnote brackets" id="id709" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Merlet S. et al., “Continuous diffusion signal, EAP and ODF
estimation via Compressive Sensing in diffusion MRI”, Medical
Image Analysis, 2013.</p>
</aside>
</aside>
</section>
<section id="id710">
<h5>Examples<a class="headerlink" href="#id710" title="Permalink to this heading">#</a></h5>
<p>In this example, where the data, gradient table and sphere tessellation
used for reconstruction are provided, we model the diffusion signal
with respect to the SHORE basis and compute the real and analytical
ODF.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="kn">import</span> <span class="n">dsi_voxels</span><span class="p">,</span> <span class="n">default_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="kn">import</span> <span class="n">gradient_table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">gtab_</span> <span class="o">=</span> <span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gtab</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">gtab_</span><span class="o">.</span><span class="n">bvals</span><span class="p">,</span> <span class="n">gtab_</span><span class="o">.</span><span class="n">bvecs</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">b0_threshold</span><span class="o">=</span><span class="n">gtab_</span><span class="o">.</span><span class="n">bvals</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.sims.voxel</span> <span class="kn">import</span> <span class="n">sticks_and_ball</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">golden_directions</span> <span class="o">=</span> <span class="n">sticks_and_ball</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">0.0015</span><span class="p">,</span> <span class="n">S0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                                          <span class="n">angles</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span>                                                  <span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="gp">... </span>                                          <span class="n">fractions</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
<span class="gp">... </span>                                          <span class="n">snr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.mapmri</span> <span class="kn">import</span> <span class="n">MapmriModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radial_order</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_model</span> <span class="o">=</span> <span class="n">MapmriModel</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">radial_order</span><span class="o">=</span><span class="n">radial_order</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mapfit</span> <span class="o">=</span> <span class="n">map_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf</span> <span class="o">=</span> <span class="n">mapfit</span><span class="o">.</span><span class="n">odf</span><span class="p">(</span><span class="n">default_sphere</span><span class="p">)</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="mapmrifit">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit" title="dipy.reconst.mapmri.MapmriFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriFit</span></code></a><a class="headerlink" href="#mapmrifit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">MapmriFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapmri_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errorcode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapmri_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errorcode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates diffusion properties for a single voxel</p>
<section id="id711">
<h4>Parameters<a class="headerlink" href="#id711" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">object,</span></dt><dd><p>AnalyticalModel</p>
</dd>
<dt>mapmri_coef<span class="classifier">1d ndarray,</span></dt><dd><p>mapmri coefficients</p>
</dd>
<dt>mu<span class="classifier">array, shape (3,)</span></dt><dd><p>scale parameters vector for x, y and z</p>
</dd>
<dt>R<span class="classifier">array, shape (3,3)</span></dt><dd><p>rotation matrix</p>
</dd>
<dt>lopt<span class="classifier">float,</span></dt><dd><p>regularization weight used for laplacian regularization</p>
</dd>
<dt>errorcode<span class="classifier">int</span></dt><dd><p>provides information on whether errors occurred in the fitting
of each voxel. 0 means no problem, 1 means a LinAlgError
occurred when trying to invert the design matrix. 2 means the
positivity constraint was unable to solve the problem. 3 means
that after positivity constraint failed, also matrix inversion
failed.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.fitted_signal">
<span class="sig-name descname"><span class="pre">fitted_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.fitted_signal" title="Permalink to this definition">#</a></dt>
<dd><p>Recovers the fitted signal for the given gradient table. If no gradient
table is given it recovers the signal for the gtab of the model object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.mapmri_R">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mapmri_R</span></span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.mapmri_R" title="Permalink to this definition">#</a></dt>
<dd><p>The MAPMRI rotation matrix</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.mapmri_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mapmri_coeff</span></span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.mapmri_coeff" title="Permalink to this definition">#</a></dt>
<dd><p>The MAPMRI coefficients</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.mapmri_mu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mapmri_mu</span></span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.mapmri_mu" title="Permalink to this definition">#</a></dt>
<dd><p>The MAPMRI scale factors</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.msd">
<span class="sig-name descname"><span class="pre">msd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.msd" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical Mean Squared Displacement (MSD).
It is defined as the Laplacian of the origin of the estimated signal
<a href="#id1550"><span class="problematic" id="id712">[1]_</span></a>. The analytical formula for the MAP-MRI basis was derived in <a href="#id1551"><span class="problematic" id="id713">[2]_</span></a>
eq. (C13, D1).</p>
<section id="id714">
<h4>References<a class="headerlink" href="#id714" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id715" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Cheng, J., 2014. Estimation and Processing of Ensemble Average</p>
</aside>
</aside>
<p>Propagator and Its Features in Diffusion MRI. Ph.D. Thesis.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id716" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.ng">
<span class="sig-name descname"><span class="pre">ng</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.ng" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical non-Gaussiannity (NG) <a href="#id1552"><span class="problematic" id="id717">[1]_</span></a>.
For the NG to be meaningful the mapmri scale factors must be
estimated only on data representing Gaussian diffusion of spins, i.e.,
bvals smaller than about 2000 s/mm^2 <a href="#id1553"><span class="problematic" id="id718">[2]_</span></a>.</p>
<section id="id719">
<h4>References<a class="headerlink" href="#id719" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id720" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id721" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Avram et al. “Clinical feasibility of using mean apparent</p>
</aside>
</aside>
<p>propagator (MAP) MRI to characterize brain tissue microstructure”.
NeuroImage 2015, in press.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.ng_parallel">
<span class="sig-name descname"><span class="pre">ng_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.ng_parallel" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical parallel non-Gaussiannity (NG) <a href="#id1554"><span class="problematic" id="id722">[1]_</span></a>.
For the NG to be meaningful the mapmri scale factors must be
estimated only on data representing Gaussian diffusion of spins, i.e.,
bvals smaller than about 2000 s/mm^2 <a href="#id1555"><span class="problematic" id="id723">[2]_</span></a>.</p>
<section id="id724">
<h4>References<a class="headerlink" href="#id724" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id725" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id726" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Avram et al. “Clinical feasibility of using mean apparent</p>
</aside>
</aside>
<p>propagator (MAP) MRI to characterize brain tissue microstructure”.
NeuroImage 2015, in press.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.ng_perpendicular">
<span class="sig-name descname"><span class="pre">ng_perpendicular</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.ng_perpendicular" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical perpendicular non-Gaussiannity (NG)
<a href="#id1556"><span class="problematic" id="id727">[1]_</span></a>. For the NG to be meaningful the mapmri scale factors must be
estimated only on data representing Gaussian diffusion of spins, i.e.,
bvals smaller than about 2000 s/mm^2 <a href="#id1557"><span class="problematic" id="id728">[2]_</span></a>.</p>
<section id="id729">
<h4>References<a class="headerlink" href="#id729" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id730" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id731" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Avram et al. “Clinical feasibility of using mean apparent</p>
</aside>
</aside>
<p>propagator (MAP) MRI to characterize brain tissue microstructure”.
NeuroImage 2015, in press.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal">
<span class="sig-name descname"><span class="pre">norm_of_laplacian_signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the norm of the laplacian of the fitted signal <a href="#id1558"><span class="problematic" id="id732">[1]_</span></a>.
This information could be useful to assess if the extrapolation of the
fitted signal contains spurious oscillations. A high laplacian may
indicate that these are present, and any q-space indices that
use integrals of the signal may be corrupted (e.g. RTOP, RTAP, RTPP,
QIV).</p>
<section id="id733">
<h4>References<a class="headerlink" href="#id733" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id734" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical Orientation Distribution Function (ODF)
from the signal <a href="#id1559"><span class="problematic" id="id735">[1]_</span></a> Eq. (32).</p>
<section id="id736">
<h4>Parameters<a class="headerlink" href="#id736" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere</span></dt><dd><p>A Sphere instance with vertices, edges and faces attributes.</p>
</dd>
<dt>s<span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
</dl>
</section>
<section id="id737">
<h4>References<a class="headerlink" href="#id737" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id738" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.odf_sh">
<span class="sig-name descname"><span class="pre">odf_sh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.odf_sh" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the real analytical odf for a given discrete sphere.
Computes the design matrix of the ODF for the given sphere vertices
and radial moment <a href="#id1560"><span class="problematic" id="id739">[1]_</span></a> eq. (32). The radial moment s acts as a
sharpening method. The analytical equation for the spherical ODF basis
is given in <a href="#id1561"><span class="problematic" id="id740">[2]_</span></a> eq. (C8).</p>
<section id="id741">
<h4>References<a class="headerlink" href="#id741" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id742" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id743" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.pdf" title="Permalink to this definition">#</a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qvals_or_gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Recovers the reconstructed signal for any qvalue array or
gradient table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.qiv">
<span class="sig-name descname"><span class="pre">qiv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.qiv" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical Q-space Inverse Variance (QIV).
It is defined as the inverse of the Laplacian of the origin of the
estimated propagator <a href="#id1562"><span class="problematic" id="id744">[1]_</span></a> eq. (22). The analytical formula for the
MAP-MRI basis was derived in <a href="#id1563"><span class="problematic" id="id745">[2]_</span></a> eq. (C14, D2).</p>
<section id="id746">
<h4>References<a class="headerlink" href="#id746" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id747" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Hosseinbor et al. “Bessel fourier orientation reconstruction</p>
</aside>
</aside>
<p>(bfor): An analytical diffusion propagator reconstruction for hybrid
diffusion imaging and computation of q-space indices. NeuroImage 64,
2013, 650-670.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id748" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.rtap">
<span class="sig-name descname"><span class="pre">rtap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.rtap" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the axis probability (RTAP)
<a href="#id1564"><span class="problematic" id="id749">[1]_</span></a> eq. (40, 44a). The analytical formula for the isotropic MAP-MRI
basis was derived in <a href="#id1565"><span class="problematic" id="id750">[2]_</span></a> eq. (C11).</p>
<section id="id751">
<h4>References<a class="headerlink" href="#id751" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id752" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id753" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.rtop">
<span class="sig-name descname"><span class="pre">rtop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.rtop" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the origin probability (RTOP)
<a href="#id1566"><span class="problematic" id="id754">[1]_</span></a> eq. (36, 43). The analytical formula for the isotropic MAP-MRI
basis was derived in <a href="#id1567"><span class="problematic" id="id755">[2]_</span></a> eq. (C11).</p>
<section id="id756">
<h4>References<a class="headerlink" href="#id756" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id757" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id758" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.MapmriFit.rtpp">
<span class="sig-name descname"><span class="pre">rtpp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.rtpp" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the plane probability (RTPP)
<a href="#id1568"><span class="problematic" id="id759">[1]_</span></a> eq. (42). The analytical formula for the isotropic MAP-MRI
basis was derived in <a href="#id1569"><span class="problematic" id="id760">[2]_</span></a> eq. (C11).</p>
<section id="id761">
<h4>References<a class="headerlink" href="#id761" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id762" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id763" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="isotropic-scale-factor">
<h3>isotropic_scale_factor<a class="headerlink" href="#isotropic-scale-factor" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.isotropic_scale_factor">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">isotropic_scale_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu_squared</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.isotropic_scale_factor" title="Permalink to this definition">#</a></dt>
<dd><p>Estimated isotropic scaling factor _[1] Eq. (49).</p>
<section id="id764">
<h4>Parameters<a class="headerlink" href="#id764" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>mu_squared<span class="classifier">array, shape (N,3)</span></dt><dd><p>squared scale factors of mapmri basis in x, y, z</p>
</dd>
</dl>
</section>
<section id="id765">
<h4>Returns<a class="headerlink" href="#id765" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>u0<span class="classifier">float</span></dt><dd><p>closest isotropic scale factor for the isotropic basis</p>
</dd>
</dl>
</section>
<section id="id766">
<h4>References<a class="headerlink" href="#id766" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id767" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-index-matrix">
<h3>mapmri_index_matrix<a class="headerlink" href="#mapmri-index-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_index_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the indices for the MAPMRI <a href="#id1570"><span class="problematic" id="id768">[1]_</span></a> basis in x, y and z.</p>
<section id="id769">
<h4>Parameters<a class="headerlink" href="#id769" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int</span></dt><dd><p>radial order of MAPMRI basis</p>
</dd>
</dl>
</section>
<section id="id770">
<h4>Returns<a class="headerlink" href="#id770" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>index_matrix<span class="classifier">array, shape (N,3)</span></dt><dd><p>ordering of the basis in x, y, z</p>
</dd>
</dl>
</section>
<section id="id771">
<h4>References<a class="headerlink" href="#id771" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id772" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="b-mat">
<h3>b_mat<a class="headerlink" href="#b-mat" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.b_mat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">b_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.b_mat" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the B coefficients from <a href="#id1571"><span class="problematic" id="id773">[1]_</span></a> Eq. (27).</p>
<section id="id774">
<h4>Parameters<a class="headerlink" href="#id774" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>index_matrix<span class="classifier">array, shape (N,3)</span></dt><dd><p>ordering of the basis in x, y, z</p>
</dd>
</dl>
</section>
<section id="id775">
<h4>Returns<a class="headerlink" href="#id775" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>B<span class="classifier">array, shape (N,)</span></dt><dd><p>B coefficients for the basis</p>
</dd>
</dl>
</section>
<section id="id776">
<h4>References<a class="headerlink" href="#id776" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id777" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="b-mat-isotropic">
<h3>b_mat_isotropic<a class="headerlink" href="#b-mat-isotropic" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.b_mat_isotropic">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">b_mat_isotropic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.b_mat_isotropic" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the isotropic B coefficients from <a href="#id1572"><span class="problematic" id="id778">[1]_</span></a> Fig 8.</p>
<section id="id779">
<h4>Parameters<a class="headerlink" href="#id779" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>index_matrix<span class="classifier">array, shape (N,3)</span></dt><dd><p>ordering of the isotropic basis in j, l, m</p>
</dd>
</dl>
</section>
<section id="id780">
<h4>Returns<a class="headerlink" href="#id780" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>B<span class="classifier">array, shape (N,)</span></dt><dd><p>B coefficients for the isotropic basis</p>
</dd>
</dl>
</section>
<section id="id781">
<h4>References<a class="headerlink" href="#id781" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id782" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-phi-1d">
<h3>mapmri_phi_1d<a class="headerlink" href="#mapmri-phi-1d" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_phi_1d">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_phi_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_phi_1d" title="Permalink to this definition">#</a></dt>
<dd><p>One dimensional MAPMRI basis function from <a href="#id1573"><span class="problematic" id="id783">[1]_</span></a> Eq. (4).</p>
<section id="id784">
<h4>Parameters<a class="headerlink" href="#id784" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>n<span class="classifier">unsigned int</span></dt><dd><p>order of the basis</p>
</dd>
<dt>q<span class="classifier">array, shape (N,)</span></dt><dd><p>points in the q-space in which evaluate the basis</p>
</dd>
<dt>mu<span class="classifier">float</span></dt><dd><p>scale factor of the basis</p>
</dd>
</dl>
</section>
<section id="id785">
<h4>References<a class="headerlink" href="#id785" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id786" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-phi-matrix">
<h3>mapmri_phi_matrix<a class="headerlink" href="#mapmri-phi-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_phi_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_phi_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_gradients</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_phi_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the MAPMRI phi matrix for the signal <a href="#id1574"><span class="problematic" id="id787">[1]_</span></a> eq. (23).</p>
<section id="id788">
<h4>Parameters<a class="headerlink" href="#id788" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt>mu<span class="classifier">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>
</dd>
<dt>q_gradients<span class="classifier">array, shape (N,3)</span></dt><dd><p>points in the q-space in which evaluate the basis</p>
</dd>
</dl>
</section>
<section id="id789">
<h4>References<a class="headerlink" href="#id789" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id790" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-psi-1d">
<h3>mapmri_psi_1d<a class="headerlink" href="#mapmri-psi-1d" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_psi_1d">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_psi_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_psi_1d" title="Permalink to this definition">#</a></dt>
<dd><p>One dimensional MAPMRI propagator basis function from <a href="#id1575"><span class="problematic" id="id791">[1]_</span></a> Eq. (10).</p>
<section id="id792">
<h4>Parameters<a class="headerlink" href="#id792" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>n<span class="classifier">unsigned int</span></dt><dd><p>order of the basis</p>
</dd>
<dt>x<span class="classifier">array, shape (N,)</span></dt><dd><p>points in the r-space in which evaluate the basis</p>
</dd>
<dt>mu<span class="classifier">float</span></dt><dd><p>scale factor of the basis</p>
</dd>
</dl>
</section>
<section id="id793">
<h4>References<a class="headerlink" href="#id793" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id794" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-psi-matrix">
<h3>mapmri_psi_matrix<a class="headerlink" href="#mapmri-psi-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_psi_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_psi_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgrad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_psi_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the MAPMRI psi matrix for the propagator <a href="#id1576"><span class="problematic" id="id795">[1]_</span></a> eq. (22).</p>
<section id="id796">
<h4>Parameters<a class="headerlink" href="#id796" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt>mu<span class="classifier">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>
</dd>
<dt>rgrad<span class="classifier">array, shape (N,3)</span></dt><dd><p>points in the r-space in which evaluate the EAP</p>
</dd>
</dl>
</section>
<section id="id797">
<h4>References<a class="headerlink" href="#id797" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id798" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-odf-matrix">
<h3>mapmri_odf_matrix<a class="headerlink" href="#mapmri-odf-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_odf_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_odf_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_odf_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the MAPMRI ODF matrix <a href="#id1577"><span class="problematic" id="id799">[1]_</span></a>  Eq. (33).</p>
<section id="id800">
<h4>Parameters<a class="headerlink" href="#id800" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt>mu<span class="classifier">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>
</dd>
<dt>s<span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
<dt>vertices<span class="classifier">array, shape (N,3)</span></dt><dd><p>points of the sphere shell in the r-space in which evaluate the ODF</p>
</dd>
</dl>
</section>
<section id="id801">
<h4>References<a class="headerlink" href="#id801" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id802" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-isotropic-phi-matrix">
<h3>mapmri_isotropic_phi_matrix<a class="headerlink" href="#mapmri-isotropic-phi-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_phi_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_phi_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Three dimensional isotropic MAPMRI signal basis function from <a href="#id1578"><span class="problematic" id="id803">[1]_</span></a>
Eq. (61).</p>
<section id="id804">
<h4>Parameters<a class="headerlink" href="#id804" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>radial order of the mapmri basis.</p>
</dd>
<dt>mu<span class="classifier">float,</span></dt><dd><p>positive isotropic scale factor of the basis</p>
</dd>
<dt>q<span class="classifier">array, shape (N,3)</span></dt><dd><p>points in the q-space in which evaluate the basis</p>
</dd>
</dl>
</section>
<section id="id805">
<h4>References<a class="headerlink" href="#id805" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id806" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-isotropic-radial-signal-basis">
<h3>mapmri_isotropic_radial_signal_basis<a class="headerlink" href="#mapmri-isotropic-radial-signal-basis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_radial_signal_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Radial part of the isotropic 1D-SHORE signal basis <a href="#id1579"><span class="problematic" id="id807">[1]_</span></a> eq. (61).</p>
<section id="id808">
<h4>Parameters<a class="headerlink" href="#id808" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>j<span class="classifier">unsigned int,</span></dt><dd><p>a positive integer related to the radial order</p>
</dd>
<dt>l<span class="classifier">unsigned int,</span></dt><dd><p>the spherical harmonic order</p>
</dd>
<dt>mu<span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the basis</p>
</dd>
<dt>qval<span class="classifier">float,</span></dt><dd><p>points in the q-space in which evaluate the basis</p>
</dd>
</dl>
</section>
<section id="id809">
<h4>References<a class="headerlink" href="#id809" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id810" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-isotropic-m-mu-independent">
<h3>mapmri_isotropic_M_mu_independent<a class="headerlink" href="#mapmri-isotropic-m-mu-independent" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_M_mu_independent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent" title="Permalink to this definition">#</a></dt>
<dd><p>Computed the mu independent part of the signal design matrix.</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-m-mu-dependent">
<h3>mapmri_isotropic_M_mu_dependent<a class="headerlink" href="#mapmri-isotropic-m-mu-dependent" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_M_mu_dependent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent" title="Permalink to this definition">#</a></dt>
<dd><p>Computed the mu dependent part of the signal design matrix.</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-psi-matrix">
<h3>mapmri_isotropic_psi_matrix<a class="headerlink" href="#mapmri-isotropic-psi-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_psi_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_psi_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgrad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Three dimensional isotropic MAPMRI propagator basis function from <a href="#id1580"><span class="problematic" id="id811">[1]_</span></a>
Eq. (61).</p>
<section id="id812">
<h4>Parameters<a class="headerlink" href="#id812" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>radial order of the mapmri basis.</p>
</dd>
<dt>mu<span class="classifier">float,</span></dt><dd><p>positive isotropic scale factor of the basis</p>
</dd>
<dt>rgrad<span class="classifier">array, shape (N,3)</span></dt><dd><p>points in the r-space in which evaluate the basis</p>
</dd>
</dl>
</section>
<section id="id813">
<h4>References<a class="headerlink" href="#id813" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id814" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-isotropic-radial-pdf-basis">
<h3>mapmri_isotropic_radial_pdf_basis<a class="headerlink" href="#mapmri-isotropic-radial-pdf-basis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_radial_pdf_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Radial part of the isotropic 1D-SHORE propagator basis <a href="#id1581"><span class="problematic" id="id815">[1]_</span></a> eq. (61).</p>
<section id="id816">
<h4>Parameters<a class="headerlink" href="#id816" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>j<span class="classifier">unsigned int,</span></dt><dd><p>a positive integer related to the radial order</p>
</dd>
<dt>l<span class="classifier">unsigned int,</span></dt><dd><p>the spherical harmonic order</p>
</dd>
<dt>mu<span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the basis</p>
</dd>
<dt>r<span class="classifier">float,</span></dt><dd><p>points in the r-space in which evaluate the basis</p>
</dd>
</dl>
</section>
<section id="id817">
<h4>References<a class="headerlink" href="#id817" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id818" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="mapmri-isotropic-k-mu-independent">
<h3>mapmri_isotropic_K_mu_independent<a class="headerlink" href="#mapmri-isotropic-k-mu-independent" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_K_mu_independent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgrad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent" title="Permalink to this definition">#</a></dt>
<dd><p>Computes mu independent part of K. Same trick as with M.</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-k-mu-dependent">
<h3>mapmri_isotropic_K_mu_dependent<a class="headerlink" href="#mapmri-isotropic-k-mu-dependent" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_K_mu_dependent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgrad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent" title="Permalink to this definition">#</a></dt>
<dd><p>Computes mu dependent part of M. Same trick as with M.</p>
</dd></dl>

</section>
<section id="binomialfloat">
<h3>binomialfloat<a class="headerlink" href="#binomialfloat" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.binomialfloat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">binomialfloat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.binomialfloat" title="Permalink to this definition">#</a></dt>
<dd><p>Custom Binomial function</p>
</dd></dl>

</section>
<section id="mapmri-isotropic-odf-matrix">
<h3>mapmri_isotropic_odf_matrix<a class="headerlink" href="#mapmri-isotropic-odf-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_odf_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_odf_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the isotropic MAPMRI ODF matrix <a href="#id1582"><span class="problematic" id="id819">[1]_</span></a> Eq. 32 but for the
isotropic propagator in <a href="#id1583"><span class="problematic" id="id820">[1]_</span></a> eq. (60). Analytical derivation in
<a href="#id1584"><span class="problematic" id="id821">[2]_</span></a> eq. (C8).</p>
<section id="id822">
<h4>Parameters<a class="headerlink" href="#id822" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt>mu<span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
<dt>s<span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
<dt>vertices<span class="classifier">array, shape (N,3)</span></dt><dd><p>points of the sphere shell in the r-space in which evaluate the ODF</p>
</dd>
</dl>
</section>
<section id="id823">
<h4>Returns<a class="headerlink" href="#id823" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>odf_mat<span class="classifier">Matrix, shape (N_vertices, N_mapmri_coef)</span></dt><dd><p>ODF design matrix to discrete sphere function</p>
</dd>
</dl>
</section>
<section id="id824">
<h4>References<a class="headerlink" href="#id824" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id825" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id826" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</section>
<section id="mapmri-isotropic-odf-sh-matrix">
<h3>mapmri_isotropic_odf_sh_matrix<a class="headerlink" href="#mapmri-isotropic-odf-sh-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_odf_sh_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the isotropic MAPMRI ODF matrix <a href="#id1585"><span class="problematic" id="id827">[1]_</span></a> Eq. 32 for the isotropic
propagator in <a href="#id1586"><span class="problematic" id="id828">[1]_</span></a> eq. (60). Here we do not compute the sphere function but
the spherical harmonics by only integrating the radial part of the
propagator. We use the same derivation of the ODF in the isotropic
implementation as in <a href="#id1587"><span class="problematic" id="id829">[2]_</span></a> eq. (C8).</p>
<section id="id830">
<h4>Parameters<a class="headerlink" href="#id830" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt>mu<span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
<dt>s<span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
</dl>
</section>
<section id="id831">
<h4>Returns<a class="headerlink" href="#id831" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>odf_sh_mat<span class="classifier">Matrix, shape (N_sh_coef, N_mapmri_coef)</span></dt><dd><p>ODF design matrix to spherical harmonics</p>
</dd>
</dl>
</section>
<section id="id832">
<h4>References<a class="headerlink" href="#id832" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id833" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id834" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</section>
<section id="mapmri-isotropic-laplacian-reg-matrix">
<h3>mapmri_isotropic_laplacian_reg_matrix<a class="headerlink" href="#mapmri-isotropic-laplacian-reg-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_laplacian_reg_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the Laplacian regularization matrix for MAP-MRI’s isotropic
implementation <a href="#id1588"><span class="problematic" id="id835">[1]_</span></a> eq. (C7).</p>
<section id="id836">
<h4>Parameters<a class="headerlink" href="#id836" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt>mu<span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
</dl>
</section>
<section id="id837">
<h4>Returns<a class="headerlink" href="#id837" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>LR<span class="classifier">Matrix, shape (N_coef, N_coef)</span></dt><dd><p>Laplacian regularization matrix</p>
</dd>
</dl>
</section>
<section id="id838">
<h4>References<a class="headerlink" href="#id838" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id839" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</section>
<section id="mapmri-isotropic-laplacian-reg-matrix-from-index-matrix">
<h3>mapmri_isotropic_laplacian_reg_matrix_from_index_matrix<a class="headerlink" href="#mapmri-isotropic-laplacian-reg-matrix-from-index-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the Laplacian regularization matrix for MAP-MRI’s isotropic
implementation <a href="#id1589"><span class="problematic" id="id840">[1]_</span></a> eq. (C7).</p>
<section id="id841">
<h4>Parameters<a class="headerlink" href="#id841" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ind_mat<span class="classifier">matrix (N_coef, 3),</span></dt><dd><p>Basis order matrix</p>
</dd>
<dt>mu<span class="classifier">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
</dl>
</section>
<section id="id842">
<h4>Returns<a class="headerlink" href="#id842" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>LR<span class="classifier">Matrix, shape (N_coef, N_coef)</span></dt><dd><p>Laplacian regularization matrix</p>
</dd>
</dl>
</section>
<section id="id843">
<h4>References<a class="headerlink" href="#id843" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id844" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</section>
<section id="mapmri-isotropic-index-matrix">
<h3>mapmri_isotropic_index_matrix<a class="headerlink" href="#mapmri-isotropic-index-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_isotropic_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_isotropic_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_index_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the indices for the isotropic MAPMRI basis <a href="#id1590"><span class="problematic" id="id845">[1]_</span></a> Fig 8.</p>
<section id="id846">
<h4>Parameters<a class="headerlink" href="#id846" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int</span></dt><dd><p>radial order of isotropic MAPMRI basis</p>
</dd>
</dl>
</section>
<section id="id847">
<h4>Returns<a class="headerlink" href="#id847" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>index_matrix<span class="classifier">array, shape (N,3)</span></dt><dd><p>ordering of the basis in x, y, z</p>
</dd>
</dl>
</section>
<section id="id848">
<h4>References<a class="headerlink" href="#id848" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id849" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

</section>
<section id="create-rspace">
<h3>create_rspace<a class="headerlink" href="#create-rspace" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.create_rspace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">create_rspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_max</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.create_rspace" title="Permalink to this definition">#</a></dt>
<dd><p>Create the real space table, that contains the points in which
to compute the pdf.</p>
<section id="id850">
<h4>Parameters<a class="headerlink" href="#id850" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gridsize<span class="classifier">unsigned int</span></dt><dd><p>dimension of the propagator grid</p>
</dd>
<dt>radius_max<span class="classifier">float</span></dt><dd><p>maximal radius in which compute the propagator</p>
</dd>
</dl>
</section>
<section id="id851">
<h4>Returns<a class="headerlink" href="#id851" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tab<span class="classifier">array, shape (N,3)</span></dt><dd><p>real space points in which calculates the pdf</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="delta">
<h3>delta<a class="headerlink" href="#delta" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.delta">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">delta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.delta" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="map-laplace-u">
<h3>map_laplace_u<a class="headerlink" href="#map-laplace-u" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.map_laplace_u">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">map_laplace_u</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.map_laplace_u" title="Permalink to this definition">#</a></dt>
<dd><p>S(n, m) static matrix for Laplacian regularization <a href="#id1591"><span class="problematic" id="id852">[1]_</span></a> eq. (13).</p>
<section id="id853">
<h4>Parameters<a class="headerlink" href="#id853" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>n, m<span class="classifier">unsigned int</span></dt><dd><p>basis order of the MAP-MRI basis in different directions</p>
</dd>
</dl>
</section>
<section id="id854">
<h4>Returns<a class="headerlink" href="#id854" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>U<span class="classifier">float,</span></dt><dd><p>Analytical integral of <span class="math notranslate nohighlight">\(\phi_n(q) * \phi_m(q)\)</span></p>
</dd>
</dl>
</section>
<section id="id855">
<h4>References<a class="headerlink" href="#id855" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id856" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</section>
<section id="map-laplace-t">
<h3>map_laplace_t<a class="headerlink" href="#map-laplace-t" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.map_laplace_t">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">map_laplace_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.map_laplace_t" title="Permalink to this definition">#</a></dt>
<dd><p>L(m, n) static matrix for Laplacian regularization <a href="#id1592"><span class="problematic" id="id857">[1]_</span></a> eq. (12).</p>
<section id="id858">
<h4>Parameters<a class="headerlink" href="#id858" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>n, m<span class="classifier">unsigned int</span></dt><dd><p>basis order of the MAP-MRI basis in different directions</p>
</dd>
</dl>
</section>
<section id="id859">
<h4>Returns<a class="headerlink" href="#id859" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">float</span></dt><dd><p>Analytical integral of <span class="math notranslate nohighlight">\(\phi_n(q) * \phi_m''(q)\)</span></p>
</dd>
</dl>
</section>
<section id="id860">
<h4>References<a class="headerlink" href="#id860" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id861" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</section>
<section id="map-laplace-s">
<h3>map_laplace_s<a class="headerlink" href="#map-laplace-s" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.map_laplace_s">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">map_laplace_s</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.map_laplace_s" title="Permalink to this definition">#</a></dt>
<dd><p>R(m,n) static matrix for Laplacian regularization <a href="#id1593"><span class="problematic" id="id862">[1]_</span></a> eq. (11).</p>
<section id="id863">
<h4>Parameters<a class="headerlink" href="#id863" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>n, m<span class="classifier">unsigned int</span></dt><dd><p>basis order of the MAP-MRI basis in different directions</p>
</dd>
</dl>
</section>
<section id="id864">
<h4>Returns<a class="headerlink" href="#id864" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">float</span></dt><dd><p>Analytical integral of <span class="math notranslate nohighlight">\(\phi_n''(q) * \phi_m''(q)\)</span></p>
</dd>
</dl>
</section>
<section id="id865">
<h4>References<a class="headerlink" href="#id865" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id866" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</section>
<section id="mapmri-stu-reg-matrices">
<h3>mapmri_STU_reg_matrices<a class="headerlink" href="#mapmri-stu-reg-matrices" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_STU_reg_matrices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_STU_reg_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_STU_reg_matrices" title="Permalink to this definition">#</a></dt>
<dd><p>Generate the static portions of the Laplacian regularization matrix
according to <a href="#id1594"><span class="problematic" id="id867">[1]_</span></a> eq. (11, 12, 13).</p>
<section id="id868">
<h4>Parameters<a class="headerlink" href="#id868" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
</dl>
</section>
<section id="id869">
<h4>Returns<a class="headerlink" href="#id869" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S, T, U<span class="classifier">Matrices, shape (N_coef,N_coef)</span></dt><dd><p>Regularization submatrices</p>
</dd>
</dl>
</section>
<section id="id870">
<h4>References<a class="headerlink" href="#id870" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id871" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</section>
<section id="mapmri-laplacian-reg-matrix">
<h3>mapmri_laplacian_reg_matrix<a class="headerlink" href="#mapmri-laplacian-reg-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.mapmri_laplacian_reg_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">mapmri_laplacian_reg_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_mat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Put the Laplacian regularization matrix together <a href="#id1595"><span class="problematic" id="id872">[1]_</span></a> eq. (10).</p>
<p>The static parts in S, T and U are multiplied and divided by the
voxel-specific scale factors.</p>
<section id="id873">
<h4>Parameters<a class="headerlink" href="#id873" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ind_mat<span class="classifier">matrix (N_coef, 3),</span></dt><dd><p>Basis order matrix</p>
</dd>
<dt>mu<span class="classifier">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>
</dd>
<dt>S, T, U<span class="classifier">matrices, shape (N_coef,N_coef)</span></dt><dd><p>Regularization submatrices</p>
</dd>
</dl>
</section>
<section id="id874">
<h4>Returns<a class="headerlink" href="#id874" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>LR<span class="classifier">matrix (N_coef, N_coef),</span></dt><dd><p>Voxel-specific Laplacian regularization matrix</p>
</dd>
</dl>
</section>
<section id="id875">
<h4>References<a class="headerlink" href="#id875" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id876" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “MAPL: Tissue microstructure estimation</p>
</aside>
</aside>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.”
NeuroImage (2016).</p>
</section>
</dd></dl>

</section>
<section id="generalized-crossvalidation-array">
<h3>generalized_crossvalidation_array<a class="headerlink" href="#generalized-crossvalidation-array" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.generalized_crossvalidation_array">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">generalized_crossvalidation_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.generalized_crossvalidation_array" title="Permalink to this definition">#</a></dt>
<dd><p>Generalized Cross Validation Function <a href="#id1596"><span class="problematic" id="id877">[1]_</span></a> eq. (15).</p>
<p>Here weights_array is a numpy array with all values that should be
considered in the GCV. It will run through the weights until the cost
function starts to increase, then stop and take the last value as the
optimum weight.</p>
<section id="id878">
<h4>Parameters<a class="headerlink" href="#id878" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">array (N),</span></dt><dd><p>Basis order matrix</p>
</dd>
<dt>M<span class="classifier">matrix, shape (N, Ncoef)</span></dt><dd><p>mapmri observation matrix</p>
</dd>
<dt>LR<span class="classifier">matrix, shape (N_coef, N_coef)</span></dt><dd><p>regularization matrix</p>
</dd>
<dt>weights_array<span class="classifier">array (N_of_weights)</span></dt><dd><p>array of optional regularization weights</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="generalized-crossvalidation">
<h3>generalized_crossvalidation<a class="headerlink" href="#generalized-crossvalidation" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.generalized_crossvalidation">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">generalized_crossvalidation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gcv_startpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.generalized_crossvalidation" title="Permalink to this definition">#</a></dt>
<dd><p>Generalized Cross Validation Function <a href="#id1597"><span class="problematic" id="id879">[1]_</span></a> eq. (15).</p>
<p>Finds optimal regularization weight based on generalized cross-validation.</p>
<section id="id880">
<h4>Parameters<a class="headerlink" href="#id880" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">array (N),</span></dt><dd><p>data array</p>
</dd>
<dt>M<span class="classifier">matrix, shape (N, Ncoef)</span></dt><dd><p>mapmri observation matrix</p>
</dd>
<dt>LR<span class="classifier">matrix, shape (N_coef, N_coef)</span></dt><dd><p>regularization matrix</p>
</dd>
<dt>gcv_startpoint<span class="classifier">float</span></dt><dd><p>startpoint for the gcv optimization</p>
</dd>
</dl>
</section>
<section id="id881">
<h4>Returns<a class="headerlink" href="#id881" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>optimal_lambda<span class="classifier">float,</span></dt><dd><p>optimal regularization weight</p>
</dd>
</dl>
</section>
<section id="id882">
<h4>References<a class="headerlink" href="#id882" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id883" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Craven et al. “Smoothing Noisy Data with Spline Functions.”
NUMER MATH 31.4 (1978): 377-403.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="gcv-cost-function">
<h3>gcv_cost_function<a class="headerlink" href="#gcv-cost-function" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mapmri.gcv_cost_function">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mapmri.</span></span><span class="sig-name descname"><span class="pre">gcv_cost_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.gcv_cost_function" title="Permalink to this definition">#</a></dt>
<dd><p>The GCV cost function that is iterated [4].</p>
</dd></dl>

</section>
<section id="multishellresponse">
<h3><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellResponse" title="dipy.reconst.mcsd.MultiShellResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiShellResponse</span></code></a><a class="headerlink" href="#multishellresponse" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellResponse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">MultiShellResponse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellResponse" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellResponse.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellResponse.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate Multi Shell response function for multiple tissues and
multiple shells.</p>
<p>The method <cite>multi_shell_fiber_response</cite> allows to create a multi-shell
fiber response with the right format, for a three compartments model.
It can be referred to in order to understand the inputs of this class.</p>
<section id="id884">
<h4>Parameters<a class="headerlink" href="#id884" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>response<span class="classifier">ndarray</span></dt><dd><p>Multi-shell fiber response. The ordering of the responses should
follow the same logic as S0.</p>
</dd>
<dt>sh_order<span class="classifier">int</span></dt><dd><p>Maximal spherical harmonics order.</p>
</dd>
<dt>shells<span class="classifier">int</span></dt><dd><p>Number of shells in the data</p>
</dd>
<dt>S0<span class="classifier">array (3,)</span></dt><dd><p>Signal with no diffusion weighting for each tissue compartments, in
the same tissue order as <cite>response</cite>. This S0 can be used for
predicting from a fit model later on.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellResponse.iso">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iso</span></span><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellResponse.iso" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="multishelldeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.mcsd.MultiShellDeconvModel" title="dipy.reconst.mcsd.MultiShellDeconvModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiShellDeconvModel</span></code></a><a class="headerlink" href="#multishelldeconvmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellDeconvModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">MultiShellDeconvModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_sphere=&lt;dipy.core.sphere.HemiSphere</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order=8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iso=2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellDeconvModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellDeconvModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_sphere=&lt;dipy.core.sphere.HemiSphere</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order=8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iso=2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellDeconvModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Multi-Shell Multi-Tissue Constrained Spherical Deconvolution
(MSMT-CSD) <a href="#id1598"><span class="problematic" id="id885">[1]_</span></a>. This method extends the CSD model proposed in <a href="#id1599"><span class="problematic" id="id886">[2]_</span></a> by
the estimation of multiple response functions as a function of multiple
b-values and multiple tissue types.</p>
<p>Spherical deconvolution computes a fiber orientation distribution
(FOD), also called fiber ODF (fODF) <a href="#id1600"><span class="problematic" id="id887">[2]_</span></a>. The fODF is derived from
different tissue types and thus overcomes the overestimation of WM in
GM and CSF areas.</p>
<p>The response function is based on the different tissue types
and is provided as input to the MultiShellDeconvModel.
It will be used as deconvolution kernel, as described in <a href="#id1601"><span class="problematic" id="id888">[2]_</span></a>.</p>
<section id="id889">
<h4>Parameters<a class="headerlink" href="#id889" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
response : ndarray or MultiShellResponse object</p>
<blockquote>
<div><p>Pre-computed multi-shell fiber response function in the form of a
MultiShellResponse object, or simple response function as a ndarray.
The later must be of shape (3, len(bvals)-1, 4), because it will be
converted into a MultiShellResponse object via the
<cite>multi_shell_fiber_response</cite> method (important note: the function
<cite>unique_bvals_tolerance</cite> is used here to select unique bvalues from
gtab as input). Each column (3,) has two elements. The first is the
eigen-values as a (3,) ndarray and the second is the signal value
for the response function without diffusion weighting (S0). Note
that in order to use more than three compartments, one must create
a MultiShellResponse object on the side.</p>
</div></blockquote>
<dl class="simple">
<dt>reg_sphere<span class="classifier">Sphere (optional)</span></dt><dd><p>sphere used to build the regularization B matrix.
Default: ‘symmetric362’.</p>
</dd>
<dt>sh_order<span class="classifier">int (optional)</span></dt><dd><p>maximal spherical harmonics order. Default: 8</p>
</dd>
<dt>iso: int (optional)</dt><dd><p>Number of tissue compartments for running the MSMT-CSD. Minimum
number of compartments required is 2.
Default: 2</p>
</dd>
</dl>
</section>
<section id="id890">
<h4>References<a class="headerlink" href="#id890" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id891" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Jeurissen, B., et al. NeuroImage 2014. Multi-tissue constrained
spherical deconvolution for improved analysis of multi-shell
diffusion MRI data</p>
</aside>
<aside class="footnote brackets" id="id892" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of
the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical
deconvolution</p>
</aside>
<aside class="footnote brackets" id="id893" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Tournier, J.D, et al. Imaging Systems and Technology
2012. MRtrix: Diffusion Tractography in Crossing Fiber Regions</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellDeconvModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellDeconvModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MultiShellDeconvModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.MultiShellDeconvModel.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Compute a signal prediction given spherical harmonic coefficients
for the provided GradientTable class instance.</p>
<section id="id894">
<h4>Parameters<a class="headerlink" href="#id894" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">ndarray</span></dt><dd><p>The spherical harmonic representation of the FOD from which to make
the signal prediction.</p>
</dd>
<dt>gtab<span class="classifier">GradientTable</span></dt><dd><p>The gradients for which the signal will be predicted. Use the
model’s gradient table by default.</p>
</dd>
<dt>S0<span class="classifier">ndarray or float</span></dt><dd><p>The non diffusion-weighted signal value.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="msdeconvfit">
<h3><a class="reference internal" href="#dipy.reconst.mcsd.MSDeconvFit" title="dipy.reconst.mcsd.MSDeconvFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MSDeconvFit</span></code></a><a class="headerlink" href="#msdeconvfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MSDeconvFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">MSDeconvFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.MSDeconvFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MSDeconvFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.MSDeconvFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Abstract class which holds the fit result of MultiShellDeconvModel.
Inherits the SphHarmFit which fits the diffusion data to a spherical
harmonic model.</p>
<section id="id895">
<h4>Parameters<a class="headerlink" href="#id895" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model: object</dt><dd><p>MultiShellDeconvModel</p>
</dd>
<dt>coeff<span class="classifier">array</span></dt><dd><p>Spherical harmonic coefficients for the ODF.</p>
</dd>
<dt>mask: ndarray</dt><dd><p>Mask for fitting</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MSDeconvFit.all_shm_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_shm_coeff</span></span><a class="headerlink" href="#dipy.reconst.mcsd.MSDeconvFit.all_shm_coeff" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MSDeconvFit.shm_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shm_coeff</span></span><a class="headerlink" href="#dipy.reconst.mcsd.MSDeconvFit.shm_coeff" title="Permalink to this definition">#</a></dt>
<dd><p>The spherical harmonic coefficients of the odf</p>
<p>Make this a property for now, if there is a use case for modifying
the coefficients we can add a setter or expose the coefficients more
directly</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.MSDeconvFit.volume_fractions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">volume_fractions</span></span><a class="headerlink" href="#dipy.reconst.mcsd.MSDeconvFit.volume_fractions" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="qpfitter">
<h3><a class="reference internal" href="#dipy.reconst.mcsd.QpFitter" title="dipy.reconst.mcsd.QpFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">QpFitter</span></code></a><a class="headerlink" href="#qpfitter" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.QpFitter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">QpFitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.QpFitter" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.QpFitter.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.QpFitter.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Makes use of the quadratic programming solver <cite>solve_qp</cite> to fit the
model. The initialization for the model is done using the warm-start by
default in <cite>CVXPY</cite>.</p>
<section id="id896">
<h4>Parameters<a class="headerlink" href="#id896" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>X<span class="classifier">ndarray</span></dt><dd><p>Matrix to be fit by the QP solver calculated in
<cite>MultiShellDeconvModel</cite></p>
</dd>
<dt>reg<span class="classifier">ndarray</span></dt><dd><p>the regularization B matrix calculated in <cite>MultiShellDeconvModel</cite></p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="multi-tissue-basis">
<h3>multi_tissue_basis<a class="headerlink" href="#multi-tissue-basis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.multi_tissue_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">multi_tissue_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iso_comp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.multi_tissue_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Builds a basis for multi-shell multi-tissue CSD model.</p>
<section id="id897">
<h4>Parameters<a class="headerlink" href="#id897" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
sh_order : int
iso_comp: int</p>
<blockquote>
<div><p>Number of tissue compartments for running the MSMT-CSD. Minimum
number of compartments required is 2.</p>
</div></blockquote>
</section>
<section id="id898">
<h4>Returns<a class="headerlink" href="#id898" title="Permalink to this heading">#</a></h4>
<dl>
<dt>B<span class="classifier">ndarray</span></dt><dd><p>Matrix of the spherical harmonics model used to fit the data</p>
</dd>
<dt>m<span class="classifier">int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code></span></dt><dd><p>The order of the harmonic.</p>
</dd>
<dt>n<span class="classifier">int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt><dd><p>The degree of the harmonic.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="solve-qp">
<h3>solve_qp<a class="headerlink" href="#solve-qp" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.solve_qp">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">solve_qp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.solve_qp" title="Permalink to this definition">#</a></dt>
<dd><p>Helper function to set up and solve the Quadratic Program (QP) in CVXPY.
A QP problem has the following form:
minimize      1/2 x’ P x + Q’ x
subject to    G x &lt;= H</p>
<p>Here the QP solver is based on CVXPY and uses OSQP.</p>
<section id="id899">
<h4>Parameters<a class="headerlink" href="#id899" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>P<span class="classifier">ndarray</span></dt><dd><p>n x n matrix for the primal QP objective function.</p>
</dd>
<dt>Q<span class="classifier">ndarray</span></dt><dd><p>n x 1 matrix for the primal QP objective function.</p>
</dd>
<dt>G<span class="classifier">ndarray</span></dt><dd><p>m x n matrix for the inequality constraint.</p>
</dd>
<dt>H<span class="classifier">ndarray</span></dt><dd><p>m x 1 matrix for the inequality constraint.</p>
</dd>
</dl>
</section>
<section id="id900">
<h4>Returns<a class="headerlink" href="#id900" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>x<span class="classifier">array</span></dt><dd><p>Optimal solution to the QP problem.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="multi-shell-fiber-response">
<h3>multi_shell_fiber_response<a class="headerlink" href="#multi-shell-fiber-response" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.multi_shell_fiber_response">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">multi_shell_fiber_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_rf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_rf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_rf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.multi_shell_fiber_response" title="Permalink to this definition">#</a></dt>
<dd><p>Fiber response function estimation for multi-shell data.</p>
<section id="id901">
<h4>Parameters<a class="headerlink" href="#id901" title="Permalink to this heading">#</a></h4>
<dl>
<dt>sh_order<span class="classifier">int</span></dt><dd><p>Maximum spherical harmonics order.</p>
</dd>
<dt>bvals<span class="classifier">ndarray</span></dt><dd><p>Array containing the b-values. Must be unique b-values, like outputted
by <cite>dipy.core.gradients.unique_bvals_tolerance</cite>.</p>
</dd>
<dt>wm_rf<span class="classifier">(4, len(bvals)) ndarray</span></dt><dd><p>Response function of the WM tissue, for each bvals.</p>
</dd>
<dt>gm_rf<span class="classifier">(4, len(bvals)) ndarray</span></dt><dd><p>Response function of the GM tissue, for each bvals.</p>
</dd>
<dt>csf_rf<span class="classifier">(4, len(bvals)) ndarray</span></dt><dd><p>Response function of the CSF tissue, for each bvals.</p>
</dd>
<dt>sphere<span class="classifier"><cite>dipy.core.Sphere</cite> instance, optional</span></dt><dd><p>Sphere where the signal will be evaluated.</p>
</dd>
</dl>
</section>
<section id="id902">
<h4>Returns<a class="headerlink" href="#id902" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>MultiShellResponse</dt><dd><p>MultiShellResponse object.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="mask-for-response-msmt">
<h3>mask_for_response_msmt<a class="headerlink" href="#mask-for-response-msmt" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.mask_for_response_msmt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">mask_for_response_msmt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_md_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0007</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_md_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.002</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.mask_for_response_msmt" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computation of masks for multi-shell multi-tissue (msmt) response</dt><dd><p>function using FA and MD.</p>
</dd>
</dl>
<section id="id903">
<h4>Parameters<a class="headerlink" href="#id903" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
data : ndarray</p>
<blockquote>
<div><p>diffusion data (4D)</p>
</div></blockquote>
<dl class="simple">
<dt>roi_center<span class="classifier">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt>roi_radii<span class="classifier">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>
</dd>
<dt>wm_fa_thr<span class="classifier">float</span></dt><dd><p>FA threshold for WM.</p>
</dd>
<dt>gm_fa_thr<span class="classifier">float</span></dt><dd><p>FA threshold for GM.</p>
</dd>
<dt>csf_fa_thr<span class="classifier">float</span></dt><dd><p>FA threshold for CSF.</p>
</dd>
<dt>gm_md_thr<span class="classifier">float</span></dt><dd><p>MD threshold for GM.</p>
</dd>
<dt>csf_md_thr<span class="classifier">float</span></dt><dd><p>MD threshold for CSF.</p>
</dd>
</dl>
</section>
<section id="id904">
<h4>Returns<a class="headerlink" href="#id904" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>mask_wm<span class="classifier">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA above the FA threshold
for WM.</p>
</dd>
<dt>mask_gm<span class="classifier">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA below the FA threshold
for GM and with MD below the MD threshold for GM.</p>
</dd>
<dt>mask_csf<span class="classifier">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA below the FA threshold
for CSF and with MD below the MD threshold for CSF.</p>
</dd>
</dl>
</section>
<section id="id905">
<h4>Notes<a class="headerlink" href="#id905" title="Permalink to this heading">#</a></h4>
<p>In msmt-CSD there is an important pre-processing step: the estimation of
every tissue’s response function. In order to do this, we look for voxels
corresponding to WM, GM and CSF. This function aims to accomplish that by
returning a mask of voxels within a ROI and who respect some threshold
constraints, for each tissue. More precisely, the WM mask must have a FA
value above a given threshold. The GM mask and CSF mask must have a FA
below given thresholds and a MD below other thresholds. To get the FA and
MD, we need to fit a Tensor model to the datasets.</p>
</section>
</dd></dl>

</section>
<section id="response-from-mask-msmt">
<h3>response_from_mask_msmt<a class="headerlink" href="#response-from-mask-msmt" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.response_from_mask_msmt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">response_from_mask_msmt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_wm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_gm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_csf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.response_from_mask_msmt" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Computation of multi-shell multi-tissue (msmt) response</dt><dd><p>functions from given tissues masks.</p>
</dd>
</dl>
<section id="id906">
<h4>Parameters<a class="headerlink" href="#id906" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
data : ndarray</p>
<blockquote>
<div><p>diffusion data</p>
</div></blockquote>
<dl class="simple">
<dt>mask_wm<span class="classifier">ndarray</span></dt><dd><p>mask from where to compute the WM response function.</p>
</dd>
<dt>mask_gm<span class="classifier">ndarray</span></dt><dd><p>mask from where to compute the GM response function.</p>
</dd>
<dt>mask_csf<span class="classifier">ndarray</span></dt><dd><p>mask from where to compute the CSF response function.</p>
</dd>
<dt>tol<span class="classifier">int</span></dt><dd><p>tolerance gap for b-values clustering. (Default = 20)</p>
</dd>
</dl>
</section>
<section id="id907">
<h4>Returns<a class="headerlink" href="#id907" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>response_wm<span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for WM for each unique bvalues (except b0).</p>
</dd>
<dt>response_gm<span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for GM for each unique bvalues (except b0).</p>
</dd>
<dt>response_csf<span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for CSF for each unique bvalues (except b0).</p>
</dd>
</dl>
</section>
<section id="id908">
<h4>Notes<a class="headerlink" href="#id908" title="Permalink to this heading">#</a></h4>
<p>In msmt-CSD there is an important pre-processing step: the estimation of
every tissue’s response function. In order to do this, we look for voxels
corresponding to WM, GM and CSF. This information can be obtained by using
mcsd.mask_for_response_msmt() through masks of selected voxels. The present
function uses such masks to compute the msmt response functions.</p>
<p>For the responses, we base our approach on the function
csdeconv.response_from_mask_ssst(), with the added layers of multishell and
multi-tissue (see the ssst function for more information about the
computation of the ssst response function). This means that for each tissue
we use the previously found masks and loop on them. For each mask, we loop
on the b-values (clustered using the tolerance gap) to get many responses
and then average them to get one response per tissue.</p>
</section>
</dd></dl>

</section>
<section id="auto-response-msmt">
<h3>auto_response_msmt<a class="headerlink" href="#auto-response-msmt" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.mcsd.auto_response_msmt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.mcsd.</span></span><span class="sig-name descname"><span class="pre">auto_response_msmt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_fa_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_md_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_md_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0032</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mcsd.auto_response_msmt" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Automatic estimation of multi-shell multi-tissue (msmt) response</dt><dd><p>functions using FA and MD.</p>
</dd>
</dl>
<section id="id909">
<h4>Parameters<a class="headerlink" href="#id909" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
data : ndarray</p>
<blockquote>
<div><p>diffusion data</p>
</div></blockquote>
<dl class="simple">
<dt>roi_center<span class="classifier">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt>roi_radii<span class="classifier">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>
</dd>
<dt>wm_fa_thr<span class="classifier">float</span></dt><dd><p>FA threshold for WM.</p>
</dd>
<dt>gm_fa_thr<span class="classifier">float</span></dt><dd><p>FA threshold for GM.</p>
</dd>
<dt>csf_fa_thr<span class="classifier">float</span></dt><dd><p>FA threshold for CSF.</p>
</dd>
<dt>gm_md_thr<span class="classifier">float</span></dt><dd><p>MD threshold for GM.</p>
</dd>
<dt>csf_md_thr<span class="classifier">float</span></dt><dd><p>MD threshold for CSF.</p>
</dd>
</dl>
</section>
<section id="id910">
<h4>Returns<a class="headerlink" href="#id910" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>response_wm<span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for WM for each unique bvalues (except b0).</p>
</dd>
<dt>response_gm<span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for GM for each unique bvalues (except b0).</p>
</dd>
<dt>response_csf<span class="classifier">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for CSF for each unique bvalues (except b0).</p>
</dd>
</dl>
</section>
<section id="id911">
<h4>Notes<a class="headerlink" href="#id911" title="Permalink to this heading">#</a></h4>
<p>In msmt-CSD there is an important pre-processing step: the estimation of
every tissue’s response function. In order to do this, we look for voxels
corresponding to WM, GM and CSF. We get this information from
mcsd.mask_for_response_msmt(), which returns masks of selected voxels
(more details are available in the description of the function).</p>
<p>With the masks, we compute the response functions by using
mcsd.response_from_mask_msmt(), which returns the <cite>response</cite> for each
tissue (more details are available in the description of the function).</p>
</section>
</dd></dl>

</section>
<section id="meandiffusionkurtosismodel">
<h3><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel" title="dipy.reconst.msdki.MeanDiffusionKurtosisModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel</span></code></a><a class="headerlink" href="#meandiffusionkurtosismodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">MeanDiffusionKurtosisModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bmag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>Mean signal Diffusion Kurtosis Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bmag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Mean Signal Diffusion Kurtosis Model <a href="#id1602"><span class="problematic" id="id912">[1]_</span></a>.

Parameters
———-
gtab : GradientTable class instance

bmag : int
    The order of magnitude that the bvalues have to differ to be
    considered an unique b-value. Default: derive this value from the
    maximal b-value provided: <span class="math notranslate nohighlight">\(bmag=log_{10}(max(bvals)) - 1\)</span>.

return_S0_hat : bool
    If True, also return S0 values for the fit.

args, kwargs : arguments and keyword arguments passed to the
fit_method. See msdki.wls_fit_msdki for details

References
———-
.. [1] Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data
       Analysis and their Application to the Healthy Ageing Brain
       (Doctoral thesis). Downing College, University of Cambridge.
       <a class="reference external" href="https://doi.org/10.17863/CAM.29356">https://doi.org/10.17863/CAM.29356</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method of the MSDKI model class</p>
<section id="id913">
<h4>Parameters<a class="headerlink" href="#id913" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">ndarray ([X, Y, Z, …], g)</span></dt><dd><p>ndarray containing the data signals in its last dimension.</p>
</dd>
<dt>mask<span class="classifier">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msdki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict a signal for this MeanDiffusionKurtosisModel class instance
given parameters.

Parameters
———-
msdki_params : ndarray
    The parameters of the mean signal diffusion kurtosis model
S0 : float or ndarray
    The non diffusion-weighted signal in every voxel, or across all
    voxels. Default: 1

Returns
——-
S : (…, N) ndarray
    Simulated mean signal based on the mean signal diffusion kurtosis
    model

Notes
—–
The predicted signal is given by:
    <span class="math notranslate nohighlight">\(MS(b) = S_0 * exp(-bD + 1/6 b^{2} D^{2} K)\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(K\)</span> are
    the mean signal diffusivity and mean signal kurtosis.

References
———-
.. [1] Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data
       Analysis and their Application to the Healthy Ageing Brain
       (Doctoral thesis). Downing College, University of Cambridge.
       <a class="reference external" href="https://doi.org/10.17863/CAM.29356">https://doi.org/10.17863/CAM.29356</a></p>
</dd></dl>

</dd></dl>

</section>
<section id="meandiffusionkurtosisfit">
<h3><a class="reference internal" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit" title="dipy.reconst.msdki.MeanDiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit</span></code></a><a class="headerlink" href="#meandiffusionkurtosisfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">MeanDiffusionKurtosisFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a MeanDiffusionKurtosisFit class instance.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.S0_hat">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">S0_hat</span></span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.S0_hat" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd">
<span class="sig-name descname"><span class="pre">msd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd" title="Permalink to this definition">#</a></dt>
<dd><p>Mean signal diffusitivity (MSD) calculated from the mean signal
Diffusion Kurtosis Model.</p>
<section id="id914">
<h4>Returns<a class="headerlink" href="#id914" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>msd<span class="classifier">ndarray</span></dt><dd><p>Calculated signal mean diffusitivity.</p>
</dd>
</dl>
</section>
<section id="id915">
<h4>References<a class="headerlink" href="#id915" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id916" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data
Analysis and their Application to the Healthy Ageing Brain
(Doctoral thesis). Downing College, University of Cambridge.
<a class="reference external" href="https://doi.org/10.17863/CAM.29356">https://doi.org/10.17863/CAM.29356</a></p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk">
<span class="sig-name descname"><span class="pre">msk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk" title="Permalink to this definition">#</a></dt>
<dd><p>Mean signal kurtosis (MSK) calculated from the mean signal
Diffusion Kurtosis Model.</p>
<section id="id917">
<h4>Returns<a class="headerlink" href="#id917" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>msk<span class="classifier">ndarray</span></dt><dd><p>Calculated signal mean kurtosis.</p>
</dd>
</dl>
</section>
<section id="id918">
<h4>References<a class="headerlink" href="#id918" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id919" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data
Analysis and their Application to the Healthy Ageing Brain
(Doctoral thesis). Downing College, University of Cambridge.
<a class="reference external" href="https://doi.org/10.17863/CAM.29356">https://doi.org/10.17863/CAM.29356</a></p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Given a mean signal diffusion kurtosis model fit, predict the signal
on the vertices of a sphere

Parameters
———-
gtab : a GradientTable class instance
    This encodes the directions for which a prediction is made

S0 : float array
   The mean non-diffusion weighted signal in each voxel. Default:
   The fitted S0 value in all voxels if it was fitted. Otherwise 1 in
   all voxels.

Returns
——-
S : (…, N) ndarray
    Simulated mean signal based on the mean signal kurtosis model

Notes
—–
The predicted signal is given by:
<span class="math notranslate nohighlight">\(MS(b) = S_0 * exp(-bD + 1/6 b^{2} D^{2} K)\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(k\)</span> are the
mean signal diffusivity and mean signal kurtosis.

References
———-
.. [1] Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data
       Analysis and their Application to the Healthy Ageing Brain
       (Doctoral thesis). Downing College, University of Cambridge.
       <a class="reference external" href="https://doi.org/10.17863/CAM.29356">https://doi.org/10.17863/CAM.29356</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di">
<span class="sig-name descname"><span class="pre">smt2di</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the intrisic diffusivity from the mean signal diffusional
kurtosis parameters assuming the 2-compartmental spherical mean
technique model <a href="#id1603"><span class="problematic" id="id920">[1]_</span></a>, <a href="#id1604"><span class="problematic" id="id921">[2]_</span></a></p>
<section id="id922">
<h4>Returns<a class="headerlink" href="#id922" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>smt2di<span class="classifier">ndarray</span></dt><dd><p>Intrinsic diffusivity computed by converting MSDKI to SMT2.</p>
</dd>
</dl>
</section>
<section id="id923">
<h4>Notes<a class="headerlink" href="#id923" title="Permalink to this heading">#</a></h4>
<p>Computes the intrinsic diffusivity using equation 16 of <a href="#id1605"><span class="problematic" id="id924">[1]_</span></a></p>
</section>
<section id="id925">
<h4>References<a class="headerlink" href="#id925" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id926" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic
anisotropy misestimation in spherical‐mean single diffusion
encoding MRI. Magnetic Resonance in Medicine (In press).
doi: 10.1002/mrm.27606</p>
</aside>
<aside class="footnote brackets" id="id927" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Kaden E, Kelm ND, Carson RP, et al. (2016) Multi‐compartment
microscopic diffusion imaging. Neuroimage 139:346–359.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f">
<span class="sig-name descname"><span class="pre">smt2f</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the axonal water fraction from the mean signal kurtosis
assuming the 2-compartmental spherical mean technique model <a href="#id1606"><span class="problematic" id="id928">[1]_</span></a>, <a href="#id1607"><span class="problematic" id="id929">[2]_</span></a></p>
<section id="id930">
<h4>Returns<a class="headerlink" href="#id930" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>smt2f<span class="classifier">ndarray</span></dt><dd><p>Axonal volume fraction calculated from MSK.</p>
</dd>
</dl>
</section>
<section id="id931">
<h4>Notes<a class="headerlink" href="#id931" title="Permalink to this heading">#</a></h4>
<p>Computes the axonal water fraction from the mean signal kurtosis
MSK using equation 17 of <a href="#id1608"><span class="problematic" id="id932">[1]_</span></a></p>
</section>
<section id="id933">
<h4>References<a class="headerlink" href="#id933" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id934" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic
anisotropy misestimation in spherical‐mean single diffusion
encoding MRI. Magnetic Resonance in Medicine (In press).
doi: 10.1002/mrm.27606</p>
</aside>
<aside class="footnote brackets" id="id935" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Kaden E, Kelm ND, Carson RP, et al. (2016) Multi‐compartment
microscopic diffusion imaging. Neuroimage 139:346–359.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA">
<span class="sig-name descname"><span class="pre">smt2uFA</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the microscopic fractional anisotropy from the mean signal
diffusional kurtosis parameters assuming the 2-compartmental spherical
mean technique model <a href="#id1609"><span class="problematic" id="id936">[1]_</span></a>, <a href="#id1610"><span class="problematic" id="id937">[2]_</span></a></p>
<section id="id938">
<h4>Returns<a class="headerlink" href="#id938" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>smt2uFA<span class="classifier">ndarray</span></dt><dd><p>Microscopic fractional anisotropy computed by converting MSDKI to
SMT2.</p>
</dd>
</dl>
</section>
<section id="id939">
<h4>Notes<a class="headerlink" href="#id939" title="Permalink to this heading">#</a></h4>
<p>Computes the intrinsic diffusivity using equation 10 of <a href="#id1611"><span class="problematic" id="id940">[1]_</span></a></p>
</section>
<section id="id941">
<h4>References<a class="headerlink" href="#id941" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id942" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic
anisotropy misestimation in spherical‐mean single diffusion
encoding MRI. Magnetic Resonance in Medicine (In press).
doi: 10.1002/mrm.27606</p>
</aside>
<aside class="footnote brackets" id="id943" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Kaden E, Kelm ND, Carson RP, et al. (2016) Multi‐compartment
microscopic diffusion imaging. Neuroimage 139:346–359.</p>
</aside>
</aside>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="mean-signal-bvalue">
<h3>mean_signal_bvalue<a class="headerlink" href="#mean-signal-bvalue" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.mean_signal_bvalue">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">mean_signal_bvalue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bmag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.mean_signal_bvalue" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the average signal across different diffusion directions
for each unique b-value

Parameters
———-
data : ndarray ([X, Y, Z, …], g)
    ndarray containing the data signals in its last dimension.
gtab : a GradientTable class instance
    The gradient table containing diffusion acquisition parameters.
bmag : The order of magnitude that the bvalues have to differ to be
    considered an unique b-value. Default: derive this value from the
    maximal b-value provided: <span class="math notranslate nohighlight">\(bmag=log_{10}(max(bvals)) - 1\)</span>.

Returns
——-
msignal : ndarray ([X, Y, Z, …, nub])
    Mean signal along all gradient directions for each unique b-value
    Note that the last dimension contains the signal means and nub is the
    number of unique b-values.
ng : ndarray(nub)
    Number of gradient directions used to compute the mean signal for
    all unique b-values

Notes
—–
This function assumes that directions are evenly sampled on the sphere or
on the hemisphere</p>
</dd></dl>

</section>
<section id="msk-from-awf">
<h3>msk_from_awf<a class="headerlink" href="#msk-from-awf" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.msk_from_awf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">msk_from_awf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.msk_from_awf" title="Permalink to this definition">#</a></dt>
<dd><p>Computes mean signal kurtosis from axonal water fraction estimates of the
SMT2 model</p>
<section id="id944">
<h4>Parameters<a class="headerlink" href="#id944" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>f<span class="classifier">ndarray ([X, Y, Z, …])</span></dt><dd><p>ndarray containing the axonal volume fraction estimate.</p>
</dd>
</dl>
</section>
<section id="id945">
<h4>Returns<a class="headerlink" href="#id945" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>msk<span class="classifier">ndarray(nub)</span></dt><dd><p>Mean signal kurtosis (msk)</p>
</dd>
</dl>
</section>
<section id="id946">
<h4>Notes<a class="headerlink" href="#id946" title="Permalink to this heading">#</a></h4>
<p>Computes mean signal kurtosis using equations 17 of <a href="#id1612"><span class="problematic" id="id947">[1]_</span></a></p>
</section>
<section id="id948">
<h4>References<a class="headerlink" href="#id948" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id949" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic
anisotropy misestimation in spherical‐mean single diffusion
encoding MRI. Magnetic Resonance in Medicine (In press).
doi: 10.1002/mrm.27606</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="awf-from-msk">
<h3>awf_from_msk<a class="headerlink" href="#awf-from-msk" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.awf_from_msk">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">awf_from_msk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.awf_from_msk" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the axonal water fraction from the mean signal kurtosis
assuming the 2-compartmental spherical mean technique model <a href="#id1613"><span class="problematic" id="id950">[1]_</span></a>, <a href="#id1614"><span class="problematic" id="id951">[2]_</span></a></p>
<section id="id952">
<h4>Parameters<a class="headerlink" href="#id952" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>msk<span class="classifier">ndarray ([X, Y, Z, …])</span></dt><dd><p>Mean signal kurtosis (msk)</p>
</dd>
<dt>mask<span class="classifier">ndarray, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be
analyzed that has the same shape of the msdki parameters</p>
</dd>
</dl>
</section>
<section id="id953">
<h4>Returns<a class="headerlink" href="#id953" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>smt2f<span class="classifier">ndarray ([X, Y, Z, …])</span></dt><dd><p>ndarray containing the axonal volume fraction estimate.</p>
</dd>
</dl>
</section>
<section id="id954">
<h4>Notes<a class="headerlink" href="#id954" title="Permalink to this heading">#</a></h4>
<p>Computes the axonal water fraction from the mean signal kurtosis
MSK using equation 17 of <a href="#id1615"><span class="problematic" id="id955">[1]_</span></a></p>
</section>
<section id="id956">
<h4>References<a class="headerlink" href="#id956" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id957" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic
anisotropy misestimation in spherical‐mean single diffusion
encoding MRI. Magnetic Resonance in Medicine (In press).
doi: 10.1002/mrm.27606</p>
</aside>
<aside class="footnote brackets" id="id958" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Kaden E, Kelm ND, Carson RP, et al. (2016) Multi‐compartment
microscopic diffusion imaging. Neuroimage 139:346–359.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="msdki-prediction">
<h3>msdki_prediction<a class="headerlink" href="#msdki-prediction" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.msdki_prediction">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">msdki_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msdki_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.msdki_prediction" title="Permalink to this definition">#</a></dt>
<dd><p>Predict the mean signal given the parameters of the mean signal DKI, an
GradientTable object and S0 signal.

Parameters
———-
params : ndarray ([X, Y, Z, …], 2)
    Array containing the mean signal diffusivity and mean signal kurtosis
    in its last axis
gtab : a GradientTable class instance
    The gradient table for this prediction
S0 : float or ndarray (optional)
    The non diffusion-weighted signal in every voxel, or across all
    voxels. Default: 1

Notes
—–
The predicted signal is given by:
    <span class="math notranslate nohighlight">\(MS(b) = S_0 * exp(-bD + 1/6 b^{2} D^{2} K)\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(K\)</span> are the
    mean signal diffusivity and mean signal kurtosis.

References
———-
.. [1] Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data
       Analysis and their Application to the Healthy Ageing Brain (Doctoral
       thesis). Downing College, University of Cambridge.
       <a class="reference external" href="https://doi.org/10.17863/CAM.29356">https://doi.org/10.17863/CAM.29356</a></p>
</dd></dl>

</section>
<section id="wls-fit-msdki">
<h3>wls_fit_msdki<a class="headerlink" href="#wls-fit-msdki" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.wls_fit_msdki">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">wls_fit_msdki</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">design_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msignal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ng</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_S0_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.wls_fit_msdki" title="Permalink to this definition">#</a></dt>
<dd><p>Fits the mean signal diffusion kurtosis imaging based on a weighted
least square solution <a href="#id1616"><span class="problematic" id="id959">[1]_</span></a>.</p>
<section id="id960">
<h4>Parameters<a class="headerlink" href="#id960" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (nub, 3)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression
coefficients of the mean signal diffusion kurtosis model. Note that
nub is the number of unique b-values</p>
</dd>
<dt>msignal<span class="classifier">ndarray ([X, Y, Z, …, nub])</span></dt><dd><p>Mean signal along all gradient directions for each unique b-value
Note that the last dimension should contain the signal means and nub
is the number of unique b-values.</p>
</dd>
<dt>ng<span class="classifier">ndarray(nub)</span></dt><dd><p>Number of gradient directions used to compute the mean signal for
all unique b-values</p>
</dd>
<dt>mask<span class="classifier">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</dd>
<dt>min_signal<span class="classifier">float, optional</span></dt><dd><p>Voxel with mean signal intensities lower than the min positive signal
are not processed. Default: 0.0001</p>
</dd>
<dt>return_S0_hat<span class="classifier">bool</span></dt><dd><p>If True, also return S0 values for the fit.</p>
</dd>
</dl>
</section>
<section id="id961">
<h4>Returns<a class="headerlink" href="#id961" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">array (…, 2)</span></dt><dd><p>Containing the mean signal diffusivity and mean signal kurtosis</p>
</dd>
</dl>
</section>
<section id="id962">
<h4>References<a class="headerlink" href="#id962" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id963" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data
Analysis and their Application to the Healthy Ageing Brain
(Doctoral thesis). Downing College, University of Cambridge.
<a class="reference external" href="https://doi.org/10.17863/CAM.29356">https://doi.org/10.17863/CAM.29356</a></p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="id964">
<h3>design_matrix<a class="headerlink" href="#id964" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.msdki.design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.msdki.</span></span><span class="sig-name descname"><span class="pre">design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ubvals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.msdki.design_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs design matrix for the mean signal diffusion kurtosis model</p>
<section id="id965">
<h4>Parameters<a class="headerlink" href="#id965" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ubvals<span class="classifier">array</span></dt><dd><p>Containing the unique b-values of the data.</p>
</dd>
</dl>
</section>
<section id="id966">
<h4>Returns<a class="headerlink" href="#id966" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (nb, 3)</span></dt><dd><p>Design matrix or B matrix for the mean signal diffusion kurtosis
model assuming that parameters are in the following order:
design_matrix[j, :] = (msd, msk, S0)</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="multivoxelfit">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="dipy.reconst.multi_voxel.MultiVoxelFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a><a class="headerlink" href="#multivoxelfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.MultiVoxelFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.multi_voxel.</span></span><span class="sig-name descname"><span class="pre">MultiVoxelFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<p>Holds an array of fits and allows access to their attributes and
methods</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.MultiVoxelFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.MultiVoxelFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict for the multi-voxel object using each single-object’s
prediction API, with S0 provided from an array.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.MultiVoxelFit.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.shape" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="callablearray">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.CallableArray" title="dipy.reconst.multi_voxel.CallableArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CallableArray</span></code></a><a class="headerlink" href="#callablearray" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.CallableArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.multi_voxel.</span></span><span class="sig-name descname"><span class="pre">CallableArray</span></span><a class="headerlink" href="#dipy.reconst.multi_voxel.CallableArray" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
<p>An array which can be called like a function</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.CallableArray.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.CallableArray.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="multi-voxel-fit">
<h3>multi_voxel_fit<a class="headerlink" href="#multi-voxel-fit" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.multi_voxel.multi_voxel_fit">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.multi_voxel.</span></span><span class="sig-name descname"><span class="pre">multi_voxel_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">single_voxel_fit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.multi_voxel_fit" title="Permalink to this definition">#</a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</section>
<section id="odfmodel">
<h3><a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a><a class="headerlink" href="#odfmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.odf.</span></span><span class="sig-name descname"><span class="pre">OdfModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as it’s
first and only argument.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<section id="id967">
<h4>Parameters<a class="headerlink" href="#id967" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable class instance</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</section>
<section id="odffit">
<h3><a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a><a class="headerlink" href="#odffit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.odf.</span></span><span class="sig-name descname"><span class="pre">OdfFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfFit.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.odf.OdfFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</section>
<section id="gfa">
<h3>gfa<a class="headerlink" href="#gfa" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.odf.gfa">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.odf.</span></span><span class="sig-name descname"><span class="pre">gfa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.gfa" title="Permalink to this definition">#</a></dt>
<dd><p>The general fractional anisotropy of a function evaluated
on the unit sphere

Parameters
———-
samples : ndarray
    Values of data on the unit sphere.

Returns
——-
gfa : ndarray
    GFA evaluated in each entry of the array, along the last dimension.
    An <cite>np.nan</cite> is returned for coordinates that contain all-zeros in
    <cite>samples</cite>.

Notes
—–
The GFA is defined as <a href="#id1617"><span class="problematic" id="id968">[1]_</span></a> ::

    sqrt{frac{n sum_i{(Psi_i - &lt;Psi&gt;)^2}}{(n-1) sum{Psi_i ^ 2}}}

Where <span class="math notranslate nohighlight">\(\Psi\)</span> is an orientation distribution function sampled discretely on
the unit sphere and angle brackets denote average over the samples on the
sphere.

.. [1] Quality assessment of High Angular Resolution Diffusion Imaging
       data using bootstrap on Q-ball reconstruction. J. Cohen Adad, M.
       Descoteaux, L.L. Wald. JMRI 33: 1194-1208.</p>
</dd></dl>

</section>
<section id="minmax-normalize">
<h3>minmax_normalize<a class="headerlink" href="#minmax-normalize" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.odf.minmax_normalize">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.odf.</span></span><span class="sig-name descname"><span class="pre">minmax_normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.minmax_normalize" title="Permalink to this definition">#</a></dt>
<dd><p>Min-max normalization of a function evaluated on the unit sphere</p>
<p>Normalizes samples to <code class="docutils literal notranslate"><span class="pre">(samples</span> <span class="pre">-</span> <span class="pre">min(samples))</span> <span class="pre">/</span> <span class="pre">(max(samples)</span> <span class="pre">-</span>
<span class="pre">min(samples))</span></code> for each unit sphere.</p>
<section id="id969">
<h4>Parameters<a class="headerlink" href="#id969" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>samples<span class="classifier">ndarray (…, N)</span></dt><dd><p>N samples on a unit sphere for each point, stored along the last axis
of the array.</p>
</dd>
<dt>out<span class="classifier">ndrray (…, N), optional</span></dt><dd><p>An array to store the normalized samples.</p>
</dd>
</dl>
</section>
<section id="id970">
<h4>Returns<a class="headerlink" href="#id970" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>out<span class="classifier">ndarray, (…, N)</span></dt><dd><p>Normalized samples.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="qtdmrimodel">
<h3><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriModel" title="dipy.reconst.qtdmri.QtdmriModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a><a class="headerlink" href="#qtdmrimodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">QtdmriModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cartesian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anisotropic_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constrain_q0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bval_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ECOS'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>The q:math:<cite>tau</cite>-dMRI model [1] to analytically and continuously represent
the q:math:<cite>tau</cite> diffusion signal attenuation over diffusion sensitization
q and diffusion time <span class="math notranslate nohighlight">\(\tau\)</span>. The model can be seen as an extension of
the MAP-MRI basis [2] towards different diffusion times.

The main idea is to model the diffusion signal over time and space as
a linear combination of continuous functions,

..math::
    :nowrap:
        begin{equation}
            hat{E}(textbf{q},tau;textbf{c}) =
            sum_i^{N_{textbf{q}}}sum_k^{<a href="#id1618"><span class="problematic" id="id1619">N_</span></a>tau} textbf{c}_{ik}
            ,Phi_i(textbf{q}),T_k(tau),
        end{equation}

where <span class="math notranslate nohighlight">\(\Phi\)</span> and <span class="math notranslate nohighlight">\(T\)</span> are the spatial and temporal basis functions,
<span class="math notranslate nohighlight">\(N_{\textbf{q}}\)</span> and <span class="math notranslate nohighlight">\(N_\tau\)</span> are the maximum spatial and temporal
order, and <span class="math notranslate nohighlight">\(i,k\)</span> are basis order iterators.

The estimation of the coefficients <span class="math notranslate nohighlight">\(c_i\)</span> can be regularized using
either analytic Laplacian regularization, sparsity regularization using
the l1-norm, or both to do a type of elastic net regularization.

From the coefficients, there exists an analytical formula to estimate
the ODF, RTOP, RTAP, RTPP, QIV and MSD, for any diffusion time.

Parameters
———-
gtab : GradientTable,
    gradient directions and bvalues container class. The bvalues
    should be in the normal s/mm^2. big_delta and small_delta need to
    given in seconds.
radial_order : unsigned int,
    an even integer representing the spatial/radial order of the basis.
time_order : unsigned int,
    an integer larger or equal than zero representing the time order
    of the basis.
laplacian_regularization : bool,
    Regularize using the Laplacian of the qt-dMRI basis.
laplacian_weighting: string or scalar,
    The string ‘GCV’ makes it use generalized cross-validation to find
    the regularization weight [3]. A scalar sets the regularization
    weight to that value.
l1_regularization : bool,
    Regularize by imposing sparsity in the coefficients using the
    l1-norm.
l1_weighting : ‘CV’ or scalar,
    The string ‘CV’ makes it use five-fold cross-validation to find
    the regularization weight. A scalar sets the regularization weight
    to that value.
cartesian : bool
    Whether to use the Cartesian or spherical implementation of the
    qt-dMRI basis, which we first explored in [4].
anisotropic_scaling : bool
    Whether to use anisotropic scaling or isotropic scaling. This
    option can be used to test if the Cartesian implementation is
    equivalent with the spherical one when using the same scaling.
normalization : bool
    Whether to normalize the basis functions such that their inner
    product is equal to one. Normalization is only necessary when
    imposing sparsity in the spherical basis if cartesian=False.
constrain_q0 : bool
    whether to constrain the q0 point to unity along the tau-space.
    This is necessary to ensure that <span class="math notranslate nohighlight">\(E(0,\tau)=1\)</span>.
bval_threshold : float
    the threshold b-value to be used, such that only data points below
    that threshold are used when estimating the scale factors.
eigenvalue_threshold : float,
    Sets the minimum of the tensor eigenvalues in order to avoid
    stability problem.
cvxpy_solver : str, optional
    cvxpy solver name. Optionally optimize the positivity constraint
    with a particular cvxpy solver. See See <a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a> for
    details. Default: ECOS.

References
———-
.. [1] Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
   Representation of dMRI in Space and Time”, Medical Image Analysis,
   2017.

.. [2] Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel
   diffusion imaging method for mapping tissue microstructure”,
   NeuroImage, 2013.

.. [3] Craven et al. “Smoothing Noisy Data with Spline Functions.”
   NUMER MATH 31.4 (1978): 377-403.

.. [4] Fick, Rutger HJ, et al. “A unifying framework for spatial and
   temporal diffusion in diffusion mri.” International Conference on
   Information Processing in Medical Imaging. Springer, Cham, 2015.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cartesian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anisotropic_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constrain_q0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bval_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ECOS'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriModel.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="qtdmrifit">
<h3><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit" title="dipy.reconst.qtdmri.QtdmriFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a><a class="headerlink" href="#qtdmrifit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">QtdmriFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qtdmri_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_scaling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solution_optimal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qtdmri_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_scaling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solution_optimal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates diffusion properties for a single voxel</p>
<section id="id971">
<h4>Parameters<a class="headerlink" href="#id971" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">object,</span></dt><dd><p>AnalyticalModel</p>
</dd>
<dt>qtdmri_coef<span class="classifier">1d ndarray,</span></dt><dd><p>qtdmri coefficients</p>
</dd>
<dt>us<span class="classifier">array, 3 x 1</span></dt><dd><p>spatial scaling factors</p>
</dd>
<dt>ut<span class="classifier">float</span></dt><dd><p>temporal scaling factor</p>
</dd>
<dt>tau_scaling<span class="classifier">float,</span></dt><dd><p>the temporal scaling that used to scale tau to the size of us</p>
</dd>
<dt>R<span class="classifier">3x3 numpy array,</span></dt><dd><p>tensor eigenvectors</p>
</dd>
<dt>lopt<span class="classifier">float,</span></dt><dd><p>laplacian regularization weight</p>
</dd>
<dt>alpha<span class="classifier">float,</span></dt><dd><p>the l1 regularization weight</p>
</dd>
<dt>cvxpy_solution_optimal: bool,</dt><dd><p>indicates whether the cvxpy coefficient estimation reach an optimal
solution</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.fitted_signal">
<span class="sig-name descname"><span class="pre">fitted_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.fitted_signal" title="Permalink to this definition">#</a></dt>
<dd><p>Recovers the fitted signal for the given gradient table. If no gradient
table is given it recovers the signal for the gtab of the model object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.msd">
<span class="sig-name descname"><span class="pre">msd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.msd" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical Mean Squared Displacement (MSD) for a
given diffusion time tau. It is defined as the Laplacian of the origin
of the estimated signal <a href="#id1620"><span class="problematic" id="id972">[1]_</span></a>. The analytical formula for the MAP-MRI
basis was derived in <a href="#id1621"><span class="problematic" id="id973">[2]_</span></a> eq. (C13, D1). The qtdmri coefficients are
first converted to mapmri coefficients following [3].</p>
<section id="id974">
<h4>Parameters<a class="headerlink" href="#id974" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</section>
<section id="id975">
<h4>References<a class="headerlink" href="#id975" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id976" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Cheng, J., 2014. Estimation and Processing of Ensemble Average
Propagator and Its Features in Diffusion MRI. Ph.D. Thesis.</p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id977" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal">
<span class="sig-name descname"><span class="pre">norm_of_laplacian_signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the norm of the laplacian of the fitted signal <a href="#id1622"><span class="problematic" id="id978">[1]_</span></a>.
This information could be useful to assess if the extrapolation of the
fitted signal contains spurious oscillations. A high laplacian norm may
indicate that these are present, and any q-space indices that
use integrals of the signal may be corrupted (e.g. RTOP, RTAP, RTPP,
QIV). In contrast to [1], the Laplacian now describes oscillations in
the 4-dimensional qt-signal [2].</p>
<section id="id979">
<h4>References<a class="headerlink" href="#id979" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id980" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical Orientation Distribution Function (ODF)
for a given diffusion time tau from the signal, <a href="#id1623"><span class="problematic" id="id981">[1]_</span></a> Eq. (32). The
qtdmri coefficients are first converted to mapmri coefficients
following [2].</p>
<section id="id982">
<h4>Parameters<a class="headerlink" href="#id982" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">dipy sphere object</span></dt><dd><p>sphere object with vertice orientations to compute the ODF on.</p>
</dd>
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
<dt>s<span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
</dl>
</section>
<section id="id983">
<h4>References<a class="headerlink" href="#id983" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id984" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et. al, “Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</aside>
<aside class="footnote brackets" id="id985" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.odf_sh">
<span class="sig-name descname"><span class="pre">odf_sh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.odf_sh" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the real analytical odf for a given discrete sphere.
Computes the design matrix of the ODF for the given sphere vertices
and radial moment <a href="#id1624"><span class="problematic" id="id986">[1]_</span></a> eq. (32). The radial moment s acts as a
sharpening method. The analytical equation for the spherical ODF basis
is given in <a href="#id1625"><span class="problematic" id="id987">[2]_</span></a> eq. (C8). The qtdmri coefficients are first converted
to mapmri coefficients following [3].</p>
<section id="id988">
<h4>Parameters<a class="headerlink" href="#id988" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
<dt>s<span class="classifier">unsigned int</span></dt><dd><p>radial moment of the ODF</p>
</dd>
</dl>
</section>
<section id="id989">
<h4>References<a class="headerlink" href="#id989" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id990" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et. al, “Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id991" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rt_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.pdf" title="Permalink to this definition">#</a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qvals_or_gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Recovers the reconstructed signal for any qvalue array or
gradient table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.qiv">
<span class="sig-name descname"><span class="pre">qiv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.qiv" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical Q-space Inverse Variance (QIV) for given
diffusion time tau.
It is defined as the inverse of the Laplacian of the origin of the
estimated propagator <a href="#id1626"><span class="problematic" id="id992">[1]_</span></a> eq. (22). The analytical formula for the
MAP-MRI basis was derived in <a href="#id1627"><span class="problematic" id="id993">[2]_</span></a> eq. (C14, D2). The qtdmri
coefficients are first converted to mapmri coefficients following [3].</p>
<section id="id994">
<h4>Parameters<a class="headerlink" href="#id994" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</section>
<section id="id995">
<h4>References<a class="headerlink" href="#id995" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id996" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Hosseinbor et al. “Bessel fourier orientation reconstruction
(bfor): An analytical diffusion propagator reconstruction for
hybrid diffusion imaging and computation of q-space indices.
NeuroImage 64, 2013, 650–670.</p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id997" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef">
<span class="sig-name descname"><span class="pre">qtdmri_to_mapmri_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef" title="Permalink to this definition">#</a></dt>
<dd><p>This function converts the qtdmri coefficients to mapmri
coefficients for a given tau <a href="#id1628"><span class="problematic" id="id998">[1]_</span></a>. The conversion is performed by a
matrix multiplication that evaluates the time-depenent part of the
basis and multiplies it with the coefficients, after which coefficients
with the same spatial orders are summed up, resulting in mapmri
coefficients.</p>
<section id="id999">
<h4>Parameters<a class="headerlink" href="#id999" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</section>
<section id="id1000">
<h4>References<a class="headerlink" href="#id1000" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1001" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.rtap">
<span class="sig-name descname"><span class="pre">rtap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.rtap" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the axis probability (RTAP)
for a given diffusion time tau, <a href="#id1629"><span class="problematic" id="id1002">[1]_</span></a> eq. (40, 44a). The analytical
formula for the isotropic MAP-MRI basis was derived in <a href="#id1630"><span class="problematic" id="id1003">[2]_</span></a> eq. (C11).
The qtdmri coefficients are first converted to mapmri coefficients
following [3].</p>
<section id="id1004">
<h4>Parameters<a class="headerlink" href="#id1004" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</section>
<section id="id1005">
<h4>References<a class="headerlink" href="#id1005" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1006" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et. al, “Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1007" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.rtop">
<span class="sig-name descname"><span class="pre">rtop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.rtop" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the origin probability (RTOP)
for a given diffusion time tau <a href="#id1631"><span class="problematic" id="id1008">[1]_</span></a> eq. (36, 43). The analytical
formula for the isotropic MAP-MRI basis was derived in <a href="#id1632"><span class="problematic" id="id1009">[2]_</span></a> eq. (C11).
The qtdmri coefficients are first converted to mapmri coefficients
following [3].</p>
<section id="id1010">
<h4>Parameters<a class="headerlink" href="#id1010" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</section>
<section id="id1011">
<h4>References<a class="headerlink" href="#id1011" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1012" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et. al, “Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1013" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.rtpp">
<span class="sig-name descname"><span class="pre">rtpp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.rtpp" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical return to the plane probability (RTPP)
for a given diffusion time tau, <a href="#id1633"><span class="problematic" id="id1014">[1]_</span></a> eq. (42). The analytical formula
for the isotropic MAP-MRI basis was derived in <a href="#id1634"><span class="problematic" id="id1015">[2]_</span></a> eq. (C11). The
qtdmri coefficients are first converted to mapmri coefficients
following [3].</p>
<section id="id1016">
<h4>Parameters<a class="headerlink" href="#id1016" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</section>
<section id="id1017">
<h4>References<a class="headerlink" href="#id1017" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1018" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et. al, “Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1019" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.sparsity_abs">
<span class="sig-name descname"><span class="pre">sparsity_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_abs" title="Permalink to this definition">#</a></dt>
<dd><p>As a measure of sparsity, calculates the number of largest
coefficients needed to absolute sum up to 99% of the total absolute sum
of all coefficients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.QtdmriFit.sparsity_density">
<span class="sig-name descname"><span class="pre">sparsity_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_density" title="Permalink to this definition">#</a></dt>
<dd><p>As a measure of sparsity, calculates the number of largest
coefficients needed to squared sum up to 99% of the total squared sum
of all coefficients</p>
</dd></dl>

</dd></dl>

</section>
<section id="qtdmri-to-mapmri-matrix">
<h3>qtdmri_to_mapmri_matrix<a class="headerlink" href="#qtdmri-to-mapmri-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_to_mapmri_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Generates the matrix that maps the qtdmri coefficients to MAP-MRI
coefficients. The conversion is done by only evaluating the time basis for
a diffusion time tau and summing up coefficients with the same spatial
basis orders [1].</p>
<section id="id1020">
<h4>Parameters<a class="headerlink" href="#id1020" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer representing the spatial/radial order of the basis.</p>
</dd>
<dt>time_order<span class="classifier">unsigned int,</span></dt><dd><p>an integer larger or equal than zero representing the time order
of the basis.</p>
</dd>
<dt>ut<span class="classifier">float</span></dt><dd><p>temporal scaling factor</p>
</dd>
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</section>
<section id="id1021">
<h4>References<a class="headerlink" href="#id1021" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1022" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="qtdmri-isotropic-to-mapmri-matrix">
<h3>qtdmri_isotropic_to_mapmri_matrix<a class="headerlink" href="#qtdmri-isotropic-to-mapmri-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_to_mapmri_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Generates the matrix that maps the spherical qtdmri coefficients to
MAP-MRI coefficients. The conversion is done by only evaluating the time
basis for a diffusion time tau and summing up coefficients with the same
spatial basis orders [1].</p>
<section id="id1023">
<h4>Parameters<a class="headerlink" href="#id1023" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer representing the spatial/radial order of the basis.</p>
</dd>
<dt>time_order<span class="classifier">unsigned int,</span></dt><dd><p>an integer larger or equal than zero representing the time order
of the basis.</p>
</dd>
<dt>ut<span class="classifier">float</span></dt><dd><p>temporal scaling factor</p>
</dd>
<dt>tau<span class="classifier">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</section>
<section id="id1024">
<h4>References<a class="headerlink" href="#id1024" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1025" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="qtdmri-temporal-normalization">
<h3>qtdmri_temporal_normalization<a class="headerlink" href="#qtdmri-temporal-normalization" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_temporal_normalization">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_temporal_normalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_temporal_normalization" title="Permalink to this definition">#</a></dt>
<dd><p>Normalization factor for the temporal basis</p>
</dd></dl>

</section>
<section id="qtdmri-mapmri-normalization">
<h3>qtdmri_mapmri_normalization<a class="headerlink" href="#qtdmri-mapmri-normalization" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_mapmri_normalization">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_mapmri_normalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_mapmri_normalization" title="Permalink to this definition">#</a></dt>
<dd><p>Normalization factor for Cartesian MAP-MRI basis. The scaling is the
same for every basis function depending only on the spatial scaling
mu.</p>
</dd></dl>

</section>
<section id="qtdmri-mapmri-isotropic-normalization">
<h3>qtdmri_mapmri_isotropic_normalization<a class="headerlink" href="#qtdmri-mapmri-isotropic-normalization" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_mapmri_isotropic_normalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization" title="Permalink to this definition">#</a></dt>
<dd><p>Normalization factor for Spherical MAP-MRI basis. The normalization
for a basis function with orders [j,l,m] depends only on orders j,l and
the isotropic scale factor.</p>
</dd></dl>

</section>
<section id="qtdmri-signal-matrix">
<h3><a href="#id1635"><span class="problematic" id="id1636">qtdmri_signal_matrix_</span></a><a class="headerlink" href="#qtdmri-signal-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_signal_matrix_">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_signal_matrix_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix_" title="Permalink to this definition">#</a></dt>
<dd><p>Function to generate the qtdmri signal basis.</p>
</dd></dl>

</section>
<section id="id1026">
<h3>qtdmri_signal_matrix<a class="headerlink" href="#id1026" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_signal_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_signal_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs the design matrix as a product of 3 separated radial,
angular and temporal design matrices. It precomputes the relevant basis
orders for each one and finally puts them together according to the index
matrix</p>
</dd></dl>

</section>
<section id="qtdmri-eap-matrix">
<h3>qtdmri_eap_matrix<a class="headerlink" href="#qtdmri-eap-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_eap_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_eap_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs the design matrix as a product of 3 separated radial,
angular and temporal design matrices. It precomputes the relevant basis
orders for each one and finally puts them together according to the index
matrix</p>
</dd></dl>

</section>
<section id="qtdmri-isotropic-signal-matrix">
<h3><a href="#id1637"><span class="problematic" id="id1638">qtdmri_isotropic_signal_matrix_</span></a><a class="headerlink" href="#qtdmri-isotropic-signal-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_signal_matrix_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="id1027">
<h3>qtdmri_isotropic_signal_matrix<a class="headerlink" href="#id1027" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_signal_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="id1028">
<h3><a href="#id1639"><span class="problematic" id="id1640">qtdmri_eap_matrix_</span></a><a class="headerlink" href="#id1028" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_eap_matrix_">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_eap_matrix_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix_" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="qtdmri-isotropic-eap-matrix">
<h3><a href="#id1641"><span class="problematic" id="id1642">qtdmri_isotropic_eap_matrix_</span></a><a class="headerlink" href="#qtdmri-isotropic-eap-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_eap_matrix_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="id1029">
<h3>qtdmri_isotropic_eap_matrix<a class="headerlink" href="#id1029" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_eap_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs the design matrix as a product of 3 separated radial,
angular and temporal design matrices. It precomputes the relevant basis
orders for each one and finally puts them together according to the index
matrix</p>
</dd></dl>

</section>
<section id="radial-basis-opt">
<h3>radial_basis_opt<a class="headerlink" href="#radial-basis-opt" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.radial_basis_opt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">radial_basis_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.radial_basis_opt" title="Permalink to this definition">#</a></dt>
<dd><p>Spatial basis dependent on spatial scaling factor us</p>
</dd></dl>

</section>
<section id="angular-basis-opt">
<h3>angular_basis_opt<a class="headerlink" href="#angular-basis-opt" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.angular_basis_opt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">angular_basis_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.angular_basis_opt" title="Permalink to this definition">#</a></dt>
<dd><p>Angular basis independent of spatial scaling factor us. Though it
includes q, it is independent of the data and can be precomputed.</p>
</dd></dl>

</section>
<section id="radial-basis-eap-opt">
<h3>radial_basis_EAP_opt<a class="headerlink" href="#radial-basis-eap-opt" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.radial_basis_EAP_opt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">radial_basis_EAP_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.radial_basis_EAP_opt" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="angular-basis-eap-opt">
<h3>angular_basis_EAP_opt<a class="headerlink" href="#angular-basis-eap-opt" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.angular_basis_EAP_opt">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">angular_basis_EAP_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.angular_basis_EAP_opt" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="temporal-basis">
<h3>temporal_basis<a class="headerlink" href="#temporal-basis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.temporal_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">temporal_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">o</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.temporal_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Temporal basis dependent on temporal scaling factor ut</p>
</dd></dl>

</section>
<section id="qtdmri-index-matrix">
<h3>qtdmri_index_matrix<a class="headerlink" href="#qtdmri-index-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_index_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the SHORE basis order indices according to [1].</p>
</dd></dl>

</section>
<section id="qtdmri-isotropic-index-matrix">
<h3>qtdmri_isotropic_index_matrix<a class="headerlink" href="#qtdmri-isotropic-index-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_index_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the SHORE basis order indices according to [1].</p>
</dd></dl>

</section>
<section id="qtdmri-laplacian-reg-matrix">
<h3>qtdmri_laplacian_reg_matrix<a class="headerlink" href="#qtdmri-laplacian-reg-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_laplacian_reg_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S_mat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T_mat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_mat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part1_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part23_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part4_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the cartesian qt-dMRI Laplacian regularization matrix. If
given, uses precomputed matrices for temporal and spatial regularization
matrices to speed up computation. Follows the the formulation of Appendix B
in [1].</p>
<section id="id1030">
<h4>References<a class="headerlink" href="#id1030" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1031" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="qtdmri-isotropic-laplacian-reg-matrix">
<h3>qtdmri_isotropic_laplacian_reg_matrix<a class="headerlink" href="#qtdmri-isotropic-laplacian-reg-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_laplacian_reg_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part1_uq_iso_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part1_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part23_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">part4_ut_precomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the spherical qt-dMRI Laplacian regularization matrix. If
given, uses precomputed matrices for temporal and spatial regularization
matrices to speed up computation. Follows the the formulation of Appendix C
in [1].</p>
<section id="id1032">
<h4>References<a class="headerlink" href="#id1032" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1033" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="part23-reg-matrix-q">
<h3>part23_reg_matrix_q<a class="headerlink" href="#part23-reg-matrix-q" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part23_reg_matrix_q">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part23_reg_matrix_q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part23_reg_matrix_q" title="Permalink to this definition">#</a></dt>
<dd><p>Partial cartesian spatial Laplacian regularization matrix following
second line of Eq. (B2) in [1].</p>
<section id="id1034">
<h4>References<a class="headerlink" href="#id1034" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1035" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="part23-iso-reg-matrix-q">
<h3>part23_iso_reg_matrix_q<a class="headerlink" href="#part23-iso-reg-matrix-q" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part23_iso_reg_matrix_q">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part23_iso_reg_matrix_q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part23_iso_reg_matrix_q" title="Permalink to this definition">#</a></dt>
<dd><p>Partial spherical spatial Laplacian regularization matrix following the
equation below Eq. (C4) in [1].</p>
<section id="id1036">
<h4>References<a class="headerlink" href="#id1036" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1037" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="part4-reg-matrix-q">
<h3>part4_reg_matrix_q<a class="headerlink" href="#part4-reg-matrix-q" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part4_reg_matrix_q">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part4_reg_matrix_q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part4_reg_matrix_q" title="Permalink to this definition">#</a></dt>
<dd><p>Partial cartesian spatial Laplacian regularization matrix following
equation Eq. (B2) in [1].</p>
<section id="id1038">
<h4>References<a class="headerlink" href="#id1038" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1039" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="part4-iso-reg-matrix-q">
<h3>part4_iso_reg_matrix_q<a class="headerlink" href="#part4-iso-reg-matrix-q" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part4_iso_reg_matrix_q">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part4_iso_reg_matrix_q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">us</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part4_iso_reg_matrix_q" title="Permalink to this definition">#</a></dt>
<dd><p>Partial spherical spatial Laplacian regularization matrix following the
equation below Eq. (C4) in [1].</p>
<section id="id1040">
<h4>References<a class="headerlink" href="#id1040" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1041" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="part1-reg-matrix-tau">
<h3>part1_reg_matrix_tau<a class="headerlink" href="#part1-reg-matrix-tau" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part1_reg_matrix_tau">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part1_reg_matrix_tau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part1_reg_matrix_tau" title="Permalink to this definition">#</a></dt>
<dd><p>Partial temporal Laplacian regularization matrix following
Appendix B in [1].</p>
<section id="id1042">
<h4>References<a class="headerlink" href="#id1042" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1043" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="part23-reg-matrix-tau">
<h3>part23_reg_matrix_tau<a class="headerlink" href="#part23-reg-matrix-tau" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part23_reg_matrix_tau">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part23_reg_matrix_tau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part23_reg_matrix_tau" title="Permalink to this definition">#</a></dt>
<dd><p>Partial temporal Laplacian regularization matrix following
Appendix B in [1].</p>
<section id="id1044">
<h4>References<a class="headerlink" href="#id1044" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1045" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="part4-reg-matrix-tau">
<h3>part4_reg_matrix_tau<a class="headerlink" href="#part4-reg-matrix-tau" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.part4_reg_matrix_tau">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">part4_reg_matrix_tau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part4_reg_matrix_tau" title="Permalink to this definition">#</a></dt>
<dd><p>Partial temporal Laplacian regularization matrix following
Appendix B in [1].</p>
<section id="id1046">
<h4>References<a class="headerlink" href="#id1046" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1047" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="h">
<h3>H<a class="headerlink" href="#h" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.H">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.H" title="Permalink to this definition">#</a></dt>
<dd><p>Step function of H(x)=1 if x&gt;=0 and zero otherwise. Used for the
temporal laplacian matrix.</p>
</dd></dl>

</section>
<section id="id1048">
<h3>generalized_crossvalidation<a class="headerlink" href="#id1048" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.generalized_crossvalidation">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">generalized_crossvalidation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">startpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0005</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.generalized_crossvalidation" title="Permalink to this definition">#</a></dt>
<dd><p>Generalized Cross Validation Function [1].</p>
<section id="id1049">
<h4>References<a class="headerlink" href="#id1049" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1050" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Craven et al. “Smoothing Noisy Data with Spline Functions.”
NUMER MATH 31.4 (1978): 377-403.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="id1051">
<h3>GCV_cost_function<a class="headerlink" href="#id1051" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.GCV_cost_function">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">GCV_cost_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arguments</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.GCV_cost_function" title="Permalink to this definition">#</a></dt>
<dd><p>Generalized Cross Validation Function that is iterated [1].</p>
<section id="id1052">
<h4>References<a class="headerlink" href="#id1052" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1053" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Craven et al. “Smoothing Noisy Data with Spline Functions.”
NUMER MATH 31.4 (1978): 377-403.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="qtdmri-isotropic-scaling">
<h3>qtdmri_isotropic_scaling<a class="headerlink" href="#qtdmri-isotropic-scaling" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_isotropic_scaling">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_isotropic_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_scaling" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs design matrix for fitting an exponential to the
diffusion time points.</p>
</dd></dl>

</section>
<section id="qtdmri-anisotropic-scaling">
<h3>qtdmri_anisotropic_scaling<a class="headerlink" href="#qtdmri-anisotropic-scaling" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_anisotropic_scaling">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_anisotropic_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bvecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs design matrix for fitting an exponential to the
diffusion time points.</p>
</dd></dl>

</section>
<section id="design-matrix-spatial">
<h3>design_matrix_spatial<a class="headerlink" href="#design-matrix-spatial" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.design_matrix_spatial">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">design_matrix_spatial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bvecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qvals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.design_matrix_spatial" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs design matrix for DTI weighted least squares or
least squares fitting. (Basser et al., 1994a)</p>
<section id="id1054">
<h4>Parameters<a class="headerlink" href="#id1054" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>bvecs<span class="classifier">array (N x 3)</span></dt><dd><p>unit b-vectors of the acquisition.</p>
</dd>
<dt>qvals<span class="classifier">array (N,)</span></dt><dd><p>corresponding q-values in 1/mm</p>
</dd>
</dl>
</section>
<section id="id1055">
<h4>Returns<a class="headerlink" href="#id1055" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>design_matrix<span class="classifier">array (g,7)</span></dt><dd><p>Design matrix or B matrix assuming Gaussian distributed tensor model
design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="create-rt-space-grid">
<h3>create_rt_space_grid<a class="headerlink" href="#create-rt-space-grid" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.create_rt_space_grid">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">create_rt_space_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_size_r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radius_r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_size_tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_radius_tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radius_tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.create_rt_space_grid" title="Permalink to this definition">#</a></dt>
<dd><p>Generates EAP grid (for potential positivity constraint).</p>
</dd></dl>

</section>
<section id="qtdmri-number-of-coefficients">
<h3>qtdmri_number_of_coefficients<a class="headerlink" href="#qtdmri-number-of-coefficients" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.qtdmri_number_of_coefficients">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">qtdmri_number_of_coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_number_of_coefficients" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the total number of coefficients of the qtdmri basis given a
radial and temporal order. Equation given below Eq (9) in [1].</p>
<section id="id1056">
<h4>References<a class="headerlink" href="#id1056" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1057" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Fick, Rutger HJ, et al. “Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time”, Medical Image Analysis,
2017.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="l1-crossvalidation">
<h3>l1_crossvalidation<a class="headerlink" href="#l1-crossvalidation" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.l1_crossvalidation">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">l1_crossvalidation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b0s_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.02,</span> <span class="pre">0.04,</span> <span class="pre">0.06,</span> <span class="pre">0.08,</span> <span class="pre">0.1,</span> <span class="pre">0.12,</span> <span class="pre">0.14,</span> <span class="pre">0.16,</span> <span class="pre">0.18,</span> <span class="pre">0.2,</span> <span class="pre">0.22,</span> <span class="pre">0.24,</span> <span class="pre">0.26,</span> <span class="pre">0.28,</span> <span class="pre">0.3,</span> <span class="pre">0.32,</span> <span class="pre">0.34,</span> <span class="pre">0.36,</span> <span class="pre">0.38,</span> <span class="pre">0.4])</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.l1_crossvalidation" title="Permalink to this definition">#</a></dt>
<dd><p>cross-validation function to find the optimal weight of alpha for
sparsity regularization</p>
</dd></dl>

</section>
<section id="elastic-crossvalidation">
<h3>elastic_crossvalidation<a class="headerlink" href="#elastic-crossvalidation" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.elastic_crossvalidation">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">elastic_crossvalidation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b0s_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lopt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.01,</span> <span class="pre">0.02,</span> <span class="pre">0.03,</span> <span class="pre">0.04,</span> <span class="pre">0.05,</span> <span class="pre">0.06,</span> <span class="pre">0.07,</span> <span class="pre">0.08,</span> <span class="pre">0.09,</span> <span class="pre">0.1,</span> <span class="pre">0.11,</span> <span class="pre">0.12,</span> <span class="pre">0.13,</span> <span class="pre">0.14,</span> <span class="pre">0.15,</span> <span class="pre">0.16,</span> <span class="pre">0.17,</span> <span class="pre">0.18,</span> <span class="pre">0.19,</span> <span class="pre">0.2])</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.elastic_crossvalidation" title="Permalink to this definition">#</a></dt>
<dd><p>cross-validation function to find the optimal weight of alpha for
sparsity regularization when also Laplacian regularization is used.</p>
</dd></dl>

</section>
<section id="visualise-gradient-table-g-delta-rainbow">
<h3>visualise_gradient_table_G_Delta_rainbow<a class="headerlink" href="#visualise-gradient-table-g-delta-rainbow" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qtdmri.</span></span><span class="sig-name descname"><span class="pre">visualise_gradient_table_G_Delta_rainbow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">big_delta_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">big_delta_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bval_isolines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0,</span> <span class="pre">250,</span> <span class="pre">1000,</span> <span class="pre">2500,</span> <span class="pre">5000,</span> <span class="pre">7500,</span> <span class="pre">10000,</span> <span class="pre">14000])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_shading</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow" title="Permalink to this definition">#</a></dt>
<dd><p>This function visualizes a q-tau acquisition scheme as a function of
gradient strength and pulse separation (big_delta). It represents every
measurements at its G and big_delta position regardless of b-vector, with a
background of b-value isolines for reference. It assumes there is only one
unique pulse length (small_delta) in the acquisition scheme.</p>
<section id="id1058">
<h4>Parameters<a class="headerlink" href="#id1058" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable object</span></dt><dd><p>constructed gradient table with big_delta and small_delta given as
inputs.</p>
</dd>
<dt>big_delta_start<span class="classifier">float,</span></dt><dd><p>optional minimum big_delta that is plotted in seconds</p>
</dd>
<dt>big_delta_end<span class="classifier">float,</span></dt><dd><p>optional maximum big_delta that is plotted in seconds</p>
</dd>
<dt>G_start<span class="classifier">float,</span></dt><dd><p>optional minimum gradient strength that is plotted in T/m</p>
</dd>
<dt>G_end<span class="classifier">float,</span></dt><dd><p>optional maximum gradient strength that is plotted in T/m</p>
</dd>
<dt>bval_isolines<span class="classifier">array,</span></dt><dd><p>optional array of bvalue isolines that are plotted in the background</p>
</dd>
<dt>alpha_shading<span class="classifier">float between [0-1]</span></dt><dd><p>optional shading of the bvalue colors in the background</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="qtimodel">
<h3><a class="reference internal" href="#dipy.reconst.qti.QtiModel" title="dipy.reconst.qti.QtiModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtiModel</span></code></a><a class="headerlink" href="#qtimodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">QtiModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SCS'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WLS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SCS'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Covariance tensor model of q-space trajectory imaging <a href="#id1643"><span class="problematic" id="id1059">[1]_</span></a>.</p>
<section id="id1060">
<h4>Parameters<a class="headerlink" href="#id1060" title="Permalink to this heading">#</a></h4>
<dl>
<dt>gtab<span class="classifier">dipy.core.gradients.GradientTable</span></dt><dd><p>Gradient table with b-tensors.</p>
</dd>
<dt>fit_method<span class="classifier">str, optional</span></dt><dd><dl>
<dt>Must be one of the following:</dt><dd><dl>
<dt>‘OLS’ for ordinary least squares</dt><dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">qti._ols_fit()</span></code></p>
</dd>
<dt>‘WLS’ for weighted least squares</dt><dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">qti._wls_fit()</span></code></p>
</dd>
<dt>‘SDPDc’ for semidefinite programming with positivity</dt><dd><blockquote>
<div><p>constraints applied <a href="#id1644"><span class="problematic" id="id1061">[2]_</span></a></p>
</div></blockquote>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">qti._sdpdc_fit()</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>cvxpy_solver: str, optionals</dt><dd><p>solver for the SDP formulation. default: ‘SCS’</p>
</dd>
</dl>
</section>
<section id="id1062">
<h4>References<a class="headerlink" href="#id1062" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1063" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Westin, Carl-Fredrik, et al. “Q-space trajectory imaging for
multidimensional diffusion MRI of the human brain.” Neuroimage 135
(2016): 345-362. <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.02.039">https://doi.org/10.1016/j.neuroimage.2016.02.039</a>.</p>
</aside>
<aside class="footnote brackets" id="id1064" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Herberthson M., Boito D., Dela Haije T., Feragen A., Westin CF.,
Ozarslan E., “Q-space trajectory imaging with positivity
constraints (QTI+)” in Neuroimage, Volume 238, 2021.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit QTI to data.</p>
<section id="id1065">
<h4>Parameters<a class="headerlink" href="#id1065" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>data<span class="classifier">numpy.ndarray</span></dt><dd><p>Array of shape (…, number of acquisitions).</p>
</dd>
<dt>mask<span class="classifier">numpy.ndarray, optional</span></dt><dd><p>Array with the same shape as the data array of a single acquisition.</p>
</dd>
</dl>
</section>
<section id="id1066">
<h4>Returns<a class="headerlink" href="#id1066" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>qtifit<span class="classifier">dipy.reconst.qti.QtiFit</span></dt><dd><p>The fitted model.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiModel.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiModel.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Generate signals from this model class instance and given parameters.</p>
<section id="id1067">
<h4>Parameters<a class="headerlink" href="#id1067" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">numpy.ndarray</span></dt><dd><p>Array of shape (…, 28) containing the model parameters. Element 0
is the natural logarithm of the signal without diffusion-weighting,
elements 1-6 are the diffusion tensor elements in Voigt notation,
and elements 7-27 are the covariance tensor elements in Voigt
notation.</p>
</dd>
</dl>
</section>
<section id="id1068">
<h4>Returns<a class="headerlink" href="#id1068" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">numpy.ndarray</span></dt><dd><p>Signals.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="qtifit">
<h3><a class="reference internal" href="#dipy.reconst.qti.QtiFit" title="dipy.reconst.qti.QtiFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtiFit</span></code></a><a class="headerlink" href="#qtifit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">QtiFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Fitted QTI model.</p>
<section id="id1069">
<h4>Parameters<a class="headerlink" href="#id1069" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>params<span class="classifier">numpy.ndarray</span></dt><dd><p>Array of shape (…, 28) containing the model parameters. Element 0
is the natural logarithm of the signal without diffusion-weighting,
elements 1-6 are the diffusion tensor elements in Voigt notation,
and elements 7-27 are the covariance tensor elements in Voigt
notation.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.S0_hat">
<span class="sig-name descname"><span class="pre">S0_hat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.S0_hat" title="Permalink to this definition">#</a></dt>
<dd><p>Estimated signal without diffusion-weighting.</p>
<section id="id1070">
<h4>Returns<a class="headerlink" href="#id1070" title="Permalink to this heading">#</a></h4>
<p>S0 : numpy.ndarray</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.c_c">
<span class="sig-name descname"><span class="pre">c_c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.c_c" title="Permalink to this definition">#</a></dt>
<dd><p>Microscopic orientation coherence.</p>
<blockquote>
<div><p>c_c : numpy.ndarray</p>
<p>Microscopic orientation coherence is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C_c = \]</div>
</div></blockquote>
</div></blockquote>
<p>rac{<a href="#id1645"><span class="problematic" id="id1646">C_</span></a>   ext{M}}{<a href="#id1647"><span class="problematic" id="id1648">C_</span></a>mu}</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.c_m">
<span class="sig-name descname"><span class="pre">c_m</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.c_m" title="Permalink to this definition">#</a></dt>
<dd><p>Normalized macroscopic anisotropy.</p>
<blockquote>
<div><p>c_m : numpy.ndarray</p>
<p>Normalized macroscopic anisotropy is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C_      ext{M} = \]</div>
</div></blockquote>
</div></blockquote>
<p>rac{3}{2} 
rac{langle mathbf{D} 
angle</p>
<blockquote>
<div><p>otimes langle mathbf{D}</p>
</div></blockquote>
<dl class="simple">
<dt>angle<span class="classifier">mathbb{E}_     ext{shear}}</span></dt><dd><p>{langle mathbf{D}</p>
</dd>
</dl>
<p>angle otimes langle mathbf{D} 
angle :</p>
<blockquote>
<div><p>mathbb{E}_     ext{iso}}</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.c_md">
<span class="sig-name descname"><span class="pre">c_md</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.c_md" title="Permalink to this definition">#</a></dt>
<dd><p>Normalized variance of mean diffusivities.</p>
<blockquote>
<div><p>c_md : numpy.ndarray</p>
<p>Normalized variance of microscopic mean diffusivities is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C_      ext{MD} = \]</div>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>rac{mathbb{C}<span class="classifier">mathbb{E}_ ext{bulk}}</span></dt><dd><p>{langle mathbf{D} otimes mathbf{D}</p>
</dd>
<dt>angle :</dt><dd><p>mathbb{E}_     ext{bulk}}</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.c_mu">
<span class="sig-name descname"><span class="pre">c_mu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.c_mu" title="Permalink to this definition">#</a></dt>
<dd><p>Normalized microscopic anisotropy.</p>
<blockquote>
<div><p>c_mu : numpy.ndarray</p>
<p>Normalized microscopic anisotropy is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C_\mu = \]</div>
</div></blockquote>
</div></blockquote>
<p>rac{3}{2} 
rac{langle mathbf{D} otimes mathbf{D}</p>
<dl class="simple">
<dt>angle<span class="classifier">mathbb{E}_     ext{shear}}{langle mathbf{D} otimes</span></dt><dd><p>mathbf{D}</p>
</dd>
</dl>
<p>angle : mathbb{E}_     ext{iso}}</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.d_sq">
<span class="sig-name descname"><span class="pre">d_sq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.d_sq" title="Permalink to this definition">#</a></dt>
<dd><p>Diffusion tensor’s outer product with itself.</p>
<section id="id1071">
<h4>Returns<a class="headerlink" href="#id1071" title="Permalink to this heading">#</a></h4>
<p>d_sq : numpy.ndarray</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.fa">
<span class="sig-name descname"><span class="pre">fa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.fa" title="Permalink to this definition">#</a></dt>
<dd><p>Fractional anisotropy.</p>
<section id="id1072">
<h4>Returns<a class="headerlink" href="#id1072" title="Permalink to this heading">#</a></h4>
<p>fa : numpy.ndarray</p>
</section>
<section id="id1073">
<h4>Notes<a class="headerlink" href="#id1073" title="Permalink to this heading">#</a></h4>
<p>Fractional anisotropy is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[ext{FA} = \sqrt{C_      ext{M}}\]</div>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.k_bulk">
<span class="sig-name descname"><span class="pre">k_bulk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.k_bulk" title="Permalink to this definition">#</a></dt>
<dd><p>Bulk kurtosis.</p>
<blockquote>
<div><p>k_bulk : numpy.ndarray</p>
<p>Bulk kurtosis is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[K_      ext{bulk} = 3 \]</div>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>rac{mathbb{C}<span class="classifier">mathbb{E}_     ext{bulk}}</span></dt><dd><p>{langle mathbf{D}</p>
</dd>
</dl>
<p>angle otimes langle mathbf{D} 
angle :</p>
<blockquote>
<div><p>mathbb{E}_     ext{bulk}}</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.k_mu">
<span class="sig-name descname"><span class="pre">k_mu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.k_mu" title="Permalink to this definition">#</a></dt>
<dd><p>Microscopic kurtosis.</p>
<blockquote>
<div><p>k_mu : numpy.ndarray</p>
<p>Microscopic kurtosis is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[K_\mu = \]</div>
</div></blockquote>
</div></blockquote>
<p>rac{6}{5} 
rac{langle mathbf{D} otimes mathbf{D}</p>
<p>angle : mathbb{E}_     ext{shear}}{langle mathbf{D} 
angle</p>
<blockquote>
<div><p>otimes langle mathbf{D}</p>
</div></blockquote>
<p>angle : mathbb{E}_     ext{bulk}}</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.k_shear">
<span class="sig-name descname"><span class="pre">k_shear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.k_shear" title="Permalink to this definition">#</a></dt>
<dd><p>Shear kurtosis.</p>
<blockquote>
<div><p>k_shear : numpy.ndarray</p>
<p>Shear kurtosis is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[K_      ext{shear} = \]</div>
</div></blockquote>
</div></blockquote>
<p>rac{6}{5} 
rac{mathbb{C} :</p>
<blockquote>
<div><p>mathbb{E}_     ext{shear}}{langle mathbf{D}</p>
</div></blockquote>
<dl class="simple">
<dt>angle otimes</dt><dd><p>langle mathbf{D}</p>
</dd>
</dl>
<p>angle : mathbb{E}_     ext{bulk}}</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.md">
<span class="sig-name descname"><span class="pre">md</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.md" title="Permalink to this definition">#</a></dt>
<dd><p>Mean diffusivity.</p>
<blockquote>
<div><p>md : numpy.ndarray</p>
<p>Mean diffusivity is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[ext{MD} = \langle \mathbf{D} \]</div>
</div></blockquote>
</div></blockquote>
<p>angle : mathbf{E}_     ext{iso}</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.mean_d_sq">
<span class="sig-name descname"><span class="pre">mean_d_sq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.mean_d_sq" title="Permalink to this definition">#</a></dt>
<dd><dl>
<dt>Average of microscopic diffusion tensors’ outer products with</dt><dd><p>themselves.</p>
<p>mean_d_sq : numpy.ndarray</p>
<p>Average of microscopic diffusion tensors’ outer products with themselves
is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\langle \mathbf{D} \otimes \mathbf{D} \]</div>
</div></blockquote>
</dd>
<dt>angle = mathbb{C} +</dt><dd><p>langle mathbf{D}</p>
</dd>
</dl>
<p>angle otimes langle mathbf{D} 
angle</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.mk">
<span class="sig-name descname"><span class="pre">mk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.mk" title="Permalink to this definition">#</a></dt>
<dd><p>Mean kurtosis.</p>
<section id="id1074">
<h4>Returns<a class="headerlink" href="#id1074" title="Permalink to this heading">#</a></h4>
<p>mk : numpy.ndarray</p>
</section>
<section id="id1075">
<h4>Notes<a class="headerlink" href="#id1075" title="Permalink to this heading">#</a></h4>
<p>Mean kurtosis is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[ext{MK} = K_    ext{bulk} + K_  ext{shear}\]</div>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Generate signals from this model fit and a given gradient table.</p>
<section id="id1076">
<h4>Parameters<a class="headerlink" href="#id1076" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">dipy.core.gradients.GradientTable</span></dt><dd><p>Gradient table with b-tensors.</p>
</dd>
</dl>
</section>
<section id="id1077">
<h4>Returns<a class="headerlink" href="#id1077" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>S<span class="classifier">numpy.ndarray</span></dt><dd><p>Signals.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.ufa">
<span class="sig-name descname"><span class="pre">ufa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.ufa" title="Permalink to this definition">#</a></dt>
<dd><p>Microscopic fractional anisotropy.</p>
<section id="id1078">
<h4>Returns<a class="headerlink" href="#id1078" title="Permalink to this heading">#</a></h4>
<p>ufa : numpy.ndarray</p>
</section>
<section id="id1079">
<h4>Notes<a class="headerlink" href="#id1079" title="Permalink to this heading">#</a></h4>
<p>Microscopic fractional anisotropy is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mu     ext{FA} = \sqrt{C_\mu}\]</div>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.v_iso">
<span class="sig-name descname"><span class="pre">v_iso</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.v_iso" title="Permalink to this definition">#</a></dt>
<dd><p>Total isotropic variance.</p>
<section id="id1080">
<h4>Returns<a class="headerlink" href="#id1080" title="Permalink to this heading">#</a></h4>
<p>v_iso : numpy.ndarray</p>
</section>
<section id="id1081">
<h4>Notes<a class="headerlink" href="#id1081" title="Permalink to this heading">#</a></h4>
<p>Total isotropic variance is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[V_      ext{iso} = \mathbb{C} : \mathbb{E}_     ext{iso}\]</div>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.v_md">
<span class="sig-name descname"><span class="pre">v_md</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.v_md" title="Permalink to this definition">#</a></dt>
<dd><p>Variance of microscopic mean diffusivities.</p>
<section id="id1082">
<h4>Returns<a class="headerlink" href="#id1082" title="Permalink to this heading">#</a></h4>
<p>v_md : numpy.ndarray</p>
</section>
<section id="id1083">
<h4>Notes<a class="headerlink" href="#id1083" title="Permalink to this heading">#</a></h4>
<p>Variance of microscopic mean diffusivities is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[V_      ext{MD} = \mathbb{C} : \mathbb{E}_      ext{bulk}\]</div>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.qti.QtiFit.v_shear">
<span class="sig-name descname"><span class="pre">v_shear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.QtiFit.v_shear" title="Permalink to this definition">#</a></dt>
<dd><p>Shear variance.</p>
<section id="id1084">
<h4>Returns<a class="headerlink" href="#id1084" title="Permalink to this heading">#</a></h4>
<p>v_shear : numpy.ndarray</p>
</section>
<section id="id1085">
<h4>Notes<a class="headerlink" href="#id1085" title="Permalink to this heading">#</a></h4>
<p>Shear variance is calculated as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[V_      ext{shear} = \mathbb{C} : \mathbb{E}_   ext{shear}\]</div>
</div></blockquote>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="from-3x3-to-6x1">
<h3>from_3x3_to_6x1<a class="headerlink" href="#from-3x3-to-6x1" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.from_3x3_to_6x1">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">from_3x3_to_6x1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.from_3x3_to_6x1" title="Permalink to this definition">#</a></dt>
<dd><p>Convert symmetric 3 x 3 matrices into 6 x 1 vectors.</p>
<section id="id1086">
<h4>Parameters<a class="headerlink" href="#id1086" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (…, 3, 3).</p>
</dd>
</dl>
</section>
<section id="id1087">
<h4>Returns<a class="headerlink" href="#id1087" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>V<span class="classifier">numpy.ndarray</span></dt><dd><p>Converted vectors of size (…, 6, 1).</p>
</dd>
</dl>
</section>
<section id="id1088">
<h4>Notes<a class="headerlink" href="#id1088" title="Permalink to this heading">#</a></h4>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{V} = egin{bmatrix}
T_{11} &amp; T_{22} &amp; T_{33} &amp;
\sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12}
\end{bmatrix}^T\]</div>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="from-6x1-to-3x3">
<h3>from_6x1_to_3x3<a class="headerlink" href="#from-6x1-to-3x3" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.from_6x1_to_3x3">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">from_6x1_to_3x3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.from_6x1_to_3x3" title="Permalink to this definition">#</a></dt>
<dd><p>Convert 6 x 1 vectors into symmetric 3 x 3 matrices.</p>
<section id="id1089">
<h4>Parameters<a class="headerlink" href="#id1089" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>V<span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (…, 6, 1).</p>
</dd>
</dl>
</section>
<section id="id1090">
<h4>Returns<a class="headerlink" href="#id1090" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">numpy.ndarray</span></dt><dd><p>Converted matrices of size (…, 3, 3).</p>
</dd>
</dl>
</section>
<section id="id1091">
<h4>Notes<a class="headerlink" href="#id1091" title="Permalink to this heading">#</a></h4>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{V} = egin{bmatrix}
T_{11} &amp; T_{22} &amp; T_{33} &amp;
\sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12}
\end{bmatrix}^T\]</div>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="from-6x6-to-21x1">
<h3>from_6x6_to_21x1<a class="headerlink" href="#from-6x6-to-21x1" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.from_6x6_to_21x1">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">from_6x6_to_21x1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.from_6x6_to_21x1" title="Permalink to this definition">#</a></dt>
<dd><p>Convert symmetric 6 x 6 matrices into 21 x 1 vectors.</p>
<section id="id1092">
<h4>Parameters<a class="headerlink" href="#id1092" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (…, 6, 6).</p>
</dd>
</dl>
</section>
<section id="id1093">
<h4>Returns<a class="headerlink" href="#id1093" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>V<span class="classifier">numpy.ndarray</span></dt><dd><p>Converted vectors of size (…, 21, 1).</p>
</dd>
</dl>
</section>
<section id="id1094">
<h4>Notes<a class="headerlink" href="#id1094" title="Permalink to this heading">#</a></h4>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[egin{matrix}
\mathbf{V} = &amp; ig[
T_{11} &amp; T_{22} &amp; T_{33} \
&amp; \sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12} \
&amp; \sqrt{2} T_{14} &amp; \sqrt{2} T_{15} &amp; \sqrt{2} T_{16} \
&amp; \sqrt{2} T_{24} &amp; \sqrt{2} T_{25} &amp; \sqrt{2} T_{26} \
&amp; \sqrt{2} T_{34} &amp; \sqrt{2} T_{35} &amp; \sqrt{2} T_{36} \
&amp; T_{44} &amp; T_{55} &amp; T_{66} \
&amp; \sqrt{2} T_{45} &amp; \sqrt{2} T_{56} &amp; \sqrt{2} T_{46} ig]^T
\end{matrix}\]</div>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="from-21x1-to-6x6">
<h3>from_21x1_to_6x6<a class="headerlink" href="#from-21x1-to-6x6" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.from_21x1_to_6x6">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">from_21x1_to_6x6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.from_21x1_to_6x6" title="Permalink to this definition">#</a></dt>
<dd><p>Convert 21 x 1 vectors into symmetric 6 x 6 matrices.</p>
<section id="id1095">
<h4>Parameters<a class="headerlink" href="#id1095" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>V<span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (…, 21, 1).</p>
</dd>
</dl>
</section>
<section id="id1096">
<h4>Returns<a class="headerlink" href="#id1096" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">numpy.ndarray</span></dt><dd><p>Converted matrices of size (…, 6, 6).</p>
</dd>
</dl>
</section>
<section id="id1097">
<h4>Notes<a class="headerlink" href="#id1097" title="Permalink to this heading">#</a></h4>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[egin{matrix}
\mathbf{V} = &amp; ig[
T_{11} &amp; T_{22} &amp; T_{33} \
&amp; \sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12} \
&amp; \sqrt{2} T_{14} &amp; \sqrt{2} T_{15} &amp; \sqrt{2} T_{16} \
&amp; \sqrt{2} T_{24} &amp; \sqrt{2} T_{25} &amp; \sqrt{2} T_{26} \
&amp; \sqrt{2} T_{34} &amp; \sqrt{2} T_{35} &amp; \sqrt{2} T_{36} \
&amp; T_{44} &amp; T_{55} &amp; T_{66} \
&amp; \sqrt{2} T_{45} &amp; \sqrt{2} T_{56} &amp; \sqrt{2} T_{46} ig]^T
\end{matrix}\]</div>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="cvxpy-1x6-to-3x3">
<h3>cvxpy_1x6_to_3x3<a class="headerlink" href="#cvxpy-1x6-to-3x3" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.cvxpy_1x6_to_3x3">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">cvxpy_1x6_to_3x3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.cvxpy_1x6_to_3x3" title="Permalink to this definition">#</a></dt>
<dd><p>Convert a 1 x 6 vector into a symmetric 3 x 3 matrix.</p>
<section id="id1098">
<h4>Parameters<a class="headerlink" href="#id1098" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>V<span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (1, 6).</p>
</dd>
</dl>
</section>
<section id="id1099">
<h4>Returns<a class="headerlink" href="#id1099" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">cvxpy.bmat</span></dt><dd><p>Converted matrix of size (3, 3).</p>
</dd>
</dl>
</section>
<section id="id1100">
<h4>Notes<a class="headerlink" href="#id1100" title="Permalink to this heading">#</a></h4>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{V} = egin{bmatrix}
T_{11} &amp; T_{22} &amp; T_{33} &amp;
\sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12}
\end{bmatrix}^T\]</div>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="cvxpy-1x21-to-6x6">
<h3>cvxpy_1x21_to_6x6<a class="headerlink" href="#cvxpy-1x21-to-6x6" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.cvxpy_1x21_to_6x6">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">cvxpy_1x21_to_6x6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.cvxpy_1x21_to_6x6" title="Permalink to this definition">#</a></dt>
<dd><p>Convert 1 x 21 vector into a symmetric 6 x 6 matrix.</p>
<section id="id1101">
<h4>Parameters<a class="headerlink" href="#id1101" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>V<span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size (1, 21).</p>
</dd>
</dl>
</section>
<section id="id1102">
<h4>Returns<a class="headerlink" href="#id1102" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>T<span class="classifier">cvxpy.bmat</span></dt><dd><p>Converted matrices of size (6, 6).</p>
</dd>
</dl>
</section>
<section id="id1103">
<h4>Notes<a class="headerlink" href="#id1103" title="Permalink to this heading">#</a></h4>
<p>The conversion of a matrix into a vector is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[egin{matrix}
\mathbf{V} = &amp; ig[
T_{11} &amp; T_{22} &amp; T_{33} \
&amp; \sqrt{2} T_{23} &amp; \sqrt{2} T_{13} &amp; \sqrt{2} T_{12} \
&amp; \sqrt{2} T_{14} &amp; \sqrt{2} T_{15} &amp; \sqrt{2} T_{16} \
&amp; \sqrt{2} T_{24} &amp; \sqrt{2} T_{25} &amp; \sqrt{2} T_{26} \
&amp; \sqrt{2} T_{34} &amp; \sqrt{2} T_{35} &amp; \sqrt{2} T_{36} \
&amp; T_{44} &amp; T_{55} &amp; T_{66} \
&amp; \sqrt{2} T_{45} &amp; \sqrt{2} T_{56} &amp; \sqrt{2} T_{46} ig]^T
\end{matrix}\]</div>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="dtd-covariance">
<h3>dtd_covariance<a class="headerlink" href="#dtd-covariance" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.dtd_covariance">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">dtd_covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DTD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.dtd_covariance" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate covariance of a diffusion tensor distribution (DTD).</p>
<blockquote>
<div><dl class="simple">
<dt>DTD<span class="classifier">numpy.ndarray</span></dt><dd><p>Diffusion tensor distribution of shape (number of tensors, 3, 3) or
(number of tensors, 6, 1).</p>
</dd>
</dl>
<dl class="simple">
<dt>C<span class="classifier">numpy.ndarray</span></dt><dd><p>Covariance tensor of shape (6, 6).</p>
</dd>
</dl>
<p>The covariance tensor is calculated according to the following equation and
converted into a rank-2 tensor <a href="#id1649"><span class="problematic" id="id1104">[1]_</span></a>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbb{C} = \langle \mathbf{D} \otimes \mathbf{D} \]</div>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>angle -</dt><dd><p>langle mathbf{D}</p>
</dd>
</dl>
<p>angle otimes langle mathbf{D} 
angle</p>
<blockquote>
<div><aside class="footnote brackets" id="id1105" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Westin, Carl-Fredrik, et al. “Q-space trajectory imaging for
multidimensional diffusion MRI of the human brain.” Neuroimage 135
(2016): 345-362. <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2016.02.039">https://doi.org/10.1016/j.neuroimage.2016.02.039</a>.</p>
</aside>
</aside>
</div></blockquote>
</dd></dl>

</section>
<section id="qti-signal">
<h3>qti_signal<a class="headerlink" href="#qti-signal" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.qti_signal">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">qti_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.qti_signal" title="Permalink to this definition">#</a></dt>
<dd><p>Generate signals using the covariance tensor signal representation.</p>
<blockquote>
<div><dl class="simple">
<dt>gtab<span class="classifier">dipy.core.gradients.GradientTable</span></dt><dd><p>Gradient table with b-tensors.</p>
</dd>
<dt>D<span class="classifier">numpy.ndarray</span></dt><dd><p>Diffusion tensors of shape (…, 3, 3), (…, 6, 1), or (…, 6).</p>
</dd>
<dt>C<span class="classifier">numpy.ndarray</span></dt><dd><p>Covariance tensors of shape (…, 6, 6), (…, 21, 1), or (…, 21).</p>
</dd>
<dt>S0<span class="classifier">numpy.ndarray, optional</span></dt><dd><p>Signal magnitudes without diffusion-weighting. Must be a single number
or an array of same shape as D and C without the last two dimensions.</p>
</dd>
</dl>
<dl class="simple">
<dt>S<span class="classifier">numpy.ndarray</span></dt><dd><p>Simulated signals.</p>
</dd>
</dl>
<p>The signal is generated according to</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[S = S_0 \exp \left(- \mathbf{b} : \langle \mathbf{D} \]</div>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>angle</dt><dd><ul class="simple">
<li></li>
</ul>
</dd>
</dl>
<p>rac{1}{2}(mathbf{b} otimes mathbf{b}) : mathbb{C} 
ight)</p>
</dd></dl>

</section>
<section id="id1106">
<h3>design_matrix<a class="headerlink" href="#id1106" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.qti.design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.qti.</span></span><span class="sig-name descname"><span class="pre">design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">btens</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qti.design_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the design matrix from the b-tensors.</p>
<blockquote>
<div><dl class="simple">
<dt>btens<span class="classifier">numpy.ndarray</span></dt><dd><p>An array of b-tensors of shape (number of acquisitions, 3, 3).</p>
</dd>
</dl>
<dl class="simple">
<dt>X<span class="classifier">numpy.ndarray</span></dt><dd><p>Design matrix.</p>
</dd>
</dl>
<p>The design matrix is generated according to</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[X = egin{pmatrix} 1 &amp; -\mathbf{b}_1^T &amp; \]</div>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>rac{1}{2}(mathbf{b}_1</dt><dd><p>otimesmathbf{b}_1)^T </p>
</dd>
</dl>
<p>dots &amp; 
dots &amp; 
dots 1 &amp;</p>
<blockquote>
<div><p>-mathbf{b}_n^T &amp;</p>
</div></blockquote>
<dl class="simple">
<dt>rac{1}{2}(mathbf{b}_notimesmathbf{b}_n)^T</dt><dd><p>end{pmatrix}</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="quick-squash">
<h3>quick_squash<a class="headerlink" href="#quick-squash" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.quick_squash.quick_squash">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.quick_squash.</span></span><span class="sig-name descname"><span class="pre">quick_squash</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.quick_squash.quick_squash" title="Permalink to this definition">#</a></dt>
<dd><p>Try and make a standard array from an object array</p>
<p>This function takes an object array and attempts to convert it to a more
useful dtype. If array can be converted to a better dtype, Nones are
replaced by <cite>fill</cite>. To make the behaviour of this function more clear, here
are the most common cases:</p>
<ol class="arabic simple">
<li><p><cite>obj_arr</cite> is an array of scalars of type <cite>T</cite>. Returns an array like
<cite>obj_arr.astype(T)</cite></p></li>
<li><p><cite>obj_arr</cite> is an array of arrays. All items in <cite>obj_arr</cite> have the same
shape <code class="docutils literal notranslate"><span class="pre">S</span></code>. Returns an array with shape <code class="docutils literal notranslate"><span class="pre">obj_arr.shape</span> <span class="pre">+</span> <span class="pre">S</span></code></p></li>
<li><p><cite>obj_arr</cite> is an array of arrays of different shapes. Returns <cite>obj_arr</cite>.</p></li>
<li><p>Items in <cite>obj_arr</cite> are not ndarrays or scalars. Returns <cite>obj_arr</cite>.</p></li>
</ol>
<section id="id1107">
<h4>Parameters<a class="headerlink" href="#id1107" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>obj_arr<span class="classifier">array, dtype=object</span></dt><dd><p>The array to be converted.</p>
</dd>
<dt>mask<span class="classifier">array, dtype=bool, optional</span></dt><dd><p>mask is nonzero where <cite>obj_arr</cite> has Nones.</p>
</dd>
<dt>fill<span class="classifier">number, optional</span></dt><dd><p>Nones are replaced by <cite>fill</cite>.</p>
</dd>
</dl>
</section>
<section id="id1108">
<h4>Returns<a class="headerlink" href="#id1108" title="Permalink to this heading">#</a></h4>
<p>result : array</p>
</section>
<section id="id1109">
<h4>Examples<a class="headerlink" href="#id1109" title="Permalink to this heading">#</a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quick_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([2, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quick_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([0, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">quick_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="reduce">
<h3>reduce<a class="headerlink" href="#reduce" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.quick_squash.reduce">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.quick_squash.</span></span><span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">value</span></span></span><a class="headerlink" href="#dipy.reconst.quick_squash.reduce" title="Permalink to this definition">#</a></dt>
<dd><p>Apply a function of two arguments cumulatively to the items of a sequence,
from left to right, so as to reduce the sequence to a single value.
For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
of the sequence in the calculation, and serves as a default when the
sequence is empty.</p>
</dd></dl>

</section>
<section id="adj-to-countarrs">
<h3>adj_to_countarrs<a class="headerlink" href="#adj-to-countarrs" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.recspeed.adj_to_countarrs">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.recspeed.</span></span><span class="sig-name descname"><span class="pre">adj_to_countarrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adj_inds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.recspeed.adj_to_countarrs" title="Permalink to this definition">#</a></dt>
<dd><p>Convert adjacency sequence to counts and flattened indices</p>
<p>We use this to provide expected input to <code class="docutils literal notranslate"><span class="pre">argmax_from_countarrs</span></code></p>
<section id="id1110">
<h4>Parameters<a class="headerlink" href="#id1110" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>adj_indices<span class="classifier">sequence</span></dt><dd><p>length V sequence of sequences, where sequence <code class="docutils literal notranslate"><span class="pre">i</span></code> contains the
neighbors of a particular vertex.</p>
</dd>
</dl>
</section>
<section id="id1111">
<h4>Returns<a class="headerlink" href="#id1111" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>counts<span class="classifier">(V,) array</span></dt><dd><p>Number of neighbors for each vertex</p>
</dd>
<dt>adj_inds<span class="classifier">(n,) array</span></dt><dd><p>flat array containing <cite>adj_indices</cite> unrolled as a vector</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="argmax-from-adj">
<h3>argmax_from_adj<a class="headerlink" href="#argmax-from-adj" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.recspeed.argmax_from_adj">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.recspeed.</span></span><span class="sig-name descname"><span class="pre">argmax_from_adj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adj_inds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.recspeed.argmax_from_adj" title="Permalink to this definition">#</a></dt>
<dd><p>Indices of local maxima from <cite>vals</cite> given adjacent points</p>
<section id="id1112">
<h4>Parameters<a class="headerlink" href="#id1112" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>vals<span class="classifier">(N,) array, dtype np.float64</span></dt><dd><p>values at all vertices referred to in either of <cite>vertex_inds</cite> or
<cite>adj_inds</cite>’</p>
</dd>
<dt>vertex_inds<span class="classifier">(V,) array</span></dt><dd><p>indices into <cite>vals</cite> giving vertices that may be local maxima.</p>
</dd>
<dt>adj_inds<span class="classifier">sequence</span></dt><dd><p>For every vertex in <code class="docutils literal notranslate"><span class="pre">vertex_inds</span></code>, the indices (into <cite>vals</cite>) of
the neighboring points</p>
</dd>
</dl>
</section>
<section id="id1113">
<h4>Returns<a class="headerlink" href="#id1113" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>inds<span class="classifier">(M,) array</span></dt><dd><p>Indices into <cite>vals</cite> giving local maxima of vals, given topology
from <cite>adj_inds</cite>, and restrictions from <cite>vertex_inds</cite>.  Inds are
returned sorted by value at that index - i.e. smallest value (at
index) first.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="argmax-from-countarrs">
<h3>argmax_from_countarrs<a class="headerlink" href="#argmax-from-countarrs" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.recspeed.argmax_from_countarrs">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.recspeed.</span></span><span class="sig-name descname"><span class="pre">argmax_from_countarrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertinds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adj_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adj_inds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.recspeed.argmax_from_countarrs" title="Permalink to this definition">#</a></dt>
<dd><p>Indices of local maxima from <cite>vals</cite> from count, array neighbors</p>
<section id="id1114">
<h4>Parameters<a class="headerlink" href="#id1114" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>vals<span class="classifier">(N,) array, dtype float</span></dt><dd><p>values at all vertices referred to in either of <cite>vertex_inds</cite> or
<cite>adj_inds</cite>’</p>
</dd>
<dt>vertinds<span class="classifier">(V,) array, dtype uint32</span></dt><dd><p>indices into <cite>vals</cite> giving vertices that may be local maxima.</p>
</dd>
<dt>adj_counts<span class="classifier">(V,) array, dtype uint32</span></dt><dd><p>For every vertex <code class="docutils literal notranslate"><span class="pre">i</span></code> in <code class="docutils literal notranslate"><span class="pre">vertex_inds</span></code>, the number of
neighbors for vertex <code class="docutils literal notranslate"><span class="pre">i</span></code></p>
</dd>
<dt>adj_inds<span class="classifier">(P,) array, dtype uint32</span></dt><dd><p>Indices for neighbors for each point.  <code class="docutils literal notranslate"><span class="pre">P=sum(adj_counts)</span></code></p>
</dd>
</dl>
</section>
<section id="id1115">
<h4>Returns<a class="headerlink" href="#id1115" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>inds<span class="classifier">(M,) array</span></dt><dd><p>Indices into <cite>vals</cite> giving local maxima of vals, given topology
from <cite>adj_counts</cite> and <cite>adj_inds</cite>, and restrictions from
<cite>vertex_inds</cite>.  Inds are returned sorted by value at that index -
i.e. smallest value (at index) first.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="le-to-odf">
<h3>le_to_odf<a class="headerlink" href="#le-to-odf" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.recspeed.le_to_odf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.recspeed.</span></span><span class="sig-name descname"><span class="pre">le_to_odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LEs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odfn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radiusn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anglesn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.recspeed.le_to_odf" title="Permalink to this definition">#</a></dt>
<dd><p>odf for interpolated Laplacian normalized signal</p>
</dd></dl>

</section>
<section id="local-maxima">
<h3>local_maxima<a class="headerlink" href="#local-maxima" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.recspeed.local_maxima">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.recspeed.</span></span><span class="sig-name descname"><span class="pre">local_maxima</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">odf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.recspeed.local_maxima" title="Permalink to this definition">#</a></dt>
<dd><p>Local maxima of a function evaluated on a discrete set of points.</p>
<p>If a function is evaluated on some set of points where each pair of
neighboring points is an edge in edges, find the local maxima.</p>
<section id="id1116">
<h4>Parameters<a class="headerlink" href="#id1116" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>odf<span class="classifier">array, 1d, dtype=double</span></dt><dd><p>The function evaluated on a set of discrete points.</p>
</dd>
<dt>edges<span class="classifier">array (N, 2)</span></dt><dd><p>The set of neighbor relations between the points. Every edge, ie
<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>
</dd>
</dl>
</section>
<section id="id1117">
<h4>Returns<a class="headerlink" href="#id1117" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>peak_values<span class="classifier">ndarray</span></dt><dd><p>Value of odf at a maximum point. Peak values is sorted in descending
order.</p>
</dd>
<dt>peak_indices<span class="classifier">ndarray</span></dt><dd><p>Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so
<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>
</dd>
</dl>
</section>
<section id="id1118">
<h4>Notes<a class="headerlink" href="#id1118" title="Permalink to this heading">#</a></h4>
<p>A point is a local maximum if it is &gt; at least one neighbor and &gt;= all
neighbors. If no points meet the above criteria, 1 maximum is returned such
that <cite>odf[maximum] == max(odf)</cite>.</p>
</section>
<section id="id1119">
<h4>See Also<a class="headerlink" href="#id1119" title="Permalink to this heading">#</a></h4>
<p>dipy.core.sphere</p>
</section>
</dd></dl>

</section>
<section id="proc-reco-args">
<h3>proc_reco_args<a class="headerlink" href="#proc-reco-args" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.recspeed.proc_reco_args">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.recspeed.</span></span><span class="sig-name descname"><span class="pre">proc_reco_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertinds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.recspeed.proc_reco_args" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="remove-similar-vertices">
<h3>remove_similar_vertices<a class="headerlink" href="#remove-similar-vertices" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.recspeed.remove_similar_vertices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.recspeed.</span></span><span class="sig-name descname"><span class="pre">remove_similar_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_antipodal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.recspeed.remove_similar_vertices" title="Permalink to this definition">#</a></dt>
<dd><p>Remove vertices that are less than <cite>theta</cite> degrees from any other

Returns vertices that are at least theta degrees from any other vertex.
Vertex v and -v are considered the same so if v and -v are both in
<cite>vertices</cite> only one is kept. Also if v and w are both in vertices, w must
be separated by theta degrees from both v and -v to be unique. To disable
this, set <cite>remove_antipodal</cite> to False to keep both directions.

Parameters
———-
vertices : (N, 3) ndarray
    N unit vectors.
theta : float
    The minimum separation between vertices in degrees.
return_mapping : {False, True}, optional
    If True, return <cite>mapping</cite> as well as <cite>vertices</cite> and maybe <cite>indices</cite>
    (see below).
return_indices : {False, True}, optional
    If True, return <cite>indices</cite> as well as <cite>vertices</cite> and maybe <cite>mapping</cite>
    (see below).
remove_antipodal : {False, True}, optional
    If True, v and -v are considered equal, and only one will be kept.

Returns
——-
unique_vertices : (M, 3) ndarray
    Vertices sufficiently separated from one another.
mapping : (N,) ndarray
    For each element <code class="docutils literal notranslate"><span class="pre">vertices[i]</span></code> (<span class="math notranslate nohighlight">\(i \in 0..N-1\)</span>), the index <span class="math notranslate nohighlight">\(j\)</span> to a
    vertex in <cite>unique_vertices</cite> that is less than <cite>theta</cite> degrees from
    <code class="docutils literal notranslate"><span class="pre">vertices[i]</span></code>.  Only returned if <cite>return_mapping</cite> is True.
indices : (N,) ndarray
    <cite>indices</cite> gives the reverse of <cite>mapping</cite>.  For each element
    <code class="docutils literal notranslate"><span class="pre">unique_vertices[j]</span></code> (<span class="math notranslate nohighlight">\(j \in 0..M-1\)</span>), the index <span class="math notranslate nohighlight">\(i\)</span> to a vertex in
    <cite>vertices</cite> that is less than <cite>theta</cite> degrees from
    <code class="docutils literal notranslate"><span class="pre">unique_vertices[j]</span></code>.  If there is more than one element of
    <cite>vertices</cite> that is less than theta degrees from <cite>unique_vertices[j]</cite>,
    return the first (lowest index) matching value.  Only return if
    <cite>return_indices</cite> is True.</p>
</dd></dl>

</section>
<section id="search-descending">
<h3>search_descending<a class="headerlink" href="#search-descending" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.recspeed.search_descending">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.recspeed.</span></span><span class="sig-name descname"><span class="pre">search_descending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.recspeed.search_descending" title="Permalink to this definition">#</a></dt>
<dd><p><cite>i</cite> in descending array <cite>a</cite> so <cite>a[i] &lt; a[0] * relative_threshold</cite></p>
<p>Call <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">a[0]</span> <span class="pre">*</span> <span class="pre">relative_threshold</span></code>. Return value <cite>i</cite> will be the
smallest index in the descending array <cite>a</cite> such that <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;</span> <span class="pre">T</span></code>.
Equivalently, <cite>i</cite> will be the largest index such that <code class="docutils literal notranslate"><span class="pre">all(a[:i]</span> <span class="pre">&gt;=</span> <span class="pre">T)</span></code>.
If all values in <cite>a</cite> are &gt;= T, return the length of array <cite>a</cite>.</p>
<section id="id1120">
<h4>Parameters<a class="headerlink" href="#id1120" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>a<span class="classifier">ndarray, ndim=1, c-contiguous</span></dt><dd><p>Array to be searched.  We assume <cite>a</cite> is in descending order.</p>
</dd>
<dt>relative_threshold<span class="classifier">float</span></dt><dd><p>Applied threshold will be <code class="docutils literal notranslate"><span class="pre">T</span></code> with <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">a[0]</span> <span class="pre">*</span> <span class="pre">relative_threshold</span></code>.</p>
</dd>
</dl>
</section>
<section id="id1121">
<h4>Returns<a class="headerlink" href="#id1121" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>i<span class="classifier">np.intp</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">a[0]</span> <span class="pre">*</span> <span class="pre">relative_threshold</span></code> then <cite>i</cite> will be the largest index
such that <code class="docutils literal notranslate"><span class="pre">all(a[:i]</span> <span class="pre">&gt;=</span> <span class="pre">T)</span></code>.  If all values in <cite>a</cite> are &gt;= T then
<cite>i</cite> will be <cite>len(a)</cite>.</p>
</dd>
</dl>
</section>
<section id="id1122">
<h4>Examples<a class="headerlink" href="#id1122" title="Permalink to this heading">#</a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">9.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_descending</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
<span class="gp">... </span><span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_descending</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_descending</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_descending</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="sum-on-blocks-1d">
<h3>sum_on_blocks_1d<a class="headerlink" href="#sum-on-blocks-1d" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.recspeed.sum_on_blocks_1d">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.recspeed.</span></span><span class="sig-name descname"><span class="pre">sum_on_blocks_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.recspeed.sum_on_blocks_1d" title="Permalink to this definition">#</a></dt>
<dd><p>Summations on blocks of 1d array</p>
</dd></dl>

</section>
<section id="rumbasdmodel">
<h3><a class="reference internal" href="#dipy.reconst.rumba.RumbaSDModel" title="dipy.reconst.rumba.RumbaSDModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">RumbaSDModel</span></code></a><a class="headerlink" href="#rumbasdmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaSDModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">RumbaSDModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.0017,</span> <span class="pre">0.0002,</span> <span class="pre">0.0002])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0008</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">600</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recon_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'smf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_coils</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxelwise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaSDModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaSDModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.0017,</span> <span class="pre">0.0002,</span> <span class="pre">0.0002])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0008</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">600</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recon_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'smf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_coils</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxelwise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaSDModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Robust and Unbiased Model-BAsed Spherical Deconvolution (RUMBA-SD) <a href="#id1650"><span class="problematic" id="id1123">[1]_</span></a></p>
<p>Modification of the Richardson-Lucy algorithm accounting for Rician
and Noncentral Chi noise distributions, which more accurately
represent MRI noise. Computes a maximum likelihood estimation of the
fiber orientation density function (fODF) at each voxel. Includes
white matter compartments alongside optional GM and CSF compartments
to account for partial volume effects. This fit can be performed
voxelwise or globally. The global fit will proceed more quickly than
the voxelwise fit provided that the computer has adequate RAM (&gt;= 16 GB
should be sufficient for most datasets).</p>
<p>Kernel for deconvolution constructed using a priori knowledge of white
matter response function, as well as the mean diffusivity of GM and/or
CSF. RUMBA-SD is robust against impulse response imprecision, and thus
the default diffusivity values are often adequate <a href="#id1651"><span class="problematic" id="id1124">[2]_</span></a>.</p>
<section id="id1125">
<h4>Parameters<a class="headerlink" href="#id1125" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
wm_response : 1d ndarray or 2d ndarray or AxSymShResponse, optional</p>
<blockquote>
<div><p>Tensor eigenvalues as a (3,) ndarray, multishell eigenvalues as
a (len(unique_bvals_tolerance(gtab.bvals))-1, 3) ndarray in
order of smallest to largest b-value, or an AxSymShResponse.
Default: np.array([1.7e-3, 0.2e-3, 0.2e-3])</p>
</div></blockquote>
<dl class="simple">
<dt>gm_response<span class="classifier">float, optional</span></dt><dd><p>Mean diffusivity for GM compartment. If <cite>None</cite>, then grey
matter volume fraction is not computed. Default: 0.8e-3</p>
</dd>
<dt>csf_response<span class="classifier">float, optional</span></dt><dd><p>Mean diffusivity for CSF compartment. If <cite>None</cite>, then CSF
volume fraction is not computed. Default: 3.0e-3</p>
</dd>
<dt>n_iter<span class="classifier">int, optional</span></dt><dd><p>Number of iterations for fODF estimation. Must be a positive int.
Default: 600</p>
</dd>
<dt>recon_type<span class="classifier">{‘smf’, ‘sos’}, optional</span></dt><dd><p>MRI reconstruction method: spatial matched filter (SMF) or
sum-of-squares (SoS). SMF reconstruction generates Rician noise
while SoS reconstruction generates Noncentral Chi noise.
Default: ‘smf’</p>
</dd>
<dt>n_coils<span class="classifier">int, optional</span></dt><dd><p>Number of coils in MRI scanner – only relevant in SoS
reconstruction. Must be a positive int. Default: 1</p>
</dd>
<dt>R<span class="classifier">int, optional</span></dt><dd><p>Acceleration factor of the acquisition. For SIEMENS,
R = iPAT factor. For GE, R = ASSET factor. For PHILIPS,
R = SENSE factor. Typical values are 1 or 2. Must be a positive
int. Default: 1</p>
</dd>
<dt>voxelwise<span class="classifier">bool, optional</span></dt><dd><p>If true, performs a voxelwise fit. If false, performs a global fit
on the entire brain at once. The global fit requires a 4D brain
volume in <cite>fit</cite>. Default: True</p>
</dd>
<dt>use_tv<span class="classifier">bool, optional</span></dt><dd><p>If true, applies total variation regularization. This only takes
effect in a global fit (<cite>voxelwise</cite> is set to <cite>False</cite>). TV can only
be applied to 4D brain volumes with no singleton dimensions.
Default: False</p>
</dd>
<dt>sphere<span class="classifier">Sphere, optional</span></dt><dd><p>Sphere on which to construct fODF. If None, uses <cite>repulsion724</cite>.
Default: None</p>
</dd>
<dt>verbose<span class="classifier">bool, optional</span></dt><dd><p>If true, logs updates on estimated signal-to-noise ratio after each
iteration. This only takes effect in a global fit (<cite>voxelwise</cite> is
set to <cite>False</cite>). Default: False</p>
</dd>
</dl>
</section>
<section id="id1126">
<h4>References<a class="headerlink" href="#id1126" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1127" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Canales-Rodríguez, E. J., Daducci, A., Sotiropoulos, S. N.,
Caruyer, E., Aja-Fernández, S., Radua, J., Mendizabal, J. M. Y.,
Iturria-Medina, Y., Melie-García, L., Alemán-Gómez, Y.,
Thiran, J.-P., Sarró, S., Pomarol-Clotet, E., &amp; Salvador, R.
(2015). Spherical Deconvolution of Multichannel Diffusion MRI
Data with Non-Gaussian Noise Models and Spatial Regularization.
PLOS ONE, 10(10), e0138910.
<a class="reference external" href="https://doi.org/10.1371/journal.pone.0138910">https://doi.org/10.1371/journal.pone.0138910</a></p>
</aside>
<aside class="footnote brackets" id="id1128" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Dell’Acqua, F., Rizzo, G., Scifo, P., Clarke, R., Scotti, G., &amp;
Fazio, F. (2007). A Model-Based Deconvolution Approach to Solve
Fiber Crossing in Diffusion-Weighted MR Imaging. IEEE
Transactions on Bio-Medical Engineering, 54, 462–472.
<a class="reference external" href="https://doi.org/10.1109/TBME.2006.888830">https://doi.org/10.1109/TBME.2006.888830</a></p>
</aside>
</aside>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="rumbafit">
<h3><a class="reference internal" href="#dipy.reconst.rumba.RumbaFit" title="dipy.reconst.rumba.RumbaFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">RumbaFit</span></code></a><a class="headerlink" href="#rumbafit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">RumbaFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs fODF, GM/CSF volume fractions, and other derived results.</p>
<p>fODF and GM/CSF fractions are normalized to collectively sum to 1 for
each voxel.</p>
<section id="id1129">
<h4>Parameters<a class="headerlink" href="#id1129" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">RumbaSDModel</span></dt><dd><p>RumbaSDModel-SD model.</p>
</dd>
<dt>model_params<span class="classifier">ndarray ([x, y, z], M)</span></dt><dd><p>fODF and GM/CSF volume fractions for each voxel.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.combined_odf_iso">
<span class="sig-name descname"><span class="pre">combined_odf_iso</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.combined_odf_iso" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs fODF combined with isotropic volume fraction at discrete
vertices on model sphere.</p>
<p>Distributes isotropic compartments evenly along each fODF direction.
Sums to 1.</p>
<section id="id1130">
<h4>Returns<a class="headerlink" href="#id1130" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>combined<span class="classifier">ndarray ([x, y, z], M-2)</span></dt><dd><p>fODF combined with isotropic volume fraction.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.f_csf">
<span class="sig-name descname"><span class="pre">f_csf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.f_csf" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs CSF volume fraction for each voxel.</p>
<section id="id1131">
<h4>Returns<a class="headerlink" href="#id1131" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>f_csf<span class="classifier">ndarray ([x, y, z])</span></dt><dd><p>CSF volume fraction.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.f_gm">
<span class="sig-name descname"><span class="pre">f_gm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.f_gm" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs GM volume fraction for each voxel.</p>
<section id="id1132">
<h4>Returns<a class="headerlink" href="#id1132" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>f_gm<span class="classifier">ndarray ([x, y, z])</span></dt><dd><p>GM volume fraction.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.f_iso">
<span class="sig-name descname"><span class="pre">f_iso</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.f_iso" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs isotropic volume fraction for each voxel.</p>
<p>Equivalent to sum of GM and CSF volume fractions.</p>
<section id="id1133">
<h4>Returns<a class="headerlink" href="#id1133" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>f_iso<span class="classifier">ndarray ([x, y, z])</span></dt><dd><p>Isotropic volume fraction.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.f_wm">
<span class="sig-name descname"><span class="pre">f_wm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.f_wm" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs white matter volume fraction for each voxel.</p>
<p>Equivalent to sum of fODF.</p>
<section id="id1134">
<h4>Returns<a class="headerlink" href="#id1134" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>f_wm<span class="classifier">ndarray ([x, y, z])</span></dt><dd><p>White matter volume fraction.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>Constructs fODF at discrete vertices on model sphere for each voxel.</p>
<section id="id1135">
<h4>Parameters<a class="headerlink" href="#id1135" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere, optional</span></dt><dd><p>Sphere on which to construct fODF. If specified, must be the same
sphere used by the <cite>RumbaSDModel</cite> model. Default: None.</p>
</dd>
</dl>
</section>
<section id="id1136">
<h4>Returns<a class="headerlink" href="#id1136" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>odf<span class="classifier">ndarray ([x, y, z], M-2)</span></dt><dd><p>fODF computed at each vertex on model sphere.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.rumba.RumbaFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.RumbaFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Compute signal prediction on model gradient table given given fODF
and GM/CSF volume fractions for each voxel.</p>
<section id="id1137">
<h4>Parameters<a class="headerlink" href="#id1137" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable, optional</span></dt><dd><p>The gradients for which the signal will be predicted. Use the
model’s gradient table if <cite>None</cite>. Default: None</p>
</dd>
<dt>S0<span class="classifier">ndarray ([x, y, z]) or float, optional</span></dt><dd><p>The non diffusion-weighted signal value for each voxel. If a float,
the same value is used for each voxel. If <cite>None</cite>, 1 is used for
each voxel. Default: None</p>
</dd>
</dl>
</section>
<section id="id1138">
<h4>Returns<a class="headerlink" href="#id1138" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>pred_sig<span class="classifier">ndarray ([x, y, z], N)</span></dt><dd><p>The predicted signal.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="logger">
<h3>logger<a class="headerlink" href="#logger" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.rumba.logger">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">logger</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.logger" title="Permalink to this definition">#</a></dt>
<dd><p>Instances of the Logger class represent a single logging channel. A
“logging channel” indicates an area of an application. Exactly how an
“area” is defined is up to the application developer. Since an
application can have any number of areas, logging channels are identified
by a unique string. Application areas can be nested (e.g. an area
of “input processing” might include sub-areas “read CSV files”, “read
XLS files” and “read Gnumeric files”). To cater for this natural nesting,
channel names are organized into a namespace hierarchy where levels are
separated by periods, much like the Java or Python package namespace. So
in the instance given above, channel names might be “input” for the upper
level, and “input.csv”, “input.xls” and “input.gnu” for the sub-levels.
There is no arbitrary limit to the depth of nesting.</p>
</dd></dl>

</section>
<section id="rumba-deconv">
<h3>rumba_deconv<a class="headerlink" href="#rumba-deconv" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.rumba.rumba_deconv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">rumba_deconv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">600</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recon_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'smf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_coils</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.rumba_deconv" title="Permalink to this definition">#</a></dt>
<dd><p>Fit fODF and GM/CSF volume fractions for a voxel using RUMBA-SD <a href="#id1652"><span class="problematic" id="id1139">[1]_</span></a>.

Deconvolves the kernel from the diffusion-weighted signal by computing a
maximum likelihood estimation of the fODF. Minimizes the negative
log-likelihood of the data under Rician or Noncentral Chi noise
distributions by adapting the iterative technique developed in
Richardson-Lucy deconvolution.

Parameters
———-
data : 1d ndarray (N,)
    Signal values for a single voxel.
kernel : 2d ndarray (N, M)
    Deconvolution kernel mapping volume fractions of the M compartments to
    N-length signal. Last two columns should be for GM and CSF.
n_iter : int, optional
    Number of iterations for fODF estimation. Must be a positive int.
    Default: 600
recon_type : {‘smf’, ‘sos’}, optional
    MRI reconstruction method: spatial matched filter (SMF) or
    sum-of-squares (SoS). SMF reconstruction generates Rician noise while
    SoS reconstruction generates Noncentral Chi noise. Default: ‘smf’
n_coils : int, optional
    Number of coils in MRI scanner – only relevant in SoS reconstruction.
    Must be a positive int. Default: 1

Returns
——-
fit_vec : 1d ndarray (M,)
    Vector containing fODF and GM/CSF volume fractions. First M-2
    components are fODF while last two are GM and CSF respectively.

Notes
—–
The diffusion MRI signal measured at a given voxel is a sum of
contributions from each intra-voxel compartment, including parallel white
matter (WM) fiber populations in a given orientation as well as effects
from GM and CSF. The equation governing these  contributions is:

<span class="math notranslate nohighlight">\(S_i = S_0\left(\sum_{j=1}^{M}f_j\exp(-b_i\textbf{v}_i^T\textbf{D}_j
\textbf{v}_i) + f_{GM}\exp(-b_iD_{GM})+f_{CSF}\exp(-b_iD_{CSF})\right)\)</span>

Where <span class="math notranslate nohighlight">\(S_i\)</span> is the resultant signal along the diffusion-sensitizing
gradient unit vector <span class="math notranslate nohighlight">\(\textbf{v_i}; i = 1, ..., N\)</span> with a b-value of <span class="math notranslate nohighlight">\(b_i\)</span>.
<span class="math notranslate nohighlight">\(f_j; j = 1, ..., M\)</span> is the volume fraction of the <span class="math notranslate nohighlight">\(j^{th}\)</span> fiber
population with an anisotropic diffusion tensor <span class="math notranslate nohighlight">\(\textbf{D_j}\)</span>.

<span class="math notranslate nohighlight">\(f_{GM}\)</span> and <span class="math notranslate nohighlight">\(f_{CSF}\)</span> are the volume fractions and <span class="math notranslate nohighlight">\(D_{GM}\)</span> and <span class="math notranslate nohighlight">\(D_{CSF}\)</span>
are the mean diffusivities of GM and CSF respectively.

This equation is linear in <span class="math notranslate nohighlight">\(f_j, f_{GM}, f_{CSF}\)</span> and can be simplified to
a single matrix multiplication:

<span class="math notranslate nohighlight">\(\textbf{S} = \textbf{Hf}\)</span>

Where <span class="math notranslate nohighlight">\(\textbf{S}\)</span> is the signal vector at a certain voxel, <span class="math notranslate nohighlight">\(\textbf{H}\)</span> is
the deconvolution kernel, and <span class="math notranslate nohighlight">\(\textbf{f}\)</span> is the vector of volume
fractions for each compartment.

Modern MRI scanners produce noise following a Rician or Noncentral Chi
distribution, depending on their signal reconstruction technique <a href="#id1653"><span class="problematic" id="id1140">[2]_</span></a>.
Using this linear model, it can be shown that the likelihood of a signal
under a Noncentral Chi noise model is:

<span class="math notranslate nohighlight">\(P(\textbf{S}|\textbf{H}, \textbf{f}, \sigma^2, n) = \prod_{i=1}^{N}\left(
\frac{S_i}{\bar{S_i}}\right)^n\exp\left\{-\frac{1}{2\sigma^2}\left[
S_i^2 + \bar{S}_i^2\right]\right\}I_{n-1}\left(\frac{S_i\bar{S}_i}
{\sigma^2}\right)u(S_i)\)</span>

Where <span class="math notranslate nohighlight">\(S_i\)</span> and <span class="math notranslate nohighlight">\(\bar{S}_i = \textbf{Hf}\)</span> are the measured and expected
signals respectively, and <span class="math notranslate nohighlight">\(n\)</span> is the number of coils in the scanner, and
<span class="math notranslate nohighlight">\(I_{n-1}\)</span> is the modified Bessel function of first kind of order <span class="math notranslate nohighlight">\(n-1\)</span>.
This gives the likelihood under a Rician distribution when <span class="math notranslate nohighlight">\(n\)</span> is set to 1.

By taking the negative log of this with respect to <span class="math notranslate nohighlight">\(\textbf{f}\)</span> and setting
the derivative to 0, the <span class="math notranslate nohighlight">\(\textbf{f}\)</span> maximizing likelihood is found to be:

<span class="math notranslate nohighlight">\(\textbf{f} = \textbf{f} \circ \frac{\textbf{H}^T\left[\textbf{S}\circ
\frac{I_n(\textbf{S}\circ \textbf{Hf}/\sigma^2)} {I_{n-1}(\textbf{S}
\circ\textbf{Hf}\sigma^2)} \right ]} {\textbf{H}^T\textbf{Hf}}\)</span>

The solution can be found using an iterative scheme, just as in the
Richardson-Lucy algorithm:

<span class="math notranslate nohighlight">\(\textbf{f}^{k+1} = \textbf{f}^k \circ \frac{\textbf{H}^T\left[\textbf{S}
\circ\frac{I_n(\textbf{S}\circ\textbf{Hf}^k/\sigma^2)} {I_{n-1}(\textbf{S}
\circ\textbf{Hf}^k/\sigma^2)} \right ]} {\textbf{H}^T\textbf{Hf}^k}\)</span>

In order to apply this, a reasonable estimate of <span class="math notranslate nohighlight">\(\sigma^2\)</span> is required.
To find this, a separate iterative scheme is found using the derivative
of the negative log with respect to <span class="math notranslate nohighlight">\(\sigma^2\)</span>, and is run in parallel.
This is shown here:

<span class="math notranslate nohighlight">\(\alpha^{k+1} = \frac{1}{nN}\left\{ \frac{\textbf{S}^T\textbf{S} +
\textbf{f}^T\textbf{H}^T\textbf{Hf}}{2} - \textbf{1}^T_N\left[(\textbf{S}
\circ\textbf{Hf})\circ\frac{I_n(\textbf{S}\circ\textbf{Hf}/\alpha^k)}
{I_{n-1}(\textbf{S}\circ\textbf{Hf}/\alpha^k)} \right ]\right \}\)</span>

For more details, see <a href="#id1654"><span class="problematic" id="id1141">[1]_</span></a>.

References
———-
.. [1] Canales-Rodríguez, E. J., Daducci, A., Sotiropoulos, S. N., Caruyer,
       E., Aja-Fernández, S., Radua, J., Mendizabal, J. M. Y.,
       Iturria-Medina, Y., Melie-García, L., Alemán-Gómez, Y., Thiran,
       J.-P.,Sarró, S., Pomarol-Clotet, E., &amp; Salvador, R. (2015).
       Spherical Deconvolution of Multichannel Diffusion MRI Data with
       Non-Gaussian Noise Models and Spatial Regularization. PLOS ONE,
       10(10), e0138910. <a class="reference external" href="https://doi.org/10.1371/journal.pone.0138910">https://doi.org/10.1371/journal.pone.0138910</a>

.. [2] Constantinides, C. D., Atalar, E., &amp; McVeigh, E. R. (1997).
       Signal-to-Noise Measurements in Magnitude Images from NMR Phased
       Arrays. Magnetic Resonance in Medicine: Official Journal of the
       Society of Magnetic Resonance in Medicine / Society of Magnetic
       Resonance in Medicine, 38(5), 852–857.</p>
</dd></dl>

</section>
<section id="mbessel-ratio">
<h3>mbessel_ratio<a class="headerlink" href="#mbessel-ratio" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.rumba.mbessel_ratio">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">mbessel_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.mbessel_ratio" title="Permalink to this definition">#</a></dt>
<dd><p>Fast computation of modified Bessel function ratio (first kind).

Computes:

<span class="math notranslate nohighlight">\(I_{n}(x) / I_{n-1}(x)\)</span>

using Perron’s continued fraction equation where <span class="math notranslate nohighlight">\(I_n\)</span> is the modified
Bessel function of first kind, order <span class="math notranslate nohighlight">\(n\)</span> <a href="#id1655"><span class="problematic" id="id1142">[1]_</span></a>.

Parameters
———-
n : int
    Order of Bessel function in numerator (denominator is of order n-1).
    Must be a positive int.
x : float or ndarray
    Value or array of values with which to compute ratio.

Returns
——-
y : float or ndarray
    Result of ratio computation.

References
———-
.. [1] W. Gautschi and J. Slavik, “On the computation of modified Bessel
       function ratios,” Math. Comp., vol. 32, no. 143, pp. 865–875, 1978,
       doi: 10.1090/S0025-5718-1978-0470267-9</p>
</dd></dl>

</section>
<section id="generate-kernel">
<h3>generate_kernel<a class="headerlink" href="#generate-kernel" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.rumba.generate_kernel">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">generate_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wm_response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gm_response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csf_response</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.generate_kernel" title="Permalink to this definition">#</a></dt>
<dd><p>Generate deconvolution kernel</p>
<p>Compute kernel mapping orientation densities of white matter fiber
populations (along each vertex of the sphere) and isotropic volume
fractions to a diffusion weighted signal.</p>
<section id="id1143">
<h4>Parameters<a class="headerlink" href="#id1143" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable
sphere : Sphere</p>
<blockquote>
<div><p>Sphere with which to sample discrete fiber orientations in order to
construct kernel</p>
</div></blockquote>
<dl class="simple">
<dt>wm_response<span class="classifier">1d ndarray or 2d ndarray or AxSymShResponse, optional</span></dt><dd><p>Tensor eigenvalues as a (3,) ndarray, multishell eigenvalues as
a (len(unique_bvals_tolerance(gtab.bvals))-1, 3) ndarray in
order of smallest to largest b-value, or an AxSymShResponse.</p>
</dd>
<dt>gm_response<span class="classifier">float, optional</span></dt><dd><p>Mean diffusivity for GM compartment. If <cite>None</cite>, then grey
matter compartment set to all zeros.</p>
</dd>
<dt>csf_response<span class="classifier">float, optional</span></dt><dd><p>Mean diffusivity for CSF compartment. If <cite>None</cite>, then CSF
compartment set to all zeros.</p>
</dd>
</dl>
</section>
<section id="id1144">
<h4>Returns<a class="headerlink" href="#id1144" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>kernel<span class="classifier">2d ndarray (N, M)</span></dt><dd><p>Computed kernel; can be multiplied with a vector consisting of volume
fractions for each of M-2 fiber populations as well as GM and CSF
fractions to produce a diffusion weighted signal.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="rumba-deconv-global">
<h3>rumba_deconv_global<a class="headerlink" href="#rumba-deconv-global" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.rumba.rumba_deconv_global">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.rumba.</span></span><span class="sig-name descname"><span class="pre">rumba_deconv_global</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">600</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recon_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'smf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_coils</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.rumba.rumba_deconv_global" title="Permalink to this definition">#</a></dt>
<dd><p>Fit fODF for all voxels simultaneously using RUMBA-SD.

Deconvolves the kernel from the diffusion-weighted signal at each voxel by
computing a maximum likelihood estimation of the fODF <a href="#id1656"><span class="problematic" id="id1145">[1]_</span></a>. Global fitting
also permits the use of total variation regularization (RUMBA-SD + TV). The
spatial dependence introduced by TV promotes smoother solutions (i.e.
prevents oscillations), while still allowing for sharp discontinuities
<a href="#id1657"><span class="problematic" id="id1146">[2]_</span></a>. This promotes smoothness and continuity along individual tracts while
preventing smoothing of adjacent tracts.

Generally, global_fit will proceed more quickly than the voxelwise fit
provided that the computer has adequate RAM (&gt;= 16 GB should be more than
sufficient).

Parameters
———-
data : 4d ndarray (x, y, z, N)
    Signal values for entire brain. None of the volume dimensions x, y, z
    can be 1 if TV regularization is required.
kernel : 2d ndarray (N, M)
    Deconvolution kernel mapping volume fractions of the M compartments to
    N-length signal. Last two columns should be for GM and CSF.
mask : 3d ndarray(x, y, z)
    Binary mask specifying voxels of interest with 1; fODF will only be
    fit at these voxels (0 elsewhere).
n_iter : int, optional
    Number of iterations for fODF estimation. Must be a positive int.
    Default: 600
recon_type : {‘smf’, ‘sos’}, optional
    MRI reconstruction method: spatial matched filter (SMF) or
    sum-of-squares (SoS). SMF reconstruction generates Rician noise while
    SoS reconstruction generates Noncentral Chi noise. Default: ‘smf’
n_coils : int, optional
    Number of coils in MRI scanner – only relevant in SoS reconstruction.
    Must be a positive int. Default: 1
use_tv : bool, optional
    If true, applies total variation regularization. This requires a brain
    volume with no singleton dimensions. Default: True
verbose : bool, optional
    If true, logs updates on estimated signal-to-noise ratio after each
    iteration. Default: False

Returns
——-
fit_array : 4d ndarray (x, y, z, M)
    fODF and GM/CSF volume fractions computed for each voxel. First M-2
    components are fODF, while last two are GM and CSf respectively.

Notes
—–
TV modifies our cost function as follows:

<span class="math notranslate nohighlight">\(J(\textbf{f}) = -\log{P(\textbf{S}|\textbf{H}, \textbf{f}, \sigma^2, n)})+
\alpha_{TV}TV(\textbf{f})\)</span>

where the first term is the negative log likelihood described in the notes
of <cite>rumba_deconv</cite>, and the second term is the TV energy, or the sum of
gradient absolute values for the fODF across the entire brain. This results
in a new multiplicative factor in the iterative scheme, now becoming:

<span class="math notranslate nohighlight">\(\textbf{f}^{k+1} = \textbf{f}^k \circ \frac{\textbf{H}^T\left[\textbf{S}
\circ\frac{I_n(\textbf{S}\circ\textbf{Hf}^k/\sigma^2)} {I_{n-1}(\textbf{S}
\circ\textbf{Hf}^k/\sigma^2)} \right ]} {\textbf{H}^T\textbf{Hf}^k}\circ
\textbf{R}^k\)</span>

where <span class="math notranslate nohighlight">\(\textbf{R}^k\)</span> is computed voxelwise by:

<span class="math notranslate nohighlight">\((\textbf{R}^k)_j = \frac{1}{1 - \alpha_{TV}div\left(\frac{\triangledown[
\textbf{f}^k_{3D}]_j}{\lvert\triangledown[\textbf{f}^k_{3D}]_j \rvert}
\right)\biggr\rvert_{x, y, z}}\)</span>

Here, <span class="math notranslate nohighlight">\(\triangledown\)</span> is the symbol for the 3D gradient at any voxel.

The regularization strength, <span class="math notranslate nohighlight">\(\alpha_{TV}\)</span> is updated after each iteration
by the discrepancy principle – specifically, it is selected to match the
estimated variance after each iteration <a href="#id1658"><span class="problematic" id="id1147">[3]_</span></a>.

References
———-
.. [1] Canales-Rodríguez, E. J., Daducci, A., Sotiropoulos, S. N., Caruyer,
       E., Aja-Fernández, S., Radua, J., Mendizabal, J. M. Y.,
       Iturria-Medina, Y., Melie-García, L., Alemán-Gómez, Y., Thiran,
       J.-P., Sarró, S., Pomarol-Clotet, E., &amp; Salvador, R. (2015).
       Spherical Deconvolution of Multichannel Diffusion MRI Data with
       Non-Gaussian Noise Models and Spatial Regularization. PLOS ONE,
       10(10), e0138910. <a class="reference external" href="https://doi.org/10.1371/journal.pone.0138910">https://doi.org/10.1371/journal.pone.0138910</a>

.. [2] Rudin, L. I., Osher, S., &amp; Fatemi, E. (1992). Nonlinear total
       variation based noise removal algorithms. Physica D: Nonlinear
       Phenomena, 60(1), 259–268.
       <a class="reference external" href="https://doi.org/10.1016/0167-2789(92)90242-F">https://doi.org/10.1016/0167-2789(92)90242-F</a>

.. [3] Chambolle A. An algorithm for total variation minimization and
       applications. Journal of Mathematical Imaging and Vision. 2004;
       20:89–97.</p>
</dd></dl>

</section>
<section id="isotropicmodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a><a class="headerlink" href="#isotropicmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">IsotropicModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></p>
<p>A base-class for the representation of isotropic signals.</p>
<p>The default behavior, suitable for single b-value data is to calculate the
mean in each voxel as an estimate of the signal that does not depend on
direction.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize an IsotropicModel.</p>
<section id="id1148">
<h4>Parameters<a class="headerlink" href="#id1148" title="Permalink to this heading">#</a></h4>
<p>gtab : a GradientTable class instance</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit an IsotropicModel.</p>
<p>This boils down to finding the mean diffusion-weighted signal in each
voxel</p>
<section id="id1149">
<h4>Parameters<a class="headerlink" href="#id1149" title="Permalink to this heading">#</a></h4>
<p>data : ndarray</p>
</section>
<section id="id1150">
<h4>Returns<a class="headerlink" href="#id1150" title="Permalink to this heading">#</a></h4>
<p>IsotropicFit class instance.</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="isotropicfit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a><a class="headerlink" href="#isotropicfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">IsotropicFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<p>A fit object for representing the isotropic signal as the mean of the
diffusion-weighted signal.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize an IsotropicFit object.</p>
<section id="id1151">
<h4>Parameters<a class="headerlink" href="#id1151" title="Permalink to this heading">#</a></h4>
<p>model : IsotropicModel class instance
params : ndarray</p>
<blockquote>
<div><p>The mean isotropic model parameters (the mean diffusion-weighted
signal in each voxel).</p>
</div></blockquote>
<dl class="simple">
<dt>n_vox<span class="classifier">int</span></dt><dd><p>The number of voxels for which the fit was done.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.IsotropicFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict the isotropic signal.</p>
<p>Based on a gradient table. In this case, the (naive!) prediction will
be the mean of the diffusion-weighted signal in the voxels.</p>
<section id="id1152">
<h4>Parameters<a class="headerlink" href="#id1152" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">a GradientTable class instance (optional)</span></dt><dd><p>Defaults to use the gtab from the IsotropicModel from which this
fit was derived.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="exponentialisotropicmodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="dipy.reconst.sfm.ExponentialIsotropicModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a><a class="headerlink" href="#exponentialisotropicmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">ExponentialIsotropicModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a></p>
<p>Representing the isotropic signal as a fit to an exponential decay function
with b-values</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize an IsotropicModel.</p>
<section id="id1153">
<h4>Parameters<a class="headerlink" href="#id1153" title="Permalink to this heading">#</a></h4>
<p>gtab : a GradientTable class instance</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel.fit" title="Permalink to this definition">#</a></dt>
<dd><section id="id1154">
<h4>Parameters<a class="headerlink" href="#id1154" title="Permalink to this heading">#</a></h4>
<p>data : ndarray</p>
<dl class="simple">
<dt>mask<span class="classifier">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed. Has the shape <cite>data.shape[:-1]</cite>. Default: None,
which implies that all points should be analyzed.</p>
</dd>
</dl>
</section>
<section id="id1155">
<h4>Returns<a class="headerlink" href="#id1155" title="Permalink to this heading">#</a></h4>
<p>ExponentialIsotropicFit class instance.</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="exponentialisotropicfit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="dipy.reconst.sfm.ExponentialIsotropicFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a><a class="headerlink" href="#exponentialisotropicfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">ExponentialIsotropicFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a></p>
<p>A fit to the ExponentialIsotropicModel object, based on data.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize an IsotropicFit object.</p>
<section id="id1156">
<h4>Parameters<a class="headerlink" href="#id1156" title="Permalink to this heading">#</a></h4>
<p>model : IsotropicModel class instance
params : ndarray</p>
<blockquote>
<div><p>The mean isotropic model parameters (the mean diffusion-weighted
signal in each voxel).</p>
</div></blockquote>
<dl class="simple">
<dt>n_vox<span class="classifier">int</span></dt><dd><p>The number of voxels for which the fit was done.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.ExponentialIsotropicFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict the isotropic signal, based on a gradient table. In this case,
the prediction will be for an exponential decay with the mean
diffusivity derived from the data that was fit.</p>
<section id="id1157">
<h4>Parameters<a class="headerlink" href="#id1157" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">a GradientTable class instance (optional)</span></dt><dd><p>Defaults to use the gtab from the IsotropicModel from which this
fit was derived.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="sparsefasciclemodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel" title="dipy.reconst.sfm.SparseFascicleModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a><a class="headerlink" href="#sparsefasciclemodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">SparseFascicleModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0015,</span> <span class="pre">0.0005,</span> <span class="pre">0.0005)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ElasticNet'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0015,</span> <span class="pre">0.0005,</span> <span class="pre">0.0005)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ElasticNet'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a Sparse Fascicle Model</p>
<section id="id1158">
<h4>Parameters<a class="headerlink" href="#id1158" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable class instance</p>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere class instance, optional</span></dt><dd><p>A sphere on which coefficients will be estimated. Default:
symmetric sphere with 362 points (from <a class="reference internal" href="dipy.data.html#module-dipy.data" title="dipy.data"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dipy.data</span></code></a>).</p>
</dd>
<dt>response<span class="classifier">(3,) array-like, optional</span></dt><dd><p>The eigenvalues of a canonical tensor to be used as the response
function of single-fascicle signals.
Default:[0.0015, 0.0005, 0.0005]</p>
</dd>
<dt>solver<span class="classifier">string, or initialized linear model object.</span></dt><dd><p>This will determine the algorithm used to solve the set of linear
equations underlying this model. If it is a string it needs to be
one of the following: {‘ElasticNet’, ‘NNLS’}. Otherwise, it can be
an object that inherits from <cite>dipy.optimize.SKLearnLinearSolver</cite>
or an object with a similar interface from Scikit Learn:
<cite>sklearn.linear_model.ElasticNet</cite>, <cite>sklearn.linear_model.Lasso</cite> or
<cite>sklearn.linear_model.Ridge</cite> and other objects that inherit from
<cite>sklearn.base.RegressorMixin</cite>.
Default: ‘ElasticNet’.</p>
</dd>
<dt>l1_ratio<span class="classifier">float, optional</span></dt><dd><p>Sets the balance between L1 and L2 regularization in ElasticNet
<a class="reference internal" href="#zou2005" id="id1159"><span>[Zou2005]</span></a>. Default: 0.5</p>
</dd>
<dt>alpha<span class="classifier">float, optional</span></dt><dd><p>Sets the balance between least-squares error and L1/L2
regularization in ElasticNet <a class="reference internal" href="#zou2005" id="id1160"><span>[Zou2005]</span></a>. Default: 0.001</p>
</dd>
<dt>isotropic<span class="classifier">IsotropicModel class instance</span></dt><dd><p>This is a class that implements the function that calculates the
value of the isotropic signal. This is a value of the signal that
is independent of direction, and therefore removed from both sides
of the SFM equation. The default is an instance of IsotropicModel,
but other functions can be inherited from IsotropicModel to
implement other fits to the aspects of the data that depend on
b-value, but not on direction.</p>
</dd>
</dl>
</section>
<section id="id1161">
<h4>Notes<a class="headerlink" href="#id1161" title="Permalink to this heading">#</a></h4>
<p>This is an implementation of the SFM, described in <a class="reference internal" href="#id1178" id="id1162"><span>[Rokem2015]</span></a>.</p>
<div role="list" class="citation-list">
<div class="citation" id="id1163" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Rokem2014<span class="fn-bracket">]</span></span>
<p>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick
N. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell
(2014). Evaluating the accuracy of diffusion MRI models in white
matter. PLoS ONE 10(4): e0123272. doi:10.1371/journal.pone.0123272</p>
</div>
<div class="citation" id="zou2005" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Zou2005<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1159">1</a>,<a role="doc-backlink" href="#id1160">2</a>)</span>
<p>Zou H, Hastie T (2005). Regularization and variable
selection via the elastic net. J R Stat Soc B:301-320</p>
</div>
</div>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleModel.design_matrix">
<span class="sig-name descname"><span class="pre">design_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.design_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>The design matrix for a SFM.</p>
<section id="id1164">
<h4>Returns<a class="headerlink" href="#id1164" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>The design matrix, where each column is a rotated version of the
response function.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel_backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'multiprocessing'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit the SparseFascicleModel object to data.</p>
<section id="id1165">
<h4>Parameters<a class="headerlink" href="#id1165" title="Permalink to this heading">#</a></h4>
<dl>
<dt>data<span class="classifier">array</span></dt><dd><p>The measured signal.</p>
</dd>
<dt>mask<span class="classifier">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that
should be analyzed. Has the shape <cite>data.shape[:-1]</cite>. Default: None,
which implies that all points should be analyzed.</p>
</dd>
<dt>num_processes<span class="classifier">int, optional</span></dt><dd><p>Split the <cite>fit</cite> calculation to a pool of children processes using
joblib. This only applies to 4D <cite>data</cite> arrays. Default is 1,
which does not require joblib and will run <cite>fit</cite> serially.
If &lt; 0 the maximal number of cores minus <code class="docutils literal notranslate"><span class="pre">num_processes</span> <span class="pre">+</span> <span class="pre">1</span></code>
is used (enter -1 to use as many cores as possible).
0 raises an error.</p>
</dd>
<dt>parallel_backend: str, ParallelBackendBase instance or None</dt><dd><p>Specify the parallelization backend implementation.
Supported backends are:
- “loky” used by default, can induce some</p>
<blockquote>
<div><p>communication and memory overhead when exchanging input and
output data with the worker Python processes.</p>
</div></blockquote>
<ul class="simple">
<li><p>“multiprocessing” previous process-based backend based on
<cite>multiprocessing.Pool</cite>. Less robust than <cite>loky</cite>.</p></li>
<li><p>“threading” is a very low-overhead backend but it suffers
from the Python Global Interpreter Lock if the called function
relies a lot on Python objects. “threading” is mostly useful
when the execution bottleneck is a compiled extension that
explicitly releases the GIL (for instance a Cython loop wrapped
in a “with nogil” block or an expensive call to a library such
as NumPy).</p></li>
</ul>
<p>Default: ‘multiprocessing’.</p>
</dd>
</dl>
</section>
<section id="id1166">
<h4>Returns<a class="headerlink" href="#id1166" title="Permalink to this heading">#</a></h4>
<p>SparseFascicleFit object</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="sparsefasciclefit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit" title="dipy.reconst.sfm.SparseFascicleFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a><a class="headerlink" href="#sparsefasciclefit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">SparseFascicleFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iso</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iso</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a SparseFascicleFit class instance</p>
<section id="id1167">
<h4>Parameters<a class="headerlink" href="#id1167" title="Permalink to this heading">#</a></h4>
<p>model : a SparseFascicleModel object.</p>
<dl class="simple">
<dt>beta<span class="classifier">ndarray</span></dt><dd><p>The parameters of fit to data.</p>
</dd>
<dt>S0<span class="classifier">ndarray</span></dt><dd><p>The mean non-diffusion-weighted signal.</p>
</dd>
<dt>iso<span class="classifier">IsotropicFit class instance</span></dt><dd><p>A representation of the isotropic signal, together with parameters
of the isotropic signal in each voxel, that is capable of
deriving/predicting an isotropic signal, based on a gradient-table.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>The orientation distribution function of the SFM</p>
<section id="id1168">
<h4>Parameters<a class="headerlink" href="#id1168" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere</span></dt><dd><p>The points in which the ODF is evaluated</p>
</dd>
</dl>
</section>
<section id="id1169">
<h4>Returns<a class="headerlink" href="#id1169" title="Permalink to this heading">#</a></h4>
<p>odf :  ndarray of shape (x, y, z, sphere.vertices.shape[0])</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.sfm.SparseFascicleFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict the signal based on the SFM parameters</p>
<section id="id1170">
<h4>Parameters<a class="headerlink" href="#id1170" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable, optional</span></dt><dd><p>The bvecs/bvals to predict the signal on. Default: the gtab from
the model object.</p>
</dd>
<dt>response<span class="classifier">list of 3 elements, optional</span></dt><dd><p>The eigenvalues of a tensor which will serve as a kernel
function. Default: the response of the model object. Default to use
<cite>model.response</cite>.</p>
</dd>
<dt>S0<span class="classifier">float or array, optional</span></dt><dd><p>The non-diffusion-weighted signal. Default: use the S0 of the data</p>
</dd>
</dl>
</section>
<section id="id1171">
<h4>Returns<a class="headerlink" href="#id1171" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>pred_sig<span class="classifier">ndarray</span></dt><dd><p>The signal predicted in each voxel/direction</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="sfm-design-matrix">
<h3>sfm_design_matrix<a class="headerlink" href="#sfm-design-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.sfm.sfm_design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.sfm.</span></span><span class="sig-name descname"><span class="pre">sfm_design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'signal'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.sfm_design_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Construct the SFM design matrix</p>
<section id="id1172">
<h4>Parameters<a class="headerlink" href="#id1172" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable or Sphere</span></dt><dd><p>Sets the rows of the matrix, if the mode is ‘signal’, this should be a
GradientTable. If mode is ‘odf’ this should be a Sphere.</p>
</dd>
<dt>sphere<span class="classifier">Sphere</span></dt><dd><p>Sets the columns of the matrix</p>
</dd>
<dt>response<span class="classifier">list of 3 elements</span></dt><dd><p>The eigenvalues of a tensor which will serve as a kernel
function.</p>
</dd>
<dt>mode<span class="classifier">str {‘signal’ | ‘odf’}, optional</span></dt><dd><p>Choose the (default) ‘signal’ for a design matrix containing predicted
signal in the measurements defined by the gradient table for putative
fascicles oriented along the vertices of the sphere. Otherwise, choose
‘odf’ for an odf convolution matrix, with values of the odf calculated
from a tensor with the provided response eigenvalues, evaluated at the
b-vectors in the gradient table, for the tensors with principal
diffusion directions along the vertices of the sphere.</p>
</dd>
</dl>
</section>
<section id="id1173">
<h4>Returns<a class="headerlink" href="#id1173" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>mat<span class="classifier">ndarray</span></dt><dd><p>A design matrix that can be used for one of the following operations:
when the ‘signal’ mode is used, each column contains the putative
signal in each of the bvectors of the <cite>gtab</cite> if a fascicle is oriented
in the direction encoded by the sphere vertex corresponding to this
column. This is used for deconvolution with a measured DWI signal. If
the ‘odf’ mode is chosen, each column instead contains the values of
the tensor ODF for a tensor with a principal diffusion direction
corresponding to this vertex. This is used to generate odfs from the
fits of the SFM for the purpose of tracking.</p>
</dd>
</dl>
</section>
<section id="id1174">
<h4>Examples<a class="headerlink" href="#id1174" title="Permalink to this heading">#</a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dipy.data</span> <span class="k">as</span> <span class="nn">dpd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">gtab</span> <span class="o">=</span> <span class="n">dpd</span><span class="o">.</span><span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">dpd</span><span class="o">.</span><span class="n">get_sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.sfm</span> <span class="kn">import</span> <span class="n">sfm_design_matrix</span>
</pre></div>
</div>
<p>A canonical tensor approximating corpus-callosum voxels <a class="reference internal" href="#id1179" id="id1175"><span>[Rokem2014]</span></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor_matrix</span> <span class="o">=</span> <span class="n">sfm_design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="p">[</span><span class="mf">0.0015</span><span class="p">,</span> <span class="mf">0.0005</span><span class="p">,</span> <span class="mf">0.0005</span><span class="p">])</span>
</pre></div>
</div>
<p>A ‘stick’ function (<a class="reference internal" href="#behrens2007" id="id1176"><span>[Behrens2007]</span></a>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stick_matrix</span> <span class="o">=</span> <span class="n">sfm_design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="id1177">
<h4>Notes<a class="headerlink" href="#id1177" title="Permalink to this heading">#</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="id1178" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Rokem2015<span class="fn-bracket">]</span></span>
<p>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick
N. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell
(2015). Evaluating the accuracy of diffusion MRI models in white
matter. PLoS ONE 10(4): e0123272. doi:10.1371/journal.pone.0123272</p>
</div>
<div class="citation" id="id1179" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Rokem2014<span class="fn-bracket">]</span></span>
<p>Ariel Rokem, Kimberly L. Chan, Jason D. Yeatman, Franco
Pestilli,  Brian A. Wandell (2014). Evaluating the accuracy of diffusion
models at multiple b-values with cross-validation. ISMRM 2014.</p>
</div>
<div class="citation" id="behrens2007" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1176">Behrens2007</a><span class="fn-bracket">]</span></span>
<p>Behrens TEJ, Berg HJ, Jbabdi S, Rushworth MFS, Woolrich MW
(2007): Probabilistic diffusion tractography with multiple fibre
orientations: What can we gain? Neuroimage 34:144-55.</p>
</div>
</div>
</section>
</dd></dl>

</section>
<section id="sphharmmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a><a class="headerlink" href="#sphharmmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">SphHarmModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>To be subclassed by all models that return a SphHarmFit when fit.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<section id="id1180">
<h4>Parameters<a class="headerlink" href="#id1180" title="Permalink to this heading">#</a></h4>
<p>gtab : GradientTable class instance</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmModel.sampling_matrix">
<span class="sig-name descname"><span class="pre">sampling_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel.sampling_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>The matrix needed to sample ODFs from coefficients of the model.</p>
<section id="id1181">
<h4>Parameters<a class="headerlink" href="#id1181" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere</span></dt><dd><p>Points used to sample ODF.</p>
</dd>
</dl>
</section>
<section id="id1182">
<h4>Returns<a class="headerlink" href="#id1182" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sampling_matrix<span class="classifier">array</span></dt><dd><p>The size of the matrix will be (N, M) where N is the number of
vertices on sphere and M is the number of coefficients needed by
the model.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="qballbasemodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a><a class="headerlink" href="#qballbasemodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.QballBaseModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">QballBaseModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></p>
<p>To be subclassed by Qball type models.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.QballBaseModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<section id="id1183">
<h4>Parameters<a class="headerlink" href="#id1183" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable</span></dt><dd><p>Diffusion gradients used to acquire data</p>
</dd>
<dt>sh_order<span class="classifier">even int &gt;= 0</span></dt><dd><p>the spherical harmonic order of the model</p>
</dd>
<dt>smooth<span class="classifier">float between 0 and 1, optional</span></dt><dd><p>The regularization parameter of the model</p>
</dd>
<dt>min_signal<span class="classifier">float, &gt; 0, optional</span></dt><dd><p>During fitting, all signal values less than <cite>min_signal</cite> are
clipped to <cite>min_signal</cite>. This is done primarily to avoid values
less than or equal to zero when taking logs.</p>
</dd>
<dt>assume_normed<span class="classifier">bool, optional</span></dt><dd><p>If True, clipping and normalization of the data with respect to the
mean B0 signal are skipped during mode fitting. This is an advanced
feature and should be used with care.</p>
</dd>
</dl>
</section>
<section id="id1184">
<h4>See Also<a class="headerlink" href="#id1184" title="Permalink to this heading">#</a></h4>
<p>normalize_data</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.QballBaseModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fits the model to diffusion data and returns the model fit</p>
</dd></dl>

</dd></dl>

</section>
<section id="sphharmfit">
<h3><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a><a class="headerlink" href="#sphharmfit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">SphHarmFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shm_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a></p>
<p>Diffusion data fit to a spherical harmonic model</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shm_coef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.gfa">
<span class="sig-name descname"><span class="pre">gfa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.gfa" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>Samples the odf function on the points of a sphere</p>
<section id="id1185">
<h4>Parameters<a class="headerlink" href="#id1185" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere</span></dt><dd><p>The points on which to sample the odf.</p>
</dd>
</dl>
</section>
<section id="id1186">
<h4>Returns<a class="headerlink" href="#id1186" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>values<span class="classifier">ndarray</span></dt><dd><p>The value of the odf on each point of <cite>sphere</cite>.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict the diffusion signal from the model coefficients.</p>
<section id="id1187">
<h4>Parameters<a class="headerlink" href="#id1187" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">a GradientTable class instance</span></dt><dd><p>The directions and bvalues on which prediction is desired</p>
</dd>
<dt>S0<span class="classifier">float array</span></dt><dd><p>The mean non-diffusion-weighted signal in each voxel.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.shape" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.shm.SphHarmFit.shm_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shm_coeff</span></span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.shm_coeff" title="Permalink to this definition">#</a></dt>
<dd><p>The spherical harmonic coefficients of the odf</p>
<p>Make this a property for now, if there is a use case for modifying
the coefficients we can add a setter or expose the coefficients more
directly</p>
</dd></dl>

</dd></dl>

</section>
<section id="csaodfmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.CsaOdfModel" title="dipy.reconst.shm.CsaOdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a><a class="headerlink" href="#csaodfmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.CsaOdfModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">CsaOdfModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a></p>
<p>Implementation of Constant Solid Angle reconstruction method.</p>
<section id="id1188">
<h4>References<a class="headerlink" href="#id1188" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1189" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Aganj, I., et al. 2009. ODF Reconstruction in Q-Ball Imaging With
Solid Angle Consideration.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.CsaOdfModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<section id="id1190">
<h5>Parameters<a class="headerlink" href="#id1190" title="Permalink to this heading">#</a></h5>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable</span></dt><dd><p>Diffusion gradients used to acquire data</p>
</dd>
<dt>sh_order<span class="classifier">even int &gt;= 0</span></dt><dd><p>the spherical harmonic order of the model</p>
</dd>
<dt>smooth<span class="classifier">float between 0 and 1, optional</span></dt><dd><p>The regularization parameter of the model</p>
</dd>
<dt>min_signal<span class="classifier">float, &gt; 0, optional</span></dt><dd><p>During fitting, all signal values less than <cite>min_signal</cite> are
clipped to <cite>min_signal</cite>. This is done primarily to avoid values
less than or equal to zero when taking logs.</p>
</dd>
<dt>assume_normed<span class="classifier">bool, optional</span></dt><dd><p>If True, clipping and normalization of the data with respect to the
mean B0 signal are skipped during mode fitting. This is an advanced
feature and should be used with care.</p>
</dd>
</dl>
</section>
<section id="id1191">
<h5>See Also<a class="headerlink" href="#id1191" title="Permalink to this heading">#</a></h5>
<p>normalize_data</p>
</section>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="dipy.reconst.shm.CsaOdfModel.max">
<span class="sig-name descname"><span class="pre">max</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0.999</span></em><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.max" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="dipy.reconst.shm.CsaOdfModel.min">
<span class="sig-name descname"><span class="pre">min</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0.001</span></em><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.min" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
</dd></dl>

</section>
<section id="opdtmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.OpdtModel" title="dipy.reconst.shm.OpdtModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpdtModel</span></code></a><a class="headerlink" href="#opdtmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.OpdtModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">OpdtModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OpdtModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a></p>
<p>Implementation of Orientation Probability Density Transform
reconstruction method.</p>
<section id="id1192">
<h4>References<a class="headerlink" href="#id1192" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1193" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Tristan-Vega, A., et al. 2010. A new methodology for estimation of
fiber populations in white matter of the brain with Funk-Radon
transform.</p>
</aside>
<aside class="footnote brackets" id="id1194" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tristan-Vega, A., et al. 2009. Estimation of fiber orientation
probability density functions in high angular resolution diffusion
imaging.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.OpdtModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OpdtModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<section id="id1195">
<h5>Parameters<a class="headerlink" href="#id1195" title="Permalink to this heading">#</a></h5>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable</span></dt><dd><p>Diffusion gradients used to acquire data</p>
</dd>
<dt>sh_order<span class="classifier">even int &gt;= 0</span></dt><dd><p>the spherical harmonic order of the model</p>
</dd>
<dt>smooth<span class="classifier">float between 0 and 1, optional</span></dt><dd><p>The regularization parameter of the model</p>
</dd>
<dt>min_signal<span class="classifier">float, &gt; 0, optional</span></dt><dd><p>During fitting, all signal values less than <cite>min_signal</cite> are
clipped to <cite>min_signal</cite>. This is done primarily to avoid values
less than or equal to zero when taking logs.</p>
</dd>
<dt>assume_normed<span class="classifier">bool, optional</span></dt><dd><p>If True, clipping and normalization of the data with respect to the
mean B0 signal are skipped during mode fitting. This is an advanced
feature and should be used with care.</p>
</dd>
</dl>
</section>
<section id="id1196">
<h5>See Also<a class="headerlink" href="#id1196" title="Permalink to this heading">#</a></h5>
<p>normalize_data</p>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="qballmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.QballModel" title="dipy.reconst.shm.QballModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballModel</span></code></a><a class="headerlink" href="#qballmodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.QballModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">QballModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a></p>
<p>Implementation of regularized Qball reconstruction method.</p>
<section id="id1197">
<h4>References<a class="headerlink" href="#id1197" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1198" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Descoteaux, M., et al. 2007. Regularized, fast, and robust
analytical Q-ball imaging.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.QballModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.006</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<section id="id1199">
<h5>Parameters<a class="headerlink" href="#id1199" title="Permalink to this heading">#</a></h5>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable</span></dt><dd><p>Diffusion gradients used to acquire data</p>
</dd>
<dt>sh_order<span class="classifier">even int &gt;= 0</span></dt><dd><p>the spherical harmonic order of the model</p>
</dd>
<dt>smooth<span class="classifier">float between 0 and 1, optional</span></dt><dd><p>The regularization parameter of the model</p>
</dd>
<dt>min_signal<span class="classifier">float, &gt; 0, optional</span></dt><dd><p>During fitting, all signal values less than <cite>min_signal</cite> are
clipped to <cite>min_signal</cite>. This is done primarily to avoid values
less than or equal to zero when taking logs.</p>
</dd>
<dt>assume_normed<span class="classifier">bool, optional</span></dt><dd><p>If True, clipping and normalization of the data with respect to the
mean B0 signal are skipped during mode fitting. This is an advanced
feature and should be used with care.</p>
</dd>
</dl>
</section>
<section id="id1200">
<h5>See Also<a class="headerlink" href="#id1200" title="Permalink to this heading">#</a></h5>
<p>normalize_data</p>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="residualbootstrapwrapper">
<h3><a class="reference internal" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="dipy.reconst.shm.ResidualBootstrapWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a><a class="headerlink" href="#residualbootstrapwrapper" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shm.ResidualBootstrapWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">ResidualBootstrapWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where_dwi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Returns a residual bootstrap sample of the signal_object when indexed</p>
<p>Wraps a signal_object, this signal object can be an interpolator. When
indexed, the the wrapper indexes the signal_object to get the signal.
There wrapper than samples the residual bootstrap distribution of signal and
returns that sample.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shm.ResidualBootstrapWrapper.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where_dwi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.ResidualBootstrapWrapper.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Builds a ResidualBootstrapWapper</p>
<p>Given some linear model described by B, the design matrix, and a
signal_object, returns an object which can sample the residual
bootstrap distribution of the signal. We assume that the signals are
normalized so we clip the bootstrap samples to be between <cite>min_signal</cite>
and 1.</p>
<section id="id1201">
<h4>Parameters<a class="headerlink" href="#id1201" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>signal_object<span class="classifier">some object that can be indexed</span></dt><dd><p>This object should return diffusion weighted signals when indexed.</p>
</dd>
<dt>B<span class="classifier">ndarray, ndim=2</span></dt><dd><p>The design matrix of the spherical harmonics model used to fit the
data. This is the model that will be used to compute the residuals
and sample the residual bootstrap distribution</p>
</dd>
<dt>where_dwi :</dt><dd><p>indexing object to find diffusion weighted signals from signal</p>
</dd>
<dt>min_signal<span class="classifier">float</span></dt><dd><p>The lowest allowable signal.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="forward-sdeconv-mat">
<h3>forward_sdeconv_mat<a class="headerlink" href="#forward-sdeconv-mat" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.forward_sdeconv_mat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">forward_sdeconv_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_rh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.forward_sdeconv_mat" title="Permalink to this definition">#</a></dt>
<dd><p>Build forward spherical deconvolution matrix</p>
<section id="id1202">
<h4>Parameters<a class="headerlink" href="#id1202" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>r_rh<span class="classifier">ndarray</span></dt><dd><p>Rotational harmonics coefficients for the single fiber response
function. Each element <code class="docutils literal notranslate"><span class="pre">rh[i]</span></code> is associated with spherical harmonics
of degree <code class="docutils literal notranslate"><span class="pre">2*i</span></code>.</p>
</dd>
<dt>n<span class="classifier">ndarray</span></dt><dd><p>The order of spherical harmonic function associated with each row of
the deconvolution matrix. Only even orders are allowed</p>
</dd>
</dl>
</section>
<section id="id1203">
<h4>Returns<a class="headerlink" href="#id1203" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>R<span class="classifier">ndarray (N, N)</span></dt><dd><p>Deconvolution matrix with shape (N, N)</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="sh-to-rh">
<h3>sh_to_rh<a class="headerlink" href="#sh-to-rh" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sh_to_rh">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sh_to_rh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_sh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sh_to_rh" title="Permalink to this definition">#</a></dt>
<dd><p>Spherical harmonics (SH) to rotational harmonics (RH)</p>
<p>Calculate the rotational harmonic decomposition up to
harmonic order <code class="docutils literal notranslate"><span class="pre">n</span></code>, degree <code class="docutils literal notranslate"><span class="pre">m</span></code> for an axially and antipodally
symmetric function. Note that all <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">!=</span> <span class="pre">0</span></code> coefficients
will be ignored as axial symmetry is assumed. Hence, there
will be <code class="docutils literal notranslate"><span class="pre">(sh_order/2</span> <span class="pre">+</span> <span class="pre">1)</span></code> non-zero coefficients.</p>
<section id="id1204">
<h4>Parameters<a class="headerlink" href="#id1204" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>r_sh<span class="classifier">ndarray (N,)</span></dt><dd><p>ndarray of SH coefficients for the single fiber response function.
These coefficients must correspond to the real spherical harmonic
functions produced by <cite>shm.real_sh_descoteaux_from_index</cite>.</p>
</dd>
<dt>m<span class="classifier">ndarray (N,)</span></dt><dd><p>The degree of the spherical harmonic function associated with each
coefficient.</p>
</dd>
<dt>n<span class="classifier">ndarray (N,)</span></dt><dd><p>The order of the spherical harmonic function associated with each
coefficient.</p>
</dd>
</dl>
</section>
<section id="id1205">
<h4>Returns<a class="headerlink" href="#id1205" title="Permalink to this heading">#</a></h4>
<dl>
<dt>r_rh<span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt><dd><p>Rotational harmonics coefficients representing the input <cite>r_sh</cite></p>
</dd>
</dl>
</section>
<section id="id1206">
<h4>See Also<a class="headerlink" href="#id1206" title="Permalink to this heading">#</a></h4>
<p>shm.real_sh_descoteaux_from_index, shm.real_sh_descoteaux</p>
</section>
<section id="id1207">
<h4>References<a class="headerlink" href="#id1207" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1208" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of the
fibre orientation distribution in diffusion MRI: Non-negativity
constrained super-resolved spherical deconvolution</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="gen-dirac">
<h3>gen_dirac<a class="headerlink" href="#gen-dirac" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.gen_dirac">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">gen_dirac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.gen_dirac" title="Permalink to this definition">#</a></dt>
<dd><p>Generate Dirac delta function orientated in (theta, phi) on the sphere</p>
<p>The spherical harmonics (SH) representation of this Dirac is returned as
coefficients to spherical harmonic functions produced from <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>
basis.</p>
<section id="id1209">
<h4>Parameters<a class="headerlink" href="#id1209" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>m<span class="classifier">ndarray (N,)</span></dt><dd><p>The degree of the spherical harmonic function associated with each
coefficient.</p>
</dd>
<dt>n<span class="classifier">ndarray (N,)</span></dt><dd><p>The order of the spherical harmonic function associated with each
coefficient.</p>
</dd>
<dt>theta<span class="classifier">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>
</dd>
<dt>phi<span class="classifier">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt>legacy: bool, optional</dt><dd><p>If true, uses DIPY’s legacy descoteaux07 implementation (where <a href="#id1305"><span class="problematic" id="id1306">|m|</span></a>
is used for m &lt; 0). Else, implements the basis as defined in
Descoteaux et al. 2007 (without the absolute value).</p>
</dd>
</dl>
</section>
<section id="id1210">
<h4>See Also<a class="headerlink" href="#id1210" title="Permalink to this heading">#</a></h4>
<p>shm.real_sh_descoteaux_from_index, shm.real_sh_descoteaux</p>
</section>
<section id="id1211">
<h4>Returns<a class="headerlink" href="#id1211" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>dirac<span class="classifier">ndarray</span></dt><dd><p>SH coefficients representing the Dirac function. The shape of this is
<cite>(m + 2) * (m + 1) / 2</cite>.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="spherical-harmonics">
<h3>spherical_harmonics<a class="headerlink" href="#spherical-harmonics" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.spherical_harmonics">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">spherical_harmonics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_scipy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.spherical_harmonics" title="Permalink to this definition">#</a></dt>
<dd><p>Compute spherical harmonics.

This may take scalar or array arguments. The inputs will be broadcast
against each other.

Parameters
———-
m : int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>
    The degree of the harmonic.
n : int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code>
    The order of the harmonic.
theta : float [0, 2*pi]
    The azimuthal (longitudinal) coordinate.
phi : float [0, pi]
    The polar (colatitudinal) coordinate.
use_scipy : bool, optional
    If True, use scipy implementation.

Returns
——-
y_mn : complex float
    The harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.

Notes
—–
This is a faster implementation of scipy.special.sph_harm for
scipy version &lt; 0.15.0. For scipy 0.15 and onwards, we use the scipy
implementation of the function.

The usual definitions for <code class="docutils literal notranslate"><span class="pre">theta`</span> <span class="pre">and</span> <span class="pre">`phi</span></code> used in DIPY are interchanged
in the method definition to agree with the definitions in
scipy.special.sph_harm, where <cite>theta</cite> represents the azimuthal coordinate
and <cite>phi</cite> represents the polar coordinate.

Although scipy uses a naming convention where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the order and <code class="docutils literal notranslate"><span class="pre">n</span></code>
is the degree of the SH, the opposite of DIPY’s, their definition for both
parameters is the same as ours, with <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>.</p>
</dd></dl>

</section>
<section id="real-sph-harm">
<h3>real_sph_harm<a class="headerlink" href="#real-sph-harm" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sph_harm">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sph_harm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sph_harm" title="Permalink to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics.

dipy.reconst.shm.real_sph_harm is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux_from_index instead

* deprecated from version: 1.3
* Will raise &lt;class ‘dipy.utils.deprecator.ExpiredDeprecationError’&gt; as of version: 2.0

Where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:

    Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
    Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0

This may take scalar or array arguments. The inputs will be broadcast
against each other.

Parameters
———-
m : int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>
    The degree of the harmonic.
n : int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code>
    The order of the harmonic.
theta : float [0, pi]
    The polar (colatitudinal) coordinate.
phi : float [0, 2*pi]
    The azimuthal (longitudinal) coordinate.

Returns
——-
y_mn : real float
    The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.

See Also
——–
scipy.special.sph_harm</p>
</dd></dl>

</section>
<section id="real-sh-tournier-from-index">
<h3>real_sh_tournier_from_index<a class="headerlink" href="#real-sh-tournier-from-index" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sh_tournier_from_index">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sh_tournier_from_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sh_tournier_from_index" title="Permalink to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics as initially defined in Tournier
2007 <a href="#id1659"><span class="problematic" id="id1212">[1]_</span></a> then updated in MRtrix3 <a href="#id1660"><span class="problematic" id="id1213">[2]_</span></a>, where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span>
is defined to be:

    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                      if m = 0
    Imag(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)    if m &lt; 0

This may take scalar or array arguments. The inputs will be broadcast
against each other.

Parameters
———-
m : int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>
    The degree of the harmonic.
n : int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code>
    The order of the harmonic.
theta : float [0, pi]
    The polar (colatitudinal) coordinate.
phi : float [0, 2*pi]
    The azimuthal (longitudinal) coordinate.
legacy: bool, optional
    If true, uses MRtrix 0.2 SH basis definition, where the <code class="docutils literal notranslate"><span class="pre">sqrt(2)</span></code>
    factor is omitted. Else, uses the MRtrix 3 definition presented above.

Returns
——-
real_sh : real float
    The real harmonics <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.

References
———-
.. [1] Tournier J.D., Calamante F. and Connelly A. Robust determination
       of the fibre orientation distribution in diffusion MRI:
       Non-negativity constrained super-resolved spherical deconvolution.
       NeuroImage. 2007;35(4):1459-1472.
.. [2] Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,
       Pietsch M, et al. MRtrix3: A fast, flexible and open software
       framework for medical image processing and visualisation.
       NeuroImage. 2019 Nov 15;202:116-137.</p>
</dd></dl>

</section>
<section id="real-sh-descoteaux-from-index">
<h3>real_sh_descoteaux_from_index<a class="headerlink" href="#real-sh-descoteaux-from-index" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sh_descoteaux_from_index">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sh_descoteaux_from_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sh_descoteaux_from_index" title="Permalink to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics as in Descoteaux et al. 2007 <a href="#id1661"><span class="problematic" id="id1214">[1]_</span></a>,
where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:

    Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                      if m = 0
    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &lt; 0

This may take scalar or array arguments. The inputs will be broadcast
against each other.

Parameters
———-
m : int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>
    The degree of the harmonic.
n : int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code>
    The order of the harmonic.
theta : float [0, pi]
    The polar (colatitudinal) coordinate.
phi : float [0, 2*pi]
    The azimuthal (longitudinal) coordinate.
legacy: bool, optional
    If true, uses DIPY’s legacy descoteaux07 implementation (where <a href="#id1307"><span class="problematic" id="id1308">|m|</span></a>
    is used for m &lt; 0). Else, implements the basis as defined in
    Descoteaux et al. 2007 (without the absolute value).

Returns
——-
real_sh : real float
    The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.

References
———-
 .. [1] Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
       Regularized, Fast, and Robust Analytical Q-ball Imaging.
       Magn. Reson. Med. 2007;58:497-510.</p>
</dd></dl>

</section>
<section id="real-sh-tournier">
<h3>real_sh_tournier<a class="headerlink" href="#real-sh-tournier" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sh_tournier">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sh_tournier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sh_tournier" title="Permalink to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics as initially defined in Tournier
2007 <a href="#id1662"><span class="problematic" id="id1215">[1]_</span></a> then updated in MRtrix3 <a href="#id1663"><span class="problematic" id="id1216">[2]_</span></a>, where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span>
is defined to be:

    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                      if m = 0
    Imag(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)    if m &lt; 0

This may take scalar or array arguments. The inputs will be broadcast
against each other.

Parameters
———-
sh_order : int
    The maximum degree or the spherical harmonic basis.
theta : float [0, pi]
    The polar (colatitudinal) coordinate.
phi : float [0, 2*pi]
    The azimuthal (longitudinal) coordinate.
full_basis: bool, optional
    If true, returns a basis including odd order SH functions as well as
    even order SH functions. Else returns only even order SH functions.
legacy: bool, optional
    If true, uses MRtrix 0.2 SH basis definition, where the <code class="docutils literal notranslate"><span class="pre">sqrt(2)</span></code>
    factor is omitted. Else, uses MRtrix 3 definition presented above.

Returns
——-
real_sh : real float
    The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.
m : array
    The degree of the harmonics.
n : array
    The order of the harmonics.

References
———-
.. [1] Tournier J.D., Calamante F. and Connelly A. Robust determination
       of the fibre orientation distribution in diffusion MRI:
       Non-negativity constrained super-resolved spherical deconvolution.
       NeuroImage. 2007;35(4):1459-1472.
.. [2] Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,
       Pietsch M, et al. MRtrix3: A fast, flexible and open software
       framework for medical image processing and visualisation.
       NeuroImage. 2019 Nov 15;202:116-137.</p>
</dd></dl>

</section>
<section id="real-sh-descoteaux">
<h3>real_sh_descoteaux<a class="headerlink" href="#real-sh-descoteaux" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sh_descoteaux">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sh_descoteaux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sh_descoteaux" title="Permalink to this definition">#</a></dt>
<dd><p>Compute real spherical harmonics as in Descoteaux et al. 2007 <a href="#id1664"><span class="problematic" id="id1217">[1]_</span></a>,
where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:

    Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                      if m = 0
    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)      if m &lt; 0

This may take scalar or array arguments. The inputs will be broadcast
against each other.

Parameters
———-
sh_order : int
    The maximum degree or the spherical harmonic basis.
theta : float [0, pi]
    The polar (colatitudinal) coordinate.
phi : float [0, 2*pi]
    The azimuthal (longitudinal) coordinate.
full_basis: bool, optional
    If true, returns a basis including odd order SH functions as well as
    even order SH functions. Otherwise returns only even order SH
    functions.
legacy: bool, optional
    If true, uses DIPY’s legacy descoteaux07 implementation (where <a href="#id1309"><span class="problematic" id="id1310">|m|</span></a>
    for m &lt; 0). Else, implements the basis as defined in Descoteaux et al.
    2007.

Returns
——-
real_sh : real float
    The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>.
m : array
    The degree of the harmonics.
n : array
    The order of the harmonics.

References
———-
 .. [1] Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
       Regularized, Fast, and Robust Analytical Q-ball Imaging.
       Magn. Reson. Med. 2007;58:497-510.</p>
</dd></dl>

</section>
<section id="real-sym-sh-mrtrix">
<h3>real_sym_sh_mrtrix<a class="headerlink" href="#real-sym-sh-mrtrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sym_sh_mrtrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sym_sh_mrtrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sym_sh_mrtrix" title="Permalink to this definition">#</a></dt>
<dd><p>dipy.reconst.shm.real_sym_sh_mrtrix is deprecated, Please use dipy.reconst.shm.real_sh_tournier instead

* deprecated from version: 1.3
* Will raise &lt;class ‘dipy.utils.deprecator.ExpiredDeprecationError’&gt; as of version: 2.0

Compute real symmetric spherical harmonics as in Tournier 2007 <a href="#id1665"><span class="problematic" id="id1218">[2]_</span></a>, where
the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be::

    Real(<span class="math notranslate nohighlight">\(Y^m_n\)</span>)       if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>             if m = 0
    Imag(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>)     if m &lt; 0

This may take scalar or array arguments. The inputs will be broadcast
against each other.

Parameters
———-
sh_order : int
    The maximum order or the spherical harmonic basis.
theta : float [0, pi]
    The polar (colatitudinal) coordinate.
phi : float [0, 2*pi]
    The azimuthal (longitudinal) coordinate.

Returns
——-
y_mn : real float
    The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code> as
    implemented in mrtrix. Warning: the basis is Tournier et al.
    2007 <a href="#id1666"><span class="problematic" id="id1219">[2]_</span></a>; 2004 <a href="#id1667"><span class="problematic" id="id1220">[1]_</span></a> is slightly different.
m : array
    The degree of the harmonics.
n : array
    The order of the harmonics.

References
———-
.. [1] Tournier J.D., Calamante F., Gadian D.G. and Connelly A.
       Direct estimation of the fibre orientation density function from
       diffusion-weighted MRI data using spherical deconvolution.
       NeuroImage. 2004;23:1176-1185.
.. [2] Tournier J.D., Calamante F. and Connelly A. Robust determination
       of the fibre orientation distribution in diffusion MRI:
       Non-negativity constrained super-resolved spherical deconvolution.
       NeuroImage. 2007;35(4):1459-1472.</p>
</dd></dl>

</section>
<section id="real-sym-sh-basis">
<h3>real_sym_sh_basis<a class="headerlink" href="#real-sym-sh-basis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.real_sym_sh_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">real_sym_sh_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sym_sh_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Samples a real symmetric spherical harmonic basis at point on the sphere

dipy.reconst.shm.real_sym_sh_basis is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux instead

* deprecated from version: 1.3
* Will raise &lt;class ‘dipy.utils.deprecator.ExpiredDeprecationError’&gt; as of version: 2.0

Samples the basis functions up to order <cite>sh_order</cite> at points on the sphere
given by <cite>theta</cite> and <cite>phi</cite>. The basis functions are defined here the same
way as in Descoteaux et al. 2007 <a href="#id1668"><span class="problematic" id="id1221">[1]_</span></a> where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is
defined to be:

    Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
    <span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
    Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0

This may take scalar or array arguments. The inputs will be broadcast
against each other.

Parameters
———-
sh_order : int
    even int &gt; 0, max spherical harmonic order
theta : float [0, 2*pi]
    The azimuthal (longitudinal) coordinate.
phi : float [0, pi]
    The polar (colatitudinal) coordinate.

Returns
——-
y_mn : real float
    The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code>
m : array
    The degree of the harmonics.
n : array
    The order of the harmonics.

References
———-
.. [1] Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
       Regularized, Fast, and Robust Analytical Q-ball Imaging.
       Magn. Reson. Med. 2007;58:497-510.</p>
</dd></dl>

</section>
<section id="sph-harm-ind-list">
<h3>sph_harm_ind_list<a class="headerlink" href="#sph-harm-ind-list" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sph_harm_ind_list">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sph_harm_ind_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sph_harm_ind_list" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the degree (<code class="docutils literal notranslate"><span class="pre">m</span></code>) and order (<code class="docutils literal notranslate"><span class="pre">n</span></code>) of all the symmetric spherical
harmonics of degree less then or equal to <code class="docutils literal notranslate"><span class="pre">sh_order</span></code>. The results,
<code class="docutils literal notranslate"><span class="pre">m_list</span></code> and <code class="docutils literal notranslate"><span class="pre">n_list</span></code> are kx1 arrays, where k depends on <code class="docutils literal notranslate"><span class="pre">sh_order</span></code>.
They can be passed to <a class="reference internal" href="#dipy.reconst.shm.real_sh_descoteaux_from_index" title="dipy.reconst.shm.real_sh_descoteaux_from_index"><code class="xref py py-func docutils literal notranslate"><span class="pre">real_sh_descoteaux_from_index()</span></code></a> and
:func:<code class="docutils literal notranslate"><span class="pre">real_sh_tournier_from_index</span></code>.</p>
<section id="id1222">
<h4>Parameters<a class="headerlink" href="#id1222" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sh_order<span class="classifier">int</span></dt><dd><p>even int &gt; 0, max order to return</p>
</dd>
<dt>full_basis: bool, optional</dt><dd><p>True for SH basis with even and odd order terms</p>
</dd>
</dl>
</section>
<section id="id1223">
<h4>Returns<a class="headerlink" href="#id1223" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>m_list<span class="classifier">array</span></dt><dd><p>degrees of even spherical harmonics</p>
</dd>
<dt>n_list<span class="classifier">array</span></dt><dd><p>orders of even spherical harmonics</p>
</dd>
</dl>
</section>
<section id="id1224">
<h4>See Also<a class="headerlink" href="#id1224" title="Permalink to this heading">#</a></h4>
<p>shm.real_sh_descoteaux_from_index, shm.real_sh_tournier_from_index</p>
</section>
</dd></dl>

</section>
<section id="order-from-ncoef">
<h3>order_from_ncoef<a class="headerlink" href="#order-from-ncoef" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.order_from_ncoef">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">order_from_ncoef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ncoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.order_from_ncoef" title="Permalink to this definition">#</a></dt>
<dd><p>Given a number <code class="docutils literal notranslate"><span class="pre">n</span></code> of coefficients, calculate back the <code class="docutils literal notranslate"><span class="pre">sh_order</span></code></p>
<section id="id1225">
<h4>Parameters<a class="headerlink" href="#id1225" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>ncoef: int</dt><dd><p>number of coefficients</p>
</dd>
<dt>full_basis: bool, optional</dt><dd><p>True when coefficients are for a full SH basis.</p>
</dd>
</dl>
</section>
<section id="id1226">
<h4>Returns<a class="headerlink" href="#id1226" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sh_order: int</dt><dd><p>maximum order of SH basis</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="smooth-pinv">
<h3>smooth_pinv<a class="headerlink" href="#smooth-pinv" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.smooth_pinv">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">smooth_pinv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.smooth_pinv" title="Permalink to this definition">#</a></dt>
<dd><p>Regularized pseudo-inverse

Computes a regularized least square inverse of B

Parameters
———-
B : array_like (n, m)
    Matrix to be inverted
L : array_like (m,)

Returns
——-
inv : ndarray (m, n)
    regularized least square inverse of B

Notes
—–
In the literature this inverse is often written <span class="math notranslate nohighlight">\((B^{T}B+L^{2})^{-1}B^{T}\)</span>.
However here this inverse is implemented using the pseudo-inverse because
it is more numerically stable than the direct implementation of the matrix
product.</p>
</dd></dl>

</section>
<section id="lazy-index">
<h3>lazy_index<a class="headerlink" href="#lazy-index" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.lazy_index">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">lazy_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.lazy_index" title="Permalink to this definition">#</a></dt>
<dd><p>Produces a lazy index</p>
<p>Returns a slice that can be used for indexing an array, if no slice can be
made index is returned as is.</p>
</dd></dl>

</section>
<section id="normalize-data">
<h3>normalize_data<a class="headerlink" href="#normalize-data" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.normalize_data">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">normalize_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where_b0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.normalize_data" title="Permalink to this definition">#</a></dt>
<dd><p>Normalizes the data with respect to the mean b0</p>
</dd></dl>

</section>
<section id="hat">
<h3>hat<a class="headerlink" href="#hat" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.hat">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">hat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.hat" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the hat matrix for the design matrix B</p>
</dd></dl>

</section>
<section id="lcr-matrix">
<h3>lcr_matrix<a class="headerlink" href="#lcr-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.lcr_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">lcr_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.lcr_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a matrix for computing leveraged, centered residuals from data</p>
<p>if r = (d-Hd), the leveraged centered residuals are lcr = (r/l)-mean(r/l)
ruturns the matrix R, such lcr = Rd</p>
</dd></dl>

</section>
<section id="bootstrap-data-array">
<h3>bootstrap_data_array<a class="headerlink" href="#bootstrap-data-array" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.bootstrap_data_array">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">bootstrap_data_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.bootstrap_data_array" title="Permalink to this definition">#</a></dt>
<dd><p>Applies the Residual Bootstraps to the data given H and R</p>
<p>data must be normalized, ie 0 &lt; data &lt;= 1</p>
<p>This function, and the bootstrap_data_voxel function, calculate
residual-bootstrap samples given a Hat matrix and a Residual matrix. These
samples can be used for non-parametric statistics or for bootstrap
probabilistic tractography:</p>
<section id="id1227">
<h4>References<a class="headerlink" href="#id1227" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1228" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>J. I. Berman, et al., “Probabilistic streamline q-ball tractography
using the residual bootstrap” 2008.</p>
</aside>
<aside class="footnote brackets" id="id1229" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>HA Haroon, et al., “Using the model-based residual bootstrap to
quantify uncertainty in fiber orientations from Q-ball analysis”
2009.</p>
</aside>
<aside class="footnote brackets" id="id1230" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>B. Jeurissen, et al., “Probabilistic Fiber Tracking Using the
Residual Bootstrap with Constrained Spherical Deconvolution” 2011.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="bootstrap-data-voxel">
<h3>bootstrap_data_voxel<a class="headerlink" href="#bootstrap-data-voxel" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.bootstrap_data_voxel">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">bootstrap_data_voxel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.bootstrap_data_voxel" title="Permalink to this definition">#</a></dt>
<dd><p>Like bootstrap_data_array but faster when for a single voxel</p>
<p>data must be 1d and normalized</p>
</dd></dl>

</section>
<section id="sf-to-sh">
<h3>sf_to_sh<a class="headerlink" href="#sf-to-sh" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sf_to_sh">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sf_to_sh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sf_to_sh" title="Permalink to this definition">#</a></dt>
<dd><p>Spherical function to spherical harmonics (SH).</p>
<section id="id1231">
<h4>Parameters<a class="headerlink" href="#id1231" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sf<span class="classifier">ndarray</span></dt><dd><p>Values of a function on the given <code class="docutils literal notranslate"><span class="pre">sphere</span></code>.</p>
</dd>
<dt>sphere<span class="classifier">Sphere</span></dt><dd><p>The points on which the sf is defined.</p>
</dd>
<dt>sh_order<span class="classifier">int, optional</span></dt><dd><p>Maximum SH order in the SH fit.  For <code class="docutils literal notranslate"><span class="pre">sh_order</span></code>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients for a symmetric
basis and <code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span></code> coefficients for a full
SH basis.</p>
</dd>
<dt>basis_type<span class="classifier">{None, ‘tournier07’, ‘descoteaux07’}, optional</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 [2]_[3]_ basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a href="#id1669"><span class="problematic" id="id1232">[1]_</span></a> basis,
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt>full_basis: bool, optional</dt><dd><p>True for using a SH basis containing even and odd order SH functions.
False for using a SH basis consisting only of even order SH functions.</p>
</dd>
<dt>legacy: bool, optional</dt><dd><p>True to use a legacy basis definition for backward compatibility
with previous <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> and <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> implementations.</p>
</dd>
<dt>smooth<span class="classifier">float, optional</span></dt><dd><p>Lambda-regularization in the SH fit.</p>
</dd>
</dl>
</section>
<section id="id1233">
<h4>Returns<a class="headerlink" href="#id1233" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sh<span class="classifier">ndarray</span></dt><dd><p>SH coefficients representing the input function.</p>
</dd>
</dl>
</section>
<section id="id1234">
<h4>References<a class="headerlink" href="#id1234" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1235" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</p>
</aside>
<aside class="footnote brackets" id="id1236" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</p>
</aside>
<aside class="footnote brackets" id="id1237" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,
Pietsch M, et al. MRtrix3: A fast, flexible and open software
framework for medical image processing and visualisation.
NeuroImage. 2019 Nov 15;202:116-137.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="sh-to-sf">
<h3>sh_to_sf<a class="headerlink" href="#sh-to-sf" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sh_to_sf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sh_to_sf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sh_to_sf" title="Permalink to this definition">#</a></dt>
<dd><p>Spherical harmonics (SH) to spherical function (SF).</p>
<section id="id1238">
<h4>Parameters<a class="headerlink" href="#id1238" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sh<span class="classifier">ndarray</span></dt><dd><p>SH coefficients representing a spherical function.</p>
</dd>
<dt>sphere<span class="classifier">Sphere</span></dt><dd><p>The points on which to sample the spherical function.</p>
</dd>
<dt>sh_order<span class="classifier">int, optional</span></dt><dd><p>Maximum SH order in the SH fit.  For <code class="docutils literal notranslate"><span class="pre">sh_order</span></code>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients for a symmetric
basis and <code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span></code> coefficients for a full
SH basis.</p>
</dd>
<dt>basis_type<span class="classifier">{None, ‘tournier07’, ‘descoteaux07’}, optional</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 [2]_[3]_ basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a href="#id1670"><span class="problematic" id="id1239">[1]_</span></a> basis,
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt>full_basis: bool, optional</dt><dd><p>True to use a SH basis containing even and odd order SH functions.
Else, use a SH basis consisting only of even order SH functions.</p>
</dd>
<dt>legacy: bool, optional</dt><dd><p>True to use a legacy basis definition for backward compatibility
with previous <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> and <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> implementations.</p>
</dd>
</dl>
</section>
<section id="id1240">
<h4>Returns<a class="headerlink" href="#id1240" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sf<span class="classifier">ndarray</span></dt><dd><p>Spherical function values on the <code class="docutils literal notranslate"><span class="pre">sphere</span></code>.</p>
</dd>
</dl>
</section>
<section id="id1241">
<h4>References<a class="headerlink" href="#id1241" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1242" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</p>
</aside>
<aside class="footnote brackets" id="id1243" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</p>
</aside>
<aside class="footnote brackets" id="id1244" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,
Pietsch M, et al. MRtrix3: A fast, flexible and open software
framework for medical image processing and visualisation.
NeuroImage. 2019 Nov 15;202:116-137.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="sh-to-sf-matrix">
<h3>sh_to_sf_matrix<a class="headerlink" href="#sh-to-sf-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.sh_to_sf_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">sh_to_sf_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sh_to_sf_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Matrix that transforms Spherical harmonics (SH) to spherical
function (SF).</p>
<section id="id1245">
<h4>Parameters<a class="headerlink" href="#id1245" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sphere<span class="classifier">Sphere</span></dt><dd><p>The points on which to sample the spherical function.</p>
</dd>
<dt>sh_order<span class="classifier">int, optional</span></dt><dd><p>Maximum SH order in the SH fit.  For <code class="docutils literal notranslate"><span class="pre">sh_order</span></code>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients for a symmetric
basis and <code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span></code> coefficients for a full
SH basis.</p>
</dd>
<dt>basis_type<span class="classifier">{None, ‘tournier07’, ‘descoteaux07’}, optional</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 [2]_[3]_ basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a href="#id1671"><span class="problematic" id="id1246">[1]_</span></a> basis,
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt>full_basis: bool, optional</dt><dd><p>If True, uses a SH basis containing even and odd order SH functions.
Else, uses a SH basis consisting only of even order SH functions.</p>
</dd>
<dt>legacy: bool, optional</dt><dd><p>True to use a legacy basis definition for backward compatibility
with previous <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> and <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> implementations.</p>
</dd>
<dt>return_inv<span class="classifier">bool, optional</span></dt><dd><p>If True then the inverse of the matrix is also returned.</p>
</dd>
<dt>smooth<span class="classifier">float, optional</span></dt><dd><p>Lambda-regularization in the SH fit.</p>
</dd>
</dl>
</section>
<section id="id1247">
<h4>Returns<a class="headerlink" href="#id1247" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>B<span class="classifier">ndarray</span></dt><dd><p>Matrix that transforms spherical harmonics to spherical function
<code class="docutils literal notranslate"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></code>.</p>
</dd>
<dt>invB<span class="classifier">ndarray</span></dt><dd><p>Inverse of B.</p>
</dd>
</dl>
</section>
<section id="id1248">
<h4>References<a class="headerlink" href="#id1248" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1249" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</p>
</aside>
<aside class="footnote brackets" id="id1250" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</p>
</aside>
<aside class="footnote brackets" id="id1251" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,
Pietsch M, et al. MRtrix3: A fast, flexible and open software
framework for medical image processing and visualisation.
NeuroImage. 2019 Nov 15;202:116-137.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="calculate-max-order">
<h3>calculate_max_order<a class="headerlink" href="#calculate-max-order" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.calculate_max_order">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">calculate_max_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.calculate_max_order" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the maximal harmonic order, given that you know the
number of parameters that were estimated.

Parameters
———-
n_coeffs : int
    The number of SH coefficients
full_basis: bool, optional
    True if the used SH basis contains even and odd order SH functions.
    False if the SH basis consists only of even order SH functions.

Returns
——-
L : int
    The maximal SH order, given the number of coefficients

Notes
—–
The calculation in this function for the symmetric SH basis
proceeds according to the following logic:
.. math::
    n = frac{1}{2} (L+1) (L+2)
    rarrow 2n = L^2 + 3L + 2
    rarrow L^2 + 3L + 2 - 2n = 0
    rarrow L^2 + 3L + 2(1-n) = 0
    rarrow L_{1,2} = frac{-3 pm sqrt{9 - 8 (1-n)}}{2}
    rarrow L{1,2} = frac{-3 pm sqrt{1 + 8n}}{2}

Finally, the positive value is chosen between the two options.

For a full SH basis, the calculation consists in solving the equation
<span class="math notranslate nohighlight">\(n = (L + 1)^2\)</span> for <span class="math notranslate nohighlight">\(L\)</span>, which gives <span class="math notranslate nohighlight">\(L = sqrt(n) - 1\)</span>.</p>
</dd></dl>

</section>
<section id="anisotropic-power">
<h3>anisotropic_power<a class="headerlink" href="#anisotropic-power" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.anisotropic_power">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">anisotropic_power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.anisotropic_power" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate anisotropic power map with a given SH coefficient matrix.

Parameters
———-
sh_coeffs : ndarray
    A ndarray where the last dimension is the
    SH coefficients estimates for that voxel.
norm_factor: float, optional
    The value to normalize the ap values.
power : int, optional
    The degree to which power maps are calculated.
non_negative: bool, optional
    Whether to rectify the resulting map to be non-negative.

Returns
——-
log_ap : ndarray
    The log of the resulting power image.

Notes
—–
Calculate AP image based on a IxJxKxC SH coefficient matrix based on the
equation:
.. math::
    AP = sum_{l=2,4,6,…}{frac{1}{2l+1} sum_{m=-l}^l{<a href="#id1252"><span class="problematic" id="id1253">|</span></a>a_{l,m}|^n}}

Where the last dimension, C, is made of a flattened array of <span class="math notranslate nohighlight">\(l`x:math:`m\)</span>
coefficients, where <span class="math notranslate nohighlight">\(l\)</span> are the SH orders, and <span class="math notranslate nohighlight">\(m = 2l+1\)</span>,
So l=1 has 1 coefficient, l=2 has 5, … l=8 has 17 and so on.
A l=2 SH coefficient matrix will then be composed of a IxJxKx6 volume.
The power, <span class="math notranslate nohighlight">\(n\)</span> is usually set to <span class="math notranslate nohighlight">\(n=2\)</span>.

The final AP image is then shifted by -log(norm_factor), to be strictly
non-negative. Remaining values &lt; 0 are discarded (set to 0), per default,
and this option is controlled through the <cite>non_negative</cite> keyword argument.

References
———-
.. [1]  Dell’Acqua, F., Lacerda, L., Catani, M., Simmons, A., 2014.
        Anisotropic Power Maps: A diffusion contrast to reveal low
        anisotropy tissues from HARDI data,
        in: Proceedings of International Society for Magnetic Resonance in
        Medicine. Milan, Italy.</p>
</dd></dl>

</section>
<section id="convert-sh-to-full-basis">
<h3>convert_sh_to_full_basis<a class="headerlink" href="#convert-sh-to-full-basis" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.convert_sh_to_full_basis">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">convert_sh_to_full_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeffs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.convert_sh_to_full_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Given an array of SH coeffs from a symmetric basis, returns the
coefficients for the full SH basis by filling odd order SH coefficients
with zeros</p>
<section id="id1254">
<h4>Parameters<a class="headerlink" href="#id1254" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sh_coeffs: ndarray</dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel.</p>
</dd>
</dl>
</section>
<section id="id1255">
<h4>Returns<a class="headerlink" href="#id1255" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>full_sh_coeffs: ndarray</dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel in
a full SH basis.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="convert-sh-from-legacy">
<h3>convert_sh_from_legacy<a class="headerlink" href="#convert-sh-from-legacy" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.convert_sh_from_legacy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">convert_sh_from_legacy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.convert_sh_from_legacy" title="Permalink to this definition">#</a></dt>
<dd><p>Convert SH coefficients in legacy SH basis to SH coefficients
of the new SH basis for <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> <a href="#id1672"><span class="problematic" id="id1256">[1]_</span></a> or <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> [2]_[3]_
bases.</p>
<section id="id1257">
<h4>Parameters<a class="headerlink" href="#id1257" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sh_coeffs: ndarray</dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel.</p>
</dd>
<dt>sh_basis: {‘descoteaux07’, ‘tournier07’}</dt><dd><p><code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 [2]_[3]_ basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a href="#id1673"><span class="problematic" id="id1258">[1]_</span></a> basis.</p>
</dd>
<dt>full_basis: bool, optional</dt><dd><p>True if the input SH basis includes both even and odd
order SH functions, else False.</p>
</dd>
</dl>
</section>
<section id="id1259">
<h4>Returns<a class="headerlink" href="#id1259" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>out_sh_coeffs: ndarray</dt><dd><p>The array of coefficients expressed in the new SH basis.</p>
</dd>
</dl>
</section>
<section id="id1260">
<h4>References<a class="headerlink" href="#id1260" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1261" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</p>
</aside>
<aside class="footnote brackets" id="id1262" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</p>
</aside>
<aside class="footnote brackets" id="id1263" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,
Pietsch M, et al. MRtrix3: A fast, flexible and open software
framework for medical image processing and visualisation.
NeuroImage. 2019 Nov 15;202:116-137.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="convert-sh-to-legacy">
<h3>convert_sh_to_legacy<a class="headerlink" href="#convert-sh-to-legacy" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shm.convert_sh_to_legacy">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shm.</span></span><span class="sig-name descname"><span class="pre">convert_sh_to_legacy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sh_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.convert_sh_to_legacy" title="Permalink to this definition">#</a></dt>
<dd><p>Convert SH coefficients in new SH basis to SH coefficients for
the legacy SH basis for <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> <a href="#id1674"><span class="problematic" id="id1264">[1]_</span></a> or <code class="docutils literal notranslate"><span class="pre">tournier07</span></code> [2]_[3]_
bases.</p>
<section id="id1265">
<h4>Parameters<a class="headerlink" href="#id1265" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>sh_coeffs: ndarray</dt><dd><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel.</p>
</dd>
<dt>sh_basis: {‘descoteaux07’, ‘tournier07’}</dt><dd><p><code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 [2]_[3]_ basis,
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a href="#id1675"><span class="problematic" id="id1266">[1]_</span></a> basis.</p>
</dd>
<dt>full_basis: bool, optional</dt><dd><p>True if the input SH basis includes both even and odd
order SH functions.</p>
</dd>
</dl>
</section>
<section id="id1267">
<h4>Returns<a class="headerlink" href="#id1267" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>out_sh_coeffs: ndarray</dt><dd><p>The array of coefficients expressed in the legacy SH basis.</p>
</dd>
</dl>
</section>
<section id="id1268">
<h4>References<a class="headerlink" href="#id1268" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1269" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</p>
</aside>
<aside class="footnote brackets" id="id1270" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</p>
</aside>
<aside class="footnote brackets" id="id1271" role="note">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,
Pietsch M, et al. MRtrix3: A fast, flexible and open software
framework for medical image processing and visualisation.
NeuroImage. 2019 Nov 15;202:116-137.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>
<section id="shoremodel">
<h3><a class="reference internal" href="#dipy.reconst.shore.ShoreModel" title="dipy.reconst.shore.ShoreModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreModel</span></code></a><a class="headerlink" href="#shoremodel" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">ShoreModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">700</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.025330295910584444</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constrain_e0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreModel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a></p>
<p>Simple Harmonic Oscillator based Reconstruction and Estimation
(SHORE) <a href="#id1676"><span class="problematic" id="id1272">[1]_</span></a> of the diffusion signal.

The main idea is to model the diffusion signal as a linear combination of
continuous functions <span class="math notranslate nohighlight">\(\phi_i\)</span>,

..math::
    :nowrap:
        begin{equation}
            S(mathbf{q})= sum_{i=0}^I  c_{i} phi_{i}(mathbf{q}).
        end{equation}

where <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> is the wave vector which corresponds to different
gradient directions. Numerous continuous functions <span class="math notranslate nohighlight">\(\phi_i\)</span> can be used to
model <span class="math notranslate nohighlight">\(S\)</span>. Some are presented in [2,3,4]_.

From the <span class="math notranslate nohighlight">\(c_i\)</span> coefficients, there exist analytical formulae to estimate
the ODF, the return to the origin probability (RTOP), the mean square
displacement (MSD), amongst others <a href="#id1677"><span class="problematic" id="id1273">[5]_</span></a>.

References
———-
.. [1] Ozarslan E. et al., “Simple harmonic oscillator based reconstruction
       and estimation for one-dimensional q-space magnetic resonance
       1D-SHORE)”, Proc Intl Soc Mag Reson Med, vol. 16, p. 35., 2008.

.. [2] Merlet S. et al., “Continuous diffusion signal, EAP and ODF
       estimation via Compressive Sensing in diffusion MRI”, Medical
       Image Analysis, 2013.

.. [3] Rathi Y. et al., “Sparse multi-shell diffusion imaging”, MICCAI,
       2011.

.. [4] Cheng J. et al., “Theoretical Analysis and Practical Insights on
       EAP Estimation via a Unified HARDI Framework”, MICCAI workshop on
       Computational Diffusion MRI, 2011.

.. [5] Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel
       diffusion imaging method for mapping tissue microstructure”,
       NeuroImage, 2013.

Notes
—–
The implementation of SHORE depends on CVXPY (<a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a>).</p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">700</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.025330295910584444</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constrain_e0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreModel.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Analytical and continuous modeling of the diffusion signal with
respect to the SHORE basis [1,2]_.
This implementation is a modification of SHORE presented in <a href="#id1678"><span class="problematic" id="id1274">[1]_</span></a>.
The modification was made to obtain the same ordering of the basis
presented in [2,3]_.

The main idea is to model the diffusion signal as a linear
combination of continuous functions <span class="math notranslate nohighlight">\(\phi_i\)</span>,

..math::
    :nowrap:
        begin{equation}
            S(mathbf{q})= sum_{i=0}^I  c_{i} phi_{i}(mathbf{q}).
        end{equation}

where <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> is the wave vector which corresponds to different
gradient directions.

From the <span class="math notranslate nohighlight">\(c_i\)</span> coefficients, there exists an analytical formula to
estimate the ODF.


Parameters
———-
gtab : GradientTable,
    gradient directions and bvalues container class
radial_order : unsigned int,
    an even integer that represent the order of the basis
zeta : unsigned int,
    scale factor
lambdaN : float,
    radial regularisation constant
lambdaL : float,
    angular regularisation constant
tau : float,
    diffusion time. By default the value that makes q equal to the
    square root of the b-value.
constrain_e0 : bool,
    Constrain the optimization such that E(0) = 1.
positive_constraint : bool,
    Constrain the propagator to be positive.
pos_grid : int,
    Grid that define the points of the EAP in which we want to enforce
    positivity.
pos_radius : float,
    Radius of the grid of the EAP in which enforce positivity in
    millimeters. By default 20e-03 mm.
cvxpy_solver : str, optional
    cvxpy solver name. Optionally optimize the positivity constraint
    with a particular cvxpy solver. See <a class="reference external" href="https://www.cvxpy.org/">https://www.cvxpy.org/</a> for
    details.
    Default: None (cvxpy chooses its own solver)

References
———-
.. [1] Merlet S. et al., “Continuous diffusion signal, EAP and
ODF estimation via Compressive Sensing in diffusion MRI”, Medical
Image Analysis, 2013.

.. [2] Cheng J. et al., “Theoretical Analysis and Practical Insights
on EAP Estimation via a Unified HARDI Framework”, MICCAI workshop on
Computational Diffusion MRI, 2011.

.. [3] Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel
   diffusion imaging method for mapping tissue microstructure”,
   NeuroImage, 2013.

Examples
——–
In this example, where the data, gradient table and sphere tessellation
used for reconstruction are provided, we model the diffusion signal
with respect to the SHORE basis and compute the real and analytical
ODF.

&gt;&gt;&gt; import warnings
&gt;&gt;&gt; from dipy.data import get_isbi2013_2shell_gtab, default_sphere
&gt;&gt;&gt; from dipy.sims.voxel import sticks_and_ball
&gt;&gt;&gt; from dipy.reconst.shm import descoteaux07_legacy_msg
&gt;&gt;&gt; from dipy.reconst.shore import ShoreModel
&gt;&gt;&gt; gtab = get_isbi2013_2shell_gtab()
&gt;&gt;&gt; data, golden_directions = sticks_and_ball(
…    gtab, d=0.0015, S0=1., angles=[(0, 0), (90, 0)],
…    fractions=[50, 50], snr=None)
…
&gt;&gt;&gt; radial_order = 4
&gt;&gt;&gt; zeta = 700
&gt;&gt;&gt; asm = ShoreModel(gtab, radial_order=radial_order, zeta=zeta,
…                  lambdaN=1e-8, lambdaL=1e-8)
&gt;&gt;&gt; with warnings.catch_warnings():
…     warnings.filterwarnings(
…         “ignore”, message=descoteaux07_legacy_msg,
…         category=PendingDeprecationWarning)
…     asmfit = asm.fit(data)
…     odf = asmfit.odf(default_sphere)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreModel.fit" title="Permalink to this definition">#</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</section>
<section id="shorefit">
<h3><a class="reference internal" href="#dipy.reconst.shore.ShoreFit" title="dipy.reconst.shore.ShoreFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreFit</span></code></a><a class="headerlink" href="#shorefit" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">ShoreFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shore_coef</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shore_coef</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates diffusion properties for a single voxel</p>
<section id="id1275">
<h4>Parameters<a class="headerlink" href="#id1275" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>model<span class="classifier">object,</span></dt><dd><p>AnalyticalModel</p>
</dd>
<dt>shore_coef<span class="classifier">1d ndarray,</span></dt><dd><p>shore coefficients</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.fitted_signal">
<span class="sig-name descname"><span class="pre">fitted_signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.fitted_signal" title="Permalink to this definition">#</a></dt>
<dd><p>The fitted signal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.msd">
<span class="sig-name descname"><span class="pre">msd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.msd" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical mean squared displacement (MSD) <a href="#id1679"><span class="problematic" id="id1276">[1]_</span></a>

..math::
    :nowrap:
        begin{equation}
            MSD:{DSI}=int_{-infty}^{infty}int_{-infty}^{infty}
            int_{-infty}^{infty} P(hat{mathbf{r}}) cdot
            hat{mathbf{r}}^{2} dr_x dr_y dr_z
        end{equation}

where <span class="math notranslate nohighlight">\(\hat{\mathbf{r}}\)</span> is a point in the 3D propagator space (see Wu
et al. <a href="#id1680"><span class="problematic" id="id1277">[1]_</span></a>).

References
———-
.. [1] Wu Y. et al., “Hybrid diffusion imaging”, NeuroImage, vol 36,
p. 617-629, 2007.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.odf">
<span class="sig-name descname"><span class="pre">odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.odf" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the ODF for a given discrete sphere.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.odf_sh">
<span class="sig-name descname"><span class="pre">odf_sh</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.odf_sh" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the real analytical ODF in terms of Spherical
Harmonics.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.pdf" title="Permalink to this definition">#</a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.pdf_grid">
<span class="sig-name descname"><span class="pre">pdf_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_max</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.pdf_grid" title="Permalink to this definition">#</a></dt>
<dd><p>Applies the analytical FFT on <span class="math notranslate nohighlight">\(S\)</span> to generate the diffusion
propagator. This is calculated on a discrete 3D grid in order to
obtain an EAP similar to that which is obtained with DSI.

Parameters
———-
gridsize : unsigned int
    dimension of the propagator grid
radius_max : float
    maximal radius in which to compute the propagator

Returns
——-
eap : ndarray
    the ensemble average propagator in the 3D grid</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.rtop_pdf">
<span class="sig-name descname"><span class="pre">rtop_pdf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.rtop_pdf" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical return to origin probability (RTOP)
from the pdf <a href="#id1681"><span class="problematic" id="id1278">[1]_</span></a>.</p>
<section id="id1279">
<h4>References<a class="headerlink" href="#id1279" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1280" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.rtop_signal">
<span class="sig-name descname"><span class="pre">rtop_signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.rtop_signal" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the analytical return to origin probability (RTOP)
from the signal <a href="#id1682"><span class="problematic" id="id1281">[1]_</span></a>.</p>
<section id="id1282">
<h4>References<a class="headerlink" href="#id1282" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1283" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ozarslan E. et al., “Mean apparent propagator (MAP) MRI: A novel</p>
</aside>
</aside>
<p>diffusion imaging method for mapping tissue microstructure”,
NeuroImage, 2013.</p>
</section>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="dipy.reconst.shore.ShoreFit.shore_coeff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shore_coeff</span></span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.shore_coeff" title="Permalink to this definition">#</a></dt>
<dd><p>The SHORE coefficients</p>
</dd></dl>

</dd></dl>

</section>
<section id="shore-matrix">
<h3>shore_matrix<a class="headerlink" href="#shore-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.025330295910584444</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the SHORE matrix for modified Merlet’s 3D-SHORE <a href="#id1683"><span class="problematic" id="id1284">[1]_</span></a>

..math::
        :nowrap:
            begin{equation}
                textbf{E}(qtextbf{u})=sum_{l=0, even}^{N_{max}}
                                        sum_{n=l}^{(N_{max}+l)/2}
                                        sum_{m=-l}^l c_{nlm}
                                        phi_{nlm}(qtextbf{u})
            end{equation}

where <span class="math notranslate nohighlight">\(\phi_{nlm}\)</span> is
..math::
        :nowrap:
            begin{equation}
                phi_{nlm}^{SHORE}(qtextbf{u})=Biggl[dfrac{2(n-l)!}
                    {zeta^{3/2} Gamma(n+3/2)} Biggr]^{1/2}
                    Biggl(dfrac{q^2}{zeta}Biggr)^{l/2}
                    expBiggl(dfrac{-q^2}{2zeta}Biggr)
                    L^{l+1/2}_{n-l} Biggl(dfrac{q^2}{zeta}Biggr)
                    Y_l^m(textbf{u}).
            end{equation}

Parameters
———-
radial_order : unsigned int,
    an even integer that represent the order of the basis
zeta : unsigned int,
    scale factor
gtab : GradientTable,
    gradient directions and bvalues container class
tau : float,
    diffusion time. By default the value that makes q=sqrt(b).

References
———-
.. [1] Merlet S. et al., “Continuous diffusion signal, EAP and
ODF estimation via Compressive Sensing in diffusion MRI”, Medical
Image Analysis, 2013.</p>
</dd></dl>

</section>
<section id="shore-matrix-pdf">
<h3>shore_matrix_pdf<a class="headerlink" href="#shore-matrix-pdf" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_matrix_pdf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_matrix_pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_matrix_pdf" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the SHORE propagator matrix <a href="#id1684"><span class="problematic" id="id1285">[1]_</span></a>”</p>
<section id="id1286">
<h4>Parameters<a class="headerlink" href="#id1286" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt>zeta<span class="classifier">unsigned int,</span></dt><dd><p>scale factor</p>
</dd>
<dt>rtab<span class="classifier">array, shape (N,3)</span></dt><dd><p>real space points in which calculates the pdf</p>
</dd>
</dl>
</section>
<section id="id1287">
<h4>References<a class="headerlink" href="#id1287" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1288" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Merlet S. et al., “Continuous diffusion signal, EAP and</p>
</aside>
</aside>
<p>ODF estimation via Compressive Sensing in diffusion MRI”, Medical
Image Analysis, 2013.</p>
</section>
</dd></dl>

</section>
<section id="shore-matrix-odf">
<h3>shore_matrix_odf<a class="headerlink" href="#shore-matrix-odf" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_matrix_odf">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_matrix_odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere_vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_matrix_odf" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the SHORE ODF matrix <a href="#id1685"><span class="problematic" id="id1289">[1]_</span></a>”</p>
<section id="id1290">
<h4>Parameters<a class="headerlink" href="#id1290" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>
</dd>
<dt>zeta<span class="classifier">unsigned int,</span></dt><dd><p>scale factor</p>
</dd>
<dt>sphere_vertices<span class="classifier">array, shape (N,3)</span></dt><dd><p>vertices of the odf sphere</p>
</dd>
</dl>
</section>
<section id="id1291">
<h4>References<a class="headerlink" href="#id1291" title="Permalink to this heading">#</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1292" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Merlet S. et al., “Continuous diffusion signal, EAP and</p>
</aside>
</aside>
<p>ODF estimation via Compressive Sensing in diffusion MRI”, Medical
Image Analysis, 2013.</p>
</section>
</dd></dl>

</section>
<section id="l-shore">
<h3>l_shore<a class="headerlink" href="#l-shore" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.l_shore">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">l_shore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.l_shore" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the angular regularisation matrix for SHORE basis</p>
</dd></dl>

</section>
<section id="n-shore">
<h3>n_shore<a class="headerlink" href="#n-shore" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.n_shore">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">n_shore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.n_shore" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the angular regularisation matrix for SHORE basis</p>
</dd></dl>

</section>
<section id="id1293">
<h3>create_rspace<a class="headerlink" href="#id1293" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.create_rspace">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">create_rspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_max</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.create_rspace" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Create the real space table, that contains the points in which</dt><dd><p>to compute the pdf.</p>
</dd>
</dl>
<section id="id1294">
<h4>Parameters<a class="headerlink" href="#id1294" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gridsize<span class="classifier">unsigned int</span></dt><dd><p>dimension of the propagator grid</p>
</dd>
<dt>radius_max<span class="classifier">float</span></dt><dd><p>maximal radius in which compute the propagator</p>
</dd>
</dl>
</section>
<section id="id1295">
<h4>Returns<a class="headerlink" href="#id1295" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>vecs<span class="classifier">array, shape (N,3)</span></dt><dd><p>positions of the pdf points in a 3D matrix</p>
</dd>
<dt>tab<span class="classifier">array, shape (N,3)</span></dt><dd><p>real space points in which calculates the pdf</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="shore-indices">
<h3>shore_indices<a class="headerlink" href="#shore-indices" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_indices">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radial_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_indices" title="Permalink to this definition">#</a></dt>
<dd><p>Given the basis order and the index, return the shore indices n, l, m
for modified Merlet’s 3D-SHORE
..math::
        :nowrap:
            begin{equation}
                textbf{E}(qtextbf{u})=sum_{l=0, even}^{N_{max}}
                                        sum_{n=l}^{(N_{max}+l)/2}
                                        sum_{m=-l}^l c_{nlm}
                                        phi_{nlm}(qtextbf{u})
            end{equation}

where <span class="math notranslate nohighlight">\(\phi_{nlm}\)</span> is
..math::
        :nowrap:
            begin{equation}
                phi_{nlm}^{SHORE}(qtextbf{u})=Biggl[dfrac{2(n-l)!}
                    {zeta^{3/2} Gamma(n+3/2)} Biggr]^{1/2}
                    Biggl(dfrac{q^2}{zeta}Biggr)^{l/2}
                    expBiggl(dfrac{-q^2}{2zeta}Biggr)
                    L^{l+1/2}_{n-l} Biggl(dfrac{q^2}{zeta}Biggr)
                    Y_l^m(textbf{u}).
            end{equation}

Parameters
———-
radial_order : unsigned int
    an even integer that represent the maximal order of the basis
index : unsigned int
    index of the coefficients, start from 0

Returns
——-
n :  unsigned int
    the index n of the modified shore basis
l :  unsigned int
    the index l of the modified shore basis
m :  unsigned int
    the index m of the modified shore basis</p>
</dd></dl>

</section>
<section id="shore-order">
<h3>shore_order<a class="headerlink" href="#shore-order" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.shore.shore_order">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.shore.</span></span><span class="sig-name descname"><span class="pre">shore_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_order" title="Permalink to this definition">#</a></dt>
<dd><p>Given the indices (n,l,m) of the basis, return the minimum order
for those indices and their index for modified Merlet’s 3D-SHORE.</p>
<section id="id1296">
<h4>Parameters<a class="headerlink" href="#id1296" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>n<span class="classifier">unsigned int</span></dt><dd><p>the index n of the modified shore basis</p>
</dd>
<dt>l<span class="classifier">unsigned int</span></dt><dd><p>the index l of the modified shore basis</p>
</dd>
<dt>m<span class="classifier">unsigned int</span></dt><dd><p>the index m of the modified shore basis</p>
</dd>
</dl>
</section>
<section id="id1297">
<h4>Returns<a class="headerlink" href="#id1297" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>radial_order<span class="classifier">unsigned int</span></dt><dd><p>an even integer that represent the maximal order of the basis</p>
</dd>
<dt>index<span class="classifier">unsigned int</span></dt><dd><p>index of the coefficient corresponding to (n,l,m), start from 0</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="dki-design-matrix">
<h3>dki_design_matrix<a class="headerlink" href="#dki-design-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.utils.dki_design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.utils.</span></span><span class="sig-name descname"><span class="pre">dki_design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.utils.dki_design_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Construct B design matrix for DKI.</p>
<section id="id1298">
<h4>Parameters<a class="headerlink" href="#id1298" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab<span class="classifier">GradientTable</span></dt><dd><p>Measurement directions.</p>
</dd>
</dl>
</section>
<section id="id1299">
<h4>Returns<a class="headerlink" href="#id1299" title="Permalink to this heading">#</a></h4>
<dl>
<dt>B<span class="classifier">array (N, 22)</span></dt><dd><p>Design matrix or B matrix for the DKI model
B[j, :] = (Bxx, Bxy, Byy, Bxz, Byz, Bzz,</p>
<blockquote>
<div><p>Bxxxx, Byyyy, Bzzzz, Bxxxy, Bxxxz,
Bxyyy, Byyyz, Bxzzz, Byzzz, Bxxyy,
Bxxzz, Byyzz, Bxxyz, Bxyyz, Bxyzz,
BlogS0)</p>
</div></blockquote>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="cti-design-matrix">
<h3>cti_design_matrix<a class="headerlink" href="#cti-design-matrix" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.utils.cti_design_matrix">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.utils.</span></span><span class="sig-name descname"><span class="pre">cti_design_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtab2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.utils.cti_design_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Construct B design matrix for CTI.</p>
<section id="id1300">
<h4>Parameters<a class="headerlink" href="#id1300" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>gtab1: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for first DDE diffusion epoch</p>
</dd>
<dt>gtab2: dipy.core.gradients.GradientTable</dt><dd><p>A GradientTable class instance for second DDE diffusion epoch</p>
</dd>
</dl>
</section>
<section id="id1301">
<h4>Returns<a class="headerlink" href="#id1301" title="Permalink to this heading">#</a></h4>
<p>B: array(N, 43)
Design matrix or B matrix for the CTI model assuming multiple
Gaussian Components</p>
</section>
</dd></dl>

</section>
<section id="vec-val-vect">
<h3>vec_val_vect<a class="headerlink" href="#vec-val-vect" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="dipy.reconst.vec_val_sum.vec_val_vect">
<span class="sig-prename descclassname"><span class="pre">dipy.reconst.vec_val_sum.</span></span><span class="sig-name descname"><span class="pre">vec_val_vect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.vec_val_sum.vec_val_vect" title="Permalink to this definition">#</a></dt>
<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>
<section id="id1302">
<h4>Parameters<a class="headerlink" href="#id1302" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>vecs<span class="classifier">shape (…, M, N) array</span></dt><dd><p>containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>
</dd>
<dt>vals<span class="classifier">shape (…, N) array</span></dt><dd><p>diagonal values carried in last dimension, <code class="docutils literal notranslate"><span class="pre">...</span></code> shape above must
match that for <cite>vecs</cite></p>
</dd>
</dl>
</section>
<section id="id1303">
<h4>Returns<a class="headerlink" href="#id1303" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>res<span class="classifier">shape (…, M, M) array</span></dt><dd><p>For all the dimensions ellided by <code class="docutils literal notranslate"><span class="pre">...</span></code>, loops to get (M, N) <code class="docutils literal notranslate"><span class="pre">vec</span></code>
matrix, and (N,) <code class="docutils literal notranslate"><span class="pre">vals</span></code> vector, and calculates
<code class="docutils literal notranslate"><span class="pre">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>
</dd>
</dl>
</section>
<section id="raises">
<h4>Raises<a class="headerlink" href="#raises" title="Permalink to this heading">#</a></h4>
<p>ValueError : non-matching <code class="docutils literal notranslate"><span class="pre">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite>
ValueError : non-matching <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></p>
</section>
<section id="id1304">
<h4>Examples<a class="headerlink" href="#id1304" title="Permalink to this heading">#</a></h4>
<p>Make a 3D array where the first dimension is only 1</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_val_vect</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="go">array([[[   9.,   24.,   39.],</span>
<span class="go">        [  24.,   66.,  108.],</span>
<span class="go">        [  39.,  108.,  177.]]])</span>
</pre></div>
</div>
<p>That’s the same as the 2D case (apart from the float casting):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">vecs</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">array([[  9,  24,  39],</span>
<span class="go">       [ 24,  66, 108],</span>
<span class="go">       [ 39, 108, 177]])</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
</section>
</section>


                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="dipy.nn.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nn</span></code></p>
      </div>
    </a>
    <a class="right-next"
       href="dipy.segment.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><code class="xref py py-mod docutils literal notranslate"><span class="pre">segment</span></code></p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.base">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.base</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.benchmarks">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.benchmarks.bench_bounding_box">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_bounding_box</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.benchmarks.bench_csd">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_csd</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.benchmarks.bench_peaks">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_peaks</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.benchmarks.bench_squash">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_squash</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.benchmarks.bench_vec_val_sum">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_vec_val_sum</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.cache">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cache</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.cross_validation">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cross_validation</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.csdeconv">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.csdeconv</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.cti">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cti</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.dki">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.dki_micro">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki_micro</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.dsi">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dsi</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.dti">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dti</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.eudx_direction_getter">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.eudx_direction_getter</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.forecast">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.forecast</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.fwdti">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.fwdti</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.gqi">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.gqi</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.ivim">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.ivim</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.mapmri">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.mapmri</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.mcsd">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.mcsd</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.msdki">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.msdki</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.multi_voxel">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.multi_voxel</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.odf">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.odf</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.qtdmri">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.qtdmri</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.qti">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.qti</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.quick_squash">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.quick_squash</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.recspeed">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.recspeed</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.rumba">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.rumba</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.sfm">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.sfm</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.shm">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shm</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.shore">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shore</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.utils">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.utils</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-dipy.reconst.vec_val_sum">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.vec_val_sum</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reconstmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.base.ReconstModel"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.base.ReconstModel.__init__"><code class="docutils literal notranslate"><span class="pre">ReconstModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.base.ReconstModel.fit"><code class="docutils literal notranslate"><span class="pre">ReconstModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reconstfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.base.ReconstFit"><code class="docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.base.ReconstFit.__init__"><code class="docutils literal notranslate"><span class="pre">ReconstFit.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bench-bounding-box">bench_bounding_box</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box"><code class="docutils literal notranslate"><span class="pre">bench_bounding_box()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#num-grad">num_grad</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.benchmarks.bench_csd.num_grad"><code class="docutils literal notranslate"><span class="pre">num_grad()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bench-csdeconv">bench_csdeconv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.benchmarks.bench_csd.bench_csdeconv"><code class="docutils literal notranslate"><span class="pre">bench_csdeconv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bench-local-maxima">bench_local_maxima</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.benchmarks.bench_peaks.bench_local_maxima"><code class="docutils literal notranslate"><span class="pre">bench_local_maxima()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#old-squash">old_squash</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.benchmarks.bench_squash.old_squash"><code class="docutils literal notranslate"><span class="pre">old_squash()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bench-quick-squash">bench_quick_squash</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.benchmarks.bench_squash.bench_quick_squash"><code class="docutils literal notranslate"><span class="pre">bench_quick_squash()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bench-vec-val-vect">bench_vec_val_vect</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect"><code class="docutils literal notranslate"><span class="pre">bench_vec_val_vect()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cache.Cache"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cache.Cache.__init__"><code class="docutils literal notranslate"><span class="pre">Cache.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cache.Cache.cache_clear"><code class="docutils literal notranslate"><span class="pre">Cache.cache_clear()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cache.Cache.cache_get"><code class="docutils literal notranslate"><span class="pre">Cache.cache_get()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cache.Cache.cache_set"><code class="docutils literal notranslate"><span class="pre">Cache.cache_set()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#coeff-of-determination">coeff_of_determination</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cross_validation.coeff_of_determination"><code class="docutils literal notranslate"><span class="pre">coeff_of_determination()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kfold-xval">kfold_xval</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cross_validation.kfold_xval"><code class="docutils literal notranslate"><span class="pre">kfold_xval()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axsymshresponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.AxSymShResponse"><code class="docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.AxSymShResponse.__init__"><code class="docutils literal notranslate"><span class="pre">AxSymShResponse.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.AxSymShResponse.basis"><code class="docutils literal notranslate"><span class="pre">AxSymShResponse.basis()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.AxSymShResponse.on_sphere"><code class="docutils literal notranslate"><span class="pre">AxSymShResponse.on_sphere()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constrainedsphericaldeconvmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><code class="docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.__init__"><code class="docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit"><code class="docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict"><code class="docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constrainedsdtmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSDTModel"><code class="docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.__init__"><code class="docutils literal notranslate"><span class="pre">ConstrainedSDTModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.fit"><code class="docutils literal notranslate"><span class="pre">ConstrainedSDTModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#auto-response">auto_response</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.auto_response"><code class="docutils literal notranslate"><span class="pre">auto_response()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#response-from-mask">response_from_mask</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.response_from_mask"><code class="docutils literal notranslate"><span class="pre">response_from_mask()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#estimate-response">estimate_response</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.estimate_response"><code class="docutils literal notranslate"><span class="pre">estimate_response()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forward-sdt-deconv-mat">forward_sdt_deconv_mat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat"><code class="docutils literal notranslate"><span class="pre">forward_sdt_deconv_mat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#csdeconv">csdeconv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.csdeconv"><code class="docutils literal notranslate"><span class="pre">csdeconv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odf-deconv">odf_deconv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.odf_deconv"><code class="docutils literal notranslate"><span class="pre">odf_deconv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odf-sh-to-sharp">odf_sh_to_sharp</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.odf_sh_to_sharp"><code class="docutils literal notranslate"><span class="pre">odf_sh_to_sharp()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mask-for-response-ssst">mask_for_response_ssst</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.mask_for_response_ssst"><code class="docutils literal notranslate"><span class="pre">mask_for_response_ssst()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#response-from-mask-ssst">response_from_mask_ssst</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.response_from_mask_ssst"><code class="docutils literal notranslate"><span class="pre">response_from_mask_ssst()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#auto-response-ssst">auto_response_ssst</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.auto_response_ssst"><code class="docutils literal notranslate"><span class="pre">auto_response_ssst()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recursive-response">recursive_response</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.recursive_response"><code class="docutils literal notranslate"><span class="pre">recursive_response()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fa-trace-to-lambdas">fa_trace_to_lambdas</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas"><code class="docutils literal notranslate"><span class="pre">fa_trace_to_lambdas()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#correlationtensormodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CorrelationTensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorModel"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorModel.__init__"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorModel.fit"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorModel.predict"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#correlationtensorfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">CorrelationTensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.__init__"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.K_aniso"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.K_aniso</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.K_iso"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.K_iso</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.K_micro"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.K_micro</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.K_total"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.K_total()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.ct"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.ct</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.CorrelationTensorFit.predict"><code class="docutils literal notranslate"><span class="pre">CorrelationTensorFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-qte-to-cti">from_qte_to_cti</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.from_qte_to_cti"><code class="docutils literal notranslate"><span class="pre">from_qte_to_cti()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-gaussian-k-from-c">multi_gaussian_k_from_c</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.multi_gaussian_k_from_c"><code class="docutils literal notranslate"><span class="pre">multi_gaussian_k_from_c()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#split-cti-params">split_cti_params</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.split_cti_params"><code class="docutils literal notranslate"><span class="pre">split_cti_params()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cti-prediction">cti_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.cti_prediction"><code class="docutils literal notranslate"><span class="pre">cti_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#params-to-cti-params">params_to_cti_params</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.params_to_cti_params"><code class="docutils literal notranslate"><span class="pre">params_to_cti_params()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ls-fit-cti">ls_fit_cti</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.cti.ls_fit_cti"><code class="docutils literal notranslate"><span class="pre">ls_fit_cti()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionkurtosismodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel.__init__"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel.fit"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel.multi_fit"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel.multi_fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisModel.predict"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionkurtosisfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.__init__"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.ak"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.ak()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.akc"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.akc()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.kfa"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.kfa</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.kmax"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.kmax()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.kt"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.kt</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.mk"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.mk()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.mkt"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.mkt()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.predict"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.DiffusionKurtosisFit.rk"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit.rk()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#carlson-rf">carlson_rf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.carlson_rf"><code class="docutils literal notranslate"><span class="pre">carlson_rf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#carlson-rd">carlson_rd</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.carlson_rd"><code class="docutils literal notranslate"><span class="pre">carlson_rd()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-diffusion">directional_diffusion</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.directional_diffusion"><code class="docutils literal notranslate"><span class="pre">directional_diffusion()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-diffusion-variance">directional_diffusion_variance</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.directional_diffusion_variance"><code class="docutils literal notranslate"><span class="pre">directional_diffusion_variance()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-kurtosis">directional_kurtosis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.directional_kurtosis"><code class="docutils literal notranslate"><span class="pre">directional_kurtosis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#apparent-kurtosis-coef">apparent_kurtosis_coef</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.apparent_kurtosis_coef"><code class="docutils literal notranslate"><span class="pre">apparent_kurtosis_coef()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mean-kurtosis">mean_kurtosis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.mean_kurtosis"><code class="docutils literal notranslate"><span class="pre">mean_kurtosis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radial-kurtosis">radial_kurtosis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.radial_kurtosis"><code class="docutils literal notranslate"><span class="pre">radial_kurtosis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axial-kurtosis">axial_kurtosis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.axial_kurtosis"><code class="docutils literal notranslate"><span class="pre">axial_kurtosis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kurtosis-maximum">kurtosis_maximum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.kurtosis_maximum"><code class="docutils literal notranslate"><span class="pre">kurtosis_maximum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mean-kurtosis-tensor">mean_kurtosis_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.mean_kurtosis_tensor"><code class="docutils literal notranslate"><span class="pre">mean_kurtosis_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kurtosis-fractional-anisotropy">kurtosis_fractional_anisotropy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.kurtosis_fractional_anisotropy"><code class="docutils literal notranslate"><span class="pre">kurtosis_fractional_anisotropy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dki-prediction">dki_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.dki_prediction"><code class="docutils literal notranslate"><span class="pre">dki_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#params-to-dki-params">params_to_dki_params</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.params_to_dki_params"><code class="docutils literal notranslate"><span class="pre">params_to_dki_params()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ls-fit-dki">ls_fit_dki</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.ls_fit_dki"><code class="docutils literal notranslate"><span class="pre">ls_fit_dki()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cls-fit-dki">cls_fit_dki</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.cls_fit_dki"><code class="docutils literal notranslate"><span class="pre">cls_fit_dki()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wrotate">Wrotate</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.Wrotate"><code class="docutils literal notranslate"><span class="pre">Wrotate()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wrotate-element">Wrotate_element</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.Wrotate_element"><code class="docutils literal notranslate"><span class="pre">Wrotate_element()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wcons">Wcons</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.Wcons"><code class="docutils literal notranslate"><span class="pre">Wcons()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#split-dki-param">split_dki_param</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki.split_dki_param"><code class="docutils literal notranslate"><span class="pre">split_dki_param()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kurtosismicrostructuremodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.__init__"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kurtosismicrostructuralfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.__init__"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.awf</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.axonal_diffusivity</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.hindered_ad</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.hindered_evals</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.hindered_rd</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.restricted_evals</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit.tortuosity</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axonal-water-fraction">axonal_water_fraction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.axonal_water_fraction"><code class="docutils literal notranslate"><span class="pre">axonal_water_fraction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusion-components">diffusion_components</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.diffusion_components"><code class="docutils literal notranslate"><span class="pre">diffusion_components()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dkimicro-prediction">dkimicro_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.dkimicro_prediction"><code class="docutils literal notranslate"><span class="pre">dkimicro_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tortuosity">tortuosity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dki_micro.tortuosity"><code class="docutils literal notranslate"><span class="pre">tortuosity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionspectrummodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumModel"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumModel.__init__"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumModel.fit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionspectrumfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.__init__"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.msd_discrete()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.odf"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.pdf"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.rtop_pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit.rtop_signal()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionspectrumdeconvmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.__init__"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffusionspectrumdeconvfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.__init__"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit.pdf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-qspace">create_qspace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.create_qspace"><code class="docutils literal notranslate"><span class="pre">create_qspace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-qtable">create_qtable</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.create_qtable"><code class="docutils literal notranslate"><span class="pre">create_qtable()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hanning-filter">hanning_filter</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.hanning_filter"><code class="docutils literal notranslate"><span class="pre">hanning_filter()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pdf-interp-coords">pdf_interp_coords</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.pdf_interp_coords"><code class="docutils literal notranslate"><span class="pre">pdf_interp_coords()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pdf-odf">pdf_odf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.pdf_odf"><code class="docutils literal notranslate"><span class="pre">pdf_odf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#half-to-full-qspace">half_to_full_qspace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.half_to_full_qspace"><code class="docutils literal notranslate"><span class="pre">half_to_full_qspace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#project-hemisph-bvecs">project_hemisph_bvecs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.project_hemisph_bvecs"><code class="docutils literal notranslate"><span class="pre">project_hemisph_bvecs()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#threshold-propagator">threshold_propagator</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.threshold_propagator"><code class="docutils literal notranslate"><span class="pre">threshold_propagator()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gen-psf">gen_PSF</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.gen_PSF"><code class="docutils literal notranslate"><span class="pre">gen_PSF()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lr-deconv">LR_deconv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dsi.LR_deconv"><code class="docutils literal notranslate"><span class="pre">LR_deconv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tensormodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorModel"><code class="docutils literal notranslate"><span class="pre">TensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorModel.__init__"><code class="docutils literal notranslate"><span class="pre">TensorModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorModel.fit"><code class="docutils literal notranslate"><span class="pre">TensorModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorModel.predict"><code class="docutils literal notranslate"><span class="pre">TensorModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tensorfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit"><code class="docutils literal notranslate"><span class="pre">TensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.__init__"><code class="docutils literal notranslate"><span class="pre">TensorFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.S0_hat"><code class="docutils literal notranslate"><span class="pre">TensorFit.S0_hat</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.ad"><code class="docutils literal notranslate"><span class="pre">TensorFit.ad()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.adc"><code class="docutils literal notranslate"><span class="pre">TensorFit.adc()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.color_fa"><code class="docutils literal notranslate"><span class="pre">TensorFit.color_fa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.directions"><code class="docutils literal notranslate"><span class="pre">TensorFit.directions</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.evals"><code class="docutils literal notranslate"><span class="pre">TensorFit.evals</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.evecs"><code class="docutils literal notranslate"><span class="pre">TensorFit.evecs</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.fa"><code class="docutils literal notranslate"><span class="pre">TensorFit.fa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.ga"><code class="docutils literal notranslate"><span class="pre">TensorFit.ga()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.linearity"><code class="docutils literal notranslate"><span class="pre">TensorFit.linearity()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.lower_triangular"><code class="docutils literal notranslate"><span class="pre">TensorFit.lower_triangular()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.md"><code class="docutils literal notranslate"><span class="pre">TensorFit.md()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.mode"><code class="docutils literal notranslate"><span class="pre">TensorFit.mode()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.odf"><code class="docutils literal notranslate"><span class="pre">TensorFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.planarity"><code class="docutils literal notranslate"><span class="pre">TensorFit.planarity()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.predict"><code class="docutils literal notranslate"><span class="pre">TensorFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.quadratic_form"><code class="docutils literal notranslate"><span class="pre">TensorFit.quadratic_form</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.rd"><code class="docutils literal notranslate"><span class="pre">TensorFit.rd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.shape"><code class="docutils literal notranslate"><span class="pre">TensorFit.shape</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.sphericity"><code class="docutils literal notranslate"><span class="pre">TensorFit.sphericity()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.TensorFit.trace"><code class="docutils literal notranslate"><span class="pre">TensorFit.trace()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractional-anisotropy">fractional_anisotropy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.fractional_anisotropy"><code class="docutils literal notranslate"><span class="pre">fractional_anisotropy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#geodesic-anisotropy">geodesic_anisotropy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.geodesic_anisotropy"><code class="docutils literal notranslate"><span class="pre">geodesic_anisotropy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mean-diffusivity">mean_diffusivity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.mean_diffusivity"><code class="docutils literal notranslate"><span class="pre">mean_diffusivity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axial-diffusivity">axial_diffusivity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.axial_diffusivity"><code class="docutils literal notranslate"><span class="pre">axial_diffusivity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radial-diffusivity">radial_diffusivity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.radial_diffusivity"><code class="docutils literal notranslate"><span class="pre">radial_diffusivity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#trace">trace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.trace"><code class="docutils literal notranslate"><span class="pre">trace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#color-fa">color_fa</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.color_fa"><code class="docutils literal notranslate"><span class="pre">color_fa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#determinant">determinant</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.determinant"><code class="docutils literal notranslate"><span class="pre">determinant()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isotropic">isotropic</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.isotropic"><code class="docutils literal notranslate"><span class="pre">isotropic()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deviatoric">deviatoric</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.deviatoric"><code class="docutils literal notranslate"><span class="pre">deviatoric()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#norm">norm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.norm"><code class="docutils literal notranslate"><span class="pre">norm()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mode">mode</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.mode"><code class="docutils literal notranslate"><span class="pre">mode()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linearity">linearity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.linearity"><code class="docutils literal notranslate"><span class="pre">linearity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#planarity">planarity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.planarity"><code class="docutils literal notranslate"><span class="pre">planarity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sphericity">sphericity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.sphericity"><code class="docutils literal notranslate"><span class="pre">sphericity()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#apparent-diffusion-coef">apparent_diffusion_coef</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.apparent_diffusion_coef"><code class="docutils literal notranslate"><span class="pre">apparent_diffusion_coef()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tensor-prediction">tensor_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.tensor_prediction"><code class="docutils literal notranslate"><span class="pre">tensor_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iter-fit-tensor">iter_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.iter_fit_tensor"><code class="docutils literal notranslate"><span class="pre">iter_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wls-fit-tensor">wls_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.wls_fit_tensor"><code class="docutils literal notranslate"><span class="pre">wls_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ols-fit-tensor">ols_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.ols_fit_tensor"><code class="docutils literal notranslate"><span class="pre">ols_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nlls-fit-tensor">nlls_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.nlls_fit_tensor"><code class="docutils literal notranslate"><span class="pre">nlls_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#restore-fit-tensor">restore_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.restore_fit_tensor"><code class="docutils literal notranslate"><span class="pre">restore_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lt-indices">_lt_indices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti._lt_indices"><code class="docutils literal notranslate"><span class="pre">_lt_indices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-lower-triangular">from_lower_triangular</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.from_lower_triangular"><code class="docutils literal notranslate"><span class="pre">from_lower_triangular()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lt-rows">_lt_rows</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti._lt_rows"><code class="docutils literal notranslate"><span class="pre">_lt_rows()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lt-cols">_lt_cols</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti._lt_cols"><code class="docutils literal notranslate"><span class="pre">_lt_cols()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lower-triangular">lower_triangular</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.lower_triangular"><code class="docutils literal notranslate"><span class="pre">lower_triangular()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#decompose-tensor">decompose_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.decompose_tensor"><code class="docutils literal notranslate"><span class="pre">decompose_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#design-matrix">design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.design_matrix"><code class="docutils literal notranslate"><span class="pre">design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantize-evecs">quantize_evecs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.quantize_evecs"><code class="docutils literal notranslate"><span class="pre">quantize_evecs()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#eig-from-lo-tri">eig_from_lo_tri</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.dti.eig_from_lo_tri"><code class="docutils literal notranslate"><span class="pre">eig_from_lo_tri()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#eudxdirectiongetter"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuDXDirectionGetter</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter"><code class="docutils literal notranslate"><span class="pre">EuDXDirectionGetter</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.__init__"><code class="docutils literal notranslate"><span class="pre">EuDXDirectionGetter.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.ang_thr"><code class="docutils literal notranslate"><span class="pre">EuDXDirectionGetter.ang_thr</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.initial_direction"><code class="docutils literal notranslate"><span class="pre">EuDXDirectionGetter.initial_direction()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.qa_thr"><code class="docutils literal notranslate"><span class="pre">EuDXDirectionGetter.qa_thr</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.eudx_direction_getter.EuDXDirectionGetter.total_weight"><code class="docutils literal notranslate"><span class="pre">EuDXDirectionGetter.total_weight</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forecastmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastModel"><code class="docutils literal notranslate"><span class="pre">ForecastModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastModel.__init__"><code class="docutils literal notranslate"><span class="pre">ForecastModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastModel.fit"><code class="docutils literal notranslate"><span class="pre">ForecastModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forecastfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit"><code class="docutils literal notranslate"><span class="pre">ForecastFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.__init__"><code class="docutils literal notranslate"><span class="pre">ForecastFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.dpar"><code class="docutils literal notranslate"><span class="pre">ForecastFit.dpar</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.dperp"><code class="docutils literal notranslate"><span class="pre">ForecastFit.dperp</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.fractional_anisotropy"><code class="docutils literal notranslate"><span class="pre">ForecastFit.fractional_anisotropy()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.mean_diffusivity"><code class="docutils literal notranslate"><span class="pre">ForecastFit.mean_diffusivity()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.odf"><code class="docutils literal notranslate"><span class="pre">ForecastFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.predict"><code class="docutils literal notranslate"><span class="pre">ForecastFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.ForecastFit.sh_coeff"><code class="docutils literal notranslate"><span class="pre">ForecastFit.sh_coeff</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#find-signal-means">find_signal_means</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.find_signal_means"><code class="docutils literal notranslate"><span class="pre">find_signal_means()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forecast-error-func">forecast_error_func</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.forecast_error_func"><code class="docutils literal notranslate"><span class="pre">forecast_error_func()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#psi-l">psi_l</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.psi_l"><code class="docutils literal notranslate"><span class="pre">psi_l()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forecast-matrix">forecast_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.forecast_matrix"><code class="docutils literal notranslate"><span class="pre">forecast_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rho-matrix">rho_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.rho_matrix"><code class="docutils literal notranslate"><span class="pre">rho_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lb-forecast">lb_forecast</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.forecast.lb_forecast"><code class="docutils literal notranslate"><span class="pre">lb_forecast()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#freewatertensormodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorModel"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorModel.__init__"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorModel.fit"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorModel.predict"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#freewatertensorfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorFit"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorFit.__init__"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorFit.f"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorFit.f</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.FreeWaterTensorFit.predict"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fwdti-prediction">fwdti_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.fwdti_prediction"><code class="docutils literal notranslate"><span class="pre">fwdti_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wls-iter">wls_iter</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.wls_iter"><code class="docutils literal notranslate"><span class="pre">wls_iter()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id602">wls_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.wls_fit_tensor"><code class="docutils literal notranslate"><span class="pre">wls_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nls-iter">nls_iter</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.nls_iter"><code class="docutils literal notranslate"><span class="pre">nls_iter()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nls-fit-tensor">nls_fit_tensor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.nls_fit_tensor"><code class="docutils literal notranslate"><span class="pre">nls_fit_tensor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lower-triangular-to-cholesky">lower_triangular_to_cholesky</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.lower_triangular_to_cholesky"><code class="docutils literal notranslate"><span class="pre">lower_triangular_to_cholesky()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cholesky-to-lower-triangular">cholesky_to_lower_triangular</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.fwdti.cholesky_to_lower_triangular"><code class="docutils literal notranslate"><span class="pre">cholesky_to_lower_triangular()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalizedqsamplingmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingModel"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.__init__"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.fit"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalizedqsamplingfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingFit"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.__init__"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.odf"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit.odf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#normalize-qa">normalize_qa</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.normalize_qa"><code class="docutils literal notranslate"><span class="pre">normalize_qa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#squared-radial-component">squared_radial_component</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.squared_radial_component"><code class="docutils literal notranslate"><span class="pre">squared_radial_component()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#npa">npa</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.npa"><code class="docutils literal notranslate"><span class="pre">npa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equatorial-zone-vertices">equatorial_zone_vertices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.equatorial_zone_vertices"><code class="docutils literal notranslate"><span class="pre">equatorial_zone_vertices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#polar-zone-vertices">polar_zone_vertices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.polar_zone_vertices"><code class="docutils literal notranslate"><span class="pre">polar_zone_vertices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#upper-hemi-map">upper_hemi_map</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.upper_hemi_map"><code class="docutils literal notranslate"><span class="pre">upper_hemi_map()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equatorial-maximum">equatorial_maximum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.equatorial_maximum"><code class="docutils literal notranslate"><span class="pre">equatorial_maximum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#patch-vertices">patch_vertices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.patch_vertices"><code class="docutils literal notranslate"><span class="pre">patch_vertices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#patch-maximum">patch_maximum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.patch_maximum"><code class="docutils literal notranslate"><span class="pre">patch_maximum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odf-sum">odf_sum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.odf_sum"><code class="docutils literal notranslate"><span class="pre">odf_sum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#patch-sum">patch_sum</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.patch_sum"><code class="docutils literal notranslate"><span class="pre">patch_sum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#triple-odf-maxima">triple_odf_maxima</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.gqi.triple_odf_maxima"><code class="docutils literal notranslate"><span class="pre">triple_odf_maxima()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivimmodeltrr"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimModelTRR</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR.__init__"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR.estimate_f_D_star()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR.estimate_linear_fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR.fit"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelTRR.predict"><code class="docutils literal notranslate"><span class="pre">IvimModelTRR.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivimmodelvp"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimModelVP</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP"><code class="docutils literal notranslate"><span class="pre">IvimModelVP</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.__init__"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.cvx_fit"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.cvx_fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.fit"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.ivim_mix_cost_one()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.nlls_cost"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.nlls_cost()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.phi"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.phi()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.stoc_search_cost"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.stoc_search_cost()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.x_and_f_to_x_f()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f"><code class="docutils literal notranslate"><span class="pre">IvimModelVP.x_f_to_x_and_f()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivimfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit"><code class="docutils literal notranslate"><span class="pre">IvimFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.__init__"><code class="docutils literal notranslate"><span class="pre">IvimFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.D"><code class="docutils literal notranslate"><span class="pre">IvimFit.D</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.D_star"><code class="docutils literal notranslate"><span class="pre">IvimFit.D_star</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.S0_predicted"><code class="docutils literal notranslate"><span class="pre">IvimFit.S0_predicted</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.perfusion_fraction"><code class="docutils literal notranslate"><span class="pre">IvimFit.perfusion_fraction</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.predict"><code class="docutils literal notranslate"><span class="pre">IvimFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.IvimFit.shape"><code class="docutils literal notranslate"><span class="pre">IvimFit.shape</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivim-prediction">ivim_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.ivim_prediction"><code class="docutils literal notranslate"><span class="pre">ivim_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#f-d-star-prediction">f_D_star_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.f_D_star_prediction"><code class="docutils literal notranslate"><span class="pre">f_D_star_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#f-d-star-error">f_D_star_error</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.f_D_star_error"><code class="docutils literal notranslate"><span class="pre">f_D_star_error()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ivim-model-selector">ivim_model_selector</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.ivim.ivim_model_selector"><code class="docutils literal notranslate"><span class="pre">ivim_model_selector()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmrimodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriModel"><code class="docutils literal notranslate"><span class="pre">MapmriModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriModel.__init__"><code class="docutils literal notranslate"><span class="pre">MapmriModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriModel.fit"><code class="docutils literal notranslate"><span class="pre">MapmriModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmrifit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit"><code class="docutils literal notranslate"><span class="pre">MapmriFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.__init__"><code class="docutils literal notranslate"><span class="pre">MapmriFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.fitted_signal"><code class="docutils literal notranslate"><span class="pre">MapmriFit.fitted_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.mapmri_R"><code class="docutils literal notranslate"><span class="pre">MapmriFit.mapmri_R</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.mapmri_coeff"><code class="docutils literal notranslate"><span class="pre">MapmriFit.mapmri_coeff</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.mapmri_mu"><code class="docutils literal notranslate"><span class="pre">MapmriFit.mapmri_mu</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.msd"><code class="docutils literal notranslate"><span class="pre">MapmriFit.msd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.ng"><code class="docutils literal notranslate"><span class="pre">MapmriFit.ng()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.ng_parallel"><code class="docutils literal notranslate"><span class="pre">MapmriFit.ng_parallel()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.ng_perpendicular"><code class="docutils literal notranslate"><span class="pre">MapmriFit.ng_perpendicular()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal"><code class="docutils literal notranslate"><span class="pre">MapmriFit.norm_of_laplacian_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.odf"><code class="docutils literal notranslate"><span class="pre">MapmriFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.odf_sh"><code class="docutils literal notranslate"><span class="pre">MapmriFit.odf_sh()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.pdf"><code class="docutils literal notranslate"><span class="pre">MapmriFit.pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.predict"><code class="docutils literal notranslate"><span class="pre">MapmriFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.qiv"><code class="docutils literal notranslate"><span class="pre">MapmriFit.qiv()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.rtap"><code class="docutils literal notranslate"><span class="pre">MapmriFit.rtap()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.rtop"><code class="docutils literal notranslate"><span class="pre">MapmriFit.rtop()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.MapmriFit.rtpp"><code class="docutils literal notranslate"><span class="pre">MapmriFit.rtpp()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isotropic-scale-factor">isotropic_scale_factor</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.isotropic_scale_factor"><code class="docutils literal notranslate"><span class="pre">isotropic_scale_factor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-index-matrix">mapmri_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_index_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#b-mat">b_mat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.b_mat"><code class="docutils literal notranslate"><span class="pre">b_mat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#b-mat-isotropic">b_mat_isotropic</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.b_mat_isotropic"><code class="docutils literal notranslate"><span class="pre">b_mat_isotropic()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-phi-1d">mapmri_phi_1d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_phi_1d"><code class="docutils literal notranslate"><span class="pre">mapmri_phi_1d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-phi-matrix">mapmri_phi_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_phi_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_phi_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-psi-1d">mapmri_psi_1d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_psi_1d"><code class="docutils literal notranslate"><span class="pre">mapmri_psi_1d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-psi-matrix">mapmri_psi_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_psi_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_psi_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-odf-matrix">mapmri_odf_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_odf_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_odf_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-phi-matrix">mapmri_isotropic_phi_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_phi_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-radial-signal-basis">mapmri_isotropic_radial_signal_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_signal_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-m-mu-independent">mapmri_isotropic_M_mu_independent</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_independent()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-m-mu-dependent">mapmri_isotropic_M_mu_dependent</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_dependent()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-psi-matrix">mapmri_isotropic_psi_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_psi_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-radial-pdf-basis">mapmri_isotropic_radial_pdf_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_pdf_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-k-mu-independent">mapmri_isotropic_K_mu_independent</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_independent()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-k-mu-dependent">mapmri_isotropic_K_mu_dependent</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_dependent()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binomialfloat">binomialfloat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.binomialfloat"><code class="docutils literal notranslate"><span class="pre">binomialfloat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-odf-matrix">mapmri_isotropic_odf_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-odf-sh-matrix">mapmri_isotropic_odf_sh_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_sh_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-laplacian-reg-matrix">mapmri_isotropic_laplacian_reg_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-laplacian-reg-matrix-from-index-matrix">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-isotropic-index-matrix">mapmri_isotropic_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_isotropic_index_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_isotropic_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-rspace">create_rspace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.create_rspace"><code class="docutils literal notranslate"><span class="pre">create_rspace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#delta">delta</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.delta"><code class="docutils literal notranslate"><span class="pre">delta()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#map-laplace-u">map_laplace_u</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.map_laplace_u"><code class="docutils literal notranslate"><span class="pre">map_laplace_u()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#map-laplace-t">map_laplace_t</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.map_laplace_t"><code class="docutils literal notranslate"><span class="pre">map_laplace_t()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#map-laplace-s">map_laplace_s</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.map_laplace_s"><code class="docutils literal notranslate"><span class="pre">map_laplace_s()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-stu-reg-matrices">mapmri_STU_reg_matrices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_STU_reg_matrices"><code class="docutils literal notranslate"><span class="pre">mapmri_STU_reg_matrices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapmri-laplacian-reg-matrix">mapmri_laplacian_reg_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix"><code class="docutils literal notranslate"><span class="pre">mapmri_laplacian_reg_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalized-crossvalidation-array">generalized_crossvalidation_array</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.generalized_crossvalidation_array"><code class="docutils literal notranslate"><span class="pre">generalized_crossvalidation_array()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalized-crossvalidation">generalized_crossvalidation</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.generalized_crossvalidation"><code class="docutils literal notranslate"><span class="pre">generalized_crossvalidation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gcv-cost-function">gcv_cost_function</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mapmri.gcv_cost_function"><code class="docutils literal notranslate"><span class="pre">gcv_cost_function()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multishellresponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiShellResponse</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellResponse"><code class="docutils literal notranslate"><span class="pre">MultiShellResponse</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellResponse.__init__"><code class="docutils literal notranslate"><span class="pre">MultiShellResponse.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellResponse.iso"><code class="docutils literal notranslate"><span class="pre">MultiShellResponse.iso</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multishelldeconvmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiShellDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellDeconvModel"><code class="docutils literal notranslate"><span class="pre">MultiShellDeconvModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellDeconvModel.__init__"><code class="docutils literal notranslate"><span class="pre">MultiShellDeconvModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellDeconvModel.fit"><code class="docutils literal notranslate"><span class="pre">MultiShellDeconvModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MultiShellDeconvModel.predict"><code class="docutils literal notranslate"><span class="pre">MultiShellDeconvModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#msdeconvfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MSDeconvFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MSDeconvFit"><code class="docutils literal notranslate"><span class="pre">MSDeconvFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MSDeconvFit.__init__"><code class="docutils literal notranslate"><span class="pre">MSDeconvFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MSDeconvFit.all_shm_coeff"><code class="docutils literal notranslate"><span class="pre">MSDeconvFit.all_shm_coeff</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MSDeconvFit.shm_coeff"><code class="docutils literal notranslate"><span class="pre">MSDeconvFit.shm_coeff</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.MSDeconvFit.volume_fractions"><code class="docutils literal notranslate"><span class="pre">MSDeconvFit.volume_fractions</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qpfitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">QpFitter</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.QpFitter"><code class="docutils literal notranslate"><span class="pre">QpFitter</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.QpFitter.__init__"><code class="docutils literal notranslate"><span class="pre">QpFitter.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-tissue-basis">multi_tissue_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.multi_tissue_basis"><code class="docutils literal notranslate"><span class="pre">multi_tissue_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solve-qp">solve_qp</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.solve_qp"><code class="docutils literal notranslate"><span class="pre">solve_qp()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-shell-fiber-response">multi_shell_fiber_response</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.multi_shell_fiber_response"><code class="docutils literal notranslate"><span class="pre">multi_shell_fiber_response()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mask-for-response-msmt">mask_for_response_msmt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.mask_for_response_msmt"><code class="docutils literal notranslate"><span class="pre">mask_for_response_msmt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#response-from-mask-msmt">response_from_mask_msmt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.response_from_mask_msmt"><code class="docutils literal notranslate"><span class="pre">response_from_mask_msmt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#auto-response-msmt">auto_response_msmt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.mcsd.auto_response_msmt"><code class="docutils literal notranslate"><span class="pre">auto_response_msmt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#meandiffusionkurtosismodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.__init__"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#meandiffusionkurtosisfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.__init__"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.S0_hat"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.S0_hat</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.msd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.msk()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.smt2di()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.smt2f()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA"><code class="docutils literal notranslate"><span class="pre">MeanDiffusionKurtosisFit.smt2uFA()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mean-signal-bvalue">mean_signal_bvalue</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.mean_signal_bvalue"><code class="docutils literal notranslate"><span class="pre">mean_signal_bvalue()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#msk-from-awf">msk_from_awf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.msk_from_awf"><code class="docutils literal notranslate"><span class="pre">msk_from_awf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#awf-from-msk">awf_from_msk</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.awf_from_msk"><code class="docutils literal notranslate"><span class="pre">awf_from_msk()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#msdki-prediction">msdki_prediction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.msdki_prediction"><code class="docutils literal notranslate"><span class="pre">msdki_prediction()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wls-fit-msdki">wls_fit_msdki</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.wls_fit_msdki"><code class="docutils literal notranslate"><span class="pre">wls_fit_msdki()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id964">design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.msdki.design_matrix"><code class="docutils literal notranslate"><span class="pre">design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multivoxelfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.MultiVoxelFit"><code class="docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.MultiVoxelFit.__init__"><code class="docutils literal notranslate"><span class="pre">MultiVoxelFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.MultiVoxelFit.predict"><code class="docutils literal notranslate"><span class="pre">MultiVoxelFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.MultiVoxelFit.shape"><code class="docutils literal notranslate"><span class="pre">MultiVoxelFit.shape</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#callablearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CallableArray</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.CallableArray"><code class="docutils literal notranslate"><span class="pre">CallableArray</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.CallableArray.__init__"><code class="docutils literal notranslate"><span class="pre">CallableArray.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-voxel-fit">multi_voxel_fit</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.multi_voxel.multi_voxel_fit"><code class="docutils literal notranslate"><span class="pre">multi_voxel_fit()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odfmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfModel"><code class="docutils literal notranslate"><span class="pre">OdfModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfModel.__init__"><code class="docutils literal notranslate"><span class="pre">OdfModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfModel.fit"><code class="docutils literal notranslate"><span class="pre">OdfModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#odffit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfFit"><code class="docutils literal notranslate"><span class="pre">OdfFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfFit.__init__"><code class="docutils literal notranslate"><span class="pre">OdfFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.OdfFit.odf"><code class="docutils literal notranslate"><span class="pre">OdfFit.odf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gfa">gfa</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.gfa"><code class="docutils literal notranslate"><span class="pre">gfa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minmax-normalize">minmax_normalize</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.odf.minmax_normalize"><code class="docutils literal notranslate"><span class="pre">minmax_normalize()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmrimodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriModel"><code class="docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriModel.__init__"><code class="docutils literal notranslate"><span class="pre">QtdmriModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriModel.fit"><code class="docutils literal notranslate"><span class="pre">QtdmriModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmrifit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit"><code class="docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.__init__"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.fitted_signal"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.fitted_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.msd"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.msd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.norm_of_laplacian_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.odf"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.odf_sh"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.odf_sh()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.pdf"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.predict"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.qiv"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.qiv()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.qtdmri_to_mapmri_coef()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.rtap"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.rtap()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.rtop"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.rtop()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.rtpp"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.rtpp()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_abs"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.sparsity_abs()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_density"><code class="docutils literal notranslate"><span class="pre">QtdmriFit.sparsity_density()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-to-mapmri-matrix">qtdmri_to_mapmri_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_to_mapmri_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-to-mapmri-matrix">qtdmri_isotropic_to_mapmri_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_to_mapmri_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-temporal-normalization">qtdmri_temporal_normalization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_temporal_normalization"><code class="docutils literal notranslate"><span class="pre">qtdmri_temporal_normalization()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-mapmri-normalization">qtdmri_mapmri_normalization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_mapmri_normalization"><code class="docutils literal notranslate"><span class="pre">qtdmri_mapmri_normalization()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-mapmri-isotropic-normalization">qtdmri_mapmri_isotropic_normalization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization"><code class="docutils literal notranslate"><span class="pre">qtdmri_mapmri_isotropic_normalization()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-signal-matrix">qtdmri_signal_matrix_</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix_"><code class="docutils literal notranslate"><span class="pre">qtdmri_signal_matrix_()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1026">qtdmri_signal_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_signal_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-eap-matrix">qtdmri_eap_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_eap_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-signal-matrix">qtdmri_isotropic_signal_matrix_</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_signal_matrix_()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1027">qtdmri_isotropic_signal_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_signal_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1028">qtdmri_eap_matrix_</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix_"><code class="docutils literal notranslate"><span class="pre">qtdmri_eap_matrix_()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-eap-matrix">qtdmri_isotropic_eap_matrix_</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_eap_matrix_()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1029">qtdmri_isotropic_eap_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_eap_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radial-basis-opt">radial_basis_opt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.radial_basis_opt"><code class="docutils literal notranslate"><span class="pre">radial_basis_opt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#angular-basis-opt">angular_basis_opt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.angular_basis_opt"><code class="docutils literal notranslate"><span class="pre">angular_basis_opt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radial-basis-eap-opt">radial_basis_EAP_opt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.radial_basis_EAP_opt"><code class="docutils literal notranslate"><span class="pre">radial_basis_EAP_opt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#angular-basis-eap-opt">angular_basis_EAP_opt</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.angular_basis_EAP_opt"><code class="docutils literal notranslate"><span class="pre">angular_basis_EAP_opt()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#temporal-basis">temporal_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.temporal_basis"><code class="docutils literal notranslate"><span class="pre">temporal_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-index-matrix">qtdmri_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_index_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-index-matrix">qtdmri_isotropic_index_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_index_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-laplacian-reg-matrix">qtdmri_laplacian_reg_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_laplacian_reg_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-laplacian-reg-matrix">qtdmri_isotropic_laplacian_reg_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_laplacian_reg_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part23-reg-matrix-q">part23_reg_matrix_q</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part23_reg_matrix_q"><code class="docutils literal notranslate"><span class="pre">part23_reg_matrix_q()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part23-iso-reg-matrix-q">part23_iso_reg_matrix_q</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part23_iso_reg_matrix_q"><code class="docutils literal notranslate"><span class="pre">part23_iso_reg_matrix_q()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part4-reg-matrix-q">part4_reg_matrix_q</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part4_reg_matrix_q"><code class="docutils literal notranslate"><span class="pre">part4_reg_matrix_q()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part4-iso-reg-matrix-q">part4_iso_reg_matrix_q</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part4_iso_reg_matrix_q"><code class="docutils literal notranslate"><span class="pre">part4_iso_reg_matrix_q()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part1-reg-matrix-tau">part1_reg_matrix_tau</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part1_reg_matrix_tau"><code class="docutils literal notranslate"><span class="pre">part1_reg_matrix_tau()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part23-reg-matrix-tau">part23_reg_matrix_tau</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part23_reg_matrix_tau"><code class="docutils literal notranslate"><span class="pre">part23_reg_matrix_tau()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#part4-reg-matrix-tau">part4_reg_matrix_tau</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.part4_reg_matrix_tau"><code class="docutils literal notranslate"><span class="pre">part4_reg_matrix_tau()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#h">H</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.H"><code class="docutils literal notranslate"><span class="pre">H()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1048">generalized_crossvalidation</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.generalized_crossvalidation"><code class="docutils literal notranslate"><span class="pre">generalized_crossvalidation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1051">GCV_cost_function</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.GCV_cost_function"><code class="docutils literal notranslate"><span class="pre">GCV_cost_function()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-isotropic-scaling">qtdmri_isotropic_scaling</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_isotropic_scaling"><code class="docutils literal notranslate"><span class="pre">qtdmri_isotropic_scaling()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-anisotropic-scaling">qtdmri_anisotropic_scaling</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling"><code class="docutils literal notranslate"><span class="pre">qtdmri_anisotropic_scaling()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#design-matrix-spatial">design_matrix_spatial</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.design_matrix_spatial"><code class="docutils literal notranslate"><span class="pre">design_matrix_spatial()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-rt-space-grid">create_rt_space_grid</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.create_rt_space_grid"><code class="docutils literal notranslate"><span class="pre">create_rt_space_grid()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtdmri-number-of-coefficients">qtdmri_number_of_coefficients</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.qtdmri_number_of_coefficients"><code class="docutils literal notranslate"><span class="pre">qtdmri_number_of_coefficients()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#l1-crossvalidation">l1_crossvalidation</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.l1_crossvalidation"><code class="docutils literal notranslate"><span class="pre">l1_crossvalidation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#elastic-crossvalidation">elastic_crossvalidation</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.elastic_crossvalidation"><code class="docutils literal notranslate"><span class="pre">elastic_crossvalidation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualise-gradient-table-g-delta-rainbow">visualise_gradient_table_G_Delta_rainbow</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow"><code class="docutils literal notranslate"><span class="pre">visualise_gradient_table_G_Delta_rainbow()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtimodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtiModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiModel"><code class="docutils literal notranslate"><span class="pre">QtiModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiModel.__init__"><code class="docutils literal notranslate"><span class="pre">QtiModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiModel.fit"><code class="docutils literal notranslate"><span class="pre">QtiModel.fit()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiModel.predict"><code class="docutils literal notranslate"><span class="pre">QtiModel.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qtifit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtiFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit"><code class="docutils literal notranslate"><span class="pre">QtiFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.__init__"><code class="docutils literal notranslate"><span class="pre">QtiFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.S0_hat"><code class="docutils literal notranslate"><span class="pre">QtiFit.S0_hat()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.c_c"><code class="docutils literal notranslate"><span class="pre">QtiFit.c_c()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.c_m"><code class="docutils literal notranslate"><span class="pre">QtiFit.c_m()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.c_md"><code class="docutils literal notranslate"><span class="pre">QtiFit.c_md()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.c_mu"><code class="docutils literal notranslate"><span class="pre">QtiFit.c_mu()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.d_sq"><code class="docutils literal notranslate"><span class="pre">QtiFit.d_sq()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.fa"><code class="docutils literal notranslate"><span class="pre">QtiFit.fa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.k_bulk"><code class="docutils literal notranslate"><span class="pre">QtiFit.k_bulk()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.k_mu"><code class="docutils literal notranslate"><span class="pre">QtiFit.k_mu()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.k_shear"><code class="docutils literal notranslate"><span class="pre">QtiFit.k_shear()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.md"><code class="docutils literal notranslate"><span class="pre">QtiFit.md()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.mean_d_sq"><code class="docutils literal notranslate"><span class="pre">QtiFit.mean_d_sq()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.mk"><code class="docutils literal notranslate"><span class="pre">QtiFit.mk()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.predict"><code class="docutils literal notranslate"><span class="pre">QtiFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.ufa"><code class="docutils literal notranslate"><span class="pre">QtiFit.ufa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.v_iso"><code class="docutils literal notranslate"><span class="pre">QtiFit.v_iso()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.v_md"><code class="docutils literal notranslate"><span class="pre">QtiFit.v_md()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.QtiFit.v_shear"><code class="docutils literal notranslate"><span class="pre">QtiFit.v_shear()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-3x3-to-6x1">from_3x3_to_6x1</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.from_3x3_to_6x1"><code class="docutils literal notranslate"><span class="pre">from_3x3_to_6x1()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-6x1-to-3x3">from_6x1_to_3x3</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.from_6x1_to_3x3"><code class="docutils literal notranslate"><span class="pre">from_6x1_to_3x3()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-6x6-to-21x1">from_6x6_to_21x1</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.from_6x6_to_21x1"><code class="docutils literal notranslate"><span class="pre">from_6x6_to_21x1()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-21x1-to-6x6">from_21x1_to_6x6</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.from_21x1_to_6x6"><code class="docutils literal notranslate"><span class="pre">from_21x1_to_6x6()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cvxpy-1x6-to-3x3">cvxpy_1x6_to_3x3</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.cvxpy_1x6_to_3x3"><code class="docutils literal notranslate"><span class="pre">cvxpy_1x6_to_3x3()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cvxpy-1x21-to-6x6">cvxpy_1x21_to_6x6</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.cvxpy_1x21_to_6x6"><code class="docutils literal notranslate"><span class="pre">cvxpy_1x21_to_6x6()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dtd-covariance">dtd_covariance</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.dtd_covariance"><code class="docutils literal notranslate"><span class="pre">dtd_covariance()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qti-signal">qti_signal</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.qti_signal"><code class="docutils literal notranslate"><span class="pre">qti_signal()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1106">design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.qti.design_matrix"><code class="docutils literal notranslate"><span class="pre">design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-squash">quick_squash</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.quick_squash.quick_squash"><code class="docutils literal notranslate"><span class="pre">quick_squash()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reduce">reduce</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.quick_squash.reduce"><code class="docutils literal notranslate"><span class="pre">reduce()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adj-to-countarrs">adj_to_countarrs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.recspeed.adj_to_countarrs"><code class="docutils literal notranslate"><span class="pre">adj_to_countarrs()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#argmax-from-adj">argmax_from_adj</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.recspeed.argmax_from_adj"><code class="docutils literal notranslate"><span class="pre">argmax_from_adj()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#argmax-from-countarrs">argmax_from_countarrs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.recspeed.argmax_from_countarrs"><code class="docutils literal notranslate"><span class="pre">argmax_from_countarrs()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#le-to-odf">le_to_odf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.recspeed.le_to_odf"><code class="docutils literal notranslate"><span class="pre">le_to_odf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#local-maxima">local_maxima</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.recspeed.local_maxima"><code class="docutils literal notranslate"><span class="pre">local_maxima()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proc-reco-args">proc_reco_args</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.recspeed.proc_reco_args"><code class="docutils literal notranslate"><span class="pre">proc_reco_args()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#remove-similar-vertices">remove_similar_vertices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.recspeed.remove_similar_vertices"><code class="docutils literal notranslate"><span class="pre">remove_similar_vertices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#search-descending">search_descending</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.recspeed.search_descending"><code class="docutils literal notranslate"><span class="pre">search_descending()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sum-on-blocks-1d">sum_on_blocks_1d</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.recspeed.sum_on_blocks_1d"><code class="docutils literal notranslate"><span class="pre">sum_on_blocks_1d()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rumbasdmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">RumbaSDModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaSDModel"><code class="docutils literal notranslate"><span class="pre">RumbaSDModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaSDModel.__init__"><code class="docutils literal notranslate"><span class="pre">RumbaSDModel.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rumbafit"><code class="xref py py-class docutils literal notranslate"><span class="pre">RumbaFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit"><code class="docutils literal notranslate"><span class="pre">RumbaFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.__init__"><code class="docutils literal notranslate"><span class="pre">RumbaFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.combined_odf_iso"><code class="docutils literal notranslate"><span class="pre">RumbaFit.combined_odf_iso()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.f_csf"><code class="docutils literal notranslate"><span class="pre">RumbaFit.f_csf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.f_gm"><code class="docutils literal notranslate"><span class="pre">RumbaFit.f_gm()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.f_iso"><code class="docutils literal notranslate"><span class="pre">RumbaFit.f_iso()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.f_wm"><code class="docutils literal notranslate"><span class="pre">RumbaFit.f_wm()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.odf"><code class="docutils literal notranslate"><span class="pre">RumbaFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.RumbaFit.predict"><code class="docutils literal notranslate"><span class="pre">RumbaFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#logger">logger</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.logger"><code class="docutils literal notranslate"><span class="pre">logger()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rumba-deconv">rumba_deconv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.rumba_deconv"><code class="docutils literal notranslate"><span class="pre">rumba_deconv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mbessel-ratio">mbessel_ratio</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.mbessel_ratio"><code class="docutils literal notranslate"><span class="pre">mbessel_ratio()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generate-kernel">generate_kernel</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.generate_kernel"><code class="docutils literal notranslate"><span class="pre">generate_kernel()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rumba-deconv-global">rumba_deconv_global</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.rumba.rumba_deconv_global"><code class="docutils literal notranslate"><span class="pre">rumba_deconv_global()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isotropicmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicModel"><code class="docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicModel.__init__"><code class="docutils literal notranslate"><span class="pre">IsotropicModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicModel.fit"><code class="docutils literal notranslate"><span class="pre">IsotropicModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isotropicfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicFit"><code class="docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicFit.__init__"><code class="docutils literal notranslate"><span class="pre">IsotropicFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.IsotropicFit.predict"><code class="docutils literal notranslate"><span class="pre">IsotropicFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exponentialisotropicmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicModel"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicModel.__init__"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicModel.fit"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exponentialisotropicfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicFit"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicFit.__init__"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.ExponentialIsotropicFit.predict"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sparsefasciclemodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleModel"><code class="docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleModel.__init__"><code class="docutils literal notranslate"><span class="pre">SparseFascicleModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleModel.design_matrix"><code class="docutils literal notranslate"><span class="pre">SparseFascicleModel.design_matrix()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleModel.fit"><code class="docutils literal notranslate"><span class="pre">SparseFascicleModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sparsefasciclefit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleFit"><code class="docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleFit.__init__"><code class="docutils literal notranslate"><span class="pre">SparseFascicleFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleFit.odf"><code class="docutils literal notranslate"><span class="pre">SparseFascicleFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.SparseFascicleFit.predict"><code class="docutils literal notranslate"><span class="pre">SparseFascicleFit.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sfm-design-matrix">sfm_design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.sfm.sfm_design_matrix"><code class="docutils literal notranslate"><span class="pre">sfm_design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sphharmmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmModel"><code class="docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmModel.__init__"><code class="docutils literal notranslate"><span class="pre">SphHarmModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmModel.sampling_matrix"><code class="docutils literal notranslate"><span class="pre">SphHarmModel.sampling_matrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qballbasemodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.QballBaseModel"><code class="docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.QballBaseModel.__init__"><code class="docutils literal notranslate"><span class="pre">QballBaseModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.QballBaseModel.fit"><code class="docutils literal notranslate"><span class="pre">QballBaseModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sphharmfit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit"><code class="docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.__init__"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.gfa"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.gfa()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.odf"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.predict"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.predict()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.shape"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.shape</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.SphHarmFit.shm_coeff"><code class="docutils literal notranslate"><span class="pre">SphHarmFit.shm_coeff</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#csaodfmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.CsaOdfModel"><code class="docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.CsaOdfModel.__init__"><code class="docutils literal notranslate"><span class="pre">CsaOdfModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.CsaOdfModel.max"><code class="docutils literal notranslate"><span class="pre">CsaOdfModel.max</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.CsaOdfModel.min"><code class="docutils literal notranslate"><span class="pre">CsaOdfModel.min</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#opdtmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpdtModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.OpdtModel"><code class="docutils literal notranslate"><span class="pre">OpdtModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.OpdtModel.__init__"><code class="docutils literal notranslate"><span class="pre">OpdtModel.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qballmodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.QballModel"><code class="docutils literal notranslate"><span class="pre">QballModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.QballModel.__init__"><code class="docutils literal notranslate"><span class="pre">QballModel.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#residualbootstrapwrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.ResidualBootstrapWrapper"><code class="docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.ResidualBootstrapWrapper.__init__"><code class="docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forward-sdeconv-mat">forward_sdeconv_mat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.forward_sdeconv_mat"><code class="docutils literal notranslate"><span class="pre">forward_sdeconv_mat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sh-to-rh">sh_to_rh</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sh_to_rh"><code class="docutils literal notranslate"><span class="pre">sh_to_rh()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gen-dirac">gen_dirac</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.gen_dirac"><code class="docutils literal notranslate"><span class="pre">gen_dirac()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spherical-harmonics">spherical_harmonics</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.spherical_harmonics"><code class="docutils literal notranslate"><span class="pre">spherical_harmonics()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sph-harm">real_sph_harm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sph_harm"><code class="docutils literal notranslate"><span class="pre">real_sph_harm()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sh-tournier-from-index">real_sh_tournier_from_index</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sh_tournier_from_index"><code class="docutils literal notranslate"><span class="pre">real_sh_tournier_from_index()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sh-descoteaux-from-index">real_sh_descoteaux_from_index</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sh_descoteaux_from_index"><code class="docutils literal notranslate"><span class="pre">real_sh_descoteaux_from_index()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sh-tournier">real_sh_tournier</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sh_tournier"><code class="docutils literal notranslate"><span class="pre">real_sh_tournier()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sh-descoteaux">real_sh_descoteaux</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sh_descoteaux"><code class="docutils literal notranslate"><span class="pre">real_sh_descoteaux()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sym-sh-mrtrix">real_sym_sh_mrtrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sym_sh_mrtrix"><code class="docutils literal notranslate"><span class="pre">real_sym_sh_mrtrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-sym-sh-basis">real_sym_sh_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.real_sym_sh_basis"><code class="docutils literal notranslate"><span class="pre">real_sym_sh_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sph-harm-ind-list">sph_harm_ind_list</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sph_harm_ind_list"><code class="docutils literal notranslate"><span class="pre">sph_harm_ind_list()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#order-from-ncoef">order_from_ncoef</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.order_from_ncoef"><code class="docutils literal notranslate"><span class="pre">order_from_ncoef()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#smooth-pinv">smooth_pinv</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.smooth_pinv"><code class="docutils literal notranslate"><span class="pre">smooth_pinv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lazy-index">lazy_index</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.lazy_index"><code class="docutils literal notranslate"><span class="pre">lazy_index()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#normalize-data">normalize_data</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.normalize_data"><code class="docutils literal notranslate"><span class="pre">normalize_data()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hat">hat</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.hat"><code class="docutils literal notranslate"><span class="pre">hat()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lcr-matrix">lcr_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.lcr_matrix"><code class="docutils literal notranslate"><span class="pre">lcr_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bootstrap-data-array">bootstrap_data_array</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.bootstrap_data_array"><code class="docutils literal notranslate"><span class="pre">bootstrap_data_array()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bootstrap-data-voxel">bootstrap_data_voxel</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.bootstrap_data_voxel"><code class="docutils literal notranslate"><span class="pre">bootstrap_data_voxel()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sf-to-sh">sf_to_sh</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sf_to_sh"><code class="docutils literal notranslate"><span class="pre">sf_to_sh()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sh-to-sf">sh_to_sf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sh_to_sf"><code class="docutils literal notranslate"><span class="pre">sh_to_sf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sh-to-sf-matrix">sh_to_sf_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.sh_to_sf_matrix"><code class="docutils literal notranslate"><span class="pre">sh_to_sf_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calculate-max-order">calculate_max_order</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.calculate_max_order"><code class="docutils literal notranslate"><span class="pre">calculate_max_order()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anisotropic-power">anisotropic_power</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.anisotropic_power"><code class="docutils literal notranslate"><span class="pre">anisotropic_power()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convert-sh-to-full-basis">convert_sh_to_full_basis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.convert_sh_to_full_basis"><code class="docutils literal notranslate"><span class="pre">convert_sh_to_full_basis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convert-sh-from-legacy">convert_sh_from_legacy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.convert_sh_from_legacy"><code class="docutils literal notranslate"><span class="pre">convert_sh_from_legacy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convert-sh-to-legacy">convert_sh_to_legacy</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shm.convert_sh_to_legacy"><code class="docutils literal notranslate"><span class="pre">convert_sh_to_legacy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shoremodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreModel"><code class="docutils literal notranslate"><span class="pre">ShoreModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreModel.__init__"><code class="docutils literal notranslate"><span class="pre">ShoreModel.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreModel.fit"><code class="docutils literal notranslate"><span class="pre">ShoreModel.fit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shorefit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit"><code class="docutils literal notranslate"><span class="pre">ShoreFit</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.__init__"><code class="docutils literal notranslate"><span class="pre">ShoreFit.__init__()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.fitted_signal"><code class="docutils literal notranslate"><span class="pre">ShoreFit.fitted_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.msd"><code class="docutils literal notranslate"><span class="pre">ShoreFit.msd()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.odf"><code class="docutils literal notranslate"><span class="pre">ShoreFit.odf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.odf_sh"><code class="docutils literal notranslate"><span class="pre">ShoreFit.odf_sh()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.pdf"><code class="docutils literal notranslate"><span class="pre">ShoreFit.pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.pdf_grid"><code class="docutils literal notranslate"><span class="pre">ShoreFit.pdf_grid()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.rtop_pdf"><code class="docutils literal notranslate"><span class="pre">ShoreFit.rtop_pdf()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.rtop_signal"><code class="docutils literal notranslate"><span class="pre">ShoreFit.rtop_signal()</span></code></a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.ShoreFit.shore_coeff"><code class="docutils literal notranslate"><span class="pre">ShoreFit.shore_coeff</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-matrix">shore_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_matrix"><code class="docutils literal notranslate"><span class="pre">shore_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-matrix-pdf">shore_matrix_pdf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_matrix_pdf"><code class="docutils literal notranslate"><span class="pre">shore_matrix_pdf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-matrix-odf">shore_matrix_odf</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_matrix_odf"><code class="docutils literal notranslate"><span class="pre">shore_matrix_odf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#l-shore">l_shore</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.l_shore"><code class="docutils literal notranslate"><span class="pre">l_shore()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#n-shore">n_shore</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.n_shore"><code class="docutils literal notranslate"><span class="pre">n_shore()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1293">create_rspace</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.create_rspace"><code class="docutils literal notranslate"><span class="pre">create_rspace()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-indices">shore_indices</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_indices"><code class="docutils literal notranslate"><span class="pre">shore_indices()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shore-order">shore_order</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.shore.shore_order"><code class="docutils literal notranslate"><span class="pre">shore_order()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dki-design-matrix">dki_design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.utils.dki_design_matrix"><code class="docutils literal notranslate"><span class="pre">dki_design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cti-design-matrix">cti_design_matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.utils.cti_design_matrix"><code class="docutils literal notranslate"><span class="pre">cti_design_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vec-val-vect">vec_val_vect</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dipy.reconst.vec_val_sum.vec_val_vect"><code class="docutils literal notranslate"><span class="pre">vec_val_vect()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  
<script type="module" src="../_static/scripts/grg-sphinx-theme.js"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item"><div>
  <h3 class="footer-heading">
    Never miss an update from us!
  </h3>
  <p class="footer-sub-heading">
    Don't worry! we are not going to spam you.
  </p>
  <div class="input-group mb-3 mar-t-10">
    <input type="text" class="form-control" placeholder="You email" aria-label="You email" id="grg-subscribe-email">
    <div class="input-group-append pointer" onclick="(document.getElementById('grg-subscribe-email').value)">
      <span class="input-group-text subscribe">Subscribe</span>
    </div>
  </div>  
  <ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dipy" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/dipymri" title="Twitter/X" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter/X</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.youtube.com/c/diffusionimaginginpython" title="YouTube" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-youtube"></i></span>
            <label class="sr-only">YouTube</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/dipy/" title="LinkedIn" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-linkedin"></i></span>
            <label class="sr-only">LinkedIn</label></a>
        </li>
</ul>
</div></div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><div class="grid-3">
  
  <div>
    <h5 class="footer-heading">
      About
    </h5>
    <ul class="footer-section">
      
        
        <li class="pad-v-5">
          <a href="../team.html">
            Developers
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://github.com/dipy/dipy/discussions" target="_blank" rel="noopener noreferrer">
            Support
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="../installation.html">
            Download
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="../https%3A//dipy.org/contributors/.html">
            Get Started
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://docs.dipy.org/tutorials/" target="_blank" rel="noopener noreferrer">
            Tutorials
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://www.youtube.com/c/diffusionimaginginpython" target="_blank" rel="noopener noreferrer">
            Videos
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
    </ul>
  </div>
  
  <div>
    <h5 class="footer-heading">
      Friends
    </h5>
    <ul class="footer-section">
      
        
        <li class="pad-v-5">
          <a href="http://nipy.org/" target="_blank" rel="noopener noreferrer">
            Nipy Projects
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="http://fury.gl/" target="_blank" rel="noopener noreferrer">
            FURY
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="http://nipy.org/nibabel" target="_blank" rel="noopener noreferrer">
            Nibabel
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://tortoise.nibib.nih.gov/" target="_blank" rel="noopener noreferrer">
            Tortoise
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
    </ul>
  </div>
  
  <div>
    <h5 class="footer-heading">
      Support
    </h5>
    <ul class="footer-section">
      
        
        <li class="pad-v-5">
          <a href="https://engineering.indiana.edu/" target="_blank" rel="noopener noreferrer">
            The department of Intelligent Systems Engineering of Indiana University
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://www.nibib.nih.gov/" target="_blank" rel="noopener noreferrer">
            The National Institute of Biomedical Imaging and Bioengineering, NIH
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://escience.washington.edu/tag/alfred-p-sloan-foundation/" target="_blank" rel="noopener noreferrer">
            The Gordon and Betty Moore Foundation and the Alfred P. Sloan Foundation, through the University of Washington eScience Institute Data Science Environment
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
        
        <li class="pad-v-5">
          <a href="https://summerofcode.withgoogle.com/" target="_blank" rel="noopener noreferrer">
            Google supported DIPY through the Google Summer of Code Program during Summer 2015, 2016, 2018
            <i class="fa-solid fa-arrow-up-long mar-l-5"></i>
          </a>
        </li>
        
      
    </ul>
  </div>
  
</div></div>
      
    </div>
  
</div>

    <div class="copyright-text">
      <i class="fa-regular fa-copyright"></i> Copyright 2008-2023, DIPY developers. Created using Grg Sphinx Theme and PyData Sphinx Theme.
    </div>
  </footer>
  </body>
</html>